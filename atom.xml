<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>艾AA</title>
  
  
  <link href="http://ailiaa.github.io/atom.xml" rel="self"/>
  
  <link href="http://ailiaa.github.io/"/>
  <updated>2023-08-31T09:11:59.117Z</updated>
  <id>http://ailiaa.github.io/</id>
  
  <author>
    <name>Aiaa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>k8s</title>
    <link href="http://ailiaa.github.io/2023/06/28/k8s/"/>
    <id>http://ailiaa.github.io/2023/06/28/k8s/</id>
    <published>2023-06-28T07:31:25.000Z</published>
    <updated>2023-08-31T09:11:59.117Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是k8s"><a href="#什么是k8s" class="headerlink" title="什么是k8s"></a>什么是k8s</h3><p>K8s是指Kubernetes，是一个用于自动化部署、扩展和管理容器化应用程序的开源平台。</p><p>简单来说，k8s就是一个<strong>编排容器的系统</strong></p><p>Kubernetes提供了一个可移植、可扩展的平台，可以自动化部署、扩展和管理应用程序。</p><p>Kubernetes基于容器技术，实现自动化的容器编排和管理，可以自动调度容器到集群中的节点上，并根据应用的需求进行水平扩展和负载均衡。</p><h3 id="k8s的核心组件有哪些"><a href="#k8s的核心组件有哪些" class="headerlink" title="k8s的核心组件有哪些"></a>k8s的核心组件有哪些</h3><ol><li><p>etcd：一个可靠的分布式键值存储，用于存储 Kubernetes 集群的状态信息。</p></li><li><p>kube-apiserver：提供了一个Kubernetes API，其他组件都可以通过该API与集群进行交互操作。（集群管理，数据交互）</p></li><li><p>kube-controller-manager：负责控制器的管理，运行各种控制器来确保系统的自愈能力，比如Replication Controller、Endpoint Controller等。</p></li><li><p>kube-scheduler：根据调度算法为新创建的Pod选择一个合适的Node，并将其绑定到该节点上。</p></li><li><p>kubelet：运行在每个Node上，负责启动Pod并确保Pod内的容器处于正常运行状态。</p></li><li><p>kube-proxy：负责为Service 提供 Cluster 内部的服务发现和负载均衡功能。</p></li><li><p>container-runtime：容器运行时环境，即运行容器所需要的一系列程序（docker）</p></li></ol><p>k8s主要由master节点和node节点构成。</p><p>master节点负责管理集群，node节点是容器应用真正运行的地方。 </p><ul><li>master节点包含的组件有：kube-api-server、kube-controller-manager、kube-scheduler、etcd。 </li><li>node节点包含的组件有：kubelet、kube-proxy、container-runtime</li></ul><h3 id="kube-api-server的端口是多少？各个pod是如何访问kube-api-server的"><a href="#kube-api-server的端口是多少？各个pod是如何访问kube-api-server的" class="headerlink" title="kube-api-server的端口是多少？各个pod是如何访问kube-api-server的"></a>kube-api-server的端口是多少？各个pod是如何访问kube-api-server的</h3><p>kube-api-server的端口是8080和6443，前者是http的端口，后者是https的端口</p><p>Pod可以通过以下两种方式访问kube-apiserver：</p><ol><li>使用环境变量：Kubernetes在每个Pod中注入了一些环境变量，其中包括了kube-apiserver的服务地址和端口信息。</li><li>使用Kubernetes集群内部DNS：在Kubernetes集群中，每个Service都会分配一个唯一的DNS名称。kube-apiserver作为一个Service，也有一个DNS名称。Pod可以使用这个DNS名称来解析出kube-apiserver的IP地址。Pod可以通过该IP地址和kube-apiserver的暴露端口进行通信。</li></ol><h3 id="k8s中命名空间的作用是什么"><a href="#k8s中命名空间的作用是什么" class="headerlink" title="k8s中命名空间的作用是什么"></a>k8s中命名空间的作用是什么</h3><p>Kubernetes中的命名空间（Namespace）是一种用于<strong>隔离</strong>不同资源和对象的机制。它可以将一个Kubernetes集群划分为多个虚拟集群，每个命名空间提供了一个独立的工作空间，用于组织和管理应用程序、服务和其他资源。</p><p>通过它可以实现资源隔离、资源管理、访问控制、共享资源和管理视图等多种功能，帮助用户更好地组织和管理集群中的资源和工作负载。</p><h3 id="pod是什么"><a href="#pod是什么" class="headerlink" title="pod是什么"></a>pod是什么</h3><p>Pod是Kubernetes中<strong>最小的可部署和可管理单元</strong>。它是一组关联的容器集合，共享同一个网络命名空间、存储卷以及其他资源。</p><p>Pod是Kubernetes中最基本的部署单元，它提供了一种逻辑上独立和可扩展的环境，使得多个容器可以在同一个Pod中协同工作，方便k8s对容器的调度和管理</p><h3 id="pod有什么特点"><a href="#pod有什么特点" class="headerlink" title="pod有什么特点"></a>pod有什么特点</h3><ol><li>共享网络：Pod内的所有容器共享同一个网络命名空间。</li><li>共享存储：Pod内的容器可以访问共享的存储卷。这样可以实现数据的持久化和共享。</li><li>生命周期绑定：Pod中的容器具有相同的生命周期，它们一起启动、调度和停止。当Pod被删除时，Pod中的所有容器也将被删除。</li><li>紧密关联：Pod中的容器经常需要相互配合工作。它们可以通过本地环回网络进行通信，无需通过网络暴露端口。</li><li>每个pod就像一个<strong>独立</strong>的逻辑机器，k8s会为每个pod分配一个集群内部唯一的IP地址，每个pod都拥有自己的IP地址、主机名、进程等；</li></ol><h3 id="pause容器是什么"><a href="#pause容器是什么" class="headerlink" title="pause容器是什么"></a>pause容器是什么</h3><p>Pause容器是一个轻量级容器，它的主要作用是<strong>协调Pod中其他容器的网络和存储功能</strong>。</p><p>当Pod中有多个容器时，Kubernetes使用pause容器来共享网络命名空间、IPC命名空间和volume存储卷等资源，并确保其他容器可以使用这些资源。</p><ul><li><strong>网络共享</strong>：当pod被创建时，pod首先会创建pause容器，从而把其他业务容器加入pause容器，从而让所有业务容器都在同一个命名空间中，实现网络共享。</li><li><strong>共享存储</strong>：在pod级别引入数据卷volume，业务容器都可以挂载这个数据卷从而实现持久化存储。</li></ul><h3 id="pod的重启策略有哪些"><a href="#pod的重启策略有哪些" class="headerlink" title="pod的重启策略有哪些"></a>pod的重启策略有哪些</h3><p>pod重启容器策略是指针对pod内<strong>所有容器</strong>的重启策略，不是重启pod</p><p>可以通过<code>restartPolicy</code>字段配置pod重启容器的策略</p><ul><li><code>Always</code>: 当容器终止退出后，总是重启容器，默认策略就是<code>Always</code>。</li><li><code>OnFailure</code>: 当容器异常退出，退出状态码非0时，才重启容器。</li><li><code>Never</code>: 当容器终止退出，不管退出状态码是什么，从不重启容器。</li></ul><h3 id="pod的镜像拉取策略有哪几种"><a href="#pod的镜像拉取策略有哪几种" class="headerlink" title="pod的镜像拉取策略有哪几种"></a>pod的镜像拉取策略有哪几种</h3><p>pod镜像拉取策略可以通过<code>imagePullPolicy</code>字段配置镜像拉取策略</p><ul><li><code>IfNotPresent</code>: 默认值，镜像在node节点宿主机上不存在时才拉取。</li><li><code>Always</code>: 总是重新拉取，即每次创建pod都会重新从镜像仓库拉取一次镜像。</li><li><code>Never</code>: 永远不会主动拉取镜像，仅使用本地镜像，需要手动拉取镜像到node节点，如果node节点不存在镜像则pod启动失败。</li></ul><h3 id="pod的存活探针有哪几种"><a href="#pod的存活探针有哪几种" class="headerlink" title="pod的存活探针有哪几种"></a>pod的存活探针有哪几种</h3><p>kubernetes可以通过存活探针检查容器是否还在运行，可以为pod中的每个容器单独定义存活探针，kubernetes将定期执行探针，如果探测失败，将杀死容器，并根据<code>restartPolicy</code>策略来决定是否重启容器</p><p>kubernetes提供了3种探测容器的存活探针</p><ul><li><code>httpGet</code>：通过容器的IP、端口、路径发送http 请求，返回200-400范围内的状态码表示成功。</li><li><code>exec</code>：在容器内执行shell命令，根据命令退出状态码是否为0进行判断，0表示健康，非0表示不健康。</li><li><code>TCPSocket</code>：与容器的端口建立TCP Socket链接。</li></ul><h3 id="存活探针的属性参数有哪几个"><a href="#存活探针的属性参数有哪几个" class="headerlink" title="存活探针的属性参数有哪几个"></a>存活探针的属性参数有哪几个</h3><ul><li><code>initialDelaySeconds</code>：表示在容器启动后延时多久秒才开始探测；</li><li><code>periodSeconds</code>：表示执行探测的频率，即间隔多少秒探测一次，默认间隔周期是10秒，最小1秒；</li><li><code>timeoutSeconds</code>：表示探测超时时间，默认1秒，最小1秒，表示容器必须在超时时间范围内做出响应，否则视为本次探测失败；</li><li><code>successThreshold</code>：表示最少连续探测成功多少次才被认定为成功，默认是1</li><li><code>failureThreshold</code>：表示连续探测失败多少次才被认定为失败，默认是3，连续3次失败，k8s 将根据pod重启策略对容器做出决定；</li></ul><h3 id="pod的就绪探针有哪几种"><a href="#pod的就绪探针有哪几种" class="headerlink" title="pod的就绪探针有哪几种"></a>pod的就绪探针有哪几种</h3><p>当一个pod启动后，就会立即加入service的endpoint ip列表中，并开始接收到客户端的链接请求，假若此时pod中的容器的业务进程还没有初始化完毕，那么这些客户端链接请求就会失败，为了解决这个问题，kubernetes提供了就绪探针来解决这个问题的。</p><p>在pod中的容器定义一个就绪探针，就绪探针周期性检查容器，如果就绪探针检查失败了，说明该pod还未准备就绪，不能接受客户端链接，则该pod将从endpoint列表中移除</p><p>k8s提供了3种就绪探针</p><ul><li><code>exec</code>：在容器中执行命令并检查命令退出的状态码，如果状态码为0，则说明容器已经准备就绪；</li><li><code>httpGet</code>：向容器发送http get请求，通过响应的http状态码判断容器是否准备就绪；</li><li><code>tcpSocket</code>：打开一个tcp连接到容器的指定端口，如果连接已建立，则认为容器已经准备就绪。</li></ul><h3 id="就绪探针的属性参数有哪些"><a href="#就绪探针的属性参数有哪些" class="headerlink" title="就绪探针的属性参数有哪些"></a>就绪探针的属性参数有哪些</h3><ul><li><code>initialDelaySeconds</code>：延时秒数，即容器启动多少秒后才开始探测，不写默认容器启动就探测；</li><li><code>periodSeconds</code>&nbsp;：执行探测的频率（秒），默认为10秒，最低值为1；</li><li><code>timeoutSeconds</code>&nbsp;：超时时间，表示探测时在超时时间内必须得到响应，负责视为本次探测失败，默认为1秒，最小值为1；</li><li><code>failureThreshold</code>&nbsp;：连续探测失败的次数，视为本次探测失败，默认为3次，最小值为1次；</li><li><code>successThreshold</code>&nbsp;：连续探测成功的次数，视为本次探测成功，默认为1次，最小值为1次；</li></ul><h3 id="就绪探针与存活探针区别是什么"><a href="#就绪探针与存活探针区别是什么" class="headerlink" title="就绪探针与存活探针区别是什么"></a>就绪探针与存活探针区别是什么</h3><p>作用上的区别：</p><p>存活探针：当存活探针检查失败，是将检查失败的容器杀死，创建新的启动容器来保持pod正常工作；</p><p>就绪探针：当就绪探针检查失败，并不重启容器，而是将pod移出endpoint，就绪探针确保了service中的pod都是可用的，确保客户端只与正常的pod交互</p><h3 id="简单讲一下-pod创建过程"><a href="#简单讲一下-pod创建过程" class="headerlink" title="简单讲一下 pod创建过程"></a>简单讲一下 pod创建过程</h3><p><img src="/images/image_%E5%88%86%E5%B8%83%E5%BC%8F/2.png"></p><p>首先，需要编写一个包含Pod配置信息的描述文件，通常使用YAML或JSON格式。在描述文件中，定义Pod的名称、命名空间、容器、网络设置、存储卷等相关配置。</p><ol><li>用户通过kubectl向api-server发起创建pod请求。</li><li>apiserver通过对应的kubeconfig进行认证，认证通过后将yaml中的po信息存到etcd。</li><li>Controller-Manager通过apiserver的watch接口发现了pod信息的更新，整合对应的信息交给apiserver，apiserver写到etcd，此时pod已经可以被调度。</li><li>Scheduler同样通过apiserver的watch接口更新到pod可以被调度，通过算法给pod分配节点，并将pod和对应节点绑定的信息交给apiserver，apiserver写到etcd，然后将pod交给kubelet。</li><li>kubelet收到pod后，调用CNI接口给pod创建pod网络，调用CRI接口去启动容器，调用CSI进行存储卷的挂载。</li><li>网络，容器，存储创建完成后pod创建完成，等业务进程启动后，pod运行成功。</li></ol><h3 id="说说pod的终止过程"><a href="#说说pod的终止过程" class="headerlink" title="说说pod的终止过程"></a>说说pod的终止过程</h3><ol><li>用户向apiserver发送删除pod对象的命令</li><li>apiserver中的pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），pod被视为dead</li><li>将pod标记为terminating状态</li><li>kubectl在监控到pod对象为状态了就会启动pod关闭过程</li><li>endpoint控制器监控到pod对象的关闭行为时将其从所有匹配到此endpoint的server资源endpoint列表中删除</li><li>如果当前pod对象定义了preStop钩子处理器，则在其被标记为terminating后会意同步的方式启动执行</li><li>pod对象中的容器进程收到停止信息</li><li>宽限期结束后，若pod中还存在运行的进程，那么pod对象会收到立即终止的信息</li><li>kubelet请求apiserver将此pod资源的宽限期设置为0从而完成删除操作，此时pod对用户已不可见</li></ol><h3 id="pod的生命周期有哪几种（也称5种相位）"><a href="#pod的生命周期有哪几种（也称5种相位）" class="headerlink" title="pod的生命周期有哪几种（也称5种相位）"></a>pod的生命周期有哪几种（也称5种相位）</h3><p>pod生命周期有的5种状态</p><ul><li><strong>Pending</strong>（挂起）：API server已经创建pod，但是该pod还有一个或多个容器的镜像没有创建，包括正在下载镜像的过程；</li><li><strong>Running</strong>（运行中）：Pod内所有的容器已经创建，且至少有一个容器处于运行状态、正在启动或者正在重启状态；</li><li><strong>Succeed</strong>（成功）：Pod内所有容器均已退出，且不会再重启；</li><li><strong>Failed</strong>（失败）：Pod内所有容器均已退出，且至少有一个容器为退出失败状态</li><li><strong>Unknown</strong>（未知）：某于某种原因apiserver无法获取该pod的状态，可能由于网络通行问题导致；</li></ul><h3 id="pod的初始化容器是干什么的"><a href="#pod的初始化容器是干什么的" class="headerlink" title="pod的初始化容器是干什么的"></a>pod的初始化容器是干什么的</h3><p>init container，初始化容器用于在启动应用容器之前完成应用容器所需要的前置条件</p><p>1、初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么kubernetes需要重启它直到成功完成；</p><p>2、初始化容器必须按照定义的顺序执行，当且仅当前一个初始化容器成功之后，后面的一个初始化容器才能运行；</p><h3 id="service是什么"><a href="#service是什么" class="headerlink" title="service是什么"></a>service是什么</h3><p>Service是一种定义了一组Pod的网络访问方式的资源对象。它为一组具有相同功能的Pod提供了一个统一的入口，并将它们封装在一个虚拟的服务IP地址后面。</p><p>Service可以通过一个稳定的IP地址和端口提供对应用程序的访问，无论这些应用程序运行在Kubernetes集群内的哪个节点上。它为应用程序提供了一种抽象层，使得后端Pod的变动对外界用户来说是透明的。</p><p>主要特性：</p><ol><li>服务发现和负载均衡：Service通过为一组Pod分配唯一的虚拟IP地址和端口，实现了服务发现功能。它会自动将请求均匀地分发到后端Pod中，从而实现负载均衡。</li><li>稳定的网络标识：每个Service都有一个稳定的虚拟IP地址和端口，这个地址和端口可以长期保持不变。</li><li>内部和外部访问：内部Service仅在集群内部可用，用于集群内部的服务通信。外部Service则通过负载均衡器、节点端口或外部IP地址等方式，将流量从集群外部引导到Service中。</li></ol><h3 id="endpoint是什么"><a href="#endpoint是什么" class="headerlink" title="endpoint是什么"></a>endpoint是什么</h3><p>Endpoint是一种资源对象，用于表示一个Service所关联的后端Pod的网络终点。它存储着Service要连接到的实际后端Pod的IP地址和端口信息。</p><p>Endpoint对象主要有两个作用：</p><ol><li>服务发现：Endpoints对象记录了与Service关联的所有后端Pod的网络地址信息。</li><li>负载均衡：Endpoints对象中可以包含多个后端Pod的IP地址和端口。当请求到达Service时，Kubernetes会将请求按照负载均衡算法分发到不同的后端Pod上，从而平衡流量负载。</li></ol><h3 id="kube-proxy是什么"><a href="#kube-proxy是什么" class="headerlink" title="kube-proxy是什么"></a>kube-proxy是什么</h3><p>kube-proxy是Kubernetes集群中的一个组件，它负责实现Service的网络代理和负载均衡功能。</p><p>kube-proxy运行在每个节点上，并监听Kubernetes API服务器上的Service和Endpoint对象的变化。它会根据这些变化动态地更新节点上的网络规则，以确保流量能够正确地路由到后端Pod上。</p><p>主要功能包括：</p><ol><li>Service代理：kube-proxy会监视Kubernetes API中的Service对象，并为每个Service创建一个虚拟IP地址和端口。当请求到达该虚拟地址时，kube-proxy会将请求转发到后端Pod上，从而实现服务发现和代理功能。</li><li>负载均衡：当请求到达Service的虚拟地址时，kube-proxy会根据预定义的负载均衡算法选择其中一个后端Pod，然后将请求转发给该Pod。</li><li>Endpoint监视：k当Endpoint发生变化时（例如，Pod的添加、删除或IP地址的更改），kube-proxy会相应地更新负载均衡器的配置，以确保流量能够正确地路由到新的后端Pod上。</li></ol><h3 id="deployment是什么"><a href="#deployment是什么" class="headerlink" title="deployment是什么"></a>deployment是什么</h3><p>Deployment是一种资源对象，用于定义和管理Pod副本集。它是Kubernetes中最常用的控制器之一，用于实现应用程序的无缝部署、更新和回滚。</p><p>Deployment对象提供了一种声明式的方式来描述应用程序的期望状态，并由Kubernetes系统负责维护实际状态与期望状态的一致性。</p><p>通过Deployment，可以轻松地进行以下操作：</p><ol><li>创建和管理Pod副本：Deployment根据定义的副本数量和Pod模板创建和管理一组Pod副本。Pod模板定义了每个副本的容器镜像、资源需求、环境变量等信息。</li><li>应用程序的无缝部署：通过修改Deployment对象的配置，可以实现应用程序的无缝部署。例如，可以通过增加副本数量来扩展应用程序，Kubernetes会自动创建新的Pod副本；反之，减少副本数量则会进行缩容。</li><li>应用程序的更新和回滚：通过修改Deployment的Pod模板或更新策略，可以实现应用程序的更新。Kubernetes会逐步替换旧版本的Pod副本，从而实现滚动更新。如果更新过程中出现问题，可以通过回滚操作将应用程序恢复到之前的版本。</li><li>健康检查和自愈能力：Deployment可以配置健康检查来监测Pod副本的运行状态，如果某个副本失败或不可用，Kubernetes会自动替换它，以确保应用程序的稳定性和可用性。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是k8s&quot;&gt;&lt;a href=&quot;#什么是k8s&quot; class=&quot;headerlink&quot; title=&quot;什么是k8s&quot;&gt;&lt;/a&gt;什么是k8s&lt;/h3&gt;&lt;p&gt;K8s是指Kubernetes，是一个用于自动化部署、扩展和管理容器化应用程序的开源平台。&lt;/p&gt;
&lt;p&gt;简</summary>
      
    
    
    
    
    <category term="分布式" scheme="http://ailiaa.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="k8s" scheme="http://ailiaa.github.io/tags/k8s/"/>
    
  </entry>
  
  <entry>
    <title>Docker</title>
    <link href="http://ailiaa.github.io/2023/06/22/docker/"/>
    <id>http://ailiaa.github.io/2023/06/22/docker/</id>
    <published>2023-06-22T09:10:07.000Z</published>
    <updated>2023-08-31T09:12:01.904Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍一下-Docker"><a href="#介绍一下-Docker" class="headerlink" title="介绍一下 Docker"></a>介绍一下 Docker</h3><p>Docker是一种开源的容器化平台，用于构建、发布和运行应用程序。</p><p>Docker使用容器化技术，将应用程序及其依赖项打包成一个独立的、可执行的容器，包括应用程序代码、运行时环境、系统工具和依赖库。容器可以在任何支持Docker的环境中运行，而无需担心环境差异或依赖问题。</p><p>通过使用Docker，开发人员和运维团队可以更轻松地构建、交付和管理应用程序，提高开发效率、部署速度和系统可靠性。同时，Docker也为分布式系统、微服务架构和持续集成/持续交付（CI/CD）提供了强大的支持。</p><h3 id="一个完整的Docker由哪些部分组成"><a href="#一个完整的Docker由哪些部分组成" class="headerlink" title="一个完整的Docker由哪些部分组成"></a>一个完整的Docker由哪些部分组成</h3><ol><li>Docker引擎（Docker Engine）：核心组件，负责处理容器的生命周期管理、镜像构建和运行等功能。包括三个主要组件：Docker守护进程（Docker daemon）、REST API以及用于与守护进程进行交互的命令行工具（例如docker命令）。</li><li>Docker镜像（Docker Images）：镜像是Docker的基本构建块，它是一个只读的模板，包含了运行应用程序所需的文件系统、应用程序代码、依赖项和配置信息等。</li><li>Docker容器（Docker Containers）：容器是从镜像创建的运行实例。</li><li>Docker仓库（Docker Registry）：仓库是存储和分发Docker镜像的地方。Docker Hub是最常用的公共仓库，包含大量的官方和社区维护的镜像。</li><li>Docker网络（Docker Networking）：Docker网络允许容器之间进行通信，并与外部网络进行连接。</li><li>Docker数据卷（Docker Volumes）：数据卷是用于持久化和共享数据的机制，可以在容器之间共享文件和目录。数据卷可以附加到容器中，并在容器重新创建时保留数据。</li></ol><h3 id="什么是-Docker镜像"><a href="#什么是-Docker镜像" class="headerlink" title="什么是 Docker镜像"></a>什么是 Docker镜像</h3><p>Docker镜像是Docker容器的基础构建模块，是一个只读的模板，包含了运行应用程序所需的<strong>文件系统、应用程序代码、依赖项和配置信息</strong>等</p><p>镜像可以通过在Dockerfile中定义构建步骤来创建，也可以从Docker Hub等公共或私有仓库中获取现有的镜像。在容器创建时，Docker引擎会使用指定的镜像作为模板，并在只读层的基础上创建一个可写层，从而生成一个运行实例，即容器。</p><p>通过使用镜像，可以实现应用程序的快速部署、可重复性和便携性。每个镜像都是独立和隔离的，可以在各种环境中使用</p><h3 id="什么是-Docker-容器"><a href="#什么是-Docker-容器" class="headerlink" title="什么是 Docker 容器"></a>什么是 Docker 容器</h3><p>Docker容器是一种轻量级的虚拟化技术，用于将应用程序及其依赖项打包在一个可移植的、自包含的环境中。它可以在不同的计算机上运行，而无需担心环境差异、依赖问题或系统冲突。</p><p>通过使用Docker容器，开发人员可以轻松构建、交付和运行应用程序。容器化的应用程序可以在开发、测试和生产环境中保持一致，避免了”在我的机器上可以运行”的问题。</p><p><strong>特点</strong>：</p><ol><li><strong>轻量级</strong>：相比传统虚拟机，它们消耗更少的系统资源和存储空间。可以快速启动、停止和迁移</li><li><strong>可移植性</strong>：Docker容器包含了应用程序及其所有依赖项，可以在任何支持Docker的环境中运行。</li><li><strong>隔离性</strong>：每个Docker容器都是相互隔离的运行时环境，它们共享主机操作系统的内核，但彼此之间相互隔离。</li><li><strong>可扩展性</strong>：通过容器编排工具（Kubernetes），可以自动化地管理和调度多个容器实例，实现高可用性和负载均衡。</li><li><strong>快速部署和回滚</strong>：容器可以在几秒钟内启动，并且支持快速回滚到之前的版本。</li></ol><h3 id="Docker-和虚拟机有什么不同"><a href="#Docker-和虚拟机有什么不同" class="headerlink" title="Docker 和虚拟机有什么不同"></a>Docker 和虚拟机有什么不同</h3><ol><li><strong>架构差异</strong>：传统虚拟机是通过在物理主机上运行一个完整的操作系统来创建虚拟化环境，每个虚拟机都有自己的内核、操作系统和应用程序。而Docker容器共享宿主机的操作系统内核，容器内只运行应用程序及其依赖项，不需要额外的操作系统。</li><li><strong>资源利用</strong>：传统虚拟机需要分配独立的资源（CPU、内存、磁盘空间等）给每个虚拟机，这会导致资源的浪费。Docker容器共享主机操作系统的资源，可以更高效地利用和管理资源，多个容器可以在同一个宿主机上运行，共享内存和硬件。</li><li><strong>启动时间</strong>：传统虚拟机的启动时间通常较长，需要启动完整的操作系统和相关服务。而Docker容器的启动时间非常快速，通常只需几秒钟，因为容器只需要加载应用程序及其依赖项即可运行。</li><li><strong>部署和迁移</strong>：传统虚拟机的部署和迁移相对复杂，需要复制整个虚拟机镜像和配置文件。而Docker容器可以通过镜像来快速部署和迁移，镜像包含了应用程序的代码、依赖项和配置信息，可以在不同的Docker主机上快速复制和运行。</li></ol><h3 id="什么是-DockerFile"><a href="#什么是-DockerFile" class="headerlink" title="什么是 DockerFile"></a>什么是 DockerFile</h3><p>Dockerfile是一种文本文件，用于定义Docker镜像的构建过程。它包含一系列指令和参数，通过这些指令来描述应用程序的组件和依赖关系，以及如何将它们打包成一个可执行的Docker容器。</p><p>在Dockerfile中，以下是一些常用的指令：</p><ol><li>FROM：指定基础镜像，即构建新镜像所基于的现有镜像。</li><li>RUN：在容器中运行命令或脚本，用于安装软件包、配置环境和进行其他系统操作。</li><li>COPY 和 ADD：将文件从主机复制到容器中，可以将应用程序代码、配置文件和其他资源添加到镜像中。</li><li>WORKDIR：设置工作目录，即在容器中执行后续指令时的默认目录。</li><li>ENV：设置环境变量，供容器中的应用程序使用。</li><li>EXPOSE：声明容器应用程序监听的端口，方便在运行容器时进行映射。</li><li>CMD 和 ENTRYPOINT：用于定义容器启动后要运行的命令或脚本。</li></ol><p>通过编写和构建Dockerfile，可以自动化地构建Docker镜像，确保镜像的一致性和可重复性。可以使用<strong>docker build</strong>命令根据Dockerfile构建镜像，并将其保存在本地或推送到远程镜像仓库以供他人使用。</p><p><img src="/images/image_%E5%88%86%E5%B8%83%E5%BC%8F/1.png"></p><h3 id="Docker-Compose-是什么"><a href="#Docker-Compose-是什么" class="headerlink" title="Docker Compose 是什么"></a>Docker Compose 是什么</h3><p>Docker Compose是一个用于定义和管理多个Docker容器的工具，它通过一个单独的YAML文件来描述应用程序的组件、服务之间的关系以及它们的配置。</p><p>使用Docker Compose，可以轻松地在一个命令行界面中定义、启动和停止由多个容器组成的复杂应用程序。可以将复杂的应用程序拆分为多个独立的容器，并使用一个统一的配置文件进行管理。</p><p>主要功能：</p><ol><li><strong>定义多个容器</strong>：通过编写服务的配置，可以定义应用程序所需的多个容器。每个服务定义了一个镜像、容器的依赖关系和其他配置选项。</li><li><strong>管理容器的关系</strong>：自动处理容器之间的网络连接和依赖关系，确保它们正确地启动和通信。</li><li><strong>统一的环境变量和网络设置</strong>：在一个配置文件中指定容器的环境变量、端口映射、网络设置等</li><li><strong>一键启动和停止</strong>：使用docker-compose命令，可以一键启动、停止和重启整个应用程序，而不需要手动操作每个容器。</li></ol><h3 id="使用Docker-Compose时如何保证容器A先于容器B运行"><a href="#使用Docker-Compose时如何保证容器A先于容器B运行" class="headerlink" title="使用Docker Compose时如何保证容器A先于容器B运行"></a>使用Docker Compose时如何保证容器A先于容器B运行</h3><p>Docker Compose 在继续下一个容器之前不会等待容器准备就绪。为了控制我们的执行顺序，我们可以使用“<strong>取决于</strong>”条件，<code>depends_on</code>&nbsp;。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"2.4"</span><span class="token key atrule">services</span><span class="token punctuation">:</span> <span class="token key atrule">backend</span><span class="token punctuation">:</span>   <span class="token key atrule">build</span><span class="token punctuation">:</span> .    <span class="token comment"># 构建自定义镜像</span>   <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> db <span class="token key atrule">db</span><span class="token punctuation">:</span>   <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用&nbsp;<code>docker-compose up</code>&nbsp;命令将按照我们指定的依赖顺序启动和运行服务。<br><code>docker-compose down</code>关闭服务</p><h3 id="docker-常用命令有哪些"><a href="#docker-常用命令有哪些" class="headerlink" title="docker 常用命令有哪些"></a>docker 常用命令有哪些</h3><ol><li><p>镜像相关命令：</p><ul><li><code>docker images</code>：列出本地所有的Docker镜像。</li><li><code>docker pull &lt;镜像名&gt;</code>：从仓库下载指定的Docker镜像。</li><li><code>docker push &lt;镜像名&gt;</code>：将本地的Docker镜像推送到仓库中。</li><li><code>docker build -t &lt;镜像名&gt; &lt;Dockerfile路径&gt;</code>：基于Dockerfile构建一个新的Docker镜像。</li><li><code>docker rmi &lt;镜像名&gt;</code>：删除指定的Docker镜像。</li></ul></li><li><p>容器相关命令：</p><ul><li><code>docker ps</code>：列出正在运行的容器。</li><li><code>docker ps -a</code>：列出所有的容器，包括正在运行和已停止的。</li><li><code>docker run &lt;镜像名&gt;</code>：创建并启动一个新的容器。</li><li><code>docker start &lt;容器ID或名称&gt;</code>：启动已停止的容器。</li><li><code>docker stop &lt;容器ID或名称&gt;</code>：停止正在运行的容器。</li><li><code>docker restart &lt;容器ID或名称&gt;</code>：重启容器。</li><li><code>docker rm &lt;容器ID或名称&gt;</code>：删除指定的容器。</li><li><code>docker exec -it &lt;容器ID或名称&gt; &lt;命令&gt;</code>：在正在运行的容器中执行命令。</li></ul></li><li><p>仓库和网络相关命令：</p><ul><li><code>docker login</code>：登录到Docker仓库。</li><li><code>docker logout</code>：登出Docker仓库。</li><li><code>docker search &lt;关键词&gt;</code>：在Docker仓库中搜索镜像。</li><li><code>docker network ls</code>：列出所有的网络。</li><li><code>docker network create &lt;网络名称&gt;</code>：创建一个新的网络。</li></ul></li></ol><h3 id="说说-Docker容器的生命周期"><a href="#说说-Docker容器的生命周期" class="headerlink" title="说说 Docker容器的生命周期"></a>说说 Docker容器的生命周期</h3><p>Docker容器的生命周期包括创建、启动、运行、停止和删除几个主要阶段</p><ol><li>创建阶段：通过使用<code>docker run</code>命令或类似的方式，基于Docker镜像创建一个新的容器。Docker引擎会根据镜像的定义，在镜像的只读层上创建一个可写层，并为容器分配资源。</li><li>启动阶段：通过<code>docker start</code>命令，启动一个已创建但处于停止状态的容器。</li><li>运行阶段：一旦容器启动，它就处于运行状态。可以使用<code>docker exec</code>命令在运行中的容器中执行额外的命令。</li><li>停止阶段：通过<code>docker stop</code>命令，停止一个正在运行的容器。如果应用程序无法正常停止，可以使用<code>docker kill</code>命令来强制停止容器。</li><li>删除阶段：通过<code>docker rm</code>命令，删除一个已停止的容器。</li></ol><p>容器本身是临时的，当容器停止或删除后，它的状态和数据都会丢失。</p><p>为了持久化数据，可以使用数据卷（Volume）或绑定挂载（Bind Mount）等方式将容器内部的数据映射到宿主机上的存储位置。</p><h3 id="docker容器之间怎么隔离"><a href="#docker容器之间怎么隔离" class="headerlink" title="docker容器之间怎么隔离"></a>docker容器之间怎么隔离</h3><p>Docker容器之间通过使用<strong>Linux内核级别的隔离技术</strong>来实现隔离。</p><ol><li>命名空间（Namespaces）：Docker使用了多种命名空间，包括PID（进程ID）、UTS（主机名和域名）、IPC（进程间通信）、网络、挂载点和用户等。每个容器在这些命名空间中具有独立的视图，使得它们在容器内部看到的系统资源是有限的，无法直接访问其他容器的资源。</li><li>控制组（Control Groups，简称cgroups）：cgroups允许对容器中的资源进行限制和分配，例如CPU、内存、磁盘IO等。通过cgroups，可以为每个容器设置资源限制，防止一个容器占用过多的资源对其他容器产生影响。</li><li>文件系统隔离：每个容器都有自己的文件系统空间，容器中的文件系统在本质上是宿主机上的一个目录或文件的快照。</li><li>网络隔离：Docker为每个容器提供了独立的网络命名空间和网络栈，使得容器可以有自己的IP地址、网络接口和路由表。</li></ol><h3 id="Docker-Swarm是什么"><a href="#Docker-Swarm是什么" class="headerlink" title="Docker Swarm是什么"></a>Docker Swarm是什么</h3><p>Docker Swarm 是 Docker 容器的集群管理工具，它允许将多个 Docker 主机组成一个分布式的容器集群。</p><p>通过 Docker Swarm，用户可以使用简单的命令或者 Docker Compose 文件来创建、部署和管理容器集群。Swarm Manager 负责集群的管理和调度，自动将服务在集群中分配和扩展。</p><p>关键概念和功能：</p><ol><li>节点（Nodes）: 每个节点可以是物理机器或虚拟机。其中有一个节点被选为 Swarm Manager（管理节点），其他节点为 Worker（工作节点）。</li><li>服务（Services）: 基本单位，表示要部署和运行的容器应用。</li><li>副本（Replicas）: 服务可以指定多个副本（replica），Swarm 会自动将这些副本调度到不同的节点上运行，以实现负载均衡和高可用性。</li><li>任务（Tasks）: 每个服务都会被划分为多个任务（task），每个任务代表一个要运行的容器实例。</li><li>网络（Networks）: 不同节点上的容器可以直接通过内部网络通信，而无需暴露主机端口。</li><li>栈（Stacks）: 相关的服务的集合。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;介绍一下-Docker&quot;&gt;&lt;a href=&quot;#介绍一下-Docker&quot; class=&quot;headerlink&quot; title=&quot;介绍一下 Docker&quot;&gt;&lt;/a&gt;介绍一下 Docker&lt;/h3&gt;&lt;p&gt;Docker是一种开源的容器化平台，用于构建、发布和运行应用程序。&lt;</summary>
      
    
    
    
    
    <category term="分布式" scheme="http://ailiaa.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="Docker" scheme="http://ailiaa.github.io/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>分布式</title>
    <link href="http://ailiaa.github.io/2023/06/16/fen-bu-shi-xi-tong/"/>
    <id>http://ailiaa.github.io/2023/06/16/fen-bu-shi-xi-tong/</id>
    <published>2023-06-16T05:29:52.000Z</published>
    <updated>2023-09-15T02:34:54.432Z</updated>
    
    <content type="html"><![CDATA[<h3 id="谈谈你对分布式系统的理解"><a href="#谈谈你对分布式系统的理解" class="headerlink" title="谈谈你对分布式系统的理解"></a>谈谈你对分布式系统的理解</h3><p>为了解决传统单体服务架构带来的各种问题，代码数量庞大，迭代测试维护困难，可能因为一处改动测试不到位造成整个服务瘫痪等问题。</p><p>分布式系统就是将一个大的服务拆分成几十个甚至上百个微小的服务。，代码不在一个项目里，方便大家分工开发，也不会冲突，便于项目维护</p><p>比如阿里的 Dubbo，还有 Spring 全家桶里的 Spring Cloud，都是解决分布式微服务架构的优秀框架。</p><h3 id="分布式系统环境下各自有什么优缺点"><a href="#分布式系统环境下各自有什么优缺点" class="headerlink" title="分布式系统环境下各自有什么优缺点"></a>分布式系统环境下各自有什么优缺点</h3><p>优点：</p><ul><li><p><strong>系统可用性提升</strong>：分布式下的服务体系，单台机器有故障，不致于造成整个服务不可用。</p></li><li><p><strong>系统并发能力提升</strong>：请求通过 Nginx 负载均衡被分发到不同的服务器上，运行同样代码的服务器可以有 1 台或 N 台，通常情况下会根据实际用户访问量随时增加机器</p></li><li><p><strong>系统容错能力提升</strong>：同一组服务分别部署在北京上海杭州，杭州的机房突发断电或者火灾，杭州机房的流量会被自动分发到北京和上海的机房，不影响用户使用。</p></li><li><p><strong>低延迟</strong> ：北京的用户请求自动分发到北京，上海的用户请求被分发到上海，服务器会根据用户的 IP 选择距离自己最近的机房，降低网络延迟。</p></li></ul><p>缺点：</p><p><strong>分布式服务依赖网络</strong>：服务器间通讯依赖网络，不可靠网络包括网络延时，丢包、中断、异步，一个完整的服务请求依赖一连串服务调用，任意一个服务节点网络出现问题，都可能造成本次请求失败。</p><p><strong>维护成本高</strong>：分布式服务系统被拆分成若干个小服务，服务从 1 变为几十个上百个服务后，增加运维成本。</p><p><strong>一致性，可用性，分区容错性无法同时满足</strong>：这三种特性最多只能满足两种，无法同时满足，需要根据实际情况去调整牺牲掉其中哪个。</p><h3 id="CAP-理论是什么"><a href="#CAP-理论是什么" class="headerlink" title="CAP 理论是什么"></a>CAP 理论是什么</h3><p><strong>CAP</strong>&nbsp;也就是&nbsp;<strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong>&nbsp;这三个单词首字母组合。</p><p>CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p><ul><li><strong>一致性</strong> : 所有节点访问同一份最新的数据副本</li><li><strong>可用性</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li><li><strong>分区容错性</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li></ul><p>网络分区：分布式系统中，多个节点之间的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域。</p><p>CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p><h3 id="为什么不可能选择-CA-架构呢"><a href="#为什么不可能选择-CA-架构呢" class="headerlink" title="为什么不可能选择 CA 架构呢"></a>为什么不可能选择 CA 架构呢</h3><p>举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了</p><p><strong>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</strong></p><p><strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p><h3 id="BASE-理论是什么"><a href="#BASE-理论是什么" class="headerlink" title="BASE 理论是什么"></a>BASE 理论是什么</h3><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong>、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。</p><p>BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p><p><strong>基本可用</strong>：基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p><ul><li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li><li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li></ul><p><strong>软状态</strong>：允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程<strong>存在延时</strong>。</p><p><strong>最终一致性</strong>：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。</p><ul><li>分布式一致性的 3 种级别：</li></ul><ol><li><strong>强一致性</strong>：系统写入了什么，读出来的就是什么。</li><li><strong>弱一致性</strong>：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li><li><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li></ol><h3 id="BASE-理论的核心思想"><a href="#BASE-理论的核心思想" class="headerlink" title="BASE 理论的核心思想"></a>BASE 理论的核心思想</h3><p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><blockquote><p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p></blockquote><h3 id="分布式存储和一般存储的区别"><a href="#分布式存储和一般存储的区别" class="headerlink" title="分布式存储和一般存储的区别"></a>分布式存储和一般存储的区别</h3><ol><li>数据复制和冗余：分布式存储系统将数据分布在多个节点上，通过数据的冗余复制来提高数据的可靠性和容错能力。而一般存储系统通常是单节点或少数几个节点存储数据，没有数据的冗余备份。</li><li>数据访问和负载均衡：分布式存储系统可以使用各种负载均衡算法，将数据请求分配到不同的节点，从而实现高并发的数据访问。而一般存储系统通常只能由单个节点处理所有的数据请求。</li><li>扩展性和容量：分布式存储系统可以根据需求动态扩展节点，从而扩展存储容量和吞吐量。而一般存储系统的容量和性能通常受限于单个节点的硬件资源。</li><li>数据一致性：分布式存储系统需要解决数据一致性的问题，即如何保证在分布式环境下多个副本之间的数据一致。而一般存储系统通常采用隔离级别、锁定机制等方法来保证数据的一致性。</li><li>故障恢复：分布式存储系统可以通过故障转移和数据复制来实现故障恢复和容错。一般存储系统通常需要手动或半自动的方式来处理故障和数据恢复。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;谈谈你对分布式系统的理解&quot;&gt;&lt;a href=&quot;#谈谈你对分布式系统的理解&quot; class=&quot;headerlink&quot; title=&quot;谈谈你对分布式系统的理解&quot;&gt;&lt;/a&gt;谈谈你对分布式系统的理解&lt;/h3&gt;&lt;p&gt;为了解决传统单体服务架构带来的各种问题，代码数量庞大，迭代测</summary>
      
    
    
    
    
    <category term="分布式" scheme="http://ailiaa.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>基于kubernetes部署云原生微服务应用Online Boutique</title>
    <link href="http://ailiaa.github.io/2023/06/09/ji-yu-kubernetes-bu-shu-yun-yuan-sheng-wei-fu-wu-ying-yong-online-boutique/"/>
    <id>http://ailiaa.github.io/2023/06/09/ji-yu-kubernetes-bu-shu-yun-yuan-sheng-wei-fu-wu-ying-yong-online-boutique/</id>
    <published>2023-06-09T09:46:17.000Z</published>
    <updated>2023-07-24T09:40:46.736Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置kubernetes集群环境"><a href="#配置kubernetes集群环境" class="headerlink" title="配置kubernetes集群环境"></a>配置kubernetes集群环境</h3><p>创建三台华为云服务器，一台做k8s-master服务器，另外两台做node节点服务器。</p><p><em><strong>对这三台服务器</strong></em>，执行以下相同命令</p><p><strong>关闭swap:</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">swapoff <span class="token parameter variable">-a</span><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/.*swap.*/#&amp;/'</span> /etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>关闭防火墙：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop ufwsystemctl disable ufwsystemctl stop firewalldsystemctl disable firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修改软件源：</strong></p><p>编辑/etc/apt/sources.list</p><p>修改镜像源(阿里云/华为/清华园)</p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> update<span class="token function">apt-get</span> upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>安装docker：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> docker.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开机自启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span>systemctl daemon-reloadsystemctl restart <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><em><strong>对于master节点</strong></em></p><p><strong>配置master节点：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">hostname</span> k8s-master<span class="token function">wget</span> https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpgapt-key <span class="token function">add</span> apt-key.gpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装kubernetes：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> apt-transport-https <span class="token function">curl</span><span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token assign-left variable">kubelet</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 <span class="token assign-left variable">kubeadm</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 <span class="token assign-left variable">kubectl</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 --allow-unauthenticated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm config images list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/1.png"></p><p><strong>配置镜像：</strong></p><p>换国内源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.17<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.17 k8s.gcr.io/kube-apiserver:v1.17.17<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.17<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.17.17<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/kube-controller-manager:v1.17.17 k8s.gcr.io/kube-controller-manager:v1.17.17<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/kube-controller-manager:v1.17.17<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.17.17<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/kube-scheduler:v1.17.17 k8s.gcr.io/kube-scheduler:v1.17.17<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/kube-scheduler:v1.17.17<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-proxy:v1.17.17<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/kube-proxy:v1.17.17 k8s.gcr.io/kube-proxy:v1.17.17<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/kube-proxy:v1.17.17<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/pause:3.1<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/pause:3.1 k8s.gcr.io/pause:3.1<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/pause:3.1<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/etcd:3.4.3-0<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/etcd:3.4.3-0 k8s.gcr.io/etcd:3.4.3-0<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/etcd:3.4.3-0<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/coredns:1.6.5<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/coredns:1.6.5 k8s.gcr.io/coredns:1.6.5<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/coredns:1.6.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/2.png"></p><p><strong>初始化master节点：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm init --pod-network-cidr<span class="token operator">=</span><span class="token number">10.244</span>.0.0/16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/3.png"></p><p>保存图中node节点加入master集群的指令：</p><p>kubeadm&nbsp;join……</p><p>切换为普通用户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token environment constant">$HOME</span>/.kube<span class="token function">sudo</span> <span class="token function">cp</span> <span class="token parameter variable">-i</span> /etc/kubernetes/admin.conf <span class="token environment constant">$HOME</span>/.kube/config<span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> <span class="token parameter variable">-u</span><span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> <span class="token parameter variable">-g</span><span class="token variable">)</span></span> <span class="token environment constant">$HOME</span>/.kube/configkubectl get pods --all-namespaces<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/4.png"></p><p>如果coredns 处于pending状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get nodes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现master处于NotReady状态</p><p>需要部署pod network插件文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /usr/local/src/kube-flannel.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">node</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/5.png"></p><p><strong>配置node节点：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">hostname</span> node1<span class="token punctuation">(</span>node2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同上操作</p><p><strong>安装****kubernetes</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpgapt-key <span class="token function">add</span> apt-key.gpg<span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> apt-transport-https <span class="token function">curl</span><span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token assign-left variable">kubelet</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 <span class="token assign-left variable">kubeadm</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 <span class="token assign-left variable">kubectl</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 --allow-unauthenticated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>docker镜像换源</strong><br>……</p><p><strong>加入集群：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm <span class="token function">join</span> <span class="token number">192.168</span>.0.202:6443 <span class="token parameter variable">--token</span> 09hdi2.ogp6wujqwvhmrisk <span class="token punctuation">\</span> --discovery-token-ca-cert-hash sha256:1cffed7c52b078773c1f128ef3b7ecfd00efda14cf2c408a324cc492bf94f523<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>可能出现的问题</strong></p><p>&lt;1&gt;如果出现coredns网络异常，则可能需要部署网络插件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /usr/local/src/kube-flannel.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&lt;2&gt;如果出现</p><pre class="line-numbers language-none"><code class="language-none">Error in configuration:* unable to read client-cert /var/lib/kubelet/pki/kubelet-client-current.pem for default-auth due to open /var/lib/kubelet/pki/kubelet-client-current.pem: no such file or directory* unable to read client-key /var/lib/kubelet/pki/kubelet-client-current.pem for default-auth due to open /var/lib/kubelet/pki/kubelet-client-current.pem: no such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>则表示token过期，需要重新create及join</p><p>&lt;3&gt;如果出现</p><pre class="line-numbers language-none"><code class="language-none">error execution phase preflight: couldn't validate the identity of the API Server: Get "https://192.168.xxx.xx:6443/api/v1/namespaces/kube-public/configmaps/cluster-info?timeout=10s": net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)To see the stack trace of this error execute with --v=5 or higher<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>则可能是防火墙问题</p><p>&lt;4&gt;如果</p><pre class="line-numbers language-none"><code class="language-none">W0706 10:27:55.181115 &nbsp;&nbsp;22817 loader.go:221] Config not found: /etc/kubernetes/admin.confThe connection to the server localhost:8080 was refused - did you specify the right host or port?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>发现 Node 节点只有 kubelet.conf 配置项，而没有admin.conf</p><p>切换为普通用户</p><pre class="line-numbers language-none"><code class="language-none">mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/kubelet.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Node节点配置完成，在master节点上执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">node</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/6.png"></p><p>如果k8s-master的状态是NotReady,可能是hostname k8s-master错误，和主机命名不一致</p><h3 id="部署dashboard"><a href="#部署dashboard" class="headerlink" title="部署dashboard"></a>部署dashboard</h3><p>将配置文件create-admin.yaml和kubernetes-dashboard-v2.0.3.yml上传到master节点，执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> create-admin.yamlkubectl apply <span class="token parameter variable">-f</span> kubernetes-dashboard-v2.0.3.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get pod <span class="token parameter variable">-o</span> wide --all-namespaces<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/7.png"></p><p>登录dashboard面板</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/8.png"></p><p>获取token登录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl <span class="token parameter variable">-n</span> kubernetes-dashboard describe secret <span class="token variable"><span class="token variable">$(</span>kubectl <span class="token parameter variable">-n</span> kubernetes-dashboard get secret <span class="token operator">|</span> <span class="token function">grep</span> admin-user <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $1}'</span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/9.png"></p><h3 id="安装并部署Istio"><a href="#安装并部署Istio" class="headerlink" title="安装并部署Istio"></a>安装并部署Istio</h3><p>去<a href="https://github.com/istio/istio/releases">https://github.com/istio/istio/releases</a>下载安装包,下载安装包之后解压</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> xf istio-1.8.5-linux-amd64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-L</span> https://istio.io/downloadIstio <span class="token operator">|</span> <span class="token assign-left variable">ISTIO_VERSION</span><span class="token operator">=</span><span class="token number">1.8</span>.5 <span class="token assign-left variable">TARGET_ARCH</span><span class="token operator">=</span>x86_64 <span class="token function">sh</span> -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加到 path</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加以下内容</p><pre class="line-numbers language-none"><code class="language-none">export ISTIOCTL_HOME="/home/istio-1.8.5"export PATH="$ISTIOCTL_HOME/bin:$PATH"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行生效</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">istioctl version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/10.png"></p><p>部署 Istio Operator</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">istioctl operator init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/11.png"></p><p>init 命令创建了 istio-operator 命名空间，并部署了 CRD、Operator Deployment 以及 operator 工作所需的其他资源。</p><p>要安装 Istio，必须先创建 IstioOperator 资源，并指定要使用的配置文件。</p><p>创建目录istioyaml，用来专门存放yaml文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> istioyaml<span class="token builtin class-name">cd</span> istioyaml/<span class="token function">vim</span> istio-demo-profile.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>填入以下内容：</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1kind: Namespacemetadata:&nbsp;&nbsp;name: istio-system---apiVersion: install.istio.io/v1alpha1kind: IstioOperatormetadata:&nbsp;&nbsp;namespace: istio-system&nbsp;&nbsp;name: demo-istio-installspec:&nbsp;&nbsp;profile: demo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> istio-demo-profile.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看istio-system命名空间下的所有资源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get all <span class="token parameter variable">-o</span> wide <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/12.png"></p><p>为了检查安装的状态，查看 istio-system&nbsp;命名空间中的 Pod 的状态。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get pod <span class="token parameter variable">-o</span> wide <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/13.png"></p><p>Istio安装完成后，创建一个命名空间online-boutique，新的项目就部署在online-boutique命名空间下，给命名空间online-boutique设置上 istio-injection=enabled 标签，启用sidecar 自动注入。</p><p>创建命名空间online-boutique</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl create ns online-boutique<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>切换命名空间</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl config set-context <span class="token parameter variable">--current</span> <span class="token parameter variable">--namespace</span><span class="token operator">=</span>online-boutique<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>让命名空间online-boutique启用sidecar 自动注入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl label ns online-boutique istio-injection<span class="token operator">=</span>enabledkubectl get ns <span class="token parameter variable">-l</span> istio-injection --show-labels<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/14.png"></p><h3 id="部署-Online-Boutique-应用"><a href="#部署-Online-Boutique-应用" class="headerlink" title="部署 Online Boutique 应用"></a>部署 Online Boutique 应用</h3><p><strong>拉取项目</strong></p><p>创建online-boutique目录，项目放在该目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> online-boutique<span class="token builtin class-name">cd</span> online-boutique/<span class="token function">git</span> clone https://github.com/GoogleCloudPlatform/microservices-demo.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>配置镜像</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> microservices-demo/<span class="token builtin class-name">cd</span> release/<span class="token comment"># 查看需要下载的镜像</span><span class="token function">grep</span> image kubernetes-manifests.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/15.png"></p><p>镜像换源，换为国内</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/gcr.io/gcr.lank8s.cn/'</span> kubernetes-manifests.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>创建 Kubernetes 资源</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /home/online-boutique/microservices-demo/release/kubernetes-manifests.yaml <span class="token parameter variable">-n</span> online-boutique<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/16.png"></p><p>检查所有 Pod 都在运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get pod <span class="token parameter variable">-o</span> wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/17.png"></p><p><strong>创建 Istio 资源</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> ./istio-manifests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>获取访问地址</strong></p><p>部署了一切后，就可以得到入口网关的 IP 地址并打开前端服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">INGRESS_HOST</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span>kubectl <span class="token parameter variable">-n</span> istio-system get <span class="token function">service</span> istio-ingressgateway <span class="token parameter variable">-o</span> <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">'{.status.loadBalancer.ingress[0].ip}'</span><span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$INGRESS_HOST</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">service</span> <span class="token parameter variable">-n</span> istio-system istio-ingressgateway <span class="token parameter variable">-o</span> wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现 EXTERNAL-IP 为 pending</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl edit  <span class="token function">service</span> istio-ingressgateway <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加外部IP</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/18.png"></p><p>访问项目地址</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/19.png"></p><h3 id="Istio插件配置"><a href="#Istio插件配置" class="headerlink" title="Istio插件配置"></a>Istio插件配置</h3><h4 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h4><p>Prometheus 是一个开源的监控系统和时间序列数据库。Istio 使用 Prometheus 来记录指标，跟踪 Istio 和网格中的应用程序的健康状况。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/istio-1.8.5/samples/addons/<span class="token function">grep</span> image prometheus.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装prometheus需要用到两个镜像：</p><p>jimmidyson/configmap-reload:v0.4.0 和 prom/prometheus:v2.21.0</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/20.png"></p><p>在k8s的node节点拉取所需镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull jimmidyson/configmap-reload:v0.4.0<span class="token function">docker</span> pull prom/prometheus:v2.21.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/21.png"></p><p>安装prometheus</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /home/istio-1.8.5/samples/addons/prometheus.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/22.png"></p><p>查看部署状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get deploy <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/23.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">service</span> <span class="token parameter variable">-n</span> istio-system <span class="token parameter variable">-o</span> wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/24.png"></p><p>prometheus的service的类型为ClusterIP，外部环境访问不了</p><p>修改prometheus这个service的类型为NodePort，这样外部环境就可以访问prometheus了</p><p>把type: ClusterIP 修改为 type: NodePort即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl edit <span class="token function">service</span> prometheus <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/25.png"></p><p>之后可以根据ip加端口号访问该服务</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/26.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/27.png"></p><h4 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h4><p>Grafana 是一个用于分析和监控的开放平台。Grafana 可以连接到各种数据源，并使用图形、表格、热图等将数据可视化。通过强大的查询语言，你可以定制现有的仪表盘并创建更高级的可视化。</p><p>通过 Grafana，我们可以监控 Istio 安装和服务网格中运行的应用程序的健康状况。</p><p>我们可以使用 grafana.yaml 来部署带有预配置仪表盘的 Grafana 示例安装。该 YAML 文件在 Istio 安装包的 /samples/addons 下。</p><p>确保在部署 Grafana 之前部署 Promeheus 插件，因为 Grafana 使用 Prometheus 作为其数据源。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/istio-1.8.5/samples/addons<span class="token function">grep</span> image grafana.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/28.png"></p><p>在k8s的node节点拉取所需镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull grafana/grafana:7.2.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/29.png"></p><p>安装grafana</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /home/istio-1.8.5/samples/addons/grafana.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/30.png"></p><p>查看部署状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get pod <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/31.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">service</span> <span class="token parameter variable">-n</span> istio-system <span class="token parameter variable">-o</span> wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/32.png"></p><p>同上</p><p>可以看到grafana这个service的类型为ClusterIP，外部环境访问不了</p><p>修改grafana这个service的类型为NodePort，这样外部环境就可以访问grafana了</p><p>把type: ClusterIP 修改为 type: NodePort即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl edit <span class="token function">service</span> grafana <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后可以根据ip加端口号访问该服务</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/33.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/34.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/35.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/36.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/37.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/38.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/39.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/40.png"></p><h4 id="Kiali"><a href="#Kiali" class="headerlink" title="Kiali"></a>Kiali</h4><p>在kubernetes中为Istio配置Kiali，实现Istio服务网格的可视化，为Online Boutique项目提供服务拓扑图、全链路跟踪、指标遥测、配置校验、健康检查等功能。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/istio-1.8.5/samples/addons/kubectl apply <span class="token parameter variable">-f</span> kiali.yamlkubectl get pod <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/41.png"></p><p>同样需要把type: ClusterIP 修改为 type: NodePort</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/42.png"></p><h4 id="Jaeger"><a href="#Jaeger" class="headerlink" title="Jaeger"></a>Jaeger</h4><p>Jaeger 是Uber推出的一款开源分布式追踪系统，兼容OpenTracing API。分布式追踪系统用于记录请求范围内的信息，包括一次调用的服务链路以及每个服务的延时，能够帮助我们很好的分析微服务间链路调用的错误及瓶颈。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/istio-1.8.5/samples/addons/kubectl apply <span class="token parameter variable">-f</span> jaeger.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/43.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">service</span> <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/44.png"></p><p>同样需要把type: ClusterIP 修改为 type: NodePort</p><p>之后可以根据ip加端口号访问该服务</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/45.png"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]&nbsp;<a href="https://www.cnblogs.com/boshen-hzb/p/10679863.html">https://www.cnblogs.com/boshen-hzb/p/10679863.html</a>&nbsp;&nbsp;istio实现对外暴露服务</p><p>[2]&nbsp;<a href="https://www.cnblogs.com/fenjyang/p/14417494.html">https://www.cnblogs.com/fenjyang/p/14417494.html</a>&nbsp;K8S线上集群排查，实测排查Node节点NotReady异常状态</p><p>[3]&nbsp;<a href="https://www.cnblogs.com/renshengdezheli/p/16841875.html#32-kubernetes%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83">https://www.cnblogs.com/renshengdezheli/p/16841875.html#32-kubernetes%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83</a>&nbsp;Istio项目实际案例——Online Boutique</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;配置kubernetes集群环境&quot;&gt;&lt;a href=&quot;#配置kubernetes集群环境&quot; class=&quot;headerlink&quot; title=&quot;配置kubernetes集群环境&quot;&gt;&lt;/a&gt;配置kubernetes集群环境&lt;/h3&gt;&lt;p&gt;创建三台华为云服务器，一台做</summary>
      
    
    
    
    
    <category term="云计算" scheme="http://ailiaa.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="kubernetes" scheme="http://ailiaa.github.io/tags/kubernetes/"/>
    
    <category term="Istio" scheme="http://ailiaa.github.io/tags/Istio/"/>
    
    <category term="微服务" scheme="http://ailiaa.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>华为云大数据集群搭建</title>
    <link href="http://ailiaa.github.io/2023/05/17/hua-wei-yun-da-shu-ju-ji-qun-da-jian/"/>
    <id>http://ailiaa.github.io/2023/05/17/hua-wei-yun-da-shu-ju-ji-qun-da-jian/</id>
    <published>2023-05-17T06:46:24.000Z</published>
    <updated>2023-05-17T07:11:24.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="华为云环境搭建"><a href="#华为云环境搭建" class="headerlink" title="华为云环境搭建"></a>华为云环境搭建</h3><h4 id="华为云ECS"><a href="#华为云ECS" class="headerlink" title="华为云ECS"></a>华为云ECS</h4><p>ECS购买需遵循以下规格：</p><ul><li>计费模式：按需计费</li><li>可用区：可用区一</li><li>CPU架构：x86</li><li>规格： 2vcpus|8GB</li><li>系统：CentOS7.6</li><li>系统盘：超高IO、100GB。</li><li>网络：按流量计费</li><li>其他配置：默认</li></ul><p>完成基础配置，网络配置，高级配置。购买4台ECS</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%871.png">&nbsp;</p><h4 id="对象存储服务OBS"><a href="#对象存储服务OBS" class="headerlink" title="对象存储服务OBS"></a>对象存储服务OBS</h4><p>区域选择与ECS相同。其他配置默认</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%872.png"></p><h4 id="创建并行文件系统"><a href="#创建并行文件系统" class="headerlink" title="创建并行文件系统"></a>创建并行文件系统</h4><p>配置默认</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%873.png"></p><p>进入创建的OBS桶，记录参数endpoint</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%874.png"></p><h4 id="获取AK-SK"><a href="#获取AK-SK" class="headerlink" title="获取AK/SK"></a>获取AK/SK</h4><p>华为云页面右上角“用户名”，下拉选择“我的凭证”，点击“访问秘钥”。新增访问秘钥，根据提示进行操作，得到文件“credentials.csv”，打开即可得到AK/SK</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%875.png"></p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%876.png"></p><h3 id="Hadoop集群搭建"><a href="#Hadoop集群搭建" class="headerlink" title="Hadoop集群搭建"></a>Hadoop集群搭建</h3><p>通过搭建开源Hadoop集群，掌握Hadoop搭建方法。并且使开源Hadoop与华为云OBS服务互联，使Hadoop集群可读取OBS数据。</p><h4 id="配置ECS"><a href="#配置ECS" class="headerlink" title="配置ECS"></a>配置ECS</h4><p>登录三个节点服务器<br>下载hadoop安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">wget</span> https://bigdata-tools-hw.obs.cn-north-1.myhuaweicloud.com/hadoop-2.8.3.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下载OBSFileSystem相关jar包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">wget</span> https://bigdata-tools-hw.obs.cn-north-1.myhuaweicloud.com/hadoop-huaweicloud-2.8.3-hw-39.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%877.png"></p><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><p>下载并拷贝jdk8至/usr/local/java，并解压缩</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/<span class="token function">mkdir</span> <span class="token function">java</span><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> jdk-8u351-linux-x64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置环境变量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按“i”进入编辑模式，使用hjkl键或方向键移动光标，在文件最后添加以下代码：</p><pre class="line-numbers language-none"><code class="language-none">JAVA_HOME=/usr/local/java/jdk1.8******export PATH=$PATH:$JAVA_HOME/binexport JAVA_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>按“Esc”退出编辑模式，输入“:wq”并按回车，保存退出。</p><p>执行以下命令，使新增配置生效。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，验证jdk安装并配置成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> –version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%878.png"></p><h4 id="配置hosts文件"><a href="#配置hosts文件" class="headerlink" title="配置hosts文件"></a>配置hosts文件</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加</p><pre class="line-numbers language-none"><code class="language-none">192.168.0.46&nbsp;node-0001192.168.0.123&nbsp;node-0002192.168.0.148&nbsp;node-0003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="配置节点互信"><a href="#配置节点互信" class="headerlink" title="配置节点互信"></a>配置节点互信</h4><p>各节点执行以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%879.png"></p><p>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /root/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8710.png"></p><p>复制该命令在各节点的输出内容。</p><p>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /root/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入各节点的复制内容，保存退出。</p><p>各节点执行：ssh node-0001~node-0003，选择yes后，确保能够无密码跳转到目标节点</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8711.png"></p><h4 id="搭建Hadoop集群"><a href="#搭建Hadoop集群" class="headerlink" title="搭建Hadoop集群"></a>搭建Hadoop集群</h4><p>创建目录<br>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /home/modules/data/buf<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /home/nm/localdir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>登录node-0001节点，解压hadoop安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">cp</span> hadoop-2.8.3.tar.gz /home/modules/<span class="token builtin class-name">cd</span> /home/modules/<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> hadoop-2.8.3.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置hadoop core-site.xml配置文件<br>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/core-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数配置：</p><pre class="line-numbers language-none"><code class="language-none">&lt;configuration&gt;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.readahead.inputstream.enabled&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;true&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.buffer.max.range&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;6291456&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.buffer.part.size&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;2097152&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.threads.read.core&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;500&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.threads.read.max&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;1000&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.write.buffer.size&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;8192&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.read.buffer.size&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;8192&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.connection.maximum&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;1000&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.defaultFS&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;hdfs://node-0001:8020&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;/home/modules/hadoop-2.8.3/tmp&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.access.key&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;FOR20CBUDGPBNEZDADQE&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.secret.key&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;5TZnFhulDt04EG1lfMzgdYCi8OMg6HwasWEcGBkO&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.endpoint&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;obs.cn-north-4.myhuaweicloud.com:5080&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.buffer.dir&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;/home/modules/data/buf&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.impl&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;org.apache.hadoop.fs.obs.OBSFileSystem&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.connection.ssl.enabled&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;false&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.fast.upload&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;true&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.socket.send.buffer&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;65536&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.socket.recv.buffer&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;65536&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.max.total.tasks&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;20&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.threads.max&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;20&lt;/value&gt;&nbsp;&lt;/property&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：fs.obs.access.key、fs.obs.secret.key、fs.obs.endpoint、fs.defaultFS需根据实际情况修改</p><p>配置hdfs-site.xml</p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/hdfs-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数配置如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;configuration&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.replication&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;3&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;node-0001:50090&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.namenode.secondary.https-address&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;node-0001:50091&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&nbsp;&lt;property&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;file:/home/modules/hadoop-2.8.3/data/namenode&lt;/value&gt;  &nbsp;&lt;/property&gt;  &nbsp;&lt;property&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;file:/home/modules/hadoop-2.8.3/data/datanode&lt;/value&gt;  &nbsp;&lt;/property&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：主机名node-0001需要根据实际替换。</p><p><strong>配置yarn-site.xml</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/yarn-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数配置如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;configuration&gt;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.local-dirs&lt;/name&gt;&lt;value&gt;/home/nm/localdir&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;28672&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;3072&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;28672&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.resource.cpu-vcores&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;38&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.scheduler.maximum-allocation-vcores&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;38&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;mapreduce_shuffle&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;node-0001&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;true&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;106800&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;false&lt;/value&gt;&nbsp;&nbsp;&nbsp;&lt;description&gt;Whether virtual memory limits will be enforced for containers&lt;/description&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;4&lt;/value&gt;&nbsp;&nbsp;&nbsp;&lt;description&gt;Ratio between virtual memory to physical memory when setting memory limits for containers&lt;/description&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.resourcemanager.scheduler.class&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairScheduler&lt;/value&gt;&nbsp;&nbsp;&lt;/property&gt;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.log.server.url&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;http://node-0001:19888/jobhistory/logs&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：主机名node-0001需要根据实际情况修改。</p><p><strong>配置mapred-site.xml</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/modules/hadoop-2.8.3/etc/hadoop/<span class="token function">mv</span> mapred-site.xml.template mapred-site.xml<span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/mapred-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参数配置如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;configuration&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;mapreduce.framework.name&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;yarn&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;node-0001:10020&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;node-0001:19888&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;mapred.task.timeout&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;1800000&lt;/value&gt;&nbsp;&lt;/property&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：主机名node-0001需要根据实际情况修改。</p><p><strong>配置slaves</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/slaves<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除原有内容，添加内容如下：</p><pre class="line-numbers language-none"><code class="language-none">node-0002node-0003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>配置hadoop环境变量</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/hadoop-env.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加如下内容：</p><pre class="line-numbers language-none"><code class="language-none">export JAVA_HOME=/usr/local/java/jdk1.8.0_351<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>配置jar包</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">cp</span> hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/hadoop-2.8.3/share/hadoop/common/lib/<span class="token function">cp</span> hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/hadoop-2.8.3/share/hadoop/tools/lib<span class="token function">cp</span> hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/hadoop-2.8.3/share/hadoop/httpfs/tomcat/webapps/webhdfs/WEB-INF/lib/<span class="token function">cp</span> hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/hadoop-2.8.3/share/hadoop/hdfs/lib/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分发hadoop包到各节点</strong></p><p>node-0001下执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 分发hadoop包到node2</span><span class="token function">scp</span> <span class="token parameter variable">-r</span> /home/modules/hadoop-2.8.3/ root@node-0002:/home/modules/<span class="token comment"># 分发hadoop包到node3</span><span class="token function">scp</span> <span class="token parameter variable">-r</span> /home/modules/hadoop-2.8.3/ root@node-0003:/home/modules/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>配置环境变量</strong></p><p>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在文件尾部添加如下内容：</p><pre class="line-numbers language-none"><code class="language-none">export HADOOP_HOME=/home/modules/hadoop-2.8.3export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATHexport HADOOP_CLASSPATH=/home/modules/hadoop-2.8.3/share/hadoop/tools/lib/*:$HADOOP_CLASSPATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>namenode初始化</strong><br>node-0001节点执行namenode初始化<br>执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hdfs namenode <span class="token parameter variable">-format</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化成功后，启动hdfs。<br>node-0001节点执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">start-all.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行hdfs命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hdfs dfs <span class="token parameter variable">-mkdir</span> /bigdata<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看集群部署报告</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hdfs dfsadmin <span class="token parameter variable">-report</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8712.png"></p><p>主要原因是 每台机器的/etc/hosts 错误</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1 localhost127.0.1.1 node-000*192.168.x.x node-0001192.168.x.x node-0002192.168.x.x node-0003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把127.0.1.1 node-000*这一行删掉</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8713.png"></p><p>停止HDFS<br>node-0001节点执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stop-all.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>测试Hadoop与OBS互联</strong></p><p>进入OBS桶，选择“对象”上传文件</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8714.png"></p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8715.png"></p><p>执行hdfs命令查看OBS文件 hadoop-bigdata&nbsp;是obs的命名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hdfs dfs <span class="token parameter variable">-ls</span> obs://hadoop-dataserver/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8716.png"></p><p>测试能否跑任务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hadoop jar /home/modules/hadoop-2.8.3/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.3.jar pi <span class="token number">100</span> <span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8717.png"></p><p>Hadooop集群搭建成功，hadooop成功与OBS互联，并且能跑通任务</p><h3 id="搭建Spark集群"><a href="#搭建Spark集群" class="headerlink" title="搭建Spark集群"></a>搭建Spark集群</h3><p>安装Spark集群，并使Spark能够读取OBS数据，使Spark集群能够实现存算分离，提高计算性能。</p><h4 id="搭建Spark集群-1"><a href="#搭建Spark集群-1" class="headerlink" title="搭建Spark集群"></a>搭建Spark集群</h4><p>获取spark安装包<br>node-0001节点下载Spark安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">wget</span> https://bigdata-tools-hw.obs.cn-north-1.myhuaweicloud.com/spark-2.3.0-bin-without-hadoop.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解压spark安装包"><a href="#解压spark安装包" class="headerlink" title="解压spark安装包"></a>解压spark安装包</h4><p>node-0001节点执行下列命令：</p><p>复制安装包到/home/modules目录下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> /root/spark-2.3.0-bin-without-hadoop.tgz /home/modules<span class="token builtin class-name">cd</span> /home/modules<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>解压安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> spark-2.3.0-bin-without-hadoop.tgz<span class="token function">mv</span> spark-2.3.0-bin-without-hadoop spark-2.3.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="配置spark-jar包"><a href="#配置spark-jar包" class="headerlink" title="配置spark jar包"></a>配置spark jar包</h4><p>在node-0001节点，复制jar包到spark/jar下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> /root/hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/spark-2.3.0/jars/<span class="token function">cp</span> /home/modules/hadoop-2.8.3/share/hadoop/common/lib/snappy-java-1.0.4.1.jar /home/modules/spark-2.3.0/jars/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="配置spark配置文件"><a href="#配置spark配置文件" class="headerlink" title="配置spark配置文件"></a>配置spark配置文件</h4><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/modules/spark-2.3.0/conf/<span class="token function">mv</span> spark-env.sh.template spark-env.sh<span class="token function">vim</span> spark-env.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>文件末尾添加如下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/usr/local/java/jdk1.8.0_351<span class="token builtin class-name">export</span> <span class="token assign-left variable">SCALA_HOME</span><span class="token operator">=</span>/home/modules/spark-2.3.0/examples/src/main/scala<span class="token builtin class-name">export</span> <span class="token assign-left variable">HADOOP_HOME</span><span class="token operator">=</span>/home/modules/hadoop-2.8.3<span class="token builtin class-name">export</span> <span class="token assign-left variable">HADOOP_CONF_DIR</span><span class="token operator">=</span>/home/modules/hadoop-2.8.3/etc/hadoop<span class="token builtin class-name">export</span> <span class="token assign-left variable">SPARK_HOME</span><span class="token operator">=</span>/home/modules/spark-2.3.0<span class="token builtin class-name">export</span> <span class="token assign-left variable">SPARK_DIST_CLASSPATH</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>/home/modules/hadoop-2.8.3/bin/hadoop classpath<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分发Spark"><a href="#分发Spark" class="headerlink" title="分发Spark"></a>分发Spark</h4><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> <span class="token parameter variable">-r</span> /home/modules/spark-2.3.0/ root@node-0002:/home/modules/<span class="token function">scp</span> <span class="token parameter variable">-r</span> /home/modules/spark-2.3.0/ root@node-0003:/home/modules/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加如下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">SPARK_HOME</span><span class="token operator">=</span>/home/modules/spark-2.3.0<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token variable">${SPARK_HOME}</span>/bin:<span class="token variable">${SPARK_HOME}</span>/sbin:<span class="token environment constant">$PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>各节点执行如下命令，使环境变量生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="验证存算分离"><a href="#验证存算分离" class="headerlink" title="验证存算分离"></a>验证存算分离</h4><p>查看要计算的文件</p><p>本次实验验证Spark与OBS实现存算分离，使用上传的playerinfo.txt文件。</p><p>数据如下：</p><pre class="line-numbers language-none"><code class="language-none">Alex James Lax GenuKerry Mary Olivia WilliamHale Edith Vera RobertMary Olivia James LaxEdith Vera Robertm Genu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计算上述数据的wordcount<br>启动yarn</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">start-yarn.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：前面如果使用的是start-all.sh，此命令可以省略</p><p>启动pyspark</p><p>在node-0001节点下执行以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pyspark<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8718.png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">lines <span class="token operator">=</span> spark<span class="token punctuation">.</span>read<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token string">"obs://hadoop-bigdata/playerinfo.txt"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rdd<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> r<span class="token punctuation">:</span> r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>counts <span class="token operator">=</span> lines<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reduceByKey<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span>output <span class="token operator">=</span> counts<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span>word<span class="token punctuation">,</span> count<span class="token punctuation">)</span> <span class="token keyword">in</span> output<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s: %i"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>word<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者使用以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$SPARK_HOME</span>/bin/run-example org.apache.spark.examples.JavaWordCount obs://hadoop-dataserver/playerinfo.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8719.png"></p><p>成功安装Spark集群，并使Spark能够读取OBS数据，使Spark集群能够实现存算分离，提高计算性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;华为云环境搭建&quot;&gt;&lt;a href=&quot;#华为云环境搭建&quot; class=&quot;headerlink&quot; title=&quot;华为云环境搭建&quot;&gt;&lt;/a&gt;华为云环境搭建&lt;/h3&gt;&lt;h4 id=&quot;华为云ECS&quot;&gt;&lt;a href=&quot;#华为云ECS&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="云计算" scheme="http://ailiaa.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="hadoop" scheme="http://ailiaa.github.io/tags/hadoop/"/>
    
    <category term="spark" scheme="http://ailiaa.github.io/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>华为云平台应用高可用部署</title>
    <link href="http://ailiaa.github.io/2023/04/25/hua-wei-yun-ping-tai-ying-yong-gao-ke-yong-bu-shu/"/>
    <id>http://ailiaa.github.io/2023/04/25/hua-wei-yun-ping-tai-ying-yong-gao-ke-yong-bu-shu/</id>
    <published>2023-04-25T07:37:20.000Z</published>
    <updated>2023-04-25T08:09:03.949Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过使用华为云弹性负载均衡ELB和弹性伸缩AS服务，实现华为云平台OA系统应用的高可用部署。</p></blockquote><h3 id="配置应用开机启动"><a href="#配置应用开机启动" class="headerlink" title="配置应用开机启动"></a>配置应用开机启动</h3><p><strong>获取启动脚本</strong></p><p>执行以下命令，下载启动脚本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># cd /home/</span><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># wget https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/autostart.sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行以下命令，打开脚本文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># vim autostart.sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，修改脚本代码。</p><p>修改JAVA_HOME为当前操作系统Java虚拟机的目录。</p><pre class="line-numbers language-none"><code class="language-none">/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.oe1.aarch64/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改app为当前OA系统jar包地址。</p><pre class="line-numbers language-none"><code class="language-none">/home/oasys_mysql/target/oasys.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，为脚本添加可执行权限。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># chmod +x autostart.sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>自定义开机启动命令</strong></p><p>执行以下命令，进入系统目录，下载服务脚本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># cd /etc/systemd/system/</span><span class="token punctuation">[</span>root@ecs-oa system<span class="token punctuation">]</span><span class="token comment"># wget [https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/oa-service.service](https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/oa-service.service)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行以下命令，为脚本添加可执行权限。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa system<span class="token punctuation">]</span><span class="token comment"># chmod +x oa-service.service</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，添加开机启动服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> oa-service.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8736.png"></p><p><strong>验证开机启动</strong></p><p>重启名为ecs-oa的云服务器。等待1-2分钟，通过ecs-oa弹性公网IP地址加8088端口访问OA系统登录页，如<a href="http://123.60.210.240:8088/%E3%80%82%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E5%90%8D%E2%80%9Csoli%E2%80%9D%E5%92%8C%E5%AF%86%E7%A0%81%E2%80%9C123456%E2%80%9D%E7%99%BB%E5%BD%95%E8%BF%9B%E5%85%A5OA%E7%B3%BB%E7%BB%9F%E4%B8%BB%E7%95%8C%E9%9D%A2%E3%80%82">http://123.60.210.240:8088/。使用用户名“soli”和密码“123456”登录进入OA系统主界面。</a></p><p>配置自启动后，根据弹性伸缩策略分发服务器的时候才能访问到项目（之后会构建这个oa服务器的镜像，供弹性负载均衡服务器运行）</p><h3 id="配置弹性负载均衡"><a href="#配置弹性负载均衡" class="headerlink" title="配置弹性负载均衡"></a>配置弹性负载均衡</h3><h4 id="购买华为云ELB弹性负载均衡"><a href="#购买华为云ELB弹性负载均衡" class="headerlink" title="购买华为云ELB弹性负载均衡"></a>购买华为云ELB弹性负载均衡</h4><p>进入华为云控制台操作页面。选择区域“北京四”，单击“服务列表”，选择“网络 弹性负载均衡ELB”，进入弹性负载均衡列表页面。页面右上角的“购买弹性负载均衡”。</p><p>选择与ecs-oa相同的“所属VPC”和“网络”，选择“按流量计费”，输入名称“elb-oa”，点击右下角“立即购买”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8737.png"></p><h4 id="配置监听器"><a href="#配置监听器" class="headerlink" title="配置监听器"></a>配置监听器</h4><p>在负载均衡器列表中，点击“点我开始配置”。在“监听器”标签中，点击“添加监听器”。默认配置，点击“下一步”。修改名称为“server_group-kunpeng”，点击“完成”。点击“现在添加”。在“后端服务器组”标签中，点击“添加”。选择名为“ecs-oa”的云服务器，点击“下一步”。添加端口输入“8088”，点击“完成”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8738.png"></p><p>等待约30秒之后，点击“刷新”按钮，ecs-oa健康检查结果显示“正常”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8739.png"></p><p>返回负载均衡器列表，记录“elb-oa”的弹性公网IP，使用该IP地址直接访问OA系统登录页，如<a href="http://http//http://123.249.75.243/%E3%80%82%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E5%90%8D%E2%80%9Csoli%E2%80%9D%E5%92%8C%E5%AF%86%E7%A0%81%E2%80%9C123456%E2%80%9D%E7%99%BB%E5%BD%95%E8%BF%9B%E5%85%A5OA%E7%B3%BB%E7%BB%9F%E4%B8%BB%E7%95%8C%E9%9D%A2%E3%80%82">http://http://http://123.249.75.243/。使用用户名“soli”和密码“123456”登录进入OA系统主界面。</a></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8740.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8741.png"></p><h3 id="配置弹性伸缩"><a href="#配置弹性伸缩" class="headerlink" title="配置弹性伸缩"></a>配置弹性伸缩</h3><h4 id="创建华为云云服务器镜像"><a href="#创建华为云云服务器镜像" class="headerlink" title="创建华为云云服务器镜像"></a>创建华为云云服务器镜像</h4><p>返回弹性云服务器列表，点击“更多 -&gt; 镜像/磁盘 -&gt; 创建镜像”。选择名为“ecs-oa”的云服务器，操作系统centos。名称“img-oa-kunpeng”，点击“立即创建”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8742.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8743.png"></p><h4 id="购买华为云AS弹性伸缩服务"><a href="#购买华为云AS弹性伸缩服务" class="headerlink" title="购买华为云AS弹性伸缩服务"></a>购买华为云AS弹性伸缩服务</h4><p>进入华为云控制台操作页面。选择区域“北京四”，单击“服务列表”，选择“弹性伸缩AS”，进入弹性伸缩列表页面。页面右上方，点击“创建弹性伸缩组”。输入名称“as-group-oa-kunpeng”，最大、期望、最小实例数分别为3、2和1台。点击加号按钮，增加伸缩配置。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8744.png"></p><h4 id="创建伸缩配置"><a href="#创建伸缩配置" class="headerlink" title="创建伸缩配置"></a>创建伸缩配置</h4><p>点击“创建伸缩配置”。输入名称为“as-config-oa-kunpeng”。选择配置为CPU架构“X86计算”，规格“华为云计算，华为云通用计算增强型，kc1.large.2 2vCPUs | 4GB”。</p><p>在“私有镜像”标签内，选择名为“img-oa-kunpeng”的私有镜像，安全组选择“sg-FullAccess”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8745.png"></p><p>返回伸缩配置列表，显示名为“as-config-oa-kunpeng”的伸缩配置</p><p>确认使用和ecs-oa同样的虚拟私有云和子网，负载均衡选择“使用弹性负载均衡”，负载均衡器选择“elb-oa”，后端服务器组选择“server_group-kunpeng”，后端端口填写“8088”，点击“立即创建”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8746.png"></p><h4 id="添加弹性策略"><a href="#添加弹性策略" class="headerlink" title="添加弹性策略"></a>添加弹性策略</h4><p>点击“添加伸缩策略”，在伸缩策略页面，点击“添加伸缩策略”。将伸缩策略命名为“as-policy-oa-kunpeng”，使用“告警策略”，设置触发条件为“CPU使用率最大值&gt;50%”，连续出现次数填写“3”，点击“确定”。</p><p>点击“概览”标签，显示当前实例数为2台，即设置的“期望实例数”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8747.png"></p><p>返回弹性云服务器列表，点击刷新按钮，显示通过AS创建的华为云实例。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8748.png"></p><p>进入弹性负载均衡器“elb-oa”的后端服务器组”标签，显示这两台华为云实例已加入。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8749.png"></p><p>返回伸缩实例as-group-oa-kunpeng的“伸缩策略”页面，点击“立即执行”，在对话框中点击“是”。在“概览”页面、云服务器列表和弹性负载均衡后端服务器组中都可显示新创建的华为云实例。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8750.png"></p><p>返回负载均衡器列表，记录“elb-oa”的弹性公网IP，使用该IP地址直接访问OA系统登录页，如<a href="http://123.249.75.243/%E3%80%82%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E5%90%8D%E2%80%9Csoli%E2%80%9D%E5%92%8C%E5%AF%86%E7%A0%81%E2%80%9C123456%E2%80%9D%E7%99%BB%E5%BD%95%E8%BF%9B%E5%85%A5OA%E7%B3%BB%E7%BB%9F%E4%B8%BB%E7%95%8C%E9%9D%A2%E3%80%82">http://123.249.75.243/。使用用户名“soli”和密码“123456”登录进入OA系统主界面。</a></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8751.png"></p><p>成功使用华为云弹性负载均衡ELB和弹性伸缩AS服务，实现华为云平台OA系统应用的高可用部署。</p><p>使用弹性负载均衡ELB公网IP访问项目的时候，可能会出现登录页面嵌套问题。</p><p>因为该OA项目的单体项目，不是分布式项目，在不同服务器中无法共享session。所以当刷新页面的时候，会把请求分发到不同服务器，这个服务器没有保存之前的信息，属于项目接口的非法访问，就跳转到登录页面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;通过使用华为云弹性负载均衡ELB和弹性伸缩AS服务，实现华为云平台OA系统应用的高可用部署。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;配置应用开机启动&quot;&gt;&lt;a href=&quot;#配置应用开机启动&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="分布式" scheme="http://ailiaa.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
    <category term="云计算" scheme="http://ailiaa.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>华为云平台数据库迁移与部署</title>
    <link href="http://ailiaa.github.io/2023/04/25/hua-wei-yun-ping-tai-shu-ju-ku-qian-yi-yu-bu-shu/"/>
    <id>http://ailiaa.github.io/2023/04/25/hua-wei-yun-ping-tai-shu-ju-ku-qian-yi-yu-bu-shu/</id>
    <published>2023-04-25T07:28:12.000Z</published>
    <updated>2023-04-25T08:09:12.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过配置华为云平台OA系统的数据库配置文件、将数据从华为云ECS自建数据库迁移至GaussDB(for MySQL)数据库，实现可供华为云平台OA系统接入的GaussDB(for MySQL)数据库部署。</p></blockquote><h3 id="部署云数据库GaussDB"><a href="#部署云数据库GaussDB" class="headerlink" title="部署云数据库GaussDB"></a>部署云数据库GaussDB</h3><p><strong>购买云数据库GaussDB</strong></p><p>进入控制台操作页面。选择区域“北京四”，单击“服务列表”，选择“数据库 &gt; 云数据库GaussDB”，进入服务列表页面。页面右上角的“购买数据库实例”。</p><p>进入云数据库GaussDB基础配置页面，选择配置如下所示，点击“立即购买”。计费模式：按需计费；区域：华北-北京四；实例名称：gauss-oa；性能规格：16核 | 64 GB；虚拟私有云：vpc-default；子网：subnet-default；内网安全组：sg-FullAccess；管理员密码&amp;确认密码。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8725.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8726.png"></p><p>查看云数据库信息，记录gauss-oa的内网地址</p><h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><h4 id="导出ecs-mysql数据"><a href="#导出ecs-mysql数据" class="headerlink" title="导出ecs-mysql数据"></a>导出ecs-mysql数据</h4><p>使用登录ecs-mysql的PuTTY，或者重新使用PuTTY登录ecs-mysql。执行以下命令，导出数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-mysql ~<span class="token punctuation">]</span><span class="token comment"># mysqldump -uroot -p oasys &gt; oasys-dump.sql</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8727.png"></p><p>因为我们的mysql是在docker中运行的，需要进入docker下的mysql</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysqlserver <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqldump <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span> oasys <span class="token operator">&gt;</span> oasys-dump.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导出的oasys-dump.sql文件在共享文件夹/opt/docker_mysql/data/中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Enter password:<span class="token punctuation">[</span>root@ecs-mysql ~<span class="token punctuation">]</span><span class="token comment"># ls</span>oasys-dump.sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8728.png"></p><h4 id="导入数据到gauss-oa"><a href="#导入数据到gauss-oa" class="headerlink" title="导入数据到gauss-oa"></a>导入数据到gauss-oa</h4><p>通过MySQL客户端登录gauss-oa，其中192.168.0.XXX修改为gauss-oa相应的内网地址。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-mysql ~<span class="token punctuation">]</span><span class="token comment"># mysql -h 192.168.0.xxx -P 3306 -u root -p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8729.png"></p><p>这里也需要先执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysqlserver <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导入oasys-dump.sql到gauss-oa</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> create database oasys<span class="token punctuation">;</span>Query OK, <span class="token number">1</span> row affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">&gt;</span> use oasys<span class="token punctuation">;</span>Database changedmysql<span class="token operator">&gt;</span> <span class="token builtin class-name">source</span> /var/lib/mysql/oasys-dump.sql<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（/opt/docker_mysql/data/oasys-dump.sql路径是主机下docker中的mysql共享文件夹,这里在docker下执行,路径是/var/lib/mysql/oasys-dump.sql，安装mysql的时候设置的data目录）</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8730.png"></p><p>查看数据库表并退出。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> show tables<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8731.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">exit</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>在使用putty登录ecs-oa，执行以下命令，打开并修改数据库连接信息。其中IP地址为gauss-oa的内网地址，密码为gauss-oa的root登录密码。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa ~<span class="token punctuation">]</span><span class="token comment"># cd /home/oasys_mysql/src/main/resources/</span><span class="token punctuation">[</span>root@ecs-oa resources<span class="token punctuation">]</span><span class="token comment"># vim application.properties</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8732.png"></p><h4 id="编译安装系统"><a href="#编译安装系统" class="headerlink" title="编译安装系统"></a>编译安装系统</h4><p>安装Maven。执行以下命令，进入项目目录，使用Maven本地安装。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa resources<span class="token punctuation">]</span><span class="token comment"># cd /home/oasys_mysql/</span><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># mvn install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行以下命令，启动应用。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># java -jar target/oasys.jar</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8733.png"></p><p>通过ecs-oa的弹性公网IP地址加8088端口访问OA系统登录页，使用用户名“soli”和密码“123456”登录OA系统主界面。</p><p>成功将数据从华为云ECS自建数据库迁移至GaussDB(for MySQL)数据库，实现可供华为云平台OA系统接入的GaussDB(for MySQL)数据库部署。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8734.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8735.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;通过配置华为云平台OA系统的数据库配置文件、将数据从华为云ECS自建数据库迁移至GaussDB(for MySQL)数据库，实现可供华为云平台OA系统接入的GaussDB(for MySQL)数据库部署。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="云计算" scheme="http://ailiaa.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>华为云平台部署OA系统</title>
    <link href="http://ailiaa.github.io/2023/04/25/hua-wei-yun-ping-tai-bu-shu-oa-xi-tong/"/>
    <id>http://ailiaa.github.io/2023/04/25/hua-wei-yun-ping-tai-bu-shu-oa-xi-tong/</id>
    <published>2023-04-25T07:01:42.000Z</published>
    <updated>2023-04-25T07:27:25.224Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过一个开源的OA(自动化办公 Office Automation)系统实例<br>实现OA系统在华为云服务器上的部署</p></blockquote><h3 id="数据库部署"><a href="#数据库部署" class="headerlink" title="数据库部署"></a>数据库部署</h3><h4 id="ECS云服务器搭建"><a href="#ECS云服务器搭建" class="headerlink" title="ECS云服务器搭建"></a>ECS云服务器搭建</h4><p>访问<a href="https://www.huaweicloud.com/?locale=zh-cn">华为云官网</a>，注册登录账号，然后进入控制台。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%871.png"></p><p>在页面左上角，选择区域“北京四”，单击“服务列表”，选择“计算 -&gt; 弹性云服务器ECS”，进入弹性云服务器列表页面。购买弹性云服务器。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%872.png"></p><p>购买后，进入弹性云服务器的基础配置页面，选择基础配置（按需计费，华为云计算，X86架构，通用计算增强型，1核2G内存，CentOS/Ubuntu），单击“下一步：网络配置”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%873.png"></p><p>进入弹性云服务器的网络配置页面，其中网络选择“vpc-default –&gt; subnet-default -&gt; 自动分配地址”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%874.png"></p><p>新建安全组，检查安全组中是否有“Sys-FullAccess”，若没有则点击“创建安全组”。选择模板为“开放全部端口”，输入名称“sg-FullAccess”，点击“确定”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%875.png"></p><p>点击安全组刷新按钮，选择“sg-FullAccess”，公网带宽选择“按流量计费”和“5”Mbit/s带宽大小，单击“下一步：高级配置”</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%876.png"></p><p>进入弹性云服务器的高级配置页面，高级配置如下图所示：</p><p>云服务器名称：ecs-mysql</p><p>输入自定义密码，密码需大于8位并带有特殊字符，再次确认密码</p><p>单击“下一步：确认配置</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%877.png"></p><p>进入弹性云服务器的确认配置页面，核对信息无误后，勾选下方的“我已经阅读并同意《华为镜像免责声明》”，如果有企业项目使用下拉框选择企业项目，单击“立即购买”，完成用于部署MySQL的云服务器购买。</p><p>返回弹性云服务器列表页面，查看刚刚购买的弹性云服务器ecs-mysql，等待其状态变为“运行中”， 记录其弹性IP地址。</p><h4 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h4><p>安装必要的docker 工具</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> <span class="token parameter variable">-y</span> yum-utils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>yum-config-manager，这个命令可以设置docker仓库源，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum-config-manager <span class="token punctuation">\</span>    --add-repo <span class="token punctuation">\</span>    https://download.docker.com/linux/centos/docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置阿里云镜像加速：登录阿里云，找到镜像加速服务，粘贴代码，运行即可，目的是为了加速镜像的获取</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%878.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%879.png"></p><p>查看docker可安装版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum list docker-ce <span class="token parameter variable">--showduplicates</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token parameter variable">-r</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定版本安装：yum -y install docker-ce-&lt; VERSION STRING &gt;<br>或者直接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> <span class="token parameter variable">-y</span> docker-ce docker-ce-cli http://containerd.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看docker版本、启动，停止以及自启动<br>查看： docker -v(或version) ；<br>启动： service docker start/systemctl start docker ;<br>停止：systemctl stop docker ;<br>自启动： systemctl enable docker .<br>查看镜像： docker images ；<br>删除镜像： docker rmi 镜像id ；<br>查看所有容器： docker ps -a ;<br>查看运行中的容器： docker ps ；<br>删除容器: docker rm &nbsp;容器id &nbsp;</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8710.png"></p><p>docker安装MySQL<br>查看可安装的MySQL：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> search mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装mysql：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8711.png"></p><p>启动mysql：</p><p>在opt目录下创建docker_mysql文件夹：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span>  /opt/ <span class="token punctuation">;</span><span class="token function">mkdir</span>  docker_mysql <span class="token punctuation">;</span><span class="token builtin class-name">cd</span> docker_mysql ；<span class="token builtin class-name">echo</span> <span class="token environment constant">$PWD</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>启动mysql容器，在var/lib/docker/containers/下查看容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">--name</span> mysqlserver <span class="token punctuation">\</span><span class="token parameter variable">-v</span> <span class="token environment constant">$PWD</span>/conf:/etc/mysql/conf.d <span class="token punctuation">\</span><span class="token parameter variable">-v</span> <span class="token environment constant">$PWD</span>/logs:/logs <span class="token punctuation">\</span><span class="token parameter variable">-v</span> <span class="token environment constant">$PWD</span>/data:/var/lib/mysql <span class="token punctuation">\</span><span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> <span class="token parameter variable">-d</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-p</span> <span class="token number">3306</span>:3306 mysql:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看mysql进程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8712.png"></p><p>进入mysql容器，并登陆mysql</p><p>进入MySQL： </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysqlserver <span class="token function">bash</span><span class="token comment"># 或 docker attach 容器ID</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>登录mysql </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-uroot</span> -p；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>退出MySQL容器： exit 或者 Ctrl+P+Q</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8713.png"></p><p><strong>导入数据：</strong></p><p>下载原始sql文件到/home目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">exit</span><span class="token punctuation">[</span>root@ecs-mysql run<span class="token punctuation">]</span><span class="token comment"># cd /home/</span><span class="token punctuation">[</span>root@ecs-mysql home<span class="token punctuation">]</span><span class="token comment"># wget [https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/oasys_mysql.sql](https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/oasys_mysql.sql)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>登录mysql，下述命令中的“mypassword”需要根据实际修改成要配置的密码。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-mysql home<span class="token punctuation">]</span><span class="token comment"># mysql -uroot -pmypassword</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建名为“oasys”的数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> create database oasys<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用“oasys”数据库，执行原始sql文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> use oasys<span class="token punctuation">;</span>mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">source</span> /home/oasys_mysql.sql<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>找不到/home/oasys_mysql.sql，因为MySQL在docker下运行，需要把oasys_mysql.sql文件放在/data:/var/lib/mysql。放在data目录下。</p><p>执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">source</span> /var/lib/mysql/oasys_mysql.sql<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8714.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8715.png"></p><h3 id="OA应用部署"><a href="#OA应用部署" class="headerlink" title="OA应用部署"></a>OA应用部署</h3><h4 id="ECS云服务器搭建-1"><a href="#ECS云服务器搭建-1" class="headerlink" title="ECS云服务器搭建"></a>ECS云服务器搭建</h4><p>同上操作</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8716.png"></p><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><p>下载并拷贝jdk8至/usr/local/java，并解压缩</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/<span class="token function">mkdir</span> <span class="token function">java</span><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> jdk-8-linux-i586<span class="token punctuation">(</span>x86<span class="token punctuation">)</span>.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置环境变量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按“i”进入编辑模式，使用hjkl键或方向键移动光标，在文件最后添加以下代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/usr/local/java/jdk1.8******<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$JAVA_HOME</span>/bin<span class="token builtin class-name">export</span> JAVA_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>按“Esc”退出编辑模式，输入“:wq”并按回车，保存退出。<br>执行以下命令，使新增配置生效。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，验证jdk安装并配置成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> –version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8717.png"><br>解决方法：<br>执行命令 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> yum <span class="token function">install</span> glibc.i686<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8718.png"></p><h4 id="安装Maven"><a href="#安装Maven" class="headerlink" title="安装Maven"></a>安装Maven</h4><p>执行以下命令，创建Maven安装目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa ~<span class="token punctuation">]</span><span class="token comment"># mkdir /usr/local/maven</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，切换到Maven安装目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa ~<span class="token punctuation">]</span><span class="token comment"># cd /usr/local/maven</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，获取Maven二进制包。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># wget [http://mirrors.huaweicloud.com/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz](http://mirrors.huaweicloud.com/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，解压Maven二进制包。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># tar -xvzf apache-maven-3.6.3-bin.tar.gz</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>步骤 5执行以下命令，打开环境变量配置文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># vim /etc/profile</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按“i”进入编辑模式，使用hjkl键或方向键移动光标，在文件最后添加以下代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">MAVEN_HOME</span><span class="token operator">=</span>/usr/local/maven/apache-maven-3.6.3<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$MAVEN_HOME</span>/bin<span class="token builtin class-name">export</span> MAVEN_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>按“Esc”退出编辑模式，输入“:wq”并按回车，保存退出。<br>执行以下命令，使新增配置生效。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># source /etc/profile</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，验证Maven安装。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># mvn -v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8719.png"></p><h4 id="Maven换源"><a href="#Maven换源" class="headerlink" title="Maven换源"></a>Maven换源</h4><p>执行以下命令，进入Maven配置文件目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># cd /usr/local/maven/apache-maven-3.6.3/conf/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，打开配置文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa conf<span class="token punctuation">]</span><span class="token comment"># vim settings.xml</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入”:158”后按回车键，在<mirrors>和</mirrors>中间，插入以下代码。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&lt;</span>mirror<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>id<span class="token operator">&gt;</span>mirror<span class="token operator">&lt;</span>/id<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>mirrorOf<span class="token operator">&gt;</span>*<span class="token operator">&lt;</span>/mirrorOf<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span>cmc-cd-mirror<span class="token operator">&lt;</span>/name<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>url<span class="token operator">&gt;</span>https://mirrors.huaweicloud.com/repository/maven/<span class="token operator">&lt;</span>/url<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/mirror<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h4><p>执行以下命令，安装Git。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa conf<span class="token punctuation">]</span><span class="token comment"># yum install -y git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，验证Git版本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa conf<span class="token punctuation">]</span><span class="token comment"># git version</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8720.png"></p><p>执行以下命令，Clone源码到本地。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa conf<span class="token punctuation">]</span><span class="token comment"># cd /home</span><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># git clone -b mysql-8 https://gitee.com/github-5407963/oasys_mysql.git</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="配置MySQL连接"><a href="#配置MySQL连接" class="headerlink" title="配置MySQL连接"></a>配置MySQL连接</h4><p>执行以下命令，进入OA系统数据库配置文件目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># cd /home/oasys_mysql/src/main/resources/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，编辑应用配置文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa resources<span class="token punctuation">]</span><span class="token comment"># vim application.properties</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改url、username和password为ecs-mysql的内网地址、mysql的登录用户名和密码，保存文件，退出。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">server.port</span><span class="token operator">=</span><span class="token number">8088</span>spring.datasource.driver-class-name<span class="token operator">=</span>com.mysql.cj.jdbc.Driver<span class="token assign-left variable">spring.datasource.url</span><span class="token operator">=</span>jdbc:mysql://192.168.0.25:3306/oasys?autoReconnect<span class="token operator">=</span>true<span class="token operator">&amp;</span><span class="token assign-left variable">useSSL</span><span class="token operator">=</span>false<span class="token operator">&amp;</span><span class="token assign-left variable">characterEncoding</span><span class="token operator">=</span>utf-8<span class="token operator">&amp;</span><span class="token assign-left variable">serverTimezone</span><span class="token operator">=</span>Hongkong<span class="token operator">&amp;</span><span class="token assign-left variable">rewriteBatchedStatements</span><span class="token operator">=</span>true<span class="token operator">&amp;</span><span class="token assign-left variable">allowPublicKeyRetrieval</span><span class="token operator">=</span>true<span class="token assign-left variable">spring.datasource.username</span><span class="token operator">=</span>root<span class="token assign-left variable">spring.datasource.password</span><span class="token operator">=</span>mypassword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以下命令，进入OA系统目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa resources<span class="token punctuation">]</span><span class="token comment"># cd /home/oasys_mysql/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，重新Maven本地编译安装。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># mvn install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8721.png"></p><p>执行以下命令，启动项目应用。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># java -jar target/oasys.jar</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8722.png"></p><p>通过ecs-oa弹性公网IP地址加8088端口访问OA系统登录页，如<a href="http://123.60.210.240:8088/%E3%80%82%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E5%90%8D%E2%80%9Csoli%E2%80%9D%E5%92%8C%E5%AF%86%E7%A0%81%E2%80%9C123456%E2%80%9D%E7%99%BB%E5%BD%95%E8%BF%9B%E5%85%A5OA%E7%B3%BB%E7%BB%9F%E4%B8%BB%E7%95%8C%E9%9D%A2%E3%80%82">http://123.60.210.240:8088/。使用用户名“soli”和密码“123456”登录进入OA系统主界面。</a></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8723.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8724.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;通过一个开源的OA(自动化办公 Office Automation)系统实例&lt;br&gt;实现OA系统在华为云服务器上的部署&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数据库部署&quot;&gt;&lt;a href=&quot;#数据库部署&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="云计算" scheme="http://ailiaa.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>基于ECS搭建云上博客</title>
    <link href="http://ailiaa.github.io/2023/04/25/ji-yu-a-li-ecs-da-jian-yun-shang-bo-ke/"/>
    <id>http://ailiaa.github.io/2023/04/25/ji-yu-a-li-ecs-da-jian-yun-shang-bo-ke/</id>
    <published>2023-04-25T06:24:34.000Z</published>
    <updated>2023-04-25T07:00:21.740Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p><strong>LAMP</strong></p><p>LAMP是指Linux（操作系统）+Apache（HTTP 服务器）+MySQL（数据库）和PHP（网络编程语言），一般用来建立Web应用平台。</p><p><strong>WordPress</strong></p><p>WordPress是一种使用PHP语言开发的博客平台，用户可以在支持PHP和MySQ数据库的服务器上架设WordPress。可以使用WordPress搭建一个简单的独立博客。</p><p><strong>云服务器ECS</strong></p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/1.png"></p><h4 id="安装并配置Apache服务"><a href="#安装并配置Apache服务" class="headerlink" title="安装并配置Apache服务"></a>安装并配置Apache服务</h4><p>Apache是Web服务器软件。<br>在实验室切换至Web Terminal。输入ECS服务器登录用户名和密码，登录ECS。<br>执行如下命令，安装Apache服务及其扩展包。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token parameter variable">-y</span> <span class="token function">install</span> httpd mod_ssl mod_perl mod_auth_mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/2.png"></p><p>执行如下命令，查看Apache是否安装成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">httpd <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/3.png"></p><p>执行如下命令，启动Apache服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start httpd.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在本机浏览器的地址栏中，访问<a href="http://ecs公网地址./">http://ECS公网地址。</a></p><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/4.png"></p><h4 id="安装MariaDB数据库"><a href="#安装MariaDB数据库" class="headerlink" title="安装MariaDB数据库"></a>安装MariaDB数据库</h4><p>执行一下命令安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> <span class="token parameter variable">-y</span> mariadb-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/5.png"></p><p>执行如下命令，启动MariaDB Server。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start mariadb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/6.png"></p><p>执行如下命令，查看MariaDB Server运行状态。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status mariadb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/7.png"></p><p>执行如下命令，设置数据库root用户的初始密码。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqladmin <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span> password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/8.png"></p><p>123456789</p><p>执行如下命令，连接数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/9.png"></p><p>执行如下命令，创建WordPress数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">create database wordpress<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行如下命令，查看数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">show databases<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/10.png"></p><p>执行如下命令，退出数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exit</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h4><p>PHP是一种广泛使用的通用开源脚本语言，适合于Web网站开发，它可以嵌入HTML中。</p><p>执行如下命令，安装PHP。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token parameter variable">-y</span> <span class="token function">install</span> php php-mysql gd php-gd gd-devel php-xml php-common php-mbstring php-ldap php-pear php-xmlrpc php-imap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/11.png"></p><p>执行如下命令，创建PHP测试页面。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"&lt;?php phpinfo(); ?&gt;"</span> <span class="token operator">&gt;</span> /var/www/html/phpinfo.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行如下命令，重启Apache服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart httpd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在浏览器的地址栏中，访问http://&lt;ECS公网地址&gt;/phpinfo.php。</p><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/12.png"></p><h4 id="安装和配置WordPress"><a href="#安装和配置WordPress" class="headerlink" title="安装和配置WordPress"></a>安装和配置WordPress</h4><p>在实验室页面右侧，单击 图标，切换至Web Terminal。</p><p>执行如下命令，安装WordPress。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token parameter variable">-y</span> <span class="token function">install</span> wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/13.png"></p><p>修改WordPress配置文件。</p><p>执行如下命令，修改wp-config.php指向路径为绝对路径。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 进入/usr/share/wordpress目录。</span><span class="token builtin class-name">cd</span> /usr/share/wordpress<span class="token comment"># 修改路径。</span><span class="token function">ln</span> <span class="token parameter variable">-snf</span> /etc/wordpress/wp-config.php wp-config.php<span class="token comment"># 查看修改后的目录结构。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/14.png"></p><p>执行如下命令，移动wordpress文件到Apache根目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 在Apache的根目录/var/www/html下，创建一个wp-blog文件夹。</span><span class="token function">mkdir</span> /var/www/html/wp-blog<span class="token function">mv</span> * /var/www/html/wp-blog/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以下命令，修改wp-config.php配置文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/database_name_here/wordpress/'</span> /var/www/html/wp-blog/wp-config.php<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/username_here/root/'</span> /var/www/html/wp-blog/wp-config.php<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/password_here/123456789/'</span> /var/www/html/wp-blog/wp-config.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以下命令，查看配置文件信息是否修改成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token parameter variable">-n</span> /var/www/html/wp-blog/wp-config.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/15.png"></p><p>执行如下命令，重启Apache服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart httpd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="测试WordPress"><a href="#测试WordPress" class="headerlink" title="测试WordPress"></a>测试WordPress</h3><p>在浏览器地址栏中，访问http://&lt;ECS公网地址&gt;/wp-blog/wp-admin/install.php。</p><p>在WordPress配置页面，配置相关信息，然后单击Install WordPress。</p><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/16.png"></p><p>成功发布一篇博文</p><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/17.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;LAMP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LAMP是指Linux（操作系统）+Apache（HTTP 服务器）+MySQL（</summary>
      
    
    
    
    
    <category term="云计算" scheme="http://ailiaa.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>MySQL版本升级5.5-8.0.20</title>
    <link href="http://ailiaa.github.io/2023/04/15/mysql-ban-ben-sheng-ji-5.5-8.0.20/"/>
    <id>http://ailiaa.github.io/2023/04/15/mysql-ban-ben-sheng-ji-5.5-8.0.20/</id>
    <published>2023-04-15T07:58:16.000Z</published>
    <updated>2023-04-25T08:15:23.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-备份数据库"><a href="#1-备份数据库" class="headerlink" title="1. 备份数据库"></a>1. 备份数据库</h3><p>在数据库编辑器中对重要的数据库导出为<code>.sql</code>文件<br>版本升级后，可以在新版本的MySQL中新建数据库执行<code>.sql</code>文件，恢复数据</p><p><em><strong>（在此升级过程中并不会删掉原有数据库，数据备份是一个好习惯）</strong></em></p><h3 id="2-下载对应版本的MySQL"><a href="#2-下载对应版本的MySQL" class="headerlink" title="2. 下载对应版本的MySQL"></a>2. 下载对应版本的MySQL</h3><p><a href="https://downloads.mysql.com/archives/community/">官网：https://downloads.mysql.com/archives/community/</a></p><p><img src="/images/image_MySQL%E5%8D%87%E7%BA%A7/1.png"></p><p>然后将安装包解压，最好和MySQL5.5（老版本）放在一起，方便查找</p><h3 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3. 配置环境变量"></a>3. 配置环境变量</h3><p><code>D:\MySQL\mysql-8.0.20\bin</code></p><p>在用户变量path 中添加MySQL的bin文件夹目录</p><p>删除老版本MySQL的环境变量</p><h3 id="4-配置文件"><a href="#4-配置文件" class="headerlink" title="4. 配置文件"></a>4. 配置文件</h3><p>在<code>mysql-8.0.20</code>目录下新建<code>my.ini</code>文件</p><p><img src="/images/image_MySQL%E5%8D%87%E7%BA%A7/2.png"></p><p>写入：</p><pre class="line-numbers language-none"><code class="language-none"># 设置3306端口port=3306# 设置mysql的安装目录，写你的目录basedir=D:\MySQL# 设置mysql数据库的数据的存放目录，这是隐藏的文件夹datadir=C:\ProgramData\MySQL/MySQL Server 8.0\Data\# 允许最大连接数max_connections=200# 允许连接失败的次数。防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-停止MySQL5-5服务"><a href="#5-停止MySQL5-5服务" class="headerlink" title="5. 停止MySQL5.5服务"></a>5. 停止MySQL5.5服务</h3><p>在任务管理器-&gt;服务 : 找到MySQL</p><p>停止MySQL服务</p><p>以管理员运行命令窗口</p><pre class="line-numbers language-none"><code class="language-none">C:\Windows\system32&gt;cd D:\MySQL\MySQL5.5\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入该文件夹，执行</p><pre class="line-numbers language-none"><code class="language-none">mysqld --remove mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-安装运行MySQL-8-0-2"><a href="#6-安装运行MySQL-8-0-2" class="headerlink" title="6. 安装运行MySQL 8.0.2"></a>6. 安装运行MySQL 8.0.2</h3><pre class="line-numbers language-none"><code class="language-none"># 设置mysql数据库的数据的存放目录，这是隐藏的文件夹datadir=C:\ProgramData\MySQL/MySQL Server 8.0\Data\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建文件夹，存放数据<br>需要查看隐藏文件夹ProgramData<br><code>C:\ProgramData\MySQL/MySQL Server 8.0\Data\</code></p><pre class="line-numbers language-none"><code class="language-none">cd D:\MySQL\mysql-8.0.20\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到mysql-8.0.20的bin目录下</p><p>执行安装命令</p><pre class="line-numbers language-none"><code class="language-none">mysqld -install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行初始化命令</p><pre class="line-numbers language-none"><code class="language-none">mysqld --initialize --user=mysql --console<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化成功后会给个root临时密码，类似 DQybZ_HT#76B</p><p>以root账号进入数据库  </p><pre class="line-numbers language-none"><code class="language-none">mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接</p><pre class="line-numbers language-none"><code class="language-none">net start mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改密码</p><pre class="line-numbers language-none"><code class="language-none">ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到此MySQL升级成功，在SQLyog编辑器中已经自动连接上8.0.20版本MySQL</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-备份数据库&quot;&gt;&lt;a href=&quot;#1-备份数据库&quot; class=&quot;headerlink&quot; title=&quot;1. 备份数据库&quot;&gt;&lt;/a&gt;1. 备份数据库&lt;/h3&gt;&lt;p&gt;在数据库编辑器中对重要的数据库导出为&lt;code&gt;.sql&lt;/code&gt;文件&lt;br&gt;版本升级后，可</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://ailiaa.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>DevOps流水线搭建03</title>
    <link href="http://ailiaa.github.io/2023/04/15/devops-liu-shui-xian-da-jian-03/"/>
    <id>http://ailiaa.github.io/2023/04/15/devops-liu-shui-xian-da-jian-03/</id>
    <published>2023-04-15T07:02:48.000Z</published>
    <updated>2023-09-15T03:31:29.445Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-测试DevOps流水线"><a href="#1-测试DevOps流水线" class="headerlink" title="1. 测试DevOps流水线"></a>1. 测试DevOps流水线</h2><h3 id="gitlab创建项目并拉取到本地"><a href="#gitlab创建项目并拉取到本地" class="headerlink" title="gitlab创建项目并拉取到本地"></a>gitlab创建项目并拉取到本地</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8730.png"><br>关闭防火墙，让本机访问gitlab</p><pre class="line-numbers language-none"><code class="language-none">$systemctl stop firewalld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>clone项目，将我们需要打包发布的项目推送到gitlab</p><pre class="line-numbers language-none"><code class="language-none">git add .git commit -m "first push"git tag 1.0.0git push origin 1.0.0git push -u origin --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="harbor-server上构建基础镜像"><a href="#harbor-server上构建基础镜像" class="headerlink" title="harbor-server上构建基础镜像"></a>harbor-server上构建基础镜像</h3><p>遇到小问题</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8732.png"></p><p>重启harbor解决</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker-compose down$sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>拉取openjdk镜像</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker pull openjdk:8u201-jdk-alpine3.9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8733.png"></p><pre class="line-numbers language-none"><code class="language-none">$sudo docker tag openjdk:8u201-jdk-alpine3.9 192.168.159.131:8077/library/openjdk8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8734.png"><br>登录harbor仓库</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker login 192.168.159.131:8077<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>推送</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker push 192.168.159.131:8077/library/openjdk8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8735.png"></p><h3 id="构建jenkins应用"><a href="#构建jenkins应用" class="headerlink" title="构建jenkins应用"></a>构建jenkins应用</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8736.png"><br>遇到问题：</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8737.png"></p><p>我这里是因为gitlab-server上没安装ssh服务,安装后解决<br>其他原因可能是私钥密钥配置错误</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8738.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8739.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8740.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8741.png"></p><p>开始构建</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8742.png"></p><p>构建成功<br>访问</p><p><img src="/images/image_DevOps/2.jpg"></p><p>修改代码后，再次push</p><p><img src="/images/image_DevOps/1.jpg"></p><p><img src="/images/image_DevOps/3.jpg"></p><p>流水线测试成功！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-测试DevOps流水线&quot;&gt;&lt;a href=&quot;#1-测试DevOps流水线&quot; class=&quot;headerlink&quot; title=&quot;1. 测试DevOps流水线&quot;&gt;&lt;/a&gt;1. 测试DevOps流水线&lt;/h2&gt;&lt;h3 id=&quot;gitlab创建项目并拉取到本地&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="docker" scheme="http://ailiaa.github.io/tags/docker/"/>
    
    <category term="harbor" scheme="http://ailiaa.github.io/tags/harbor/"/>
    
    <category term="jenkins" scheme="http://ailiaa.github.io/tags/jenkins/"/>
    
    <category term="DevOps" scheme="http://ailiaa.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>DevOps流水线搭建02</title>
    <link href="http://ailiaa.github.io/2023/04/10/devops-liu-shui-xian-da-jian-02/"/>
    <id>http://ailiaa.github.io/2023/04/10/devops-liu-shui-xian-da-jian-02/</id>
    <published>2023-04-10T01:30:18.000Z</published>
    <updated>2023-09-15T03:31:16.846Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-各主机中的工具配置"><a href="#1-各主机中的工具配置" class="headerlink" title="1. 各主机中的工具配置"></a>1. 各主机中的工具配置</h2><h3 id="jenkins-server"><a href="#jenkins-server" class="headerlink" title="jenkins-server"></a>jenkins-server</h3><p><strong>docker配置</strong><br>配置docker主机使用harbor，添加信任harbor-server中的私有仓库<br>（harbor仓库ip+端口号）</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/docker/daemon.json# 写入{"insecure-registries": ["http://192.168.159.131:8077"]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启docker</p><pre class="line-numbers language-none"><code class="language-none">$systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>登录harbor主机中的docker仓库服务</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker login 192.168.159.131:8077<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8712.png"><br><strong>配置jenkins使用docker</strong></p><p>验证系统中是否有jenkins用户</p><pre class="line-numbers language-none"><code class="language-none">$grep jenkins /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证系统中是否有docker用户及用户组</p><pre class="line-numbers language-none"><code class="language-none">$grep docker /etc/group<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8713.png"><br>添加jenkins用户到docker用户组</p><pre class="line-numbers language-none"><code class="language-none">$sudo usermod -G docker jenkins$grep docker /etc/group<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8714.png"><br>重启jenkins服务</p><pre class="line-numbers language-none"><code class="language-none">$systemctl restart jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="harbor-server"><a href="#harbor-server" class="headerlink" title="harbor-server"></a>harbor-server</h3><p><strong>docker配置</strong><br>同上</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/docker/daemon.json# 写入{        "insecure-registries": ["http://192.168.159.131:8077"]}$cat /etc/docker/daemon.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启docker-compose</p><pre class="line-numbers language-none"><code class="language-none">$docker-compose down$systemctl restart docker$docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="web-server"><a href="#web-server" class="headerlink" title="web-server"></a>web-server</h3><p><strong>docker配置</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/docker/daemon.json# 写入{        "insecure-registries": ["http://192.168.159.131:8077"]}$cat /etc/docker/daemon.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启docker</p><pre class="line-numbers language-none"><code class="language-none">$systemctl restart docker$sudo docker login 192.168.159.131:8077<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-配置gitlab相关密钥"><a href="#2-配置gitlab相关密钥" class="headerlink" title="2. 配置gitlab相关密钥"></a>2. 配置gitlab相关密钥</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p><strong>Windows下生成ssh密钥，并用ssh免密访问Linux服务器</strong></p><pre class="line-numbers language-none"><code class="language-none">$ssh-keygen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8715.png"></p><p>可以在 C:\User\XXX\ 文件夹下看到一个.ssh的文件夹，里面有两个文件</p><p>id_rsa.pub，就是公钥文件，需要给Linux服务器的管理者，让他将id_rsa.pub文件中的公钥内容注册到Linux中，以便能够通过ssh来访问该Linux服务器。公钥注册到Linux服务器后，就可以在本机ssh到远端Linux服务器，并访问了。</p><p>添加到gitlab ssh密钥中:</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8716.png"></p><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p><strong>jenkins-server主机生成公钥，添加公钥至gitlab-ce</strong></p><pre class="line-numbers language-none"><code class="language-none">$ssh-keygen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8717.png"></p><pre class="line-numbers language-none"><code class="language-none">$cat /home/l/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8718.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8719.png"><br><strong>配置jenkins-sever主机的私钥到凭据列表</strong></p><pre class="line-numbers language-none"><code class="language-none">$cat /home/l/.ssh/id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8720.png"></p><p><em><strong>（注意这里要全部复制，包括首尾）</strong></em></p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8721.png"><br>修改jenkins配置文件</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/default/jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以root用户运行(因为上述操在作root用户下生成的公钥和私钥)</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8722.png"></p><h2 id="3-jenkins插件安装"><a href="#3-jenkins插件安装" class="headerlink" title="3. jenkins插件安装"></a>3. jenkins插件安装</h2><ul><li>maven integration：用于编译JAVA项目</li><li>git parameter：用于基于git版本提交进行参数构建项目</li><li>gitlab：用于jenkins-server拉取项目</li><li>Generic Webhook Trigger：用于项目自动化构建</li><li>ssh：用于jenkins-server对web-server实施项目部署</li></ul><h2 id="4-Jenkins全局工具配置"><a href="#4-Jenkins全局工具配置" class="headerlink" title="4. Jenkins全局工具配置"></a>4. Jenkins全局工具配置</h2><h3 id="JDK配置"><a href="#JDK配置" class="headerlink" title="JDK配置"></a>JDK配置</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8723.png"></p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8724.png"></p><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8725.png"></p><h3 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8726.png"></p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8727.png"></p><h2 id="5-jenkins系统配置"><a href="#5-jenkins系统配置" class="headerlink" title="5. jenkins系统配置"></a>5. jenkins系统配置</h2><p>主要配置jenkins-server通过ssh协议连接web-server<br>添加jenkins-server访问web-server凭据<br>测试连接是否成功（web-server对应的主机需要修改ssh配置允许用root账号密码连接）：</p><pre class="line-numbers language-none"><code class="language-none">$sudo vi /etc/ssh/sshd_config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8728.png"><br>重启</p><pre class="line-numbers language-none"><code class="language-none">$service sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不行，应该是root密码错误，root密码不是开机解锁密码，忘记root密码可以修改root密码</p><pre class="line-numbers language-none"><code class="language-none">$sudo passwd root <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功连接</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8729.png"><br>各工具配置完成，接下来可以测试DevOps流水线是否搭建成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-各主机中的工具配置&quot;&gt;&lt;a href=&quot;#1-各主机中的工具配置&quot; class=&quot;headerlink&quot; title=&quot;1. 各主机中的工具配置&quot;&gt;&lt;/a&gt;1. 各主机中的工具配置&lt;/h2&gt;&lt;h3 id=&quot;jenkins-server&quot;&gt;&lt;a href=&quot;#j</summary>
      
    
    
    
    
    <category term="docker" scheme="http://ailiaa.github.io/tags/docker/"/>
    
    <category term="harbor" scheme="http://ailiaa.github.io/tags/harbor/"/>
    
    <category term="jenkins" scheme="http://ailiaa.github.io/tags/jenkins/"/>
    
    <category term="DevOps" scheme="http://ailiaa.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>DevOps流水线搭建01</title>
    <link href="http://ailiaa.github.io/2023/04/07/devops-liu-shui-xian-da-jian-01/"/>
    <id>http://ailiaa.github.io/2023/04/07/devops-liu-shui-xian-da-jian-01/</id>
    <published>2023-04-07T05:41:13.000Z</published>
    <updated>2023-09-15T03:30:35.342Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><p>个人主机，三台ubuntu虚拟机</p><p>工具安装：</p><ul><li>Git:用于提交业务代码或克隆业务代码仓库</li><li>Gitlab:用于存储业务代码</li><li>Jenkins:用于利用插件完成业务代码编译、构建、推送至Harbor容器镜像仓库及项目部署</li><li>Tomcat:用于运行JAVA业务代码</li><li>Maven:用于编译业务代码</li><li>Harbor:用于存储业务代码构建的容器镜像存储</li><li>Docker:用于构建容器镜像，部署项目</li></ul><h2 id="2-主机"><a href="#2-主机" class="headerlink" title="2. 主机"></a>2. 主机</h2><table><thead><tr><th>主机</th><th>主机IP</th><th>业务功能</th><th>安装软件</th></tr></thead><tbody><tr><td>Windows本机</td><td>192.168.159.1</td><td>开发项目代码</td><td>git</td></tr><tr><td>harbor-server</td><td>192.168.159.131</td><td>存储容器镜像</td><td>harbor、docker</td></tr><tr><td>jenkins-server</td><td>192.168.159.129</td><td>编译代码、打包镜像、项目构建</td><td>jenkins、docker、git</td></tr><tr><td>gitlab-server</td><td>192.168.159.130</td><td>代码仓库</td><td>gitlab-ce</td></tr><tr><td>web-server</td><td>192.168.159.129</td><td>运行容器，项目上线</td><td>docker</td></tr></tbody></table><h2 id="3-各主机工具安装"><a href="#3-各主机工具安装" class="headerlink" title="3. 各主机工具安装"></a>3. 各主机工具安装</h2><h3 id="windows本机"><a href="#windows本机" class="headerlink" title="windows本机"></a>windows本机</h3><p>安装git,直接去官网下载安装<br>控制台<code>git --version</code>,打印版本信息即成功安装</p><h3 id="Jenkins-server"><a href="#Jenkins-server" class="headerlink" title="Jenkins-server"></a>Jenkins-server</h3><p><strong>安装jdk</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo apt-get update$sudo apt-get install openjdk-17-jdk$java -version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（如果没有版本信息，需要将路径添加到环境变量中）<br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%871.png"><br><strong>安装jenkins</strong><br>安装</p><pre class="line-numbers language-none"><code class="language-none">$wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -$sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list'$sudo apt-get install jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>启动</p><pre class="line-numbers language-none"><code class="language-none">$systemctl start jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动成功后访问，默认端口8080</p><p>登录admin账号，密钥获取</p><pre class="line-numbers language-none"><code class="language-none">$cat /var/lib/jenkins/secrets/initialAdminPassword<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装推荐插件<br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%872.png"><br>如果有插件安装失败，之后点击重试安装即可</p><p>完成安装：<br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%873.png"><br><strong>安装git</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo apt-get update$git --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>安装maven</strong></p><p>在这新建maven文件夹(随便)<br>/usr/local/src/maven/</p><p>在这个文件夹中执行命令，下载解压删除安装包</p><pre class="line-numbers language-none"><code class="language-none">$wget https://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz$tar -zxvf apache-maven-3.8.8-bin.tar.gz$rm apache-maven-3.8.8-bin.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>添加环境变量（注意路径和版本）</p><pre class="line-numbers language-none"><code class="language-none">$export MAVEN_HOME=/usr/local/src/maven/apache-maven-3.8.8 $export CLASSPATH=${MAVEN_HOME}/lib:$CLASSPATH$export PATH=${MAVEN_HOME}/bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>检查是否成功</p><pre class="line-numbers language-none"><code class="language-none">$mvn -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%874.png"></p><h3 id="gitlib-server"><a href="#gitlib-server" class="headerlink" title="gitlib-server"></a>gitlib-server</h3><p><strong>安装gitlab</strong></p><pre class="line-numbers language-none"><code class="language-none">$wget --content-disposition https://packages.gitlab.com/gitlab/gitlab-ce/packages/ubuntu/focal/gitlab-ce_15.5.2-ce.0_amd64.deb/download.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压</p><pre class="line-numbers language-none"><code class="language-none">$sudo dpkg -i gitlab-ce_15.5.2-ce.0_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%875.png"><br>查看当前gitlab网页ip和端口号：</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/gitlab/gitlab.rb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只要修改配置文件就要reconfigure</p><pre class="line-numbers language-none"><code class="language-none">$sudo gitlab-ctl reconfigure<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动</p><pre class="line-numbers language-none"><code class="language-none">$sudo gitlab-ctl start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看状态</p><pre class="line-numbers language-none"><code class="language-none">$sudo gitlab-ctl status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>root密码</p><pre class="line-numbers language-none"><code class="language-none">$cat /etc/gitlab/initial_root_password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改root密码</p><pre class="line-numbers language-none"><code class="language-none">#进入gitlab控制台$sudo gitlab-rails console production#获取root用户$user = User.where(id: 1).first#设置新密码，注意新密码要大于8位$user.password = newPwd#再次确认新密码$user.password_confirmation = newPwd#保存密码$user.save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%876.png"></p><h3 id="web-server"><a href="#web-server" class="headerlink" title="web-server"></a>web-server</h3><p>只需安装docker</p><h3 id="harbor-server"><a href="#harbor-server" class="headerlink" title="harbor-server"></a>harbor-server</h3><p><strong>安装docker-compose</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo apt-get update$sudo apt-get install docker-compose-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%877.png"><br>检查安装</p><pre class="line-numbers language-none"><code class="language-none">$docker compose version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%878.png"><br><strong>安装harbor</strong><br>下载</p><pre class="line-numbers language-none"><code class="language-none">$wget https://github.com/goharbor/harbor/releases/download/v2.3.2/harbor-offline-installer-v2.3.2.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压<br><strong>$sudo tar -zxvf harbor-offline-installer-v2.3.2.tgz</strong></p><p>修改配置文件</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%879.png"></p><p>修改hostname和port</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8710.png"><br>执行修改</p><pre class="line-numbers language-none"><code class="language-none">$sudo ./install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认admin账号密码：Harbor12345<br>访问登录</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8711.png"></p><pre class="line-numbers language-none"><code class="language-none">#停止harbor$sudo docker-compose down -v#修改yml文件后需要重新加载$./prepare#重启harbor$sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>各主机工具安装完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-环境搭建&quot;&gt;&lt;a href=&quot;#1-环境搭建&quot; class=&quot;headerlink&quot; title=&quot;1. 环境搭建&quot;&gt;&lt;/a&gt;1. 环境搭建&lt;/h2&gt;&lt;p&gt;个人主机，三台ubuntu虚拟机&lt;/p&gt;
&lt;p&gt;工具安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git:用于提交业</summary>
      
    
    
    
    
    <category term="docker" scheme="http://ailiaa.github.io/tags/docker/"/>
    
    <category term="harbor" scheme="http://ailiaa.github.io/tags/harbor/"/>
    
    <category term="jenkins" scheme="http://ailiaa.github.io/tags/jenkins/"/>
    
    <category term="DevOps" scheme="http://ailiaa.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>Redis_高可用</title>
    <link href="http://ailiaa.github.io/2023/03/28/redis-gao-ke-yong/"/>
    <id>http://ailiaa.github.io/2023/03/28/redis-gao-ke-yong/</id>
    <published>2023-03-28T12:12:37.000Z</published>
    <updated>2023-09-15T03:29:36.885Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 实现高可用有三种部署模式：<strong>主从模式，哨兵模式，集群模式</strong>。</p><h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>主从模式中，Redis部署了多台机器，有主节点，负责读写操作，有从节点，只负责读操作。从节点的数据来自主节点，实现原理就是<strong>主从复制机制</strong></p><p>主从复制包括全量复制，增量复制两种。一般当slave第一次启动连接master，或者认为是第一次连接，就采用<strong>全量复制</strong>，全量复制流程如下：</p><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/01.webp"></p><ul><li>  1.slave发送sync命令到master。</li><li>  2.master接收到SYNC命令后，执行bgsave命令，生成RDB全量文件。</li><li>  3.master使用缓冲区，记录RDB快照生成期间的所有写命令。</li><li>  4.master执行完bgsave后，向所有slave发送RDB快照文件。</li><li>  5.slave收到RDB快照文件后，载入、解析收到的快照。</li><li>  6.master使用缓冲区，记录RDB同步期间生成的所有写的命令。</li><li>  7.master快照发送完毕后，开始向slave发送缓冲区中的写命令;</li><li>  8.salve接受命令请求，并执行来自master缓冲区的写命令</li></ul><p>redis2.8版本之后，已经使用<strong>psync来替代sync</strong>，因为sync命令非常消耗系统资源，psync的效率更高。</p><p>slave与master全量同步之后，master上的数据，如果再次发生更新，就会触发<strong>增量复制</strong>。</p><p>当master节点发生数据增减时，就会触发<code>replicationFeedSalves()</code>函数，接下来在 Master节点上调用的每一个命令会使用<code>replicationFeedSlaves()</code>来同步到Slave节点。执行此函数之前呢，master节点会判断用户执行的命令是否有数据更新，如果有数据更新的话，并且slave节点不为空，就会执行此函数。这个函数作用就是：<strong>把用户执行的命令发送到所有的slave节点</strong>，让slave节点执行。流程如下：</p><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/02.webp"></p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>主从模式中，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址。显然，多数业务场景都不能接受这种故障处理方式。Redis从2.8开始正式提供了Redis Sentinel（哨兵）架构来解决这个问题。</p><p><strong>哨兵模式</strong>，由一个或多个Sentinel实例组成的Sentinel系统，它可以监视所有的Redis主节点和从节点，并在被监视的主节点进入下线状态时，<strong>自动将下线主服务器属下的某个从节点升级为新的主节点</strong>。但是呢，一个哨兵进程对Redis节点进行监控，就可能会出现问题（<strong>单点问题</strong>），因此，可以使用多个哨兵来进行监控Redis节点，并且各个哨兵之间还会进行监控。</p><p>简单来说，哨兵模式就三个作用：</p><ul><li>  发送命令，等待Redis服务器（包括主服务器和从服务器）返回监控其运行状态；</li><li>  哨兵监测到主节点宕机，会自动将从节点切换成主节点，然后通过发布订阅模式通知其他的从节点，修改配置文件，让它们切换主机；</li><li>  哨兵之间还会相互监控，从而达到高可用。</li></ul><p><strong>故障切换的过程是怎样的呢</strong></p><blockquote><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。</p></blockquote><p>哨兵的工作模式如下：</p><ol><li> 每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他Sentinel实例发送一个 PING命令。</li><li> 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel标记为主观下线。</li><li> 如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。</li><li> 当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线。</li><li> 在一般情况下， 每个 Sentinel 会以每10秒一次的频率向它已知的所有Master，Slave发送 INFO 命令。</li><li> 当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次</li><li> 若没有足够数量的 Sentinel同意Master已经下线， Master的客观下线状态就会被移除；若Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</li></ol><h3 id="Cluster集群模式"><a href="#Cluster集群模式" class="headerlink" title="Cluster集群模式"></a>Cluster集群模式</h3><p>哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。但是它每个节点存储的数据是一样的，浪费内存，并且不好在线扩容。 因此，Cluster集群应运而生，它在Redis3.0加入的，实现了Redis的<strong>分布式存储</strong>。对数据进行分片，也就是说<strong>每台Redis节点上存储不同的内容</strong>，来解决在线扩容的问题。并且，它也提供复制和故障转移的功能。</p><h4 id="Cluster集群节点的通讯"><a href="#Cluster集群节点的通讯" class="headerlink" title="Cluster集群节点的通讯"></a>Cluster集群节点的通讯</h4><p>一个Redis集群由多个节点组成，<strong>各个节点之间是怎么通信的呢</strong>？通过<strong>Gossip协议</strong>！</p><p>Redis Cluster集群通过Gossip协议进行通信，节点之前不断交换信息，交换的信息内容包括节点出现故障、新节点加入、主从节点变更信息、slot信息等等。常用的Gossip消息分为4种，分别是：ping、pong、meet、fail。</p><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/03.webp"></p><ul><li>  meet消息：通知新节点加入。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换。</li><li>  ping消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。</li><li>  pong消息：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新。</li><li>  fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。</li></ul><p>特别的，每个节点是通过<strong>集群总线(cluster bus)</strong> 与其他的节点进行通信的。通讯时，使用特殊的端口号，即对外服务端口号加10000。例如如果某个node的端口号是6379，那么它与其它nodes通信的端口号是 16379。nodes 之间的通信采用特殊的二进制协议。</p><h4 id="Hash-Slot插槽算法"><a href="#Hash-Slot插槽算法" class="headerlink" title="Hash Slot插槽算法"></a>Hash Slot插槽算法</h4><p>既然是分布式存储，Cluster集群使用的分布式算法是<strong>一致性Hash</strong>嘛？并不是，而是<strong>Hash Slot插槽算法</strong>。</p><p><strong>插槽算法</strong>把整个数据库被分为16384个slot（槽），每个进入Redis的键值对，根据key进行散列，分配到这16384插槽中的一个。使用的哈希映射也比较简单，用CRC16算法计算出一个16 位的值，再对16384取模。数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理这16384个槽。</p><p>集群中的每个节点负责一部分的hash槽，比如当前集群有A、B、C个节点，每个节点上的哈希槽数 =16384/3，那么就有：</p><ul><li>  节点A负责0~5460号哈希槽</li><li>  节点B负责5461~10922号哈希槽</li><li>  节点C负责10923~16383号哈希槽</li></ul><h4 id="Redis-Cluster集群"><a href="#Redis-Cluster集群" class="headerlink" title="Redis Cluster集群"></a>Redis Cluster集群</h4><p>Redis Cluster集群中，需要确保16384个槽对应的node都正常工作，如果某个node出现故障，它负责的slot也会失效，整个集群将不能工作。</p><p>因此为了保证高可用，Cluster集群引入了主从复制，一个主节点对应一个或者多个从节点。当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点宕机时，就会启用从节点。</p><p>虽然数据是分开存储在不同节点上的，但是对客户端来说，整个集群Cluster，被看做一个整体。客户端端连接任意一个node，看起来跟操作单实例的Redis一样。当客户端操作的key没有被分配到正确的node节点时，Redis会返回转向指令，最后指向正确的node，这就有点像浏览器页面的302 重定向跳转。</p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>Redis集群实现了高可用，当集群内节点出现故障时，通过<strong>故障转移</strong>，以保证集群正常对外提供服务。</p><p>redis集群通过ping/pong消息，实现故障发现。这个环境包括<strong>主观下线和客观下线</strong>。</p><p><strong>主观下线：</strong>&nbsp;某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况。</p><p><strong>客观下线：</strong> 指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移。</p><ul><li>  假如节点A标记节点B为主观下线，一段时间后，节点A通过消息把节点B的状态发到其它节点，当节点C接受到消息并解析出消息体时，如果发现节点B的pfail状态时，会触发客观下线流程；</li><li>  当下线为主节点时，此时Redis Cluster集群为统计持有槽的主节点投票，看投票数是否达到一半，当下线报告统计数大于一半时，被标记为<strong>客观下线</strong>状态。</li></ul><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/04.webp"></p><p><strong>故障恢复</strong>：故障发现后，如果下线节点的是主节点，则需要在它的从节点中选一个替换它，以保证集群的高可用。流程如下：</p><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/05.webp"></p><ul><li>  资格检查：检查从节点是否具备替换故障主节点的条件。</li><li>  准备选举时间：资格检查通过后，更新触发故障选举时间。</li><li>  发起选举：到了故障选举时间，进行选举。</li><li>  选举投票：只有持有槽的<strong>主节点</strong>才有票，从节点收集到足够的选票（大于一半），触发<strong>替换主节点操作</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 实现高可用有三种部署模式：&lt;strong&gt;主从模式，哨兵模式，集群模式&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;主从模式&quot;&gt;&lt;a href=&quot;#主从模式&quot; class=&quot;headerlink&quot; title=&quot;主从模式&quot;&gt;&lt;/a&gt;主从模式&lt;/h3&gt;&lt;p&gt;主从模</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="NoSQL" scheme="http://ailiaa.github.io/tags/NoSQL/"/>
    
    <category term="redis" scheme="http://ailiaa.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>场景</title>
    <link href="http://ailiaa.github.io/2023/03/26/chang-jing/"/>
    <id>http://ailiaa.github.io/2023/03/26/chang-jing/</id>
    <published>2023-03-26T09:14:25.000Z</published>
    <updated>2023-09-15T03:17:07.354Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h2><h3 id="10亿个数据中找出最大的10000个"><a href="#10亿个数据中找出最大的10000个" class="headerlink" title="10亿个数据中找出最大的10000个"></a>10亿个数据中找出最大的10000个</h3><p><strong>最小堆法</strong></p><ol><li>先拿10000个数建堆</li><li>然后逐个添加剩余元素</li><li>如果大于堆顶的数（10000中最小的），将这个数替换堆顶，并调整结构使之仍然是一个最小堆</li><li>遍历完后，堆中的10000个数就是所需的最大的10000个。</li><li>复杂度分析：时间复杂度是O（mlogm），算法的时间复杂度为O（nmlogm）（n为10亿，m为10000）。</li></ol><p><strong>如果内存受限</strong>：可以直接在内存总使用Hash方法将数据划分成n个partition，每个partition交给一个线程处理，线程的处理逻辑可以采用最小堆，最后一个线程将结果归并。</p><h3 id="有几台机器存储着几亿淘宝搜索日志，你只有一台-2g-的电脑，怎么选出搜索热度最高的十个？"><a href="#有几台机器存储着几亿淘宝搜索日志，你只有一台-2g-的电脑，怎么选出搜索热度最高的十个？" class="headerlink" title="有几台机器存储着几亿淘宝搜索日志，你只有一台 2g 的电脑，怎么选出搜索热度最高的十个？"></a>有几台机器存储着几亿淘宝搜索日志，你只有一台 2g 的电脑，怎么选出搜索热度最高的十个？</h3><p>【分治+trie树/hash+小顶堆】</p><p>先将数据集按照hash方法分解成n个小数据集，然后使用trie树或者hash统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出频率最高的前K个数，最后在所有top K中求出最终的top K。</p><h2 id="海量数据排序、压缩问题"><a href="#海量数据排序、压缩问题" class="headerlink" title="海量数据排序、压缩问题"></a>海量数据排序、压缩问题</h2><h3 id="重要方法——位图法-Bitmap"><a href="#重要方法——位图法-Bitmap" class="headerlink" title="重要方法——位图法 Bitmap"></a>重要方法——位图法 Bitmap</h3><p>位图的基本概念：用一个位（bit）来标记某个数据的存放状态。例如，有{2, 4, 5, 6, 67, 5}这么几个整数，我维护一个 00…0000（共67位）的0/1字符串，1表示该索引（=数据值）处存在数，0则表示不存在。</p><p>应用：位图法可以用于海量数据排序，海量数据去重，海量数据压缩</p><p>优点：针对于稠密的数据集可以很好体现出位图法的优势，内存消耗少，速度较快</p><p>缺点：不适用于稀疏数据集，比如我们有一个长度为10的序列，最大值为20亿，则构造位串的内存消耗将相当大250M，而实际却只需要40个字节，此外位图法还存在可读性差等缺点。</p><h3 id="非重复排序"><a href="#非重复排序" class="headerlink" title="非重复排序"></a>非重复排序</h3><p>假设我们有一个不重复的整型序列{n1， n2， … ,nn}，假设最大值为nmax，则我们可以维护一个长度为nmax的位串。</p><p>主要过程：</p><ul><li>第一遍 遍历整个序列，将出现的数字在位串（java中可以用数组实现）中对应的位置置为1；</li><li>第二遍 遍历位图，依次输出值为1的位对应的数字，这些1所在的位串中的位置的索引代表序列数据，1出现的先后位置则代表序列的大小关系。</li></ul><h3 id="重复排序"><a href="#重复排序" class="headerlink" title="重复排序"></a>重复排序</h3><p>同上，只是子串中不只存在<code>0/1</code>，实际数量为多少，则值为多少.输出时，值为多少则输出多少遍</p><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p><strong>前提</strong>：数据中存在大量的冗余值<br>基本思路就是使用某个子串存储原数据中的海量值</p><h3 id="如何用redis存储统计1亿用户一年的登陆情况，并快速检索任意时间窗口内的活跃用户数量"><a href="#如何用redis存储统计1亿用户一年的登陆情况，并快速检索任意时间窗口内的活跃用户数量" class="headerlink" title="如何用redis存储统计1亿用户一年的登陆情况，并快速检索任意时间窗口内的活跃用户数量"></a>如何用redis存储统计1亿用户一年的登陆情况，并快速检索任意时间窗口内的活跃用户数量</h3><p>redis单独对bitmap提供了一套命令。可以对任意一位进行设置和读取。所以可以在位图中使用1表示活跃。</p><p>bitmap的核心命令：</p><p>SETBIT：设置某位为1<br>语法：SETBIT key offset value</p><p>GETBIT：获取某位的值<br>语法：GETBIT key offset</p><p>bitmap的其他命令还有bitcount，bitpos，bitop等命令。都是对位的操作。</p><p>获取某一天id为88000的用户是否活跃：getbit 2020-01-01 88000 (时间复杂度为O(1))<br>统计某一天的所有的活跃用户数：bitcount 2019-01-01 (时间复杂度为O(N))<br>-统计某一段时间内的活跃用户数，需要用到bitop命令。这个命令提供四种位运算，AND(与)，(OR)或，XOR(亦或)，NOT(非)。</p><p>以下例子求出了2019-01-01到2019-01-05这段时间内的活跃用户数。<br>bitop or result 2019-01-01 2019-01-02 2019-01-03 2019-01-04 2019-01-05 (时间复杂度为O(N))</p><h2 id="资源-vs-请求问题"><a href="#资源-vs-请求问题" class="headerlink" title="资源 vs 请求问题"></a>资源 vs 请求问题</h2><h3 id="如果一个外卖配送单子要发布，现在有200个骑手都想要接这一单，如何保证只有一个骑手接到单子？"><a href="#如果一个外卖配送单子要发布，现在有200个骑手都想要接这一单，如何保证只有一个骑手接到单子？" class="headerlink" title="如果一个外卖配送单子要发布，现在有200个骑手都想要接这一单，如何保证只有一个骑手接到单子？"></a>如果一个外卖配送单子要发布，现在有200个骑手都想要接这一单，如何保证只有一个骑手接到单子？</h3><p>单机情况</p><ul><li>采用volatile关键字修饰该订单采用CAS操作对其进行乐观锁操作。volatile保证可见性，CAS保证原子性</li></ul><p>集群：</p><ul><li>采用redis分布式锁加锁。</li><li>消息队列 实现幂等接口</li></ul><h3 id="多个微信用户抢红包"><a href="#多个微信用户抢红包" class="headerlink" title="多个微信用户抢红包"></a>多个微信用户抢红包</h3><p>类似于秒杀系统</p><ol><li>数据库加乐观锁、悲观锁</li><li>在逻辑处理界面加分布式锁</li><li>消息队列</li></ol><h3 id="1000个任务分给10个人做"><a href="#1000个任务分给10个人做" class="headerlink" title="1000个任务分给10个人做"></a>1000个任务分给10个人做</h3><ol><li>全局队列，每一个人都从一个队列中取  </li><li>分成10个队列对应每一个人</li></ol><h2 id="设计类问题"><a href="#设计类问题" class="headerlink" title="设计类问题"></a>设计类问题</h2><h3 id="你如何设计一个消息队列"><a href="#你如何设计一个消息队列" class="headerlink" title="你如何设计一个消息队列?"></a>你如何设计一个消息队列?</h3><p>首先这个 mq 得支持可伸缩性吧<br>就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</p><p>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？<br>那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</p><p>其次你考虑一下你的 mq 的可用性啊？<br>这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</p><p>能不能支持数据 0 丢失啊？<br>可以的，参考我们之前说的那个 kafka 数据零丢失方案。</p><h3 id="你如何设计一个缓存系统"><a href="#你如何设计一个缓存系统" class="headerlink" title="你如何设计一个缓存系统?"></a>你如何设计一个缓存系统?</h3><p>1.数据结构</p><p>首要考虑的就是数据该如何存储，用什么数据结构存储，最简单的就直接用Map来存储数据；或者复杂的如redis一样提供了多种数据类型哈希，列表，集合，有序集合等</p><p>2.对象上限</p><p>因为是本地缓存，内存有上限，所以一般都会指定缓存对象的数量比如1024，当达到某个上限后需要有某种策略去删除多余的数据；</p><p>3.清除策略</p><p>上面说到当达到对象上限之后需要有清除策略，常见的比如有LRU(最近最少使用)、FIFO(先进先出)、LFU(最近最不常用)；</p><p>4.过期时间</p><p>除了使用清除策略，一般本地缓存也会有一个过期时间设置，比如redis可以给每个key设置一个过期时间，这样当达到过期时间之后直接删除，采用清除策略+过期时间双重保证；</p><p>5.线程安全</p><p>像redis是直接使用单线程处理，所以就不存在线程安全问题；而我们现在提供的本地缓存往往是可以多个线程同时访问的，所以线程安全是不容忽视的问题；并且线程安全问题是不应该抛给使用者去保证；</p><p>6.简明的接口</p><p>提供常用的get，put，remove，clear，getSize方法即可；</p><p>7.是否持久化</p><p>这个不是必须的，是否需要将缓存数据持久化看需求</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="怎么判别淘宝刷单？怎么检验手段效果？"><a href="#怎么判别淘宝刷单？怎么检验手段效果？" class="headerlink" title="怎么判别淘宝刷单？怎么检验手段效果？"></a>怎么判别淘宝刷单？怎么检验手段效果？</h3><p><strong>商家角度：</strong></p><p>营业额远高于历史平均数据<br>营业额远高于行业平均数据<br>下单的用户很多均为存在异常行为被监控的账户</p><p><strong>顾客角度</strong>（账号维度）：判断是否存在异常行为</p><p>单次交易行为：是否精准搜索、货比三家、页面停留时间等<br>近期购物成功率：远高于历史时期平均购物成功率<br>是否可能为垫付：短时间支付宝账户内收到与下单金额相同的金额<br>下单的店铺很多均为存在异常行为被监控的账户</p><p><strong>商家与顾客：</strong></p><p>存在相近或者共同的网络环境：如ip、wifi等</p><h3 id="如何把一个文件快速下发到-100w-个服务器"><a href="#如何把一个文件快速下发到-100w-个服务器" class="headerlink" title="如何把一个文件快速下发到 100w 个服务器"></a>如何把一个文件快速下发到 100w 个服务器</h3><p>采用p2p网络形式，比如树状形式，网状形式，单个节点既可以从其他节点接收服务又可以向其他节点提供服务。<strong>广度优先遍历</strong></p><h3 id="如何实现两个线程交替打印"><a href="#如何实现两个线程交替打印" class="headerlink" title="如何实现两个线程交替打印"></a>如何实现两个线程交替打印</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Integer</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// volatile + synchronized</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">solution1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token punctuation">}</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token punctuation">}</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Top-K问题&quot;&gt;&lt;a href=&quot;#Top-K问题&quot; class=&quot;headerlink&quot; title=&quot;Top K问题&quot;&gt;&lt;/a&gt;Top K问题&lt;/h2&gt;&lt;h3 id=&quot;10亿个数据中找出最大的10000个&quot;&gt;&lt;a href=&quot;#10亿个数据中找出最大的100</summary>
      
    
    
    
    
    <category term="后端场景" scheme="http://ailiaa.github.io/tags/%E5%90%8E%E7%AB%AF%E5%9C%BA%E6%99%AF/"/>
    
  </entry>
  
  <entry>
    <title>Reids_分布式锁</title>
    <link href="http://ailiaa.github.io/2023/03/26/reids-fen-bu-shi-suo/"/>
    <id>http://ailiaa.github.io/2023/03/26/reids-fen-bu-shi-suo/</id>
    <published>2023-03-26T02:57:14.000Z</published>
    <updated>2023-08-31T09:09:01.094Z</updated>
    
    <content type="html"><![CDATA[<p>对于单机多线程来说，在 Java 中，我们通常使用 <code>ReetrantLock</code> 类、<code>synchronized</code> 关键字这类 JDK 自带的 <strong>本地锁</strong> 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。</p><p>分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，<strong>分布式锁</strong>&nbsp;就诞生了。</p><h3 id="基于-Redis-实现分布式锁"><a href="#基于-Redis-实现分布式锁" class="headerlink" title="基于 Redis 实现分布式锁"></a>基于 Redis 实现分布式锁</h3><h4 id="基于Redis实现一个最简易的分布式锁"><a href="#基于Redis实现一个最简易的分布式锁" class="headerlink" title="基于Redis实现一个最简易的分布式锁"></a>基于Redis实现一个最简易的分布式锁</h4><p>不论是本地锁还是分布式锁，核心都在于“互斥”。</p><p>在 Redis 中， <code>SETNX</code> 命令是可以帮助我们实现互斥。<code>SETNX</code> 即 <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists (对应 Java 中的 <code>setIfAbsent</code> 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， <code>SETNX</code> 啥也不做。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> SETNX lockKey uniqueValue<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">&gt;</span> SETNX lockKey uniqueValue<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>释放锁的话，直接通过 <code>DEL</code> 命令删除对应的 key 即可。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> DEL lockKey<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。</p><p>选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token operator">//</span> 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">then</span>    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"del"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。</p><h4 id="给锁设置一个过期时间"><a href="#给锁设置一个过期时间" class="headerlink" title="给锁设置一个过期时间"></a>给锁设置一个过期时间</h4><p>为了避免锁无法被释放，我们可以想到的一个解决办法就是：<strong>给这个 key（也就是锁） 设置一个过期时间</strong> 。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SET lockKey uniqueValue EX <span class="token number">3</span> NXOK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>  <strong>lockKey</strong>：加锁的锁名；</li><li>  <strong>uniqueValue</strong>：能够唯一标示锁的随机字符串；</li><li>  <strong>NX</strong>：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；</li><li>  <strong>EX</strong>：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。</li></ul><p><strong>一定要保证设置指定 key 的值和过期时间是一个原子操作！</strong> 不然的话，依然可能会出现锁无法被释放的问题。</p><p>这样确实可以解决问题，不过，这种解决办法同样存在漏洞：<strong>如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。</strong></p><h4 id="实现锁的续期"><a href="#实现锁的续期" class="headerlink" title="实现锁的续期"></a>实现锁的续期</h4><p>Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel、Redis Cluster 等多种部署架构。</p><p>Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。</p><p><img src="/images/image_redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/01.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//默认 30秒，支持修改</span><span class="token keyword">private</span> <span class="token keyword">long</span> lockWatchdogTimeout <span class="token operator">=</span> <span class="token number">30</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Config</span> <span class="token function">setLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token keyword">long</span> lockWatchdogTimeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>lockWatchdogTimeout <span class="token operator">=</span> lockWatchdogTimeout<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> lockWatchdogTimeout<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>renewExpiration()</code> 方法包含了看门狗的主要逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment">//......</span>        <span class="token class-name">Timeout</span> task <span class="token operator">=</span> commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newTimeout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Timeout</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>                <span class="token comment">//......</span>                <span class="token comment">// 异步续期，基于 Lua 脚本</span>                <span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token function">renewExpirationAsync</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                future<span class="token punctuation">.</span><span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">// 无法续期</span>                        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Can't update lock "</span> <span class="token operator">+</span> <span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" expiration"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">// 递归调用实现续期</span>                        <span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment">// 取消续期</span>                        <span class="token function">cancelExpirationRenewal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>         <span class="token comment">// 延迟 internalLockLeaseTime/3（默认 10s，也就是 30/3） 再调用</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> internalLockLeaseTime <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ee<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。</p><p>Watch Dog 通过调用 <code>renewExpirationAsync()</code> 方法实现锁的异步续期：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> <span class="token function">renewExpirationAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span><span class="token constant">EVAL_BOOLEAN</span><span class="token punctuation">,</span>            <span class="token comment">// 判断是否为持锁线程，如果是就执行续期操作，就锁的过期时间设置为 30s（默认）</span>            <span class="token string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                    <span class="token string">"return 1; "</span> <span class="token operator">+</span>                    <span class="token string">"end; "</span> <span class="token operator">+</span>                    <span class="token string">"return 0;"</span><span class="token punctuation">,</span>            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出， <code>renewExpirationAsync</code> 方法其实是调用 Lua 脚本实现的续期，这样做主要是为了保证续期操作的原子性。</p><p>我这里以 Redisson 的分布式可重入锁 <code>RLock</code> 为例来说明如何使用 Redisson 实现分布式锁：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 1.获取指定的分布式锁对象</span><span class="token class-name">RLock</span> lock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2.拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3.执行业务</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// 4.释放锁</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。</p><pre class="line-numbers language-none"><code class="language-none">// 手动给锁设置过期时间，不具备 Watch Dog 自动续期机制lock.lock(10, TimeUnit.SECONDS);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。</p><h4 id="实现可重入锁"><a href="#实现可重入锁" class="headerlink" title="实现可重入锁"></a>实现可重入锁</h4><p>所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 <code>synchronized</code> 和 <code>ReentrantLock</code> 都属于可重入锁。</p><p><strong>不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。</strong></p><p>可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。</p><p>实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 <strong>Redisson</strong> ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。</p><h4 id="分布式锁的可靠性"><a href="#分布式锁的可靠性" class="headerlink" title="分布式锁的可靠性"></a>分布式锁的可靠性</h4><p>为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。</p><p>Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p><p><img src="/images/image_redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/02.png"></p><p>Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。</p><p>即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。</p><p>Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。</p><p>如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 ZooKeeper 来做，只是性能会差一些。</p><h3 id="基于-ZooKeeper-实现分布式锁"><a href="#基于-ZooKeeper-实现分布式锁" class="headerlink" title="基于 ZooKeeper 实现分布式锁"></a>基于 ZooKeeper 实现分布式锁</h3><p>Redis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。实际项目中，我们应该根据业务的具体需求来选择</p><h4 id="基于-ZooKeeper-实现分布式锁-1"><a href="#基于-ZooKeeper-实现分布式锁-1" class="headerlink" title="基于 ZooKeeper 实现分布式锁"></a>基于 ZooKeeper 实现分布式锁</h4><p>ZooKeeper 分布式锁是基于 <strong>临时顺序节点</strong> 和 <strong>Watcher（事件监听器）</strong> 实现的。</p><p>获取锁：</p><ol><li> 首先我们要有一个持久节点<code>/locks</code>，客户端获取锁就是在<code>locks</code>下创建临时顺序节点。</li><li> 假设客户端 1 创建了<code>/locks/lock1</code>节点，创建成功之后，会判断 <code>lock1</code>是否是 <code>/locks</code> 下最小的子节点。</li><li> 如果 <code>lock1</code>是最小的子节点，则获取锁成功。否则，获取锁失败。</li><li> 如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如<code>/locks/lock0</code>上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。</li></ol><p>释放锁：</p><ol><li> 成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。</li><li> 成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。</li><li> 我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放</li></ol><p>实际项目中，推荐使用 Curator 来实现 ZooKeeper 分布式锁。Curator 是 Netflix 公司开源的一套 ZooKeeper Java 客户端框架，相比于 ZooKeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。</p><p><code>Curator</code>主要实现了下面四种锁：</p><ul><li>  <code>InterProcessMutex</code>：分布式可重入排它锁</li><li>  <code>InterProcessSemaphoreMutex</code>：分布式不可重入排它锁</li><li>  <code>InterProcessReadWriteLock</code>：分布式读写锁</li><li>  <code>InterProcessMultiLock</code>：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CuratorFramework</span> client <span class="token operator">=</span> <span class="token class-name">ZKUtils</span><span class="token punctuation">.</span><span class="token function">getClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>client<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 分布式可重入排它锁</span><span class="token class-name">InterProcessLock</span> lock1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessMutex</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> lockPath1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 分布式不可重入排它锁</span><span class="token class-name">InterProcessLock</span> lock2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessSemaphoreMutex</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> lockPath2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将多个锁作为一个整体</span><span class="token class-name">InterProcessMultiLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessMultiLock</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>lock1<span class="token punctuation">,</span> lock2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lock<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"不能获取多锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已获取多锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第一个锁: "</span> <span class="token operator">+</span> lock1<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第二个锁: "</span> <span class="token operator">+</span> lock2<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// 资源操作</span>    resource<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"释放多个锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第一个锁: "</span> <span class="token operator">+</span> lock1<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第二个锁: "</span> <span class="token operator">+</span> lock2<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="临时顺序节点"><a href="#临时顺序节点" class="headerlink" title="临时顺序节点"></a>临时顺序节点</h4><p>每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。</p><p>我们通常是将 znode 分为 4 大类：</p><ul><li>  <strong>持久（PERSISTENT）节点</strong>：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li><li>  <strong>临时（EPHEMERAL）节点</strong>：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，<strong>临时节点只能做叶子节点</strong> ，不能创建子节点。</li><li>  <strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong>：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 <code>/node1/app0000000001</code>、<code>/node1/app0000000002</code> 。</li><li>  <strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong>：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li></ul><p>可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。</p><p>使用 Redis 实现分布式锁的时候，我们是通过过期时间来避免锁无法被释放导致死锁问题的，而 ZooKeeper 直接利用临时节点的特性即可。</p><p>假设不适用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。</p><h4 id="设置对前一个节点的监听"><a href="#设置对前一个节点的监听" class="headerlink" title="设置对前一个节点的监听"></a>设置对前一个节点的监听</h4><blockquote><p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p></blockquote><p>同一时间段内，可能会有很多客户端同时获取锁，但只有一个可以获取成功。如果获取锁失败，则说明有其他的客户端已经成功获取锁。获取锁失败的客户端并不会不停地循环去尝试加锁，而是在前一个节点注册一个事件监听器。</p><p>这个事件监听器的作用是：<strong>当前一个节点对应的客户端释放锁之后（也就是前一个节点被删除之后，监听的是删除事件），通知获取锁失败的客户端（唤醒等待的线程，Java 中的 <code>wait/notifyAll</code> ），让它尝试去获取锁，然后就成功获取锁了。</strong></p><h4 id="实现可重入锁-1"><a href="#实现可重入锁-1" class="headerlink" title="实现可重入锁"></a>实现可重入锁</h4><p>这里以 Curator 的 <code>InterProcessMutex</code> 对可重入锁的实现来介绍</p><p>当我们调用 <code>InterProcessMutex#acquire</code>方法获取锁的时候，会调用<code>InterProcessMutex#internalLock</code>方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 获取可重入互斥锁，直到获取成功为止</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">internalLock</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOException</span><span class="token punctuation">(</span><span class="token string">"Lost connection while trying to acquire lock: "</span> <span class="token operator">+</span> basePath<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>internalLock</code> 方法会先获取当前请求锁的线程，然后从 <code>threadData</code>( <code>ConcurrentMap&lt;Thread, LockData&gt;</code> 类型)中获取当前线程对应的 <code>lockData</code> 。 <code>lockData</code> 包含锁的信息和加锁的次数，是实现可重入锁的关键。</p><p>第一次获取锁的时候，<code>lockData</code>为 <code>null</code>。获取锁成功之后，会将当前线程和对应的 <code>lockData</code> 放到 <code>threadData</code> 中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">internalLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>  <span class="token comment">// 获取当前请求锁的线程</span>  <span class="token class-name">Thread</span> currentThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 拿对应的 lockData</span>  <span class="token class-name">LockData</span> lockData <span class="token operator">=</span> threadData<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第一次获取锁的话，lockData 为 null</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lockData <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 当前线程获取过一次锁之后</span>    <span class="token comment">// 因为当前线程的锁存在， lockCount 自增后返回，实现锁重入.</span>    lockData<span class="token punctuation">.</span>lockCount<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">// 尝试获取锁</span>  <span class="token class-name">String</span> lockPath <span class="token operator">=</span> internals<span class="token punctuation">.</span><span class="token function">attemptLock</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> <span class="token function">getLockNodeBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lockPath <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">LockData</span> newLockData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LockData</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">,</span> lockPath<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 获取锁成功之后，将当前线程和对应的 lockData 放到 threadData 中</span>    threadData<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">,</span> newLockData<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>LockData</code>是 <code>InterProcessMutex</code>中的一个静态内部类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ConcurrentMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">,</span> <span class="token class-name">LockData</span><span class="token punctuation">&gt;</span></span> threadData <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newConcurrentMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LockData</span><span class="token punctuation">{</span>    <span class="token comment">// 当前持有锁的线程</span>    <span class="token keyword">final</span> <span class="token class-name">Thread</span> owningThread<span class="token punctuation">;</span>    <span class="token comment">// 锁对应的子节点</span>    <span class="token keyword">final</span> <span class="token class-name">String</span> lockPath<span class="token punctuation">;</span>    <span class="token comment">// 加锁的次数</span>    <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> lockCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">LockData</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> owningThread<span class="token punctuation">,</span> <span class="token class-name">String</span> lockPath<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>owningThread <span class="token operator">=</span> owningThread<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>lockPath <span class="token operator">=</span> lockPath<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果已经获取过一次锁，后面再来获取锁的话，直接就会在 <code>if (lockData != null)</code> 这里被拦下了，然后就会执行<code>lockData.lockCount.incrementAndGet();</code> 将加锁次数加 1。</p><p>整个可重入锁的实现逻辑非常简单，直接在客户端判断当前线程有没有获取锁，有的话直接将加锁次数加 1 就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于单机多线程来说，在 Java 中，我们通常使用 &lt;code&gt;ReetrantLock&lt;/code&gt; 类、&lt;code&gt;synchronized&lt;/code&gt; 关键字这类 JDK 自带的 &lt;strong&gt;本地锁&lt;/strong&gt; 来控制一个 JVM 进程内的多个线程对本地共</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="NoSQL" scheme="http://ailiaa.github.io/tags/NoSQL/"/>
    
    <category term="redis" scheme="http://ailiaa.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>设计模式(补档)</title>
    <link href="http://ailiaa.github.io/2023/03/25/she-ji-mo-shi-bu-dang/"/>
    <id>http://ailiaa.github.io/2023/03/25/she-ji-mo-shi-bu-dang/</id>
    <published>2023-03-25T05:20:57.000Z</published>
    <updated>2023-08-31T09:02:25.677Z</updated>
    
    <content type="html"><![CDATA[<h3 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h3><p>常⽤的⾯向对象设计原则包括7个，这些原则并不是孤⽴存在的，它们相互 依赖，相互补充。</p><ul><li>开闭原则（Open Closed Principle，OCP）</li><li>单⼀职责原则（Single Responsibility Principle, SRP） </li><li>⾥⽒替换原则（Liskov Substitution Principle，LSP） </li><li>依赖倒置原则（Dependency Inversion Principle，DIP） </li><li>接⼝隔离原则（Interface Segregation Principle，ISP） </li><li>合成/聚合复⽤原则（Composite/Aggregate Reuse Principle， C/ARP） </li><li>最少知识原则（Least Knowledge Principle，LKP）</li><li>或者迪⽶特法则 （Law of Demeter，LOD</li></ul><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.png"></p><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p>设计模式是软件开发⼈员在软件开发过程中⾯临的⼀般问题的<strong>解决⽅案</strong>。这些解决⽅案是众多软件开发⼈员经过相当⻓的 ⼀段时间的试验和错误总结出来的。 </p><p>设计模式是⼀套被反复使⽤的、多数⼈知晓的、经过分类编⽬的、代码设计经验的总结。使⽤设计模式是为了重⽤代码、让代码更容易被他⼈理解、保证代码可靠性。</p><p>项⽬中合理地运⽤设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了 ⼀个在我们周围不断重复发⽣的问题，以及该问题的核⼼解决⽅案</p><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><p><strong>创建型</strong>： 在创建对象的同时隐藏创建逻辑，不使⽤ new 直接实例化对象，程序在判断需要创建哪些对象时更灵活。包括⼯⼚/抽象⼯⼚/单例/ 建造者/原型模式。 </p><p><strong>结构型</strong>： 通过类和接⼝间的继承和引⽤实现创建复杂结构的对象。包 括适配器/桥接模式/过滤器/组合/装饰器/外观/享元/代理模式。 </p><p><strong>⾏为型</strong>： 通过类之间不同通信⽅式实现不同⾏为。包括责任链/命名/解 释器/迭代器/中介者/备忘录/观察者/状态/策略/模板/访问者模式</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.png"></p><h3 id="简单⼯⼚模式"><a href="#简单⼯⼚模式" class="headerlink" title="简单⼯⼚模式"></a>简单⼯⼚模式</h3><p>简单⼯⼚模式指由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻辑，只需提供传⼊⼯⼚的参数。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.png"></p><p>适⽤于⼯⼚类负责创建对象较少的情况，缺点是如果要增加新产品，就需 要修改⼯⼚类的判断逻辑，违背开闭原则，且产品多的话会使⼯⼚类⽐较 复杂。</p><p>抽象产品</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>具体产品</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Meizu</span> <span class="token keyword">implements</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"魅族"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Xiaomi</span> <span class="token keyword">implements</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小米"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>工厂类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PhoneFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Phone</span> <span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token class-name">String</span> phone<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"小米"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Xiaomi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"魅族"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Meizu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>消费者</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">PhoneFactory</span><span class="token punctuation">.</span><span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token string">"Xiaomi"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">PhoneFactory</span><span class="token punctuation">.</span><span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token string">"Meizu"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="⼯⼚⽅法模式"><a href="#⼯⼚⽅法模式" class="headerlink" title="⼯⼚⽅法模式"></a>⼯⼚⽅法模式</h3><p>和简单⼯⼚模式中⼯⼚负责⽣产所有产品相⽐，⼯⼚⽅法模式将⽣成具体 产品的任务分发给具体的产品⼯⼚。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04.png"></p><p>也就是定义⼀个抽象⼯⼚，其定义了产品的⽣产接⼝，但不负责具体的产 品，将⽣产任务交给不同的派⽣类⼯⼚。这样不⽤通过指定类型来创建对 象了。</p><p>在简单工厂模式中，在抽象工厂下分为具体工厂</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XiaomiFactory</span> <span class="token keyword">implements</span> <span class="token class-name">PhoneFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Phone</span> <span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Xiaomi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MeizuFactory</span> <span class="token keyword">implements</span> <span class="token class-name">PhoneFactory</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Phone</span> <span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Meizu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>消费者</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Phone</span> xiaomi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XiaomiFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Phone</span> meizu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MeizuFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xiaomi<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        meizu<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抽象⼯⼚模式"><a href="#抽象⼯⼚模式" class="headerlink" title="抽象⼯⼚模式"></a>抽象⼯⼚模式</h3><p>简单⼯⼚模式和⼯⼚⽅法模式不管⼯⼚怎么拆分抽象，都只是针对⼀类产品，如果要⽣成另⼀种产品，就⽐较难办了</p><p>抽象⼯⼚模式通过在 AbstarctFactory 中增加创建产品的接⼝，并在具体⼦⼯⼚中实现新加产品的创建。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05.png"></p><p>抽象工厂仅仅是在工厂方法模式下新增了一些接口，只是工厂模式的一个拓展，当抽象工厂模式只有一个产品体系的话就会退化成工厂模式。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例。</p><p>Spring 中的 Bean 默认都是单例的，作用域是singleton</p><p><strong>懒汉式，线程不安全</strong></p><p>用private声明了构造方法，这样做其他类就不能直接通过new实例化了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>懒汉式，线程安全</strong></p><p>synchronized修饰get()方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>饿汉式</strong></p><p>用private声明了构造方法，这样做其他类就不能直接通过new实例化了<br>（类加载时就初始化）这样就会浪费了内存空间。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>双重校验锁</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>为什么加上volatile关键字，有什么用呢？</strong></p><p>new的时候不是原子性， singleton = new Singleton(); 这段代码其实是分为三步执行：</p><ol><li> 分配内存空间</li><li> 执行构造方法，初始化对象</li><li> 将引用指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。</p><p>指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getSingleton</code>() 后发现 <code>singleton</code> 不为空，因此返回 <code>singleton</code>，但此时 <code>singleton</code> 还未被初始化。</p><p><strong>双重检查加锁单例模式为什么两次校验？</strong></p><p><strong>第一次校验</strong>：</p><p><strong>为了代码提高代码执行效率</strong>：由于单例模式只要一次创建实例即可，所以当创建了一个实例之后，再次调用getInstance方法就<strong>不必要进入同步代码块</strong>，不用竞争锁。直接返回前面创建的实例即可。</p><p><strong>第二次校验</strong>：</p><p><strong>防止二次创建实例</strong>：假如有一种情况，当singleton还未被创建时，线程t1调用getInstance方法，由于第一次判断singleton == null，此时线程t1准备继续执行，但是由于CPU资源被线程t2抢占了，此时t2页调用getInstance方法，同样的，由于singleton并没有实例化，t2同样可以通过第一个if，然后继续往下执行，同步代码块，第二个if也通过，然后t2线程创建了一个实例singleton。此时t2线程完成任务，资源又回到t1线程，t1此时也进入同步代码块，如果没有这个第二个if，那么，t1就也会创建一个singleton实例，那么，就会出现创建多个实例的情况，但是加上第二个if，就可以完全避免这个多线程导致多次创建实例的问题。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>代理模式的本质就是将非核心事务转交给第三方处理</strong>，比如老板和秘书，明星和经纪人</p><p>代理模式的本质是⼀个中间件，主要⽬的是解耦合服务提供者和使⽤者。使⽤者通过代理<strong>间接</strong>的访问服务提供者，便于后者的封装和控制。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06.png"></p><p>优点：</p><ul><li><strong>高内聚低耦合：核心代码专注业务本身，把非业务代码通通交给代理实现</strong></li><li><strong>增加扩展性：扩展其他功能时不影响核心业务代码</strong></li></ul><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理是在程序运行前，代理类的.class文件就已经存在了</p><p>定义接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//定义一个明星的接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IStarDao</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现行为</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StarDao</span> <span class="token keyword">implements</span> <span class="token class-name">IStarDao</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拍广告"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义代理类，<strong>静态代理的关键代码</strong></p><p>经纪人代理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentProxy</span> <span class="token keyword">implements</span> <span class="token class-name">IStarDao</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">IStarDao</span> action<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AgentProxy</span><span class="token punctuation">(</span><span class="token class-name">IStarDao</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>action <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"经纪人接广告"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//表演行动开始::代理人是经纪人，但实际赚钱的是明星</span>        perform<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"经纪人数钱"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//明星</span>        <span class="token class-name">StarDao</span> starDao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StarDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//帮明星代理的经纪人</span>        <span class="token class-name">AgentProxy</span> agentProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AgentProxy</span><span class="token punctuation">(</span>starDao<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//帮明星代理的经纪人,让明星开始他的表演</span>        agentProxy<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：<strong>拓展新功能时能不修改我们核心代码。</strong></p><p>缺点：<strong>代理对象和目标对象类需要实现一样的接口</strong>，会导致代理类会非常非常多。并且重用性不强</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p><strong>JDK动态代理</strong></p><p>JDK代理实现是利用lang包下的reflect</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定义一个明星的接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IStarDao</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实现明星的行为</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StarDao</span> <span class="token keyword">implements</span> <span class="token class-name">IStarDao</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拍广告"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>JDK动态代理的关键代码</strong></p><p>代理类无需再和目标对象类实现同样的接口，更加的灵活。</p><p>代理实例的三个参数：</p><ul><li>ClassLoader loader : 指定当前目标对象使用的类加载器</li><li>Class&lt; ? &gt;[] interfaces : 目标对象实现的接口类型</li><li>InvocationHandler : 事情处理，执行目标对象的方法时，会触发事情处理方法，把当前执行的目标对象方法作为参数传入</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentProxyFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AgentProxyFactory</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 给目标对象 生成一个代理对象     */</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>                <span class="token comment">//反射机制调用目标对象的方法</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"经纪人接广告"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Object</span> returnValue <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"经纪人数钱"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> returnValue<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现代理类不需要继承接口，但需要在真正实例化时将目标对象给代理对象既可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//创建目标对象</span>        <span class="token class-name">StarDao</span> iStarDao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StarDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//给目标对象，创建代理对象，可以转成Dao</span>        <span class="token class-name">IStarDao</span> proxyInstance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IStarDao</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">AgentProxyFactory</span><span class="token punctuation">(</span>iStarDao<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//通过代理对象，调用目标对象</span>        proxyInstance<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优势：</p><ul><li>在扩展功能时不修改核心代码，</li><li>JDK动态代理类不需要和目标对象类一样都需要实现同样的接口，让代理类更加灵活。</li></ul><p>劣势：目标对象依然需要实现接口。</p><p><strong>cglib动态代理</strong></p><p>cglib代理也称&nbsp;<strong>子类代理</strong>，它是从内存中构建出一个子类来扩展目标对象的功能。</p><p>定义目标类，不同的不需要再定义接口，直接实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StarDao</span>  <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拍广告"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代理类AgentProxyFactory 实现 MethodInterceptor 接口用来调用目标类，实现动态代理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentProxyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> targer<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AgentProxyFactory</span><span class="token punctuation">(</span><span class="token class-name">Object</span> targer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>targer <span class="token operator">=</span> targer<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//返回一个代理对象,是target 对象的代理对象</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//1.创建一个工具类</span>        <span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.设置父类</span>        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>targer<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.设置回调函数</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//4.创建子类对象，即代理对象</span>        <span class="token keyword">return</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//调用目标对象</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"经纪人接广告"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> returnValue <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>targer<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"经纪人数钱"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> returnValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//创建目标对象</span>        <span class="token class-name">StarDao</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StarDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取到代理对象，并且将目标对象传给代理对象</span>        <span class="token class-name">StarDao</span> proxyInstance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">StarDao</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">AgentProxyFactory</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//执行代理对象的方法</span>        proxyInstance<span class="token punctuation">.</span><span class="token function">sing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优势：不用实现同一个接口。让代理模式真正灵动起来。</p><p>劣势：需要多导入jar包了</p><h4 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别"></a>静态代理和动态代理的区别</h4><p><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接⼝，可以直接代理实现类，并且可以不需要针对每个⽬标类都创建⼀个代理类。静态代理中，接⼝⼀旦新增加⽅法，⽬标对象和代理对象都要进⾏修改，⾮常麻烦</p><p><strong>JVM 层⾯</strong> ：静态代理在编译时就将接⼝、实现类、代理类这些都变成了⼀个个实际的 class ⽂件。⽽动态代理是在运⾏时动态⽣成类字节码，并加载到 JVM 中的。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式主要⽤于处理对象间的<strong>⼀对多的关系</strong>，是⼀种对象⾏为模式。该模式的实际应⽤场景⽐较容易确认，当⼀个对象状态发⽣变化时，所有该对象的关注者均能收到状态变化通知，以进⾏相应的处理。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07.png"></p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将两个不同接⼝的类来进⾏通信，在不修改这两个的前提下可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。</p><p>所谓适配器模式就是将⼀个类的接⼝，转换成客户期望的另⼀个接⼝。它可以让原本两个不兼容的接⼝能够⽆缝完成对接。作为中间件的适配器将⽬标类和适配者解耦，增加了类的透明性和可复⽤性。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;软件设计原则&quot;&gt;&lt;a href=&quot;#软件设计原则&quot; class=&quot;headerlink&quot; title=&quot;软件设计原则&quot;&gt;&lt;/a&gt;软件设计原则&lt;/h3&gt;&lt;p&gt;常⽤的⾯向对象设计原则包括7个，这些原则并不是孤⽴存在的，它们相互 依赖，相互补充。&lt;/p&gt;
&lt;ul&gt;
&lt;l</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://ailiaa.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis(补档)</title>
    <link href="http://ailiaa.github.io/2023/03/22/redis-bu-dang/"/>
    <id>http://ailiaa.github.io/2023/03/22/redis-bu-dang/</id>
    <published>2023-03-22T08:45:06.000Z</published>
    <updated>2023-09-15T03:12:40.955Z</updated>
    
    <content type="html"><![CDATA[<h3 id="什么是-Redis"><a href="#什么是-Redis" class="headerlink" title="什么是 Redis"></a>什么是 Redis</h3><p>Redis 是一个基于 C 语言开发的非关系型数据库，Redis 的数据是存在内存中的，读写速度非常快，被广泛应用于缓存方向。Redis 存储的是 KV 键值对数据。</p><h3 id="Redis-为什么这么快"><a href="#Redis-为什么这么快" class="headerlink" title="Redis 为什么这么快"></a>Redis 为什么这么快</h3><ul><li>Redis 基于内存，内存的访问速度是磁盘的上千倍；</li><li>Redis 采用IO多路复用机制</li><li>Redis 单线程的优势，没有线程上下文切换的开销</li><li>Redis 内置了多种优化过后的数据结构实现，性能非常高。</li></ul><h3 id="Redis和Memcached相比有哪些优势"><a href="#Redis和Memcached相比有哪些优势" class="headerlink" title="Redis和Memcached相比有哪些优势"></a>Redis和Memcached相比有哪些优势</h3><ul><li><p>Redis<strong>数据结构更丰富</strong>，支持string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)等数据结构存储，Memcached仅支持String数据类型。</p></li><li><p>Redis支持数据的<strong>持久化</strong>，可以把内存中的数据持久化到硬盘中，而Memcached不支持持久化，数据只能存在内存中，重启后数据就没了。</p></li><li><p>Memcached没有原生的<strong>集群模式</strong>，需要依靠客户端自己实现集群分片，而Redis原生支持集群模式。</p></li><li><p>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用<strong>单线程</strong>的多路 IO 复用模型。</p></li></ul><h3 id="Redis常用指令"><a href="#Redis常用指令" class="headerlink" title="Redis常用指令"></a>Redis常用指令</h3><ul><li> 设置key-value ：set key value</li><li>获取值：get key</li><li>删除：del key</li><li>判断key是否存在：exists key</li><li>设置10秒过期：expire key 10</li><li>设置10毫秒过期：pexpire key 10</li><li>删除过期时间：persist key</li><li>切换数据库：redis有16个数据库，默认使用0号数据库，切换数据库的命令为：select index</li><li>清空当前选中的数据库：flushdb</li><li>清空所有数据库：flushall</li><li>查看当前数据库的所有key：keys *</li><li>查看字段类型：type key</li></ul><h3 id="Redis有哪些数据结构-应⽤场景"><a href="#Redis有哪些数据结构-应⽤场景" class="headerlink" title="Redis有哪些数据结构 应⽤场景"></a>Redis有哪些数据结构 应⽤场景</h3><p>Redis的数据结构有：</p><ol><li><p>String字符串：可以⽤来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利⽤了这种数据结构，还包括可以实现计数器、Session共享、分布式ID</p></li><li><p>HashMap哈希表：可以⽤来存储⼀些key-value对，更适合⽤来存储对象</p></li><li><p>List列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使⽤，可以⽤来缓存类似微信公众号、微博等消息流数据</p></li><li><p>Set集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进⾏交集、并集、差集操作，从⽽可以实现类似，我和某⼈共同关注的⼈、朋友圈点赞等功能</p></li><li><p>zSet有序集合：集合是⽆序的，有序集合可以设置顺序，可以⽤来实现排⾏榜功能</p></li></ol><h3 id="String-的底层实现"><a href="#String-的底层实现" class="headerlink" title="String 的底层实现"></a>String 的底层实现</h3><p>redis的String类型在底层实现中有三种实现方式。</p><ol><li>使用整数值实现的字符串对象，使用的是<strong>8个字节的long</strong>类型进行存储。</li><li>使用<strong>embstr编码</strong>的动态字符串实现的字符串对象，存储长度小于44字节的字符串</li><li><strong>动态字符串</strong>实现的字符串对象，存储长度大于44字节的字符串。</li></ol><p>redis会根据值的类型和长度自动选择存储的类型。</p><p>动态字符串是redis写的一个抽象数据类型，存储了字符串的长度、空闲长度和字符数组等字段。</p><h3 id="Redis的过期策略有哪些"><a href="#Redis的过期策略有哪些" class="headerlink" title="Redis的过期策略有哪些"></a>Redis的过期策略有哪些</h3><ol><li> <strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li> <strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性删除</strong> 。</p><h3 id="如何解决key-valve数据量很大的问题"><a href="#如何解决key-valve数据量很大的问题" class="headerlink" title="如何解决key-valve数据量很大的问题"></a>如何解决key-valve数据量很大的问题</h3><ol><li>Redis 配置：修改配置文件或者在启动 Redis 服务器时指定参数来设置最大内存限制。</li><li>数据分片：将数据分片存储到多个 Redis 实例中。根据数据的某种规则（例如哈希函数），将不同的 key-value 对映射到不同的 Redis 实例中。</li><li>合适的数据结构：Redis 提供了多种数据结构，如字符串、哈希表、列表、集合和有序集合等。根据实际需求选择合适的数据结构来存储数据。</li><li>压缩数据：可以使用 Redis 提供的压缩功能来减小数据占用的空间。Redis 支持使用 Gzip 或 LZF 算法对数据进行压缩。</li><li>分解为多个字段或多个键：如果单个 key-value 对的数据结构复杂，可以考虑将其拆分为多个字段或多个键进行存储。</li></ol><h3 id="如何解决大量key集中过期导致卡顿"><a href="#如何解决大量key集中过期导致卡顿" class="headerlink" title="如何解决大量key集中过期导致卡顿"></a>如何解决大量key集中过期导致卡顿</h3><p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的</p><ol><li> 给 key 设置随机过期时间。</li><li> 开启 lazy-free（<strong>惰性删除</strong>/延迟释放）。 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li></ol><h3 id="Redis-内存淘汰机制有哪些"><a href="#Redis-内存淘汰机制有哪些" class="headerlink" title="Redis 内存淘汰机制有哪些"></a>Redis 内存淘汰机制有哪些</h3><ol><li> <strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li><li> <strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li><li> <strong>volatile-random</strong>：从已设置过期时间的数据集中随机选择数据淘汰</li><li> <strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（最常用的）</li><li> <strong>allkeys-random</strong>：从数据集中任意选择数据淘汰</li><li> <strong>no-eviction</strong>：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。</li></ol><h3 id="Redis-持久化机制有哪些"><a href="#Redis-持久化机制有哪些" class="headerlink" title="Redis 持久化机制有哪些"></a>Redis 持久化机制有哪些</h3><p><strong>RDB</strong>：Redis DataBase，在指定的时间间隔内将内存中的<strong>数据集快照</strong>写⼊磁盘，实际操作过程是fork⼀个⼦进程，先将数据集写⼊临时⽂件，写⼊成功后，再替换之前的⽂件，⽤⼆进制压缩存储。（Redis 默认）</p><p>Redis提供了两个命令来生成 RDB 文件：</p><ul><li>save：在主进程中执行，会导致写请求阻塞。</li><li>bgsave：fork一个子进程，专门用于写入 RDB 文件，避免了主进程的阻塞。</li></ul><p>优点：</p><ul><li><p>RDB文件紧凑，体积小，网络传输快，适合全量复制</p></li><li><p>与AOF方式相比，通过RDB文件恢复数据比较快更快</p></li><li><p>RDB最大化了Redis的性能，因为Redis父进程持久化时只需要fork一个子进程，这个子进程可以共享主进程的所有内存数据，子进程会去读取主进程的内存数据，并把它们写入RDB文件。</p></li></ul><p>缺点：</p><ul><li><p>快照是定期生成的，所有在 Redis 故障时或多或少会丢失一部分数据</p></li><li><p>当数据量比较大时，fork 的过程是非常耗时的，fork 子进程时是会阻塞的，在这期间 Redis 是不能响应客户端的请求的。</p></li></ul><p><strong>AOF</strong>：Append Only File，以<strong>⽇志</strong>的形式记录服务器所处理的每⼀个写、删除操作，查询操作不会记录，以⽂本的⽅式记录，可以打开⽂件看到详细的操作记录</p><p>优点：</p><ul><li>数据安全，Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是⾮常⾼的，所差的是⼀旦系统出现宕机现象，那么这⼀秒钟之内修改的数据将会丢失。</li><li>通过 append 模式写⽂件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-check-aof ⼯具解决数据⼀致性问题。</li><li>AOF 机制的 rewrite 模式。定期对AOF⽂件进⾏重写，以达到压缩的⽬的</li></ul><p>缺点：</p><ul><li>AOF ⽂件⽐ RDB ⽂件⼤，且恢复速度慢。</li><li>数据集⼤的时候，⽐ rdb 启动效率低。</li><li>运⾏效率没有RDB⾼</li></ul><h3 id="Redis事务机制"><a href="#Redis事务机制" class="headerlink" title="Redis事务机制"></a>Redis事务机制</h3><p>Redis通过<strong>MULTI、EXEC、WATCH</strong>等一组命令集合，来实现事务机制。<strong>顺序性、一次性、排他性</strong>的执行一个队列中的一系列命令。</p><p>Redis执行事务的流程如下：</p><ul><li>  开始事务（MULTI）</li><li>  命令入队</li><li>  执行事务（EXEC）、撤销事务（DISCARD ）</li></ul><p>Redis 事务是不支持回滚（roll back）操作的，不满足原子性的，而且不满足持久性</p><h3 id="缓存穿透、缓存击穿、缓存雪崩分别是什么"><a href="#缓存穿透、缓存击穿、缓存雪崩分别是什么" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩分别是什么"></a>缓存穿透、缓存击穿、缓存雪崩分别是什么</h3><ol><li><p>缓存雪崩：如果缓存中某⼀时刻⼤批热点数据同时过期，那么就可能导致⼤量请求直接访问Mysql了。解决办法就是在过期时间上增加⼀点随机值，另外如果搭建⼀个⾼可⽤的Redis集群也是防⽌缓存雪崩的有效⼿段</p></li><li><p>缓存击穿：和缓存雪崩类似，缓存雪崩是⼤批热点数据失效，⽽缓存击穿是指某⼀个热点key突然失效，也导致了⼤量请求直接访问Mysql数据库，这就是缓存击穿。解决⽅案就是考虑这个热点key不设过期时间</p></li><li><p>缓存穿透：假如某⼀时刻访问redis的⼤量key都在redis中不存在（⽐如⿊客故意伪造⼀些乱七⼋糟的key），那么也会给数据造成压⼒，这就是缓存穿透。解决⽅案是使⽤布隆过滤器，它的作⽤就是如果它认为⼀个key不存在，那么这个key就肯定不存在，所以可以在缓存之前加⼀层布隆过滤器来拦截不存在的key</p></li></ol><h3 id="Redis和Mysql如何保证数据⼀致"><a href="#Redis和Mysql如何保证数据⼀致" class="headerlink" title="Redis和Mysql如何保证数据⼀致"></a>Redis和Mysql如何保证数据⼀致</h3><p>延迟双删：</p><p>先删除Redis缓存数据，再更新Mysql，延迟⼏百毫秒再删除Redis缓存数据，这样就算在更新Mysql时，有其他线程读了Mysql，把⽼数据读到了Redis中，那么也会被删除掉，从⽽把数据保持⼀致</p><h3 id="Redis集群策略有哪些"><a href="#Redis集群策略有哪些" class="headerlink" title="Redis集群策略有哪些"></a>Redis集群策略有哪些</h3><p>Redis提供了三种集群策略：</p><ol><li><p>主从模式：这种模式⽐较简单，主库可以读写，并且会和从库进⾏数据同步，这种模式下，客户端直接连主库或某个从库，但是但主库或从库宕机后，客户端需要⼿动修改IP，另外，这种模式也⽐较难进⾏扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能⽀持特⼤数据量</p></li><li><p>哨兵模式：这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕机，然后在从库中选择⼀个库作为进的主库，另外哨兵也可以做集群，从⽽可以保证但某⼀个哨兵节点宕机后，还有其他哨兵节点可以继续⼯作，这种模式可以⽐较好的保证Redis集群的⾼可⽤，但是仍然不能很好的解决Redis的容量上限问题。</p></li><li><p>Cluster模式：Cluster模式是⽤得⽐较多的模式，它⽀持多主多从，这种模式会按照key进⾏槽位的分配，可以使得不同的key分散到不同的主节点上，利⽤这种模式可以使得整个集群⽀持更⼤的数据容量，同时每个主节点可以拥有⾃⼰的多个从节点，如果该主节点宕机，会从它的从节点中选举⼀个新的主节点。</p></li></ol><h3 id="Redis-主从复制的核⼼原理"><a href="#Redis-主从复制的核⼼原理" class="headerlink" title="Redis 主从复制的核⼼原理"></a>Redis 主从复制的核⼼原理</h3><p>通过执⾏slaveof命令或设置slaveof选项，让⼀个服务器去复制另⼀个服务器的数据。主数据库可以进⾏读写操作，当写操作导致数据变化时会⾃动将数据同步给从数据库。⽽从数据库⼀般是只读的，并接受主数据库同步过来的数据。⼀个主数据库可以拥有多个从数据库，⽽⼀个从数据库只能拥有⼀个主数据库。</p><p>全量复制：</p><ol><li><p>主节点通过bgsave命令fork⼦进程进⾏RDB持久化，该过程是⾮常消耗CPU、内存(⻚表复制)、硬盘IO的</p></li><li><p>主节点通过⽹络将RDB⽂件发送给从节点，对主从节点的带宽都会带来很⼤的消耗</p></li><li><p>从节点清空⽼数据、载⼊新RDB⽂件的过程是阻塞的，⽆法响应客户端的命令；如果从节点执⾏bgrewriteaof，也会带来额外的消耗</p></li></ol><p>部分复制：</p><ol><li><p>复制偏移量：执⾏复制的双⽅，主从节点，分别会维护⼀个复制偏移量offset</p></li><li><p>复制积压缓冲区：主节点内部维护了⼀个固定⻓度的、先进先出(FIFO)队列 作为复制积压缓冲区，当主从节点offset的差距过⼤超过缓冲区⻓度时，将⽆法执⾏部分复制，只能执⾏全量复制。</p></li><li><p>服务器运⾏ID(runid)：每个Redis节点，都有其运⾏ID，运⾏ID由节点在启动时⾃动⽣成，主节点会将⾃⼰的运⾏ID发送给从节点，从节点会将主节点的运⾏ID存起来。 从节点Redis断开重连的时候，就是根据运⾏ID来判断同步的进度：○ 如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使⽤部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；○ 如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进⾏全量复制。</p></li></ol><h3 id="Redis分布式锁底层是如何实现的"><a href="#Redis分布式锁底层是如何实现的" class="headerlink" title="Redis分布式锁底层是如何实现的"></a>Redis分布式锁底层是如何实现的</h3><p>通常依赖于Redis提供的原子性操作和特定的数据结构。</p><ol><li><p>获取锁：</p><ul><li>利⽤setnx来保证：如果key不存在才能获取到锁，如果key存在，则获取不到锁。(SETNX key value：将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作，该命令在设置成功时返回 1，设置失败时返回 0。)</li><li>如果setnx命令执行失败，说明锁已被其他客户端占用，需要等待一段时间后再次尝试获取锁（通常使用循环重试来实现）。</li></ul></li><li><p>释放锁：</p><ul><li>使用DEL命令删除之前存储的锁，释放当前客户端持有的锁</li></ul></li><li><p>结合Lua脚本</p><ul><li>Lua脚本能够在Redis服务器端原子地执行一系列命令，可以减少网络开销和提高性能。例如，使用Lua脚本可以在一次网络往返的过程中检查锁是否存在并获取锁。</li></ul></li><li><p>考虑锁过期</p><ul><li><p>setnx同时设置一个适当的过期时间（避免锁无法释放导致死锁）</p></li><li><p>看⻔狗定时任务来监听锁是否需要续约</p><ol><li>续约逻辑：客户端需要定时（一般为锁过期时间的一半）向Redis服务器发送指令，告知服务器当前客户端依然持有锁，并请求更新锁的过期时间。可以使用Redis的EXPIRE命令来更新锁的过期时间。</li><li>超时处理：如果客户端未能及时发送续约指令，或者续约指令发送失败，则说明该客户端出现了异常，无法继续持有锁。此时，Redis服务器需要将锁分配给其他等待获取锁的客户端。</li><li>竞争解决：如果有多个客户端同时发送续约指令，Redis服务器需要根据一定的规则（如先到先得或者权重分配）来判断哪个客户端可以继续持有锁。</li></ol></li></ul></li><li><p>避免死锁和活锁等问题</p></li></ol><ul><li><p>避免死锁：</p><ul><li>使用唯一标识符（例如UUID）作为锁的值，确保每个客户端持有的锁都是唯一的。</li><li>释放锁时，核对锁的值是否与之前获取锁时设置的值一致，以防止误删其他客户端的锁。</li></ul></li><li><p>避免活锁：</p><ul><li>引入随机的等待时间或指数退避策略。在获取锁失败时，等待一段随机时间后再次尝试获取锁，以减少同时竞争锁的概率。</li><li>设置一个最大尝试次数或超时时间，在达到限制后停止尝试获取锁，避免无限循环导致活锁。</li></ul></li></ul><ol start="6"><li>考虑到redis节点挂掉后的情况</li></ol><ul><li>采⽤（RedLock）红锁的⽅式来同时向N/2+1个节点申请锁，都申请到了才证明获取锁成功，红锁是分布式环境下的多实例互斥锁算法</li></ul><ol><li>将锁名称、唯一标识符和过期时间发送给集群中的每个Redis节点。</li><li>在每个节点上尝试获取锁。</li><li>如果有超过 N/2+1 个节点成功获取了锁，那么认为获取锁成功；否则，认为获取锁失败。</li><li>如果成功获取了锁，开始执行临界区代码。</li><li>执行完临界区代码后，释放锁，即在所有节点上删除锁。</li></ol><p>核心思想：在多个独立的Redis节点获取到锁的数量进行判断，确保在大多数节点可用的情况下才能获取锁。防止因某个节点不可用而导致的锁失效问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;什么是-Redis&quot;&gt;&lt;a href=&quot;#什么是-Redis&quot; class=&quot;headerlink&quot; title=&quot;什么是 Redis&quot;&gt;&lt;/a&gt;什么是 Redis&lt;/h3&gt;&lt;p&gt;Redis 是一个基于 C 语言开发的非关系型数据库，Redis 的数据是存在内存中</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="NoSQL" scheme="http://ailiaa.github.io/tags/NoSQL/"/>
    
    <category term="redis" scheme="http://ailiaa.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>常见算法</title>
    <link href="http://ailiaa.github.io/2023/03/20/chang-jian-suan-fa/"/>
    <id>http://ailiaa.github.io/2023/03/20/chang-jian-suan-fa/</id>
    <published>2023-03-20T01:25:58.000Z</published>
    <updated>2023-09-15T02:54:14.734Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数据库连接池"><a href="#数据库连接池" class="headerlink" title="数据库连接池"></a>数据库连接池</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">Connection</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">DriverManager</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>sql<span class="token punctuation">.</span></span><span class="token class-name">SQLException</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">ArrayList</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span></span><span class="token class-name">List</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ConnectionPool</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">URL</span> <span class="token operator">=</span> <span class="token string">"jdbc:mysql://localhost:3306/mydatabase"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">USERNAME</span> <span class="token operator">=</span> <span class="token string">"username"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">String</span> <span class="token constant">PASSWORD</span> <span class="token operator">=</span> <span class="token string">"password"</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_POOL_SIZE</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Connection</span><span class="token punctuation">&gt;</span></span> connectionPool<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">ConnectionPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">initializeConnectionPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 初始化连接池，创建初始数量的连接     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">initializeConnectionPool</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        connectionPool <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token constant">MAX_POOL_SIZE</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">Connection</span> connection <span class="token operator">=</span> <span class="token class-name">DriverManager</span><span class="token punctuation">.</span><span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token constant">URL</span><span class="token punctuation">,</span> <span class="token constant">USERNAME</span><span class="token punctuation">,</span> <span class="token constant">PASSWORD</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                connectionPool<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">SQLException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 从连接池中获取一个可用的连接     *     * @return 可用的连接     */</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token class-name">Connection</span> <span class="token function">getConnection</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">SQLException</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>connectionPool<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">try</span> <span class="token punctuation">{</span>                <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token class-name">Connection</span> connection <span class="token operator">=</span> connectionPool<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>connectionPool<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> connection<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 将连接释放回连接池     *     * @param connection 要释放的连接     */</span>    <span class="token keyword">public</span> <span class="token keyword">synchronized</span> <span class="token keyword">void</span> <span class="token function">releaseConnection</span><span class="token punctuation">(</span><span class="token class-name">Connection</span> connection<span class="token punctuation">)</span> <span class="token punctuation">{</span>        connectionPool<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>connection<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h3><p><strong>双向链表</strong>：按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。<br><strong>哈希表</strong>：即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。  </p><p>首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部， 即可在O(1) 的时间内完成 get 或者 put 操作。  </p><p>对于 get 操作，首先判断 key 是否存在： </p><ul><li>如果 key 不存在，则返回 −1-1−1；  </li><li>如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。  </li></ul><p>对于 put 操作，首先判断 key 是否存在：  </p><ul><li>如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项； </li><li>如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。  </li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">DLinkedNode</span><span class="token punctuation">&gt;</span></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">DLinkedNode</span> head<span class="token punctuation">,</span>tail<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>          <span class="token comment">//虚拟头尾节点  </span>        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>          tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token class-name">DLinkedNode</span> node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token comment">//移到头部  </span>        <span class="token function">moveToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token class-name">DLinkedNode</span> node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token comment">// 如果 key 不存在，创建一个新的节点  </span>            <span class="token class-name">DLinkedNode</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 添加进哈希表  </span>            cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 添加至双向链表的头部  </span>            <span class="token function">addToHead</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>              size<span class="token operator">++</span><span class="token punctuation">;</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> capacity<span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token comment">// 如果超出容量，删除双向链表的尾部节点  </span>                <span class="token class-name">DLinkedNode</span> tail <span class="token operator">=</span> <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 删除哈希表中对应的项  </span>                cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tail<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                  size<span class="token operator">--</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>              <span class="token comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部  </span>            node<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>              <span class="token function">moveToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>        <span class="token comment">//定义双向链表  </span>    <span class="token keyword">class</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">{</span>          <span class="token keyword">int</span> key<span class="token punctuation">;</span>          <span class="token keyword">int</span> value<span class="token punctuation">;</span>          <span class="token class-name">DLinkedNode</span> prev<span class="token punctuation">;</span>          <span class="token class-name">DLinkedNode</span> next<span class="token punctuation">;</span>          <span class="token keyword">public</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>          <span class="token keyword">public</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addToHead</span><span class="token punctuation">(</span><span class="token class-name">DLinkedNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>          node<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>          node<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>          head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>          head<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token class-name">DLinkedNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>          node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>          node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">moveToHead</span><span class="token punctuation">(</span><span class="token class-name">DLinkedNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">addToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token class-name">DLinkedNode</span> <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token class-name">DLinkedNode</span> res <span class="token operator">=</span> tail<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>          <span class="token function">removeNode</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> res<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用内置数据结构LinkedHashMap</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LRUCache2</span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">LRUCache2</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">//容量，负载因子，是否顺序访问（默认false插序访问）  </span>        <span class="token keyword">super</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token number">0.75F</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>      <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> capacity<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例。</p><p><strong>懒汉式，线程不安全</strong></p><p>用private声明了构造方法，这样做其他类就不能直接通过new实例化了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>懒汉式，线程安全</strong></p><p>synchronized修饰get()方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>饿汉式</strong></p><p>用private声明了构造方法，这样做其他类就不能直接通过new实例化了<br>（类加载时就初始化）这样就会浪费了内存空间。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>双重校验锁</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="多线程交替输出ABC"><a href="#多线程交替输出ABC" class="headerlink" title="多线程交替输出ABC"></a>多线程交替输出ABC</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span></span><span class="token class-name">Semaphore</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Condition</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">Lock</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>concurrent<span class="token punctuation">.</span>locks<span class="token punctuation">.</span></span><span class="token class-name">ReentrantLock</span></span><span class="token punctuation">;</span><span class="token comment">/** * 交替输出ABC字母 */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AlternateABC</span> <span class="token punctuation">{</span>    <span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Integer</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token comment">// volatile + synchronized</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">solution1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token punctuation">}</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        count<span class="token operator">++</span><span class="token punctuation">;</span>                        i<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token punctuation">}</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        count<span class="token operator">++</span><span class="token punctuation">;</span>                        i<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token punctuation">}</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        count<span class="token operator">++</span><span class="token punctuation">;</span>                        i<span class="token operator">++</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//资源 1</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//资源 2</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数据库连接池&quot;&gt;&lt;a href=&quot;#数据库连接池&quot; class=&quot;headerlink&quot; title=&quot;数据库连接池&quot;&gt;&lt;/a&gt;数据库连接池&lt;/h3&gt;&lt;pre class=&quot;line-numbers language-java&quot; data-language=&quot;ja</summary>
      
    
    
    
    
    <category term="算法" scheme="http://ailiaa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://ailiaa.github.io/2023/03/15/xiao-xi-dui-lie-bu-dang/"/>
    <id>http://ailiaa.github.io/2023/03/15/xiao-xi-dui-lie-bu-dang/</id>
    <published>2023-03-15T03:27:47.000Z</published>
    <updated>2023-09-15T03:13:35.294Z</updated>
    
    <content type="html"><![CDATA[<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h3><p>可以把消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。</p><p>由于队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。</p><p>参与消息传递的双方称为&nbsp;<strong>生产者</strong>&nbsp;和&nbsp;<strong>消费者</strong>&nbsp;，生产者负责发送消息，消费者负责处理消息。</p><h3 id="消息队列的作用是什么（优点）"><a href="#消息队列的作用是什么（优点）" class="headerlink" title="消息队列的作用是什么（优点）"></a>消息队列的作用是什么（优点）</h3><ol><li> <strong>异步处理</strong>：提高系统性能（减少响应所需时间）</li><li> <strong>削峰/限流</strong>：把请求数据先存入消息队列中，消费系统再根据自己的消费能力拉取消费。</li><li> <strong>降低系统耦合性。</strong></li></ol><h3 id="使用消息队列会带来哪些问题（缺点）"><a href="#使用消息队列会带来哪些问题（缺点）" class="headerlink" title="使用消息队列会带来哪些问题（缺点）"></a>使用消息队列会带来哪些问题（缺点）</h3><ul><li>  <strong>系统可用性降低：</strong> 需要考虑消息丢失或者说 MQ 挂掉等等的情况</li><li>  <strong>系统复杂性提高：</strong> 需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题</li><li>  <strong>一致性问题：</strong> 消息的真正消费者并没有正确消费消息，导致数据不一致</li></ul><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="Kafka-是什么"><a href="#Kafka-是什么" class="headerlink" title="Kafka 是什么"></a>Kafka 是什么</h3><p>Kafka 是一个分布式流式处理平台。​ </p><p>Kafka 是一个多分区、多副本且基于zookeeper协调的分布式消息系统。</p><h3 id="Kafka-应用场景有哪些"><a href="#Kafka-应用场景有哪些" class="headerlink" title="Kafka 应用场景有哪些"></a>Kafka 应用场景有哪些</h3><ol><li> <strong>消息队列</strong> ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li><li> <strong>数据处理：</strong> 构建实时的流数据处理程序来转换或处理数据流</li></ol><h3 id="Kafka的优势"><a href="#Kafka的优势" class="headerlink" title="Kafka的优势"></a>Kafka的优势</h3><p>会经常拿它跟 RocketMQ、RabbitMQ 对比：</p><ul><li><p><strong>高吞吐量</strong>：Kafka 每秒可以生产约 25 万消息（50 MB），每秒处理 55 万消息（110 MB）</p></li><li><p><strong>持久化数据存储</strong>：将消息持久化到磁盘，防止数据丢失</p></li><li><p><strong>分布式系统易于扩展</strong>：所有的 producer、broker 和 consumer 都会有多个，均为分布式的。无需停机即可扩展机器。</p></li></ul><h3 id="Kafka和RabbitMQ的区别"><a href="#Kafka和RabbitMQ的区别" class="headerlink" title="Kafka和RabbitMQ的区别"></a>Kafka和RabbitMQ的区别</h3><ol><li>数据处理模型：Kafka是一个分布式发布-订阅消息系统，以高吞吐量和持久性为目标。RabbitMQ是一个基于AMQP（高级消息队列协议）的消息中间件，它使用队列模型来处理消息。</li><li>处理方式：Kafka通过分区和复制机制来实现高吞吐量和高可靠性。RabbitMQ使用先进先出（FIFO）的队列模型来处理消息，按照顺序逐一传递和消费消息。</li><li>数据保证：Kafka提供的是至少一次交付的语义，即消息不会丢失，但可能会重复。RabbitMQ提供的是恰好一次交付的语义，即消息不会丢失也不会重复。它使用确认机制和消息确认应答来确保消息的可靠性。</li><li>适用场景：Kafka适用于处理高吞吐量和持久化的流式数据，而RabbitMQ适用于可靠的点对点通信和任务队列。</li></ol><h3 id="什么是Producer、Consumer、Broker、Topic、Partition"><a href="#什么是Producer、Consumer、Broker、Topic、Partition" class="headerlink" title="什么是Producer、Consumer、Broker、Topic、Partition"></a>什么是Producer、Consumer、Broker、Topic、Partition</h3><ul><li> <strong>Producer（生产者）</strong> : 产生消息的一方。</li><li> <strong>Consumer（消费者）</strong> : 消费消息的一方。</li><li> <strong>Broker（代理）</strong> : 可以看作是一个独立的 Kafka 实例。多个Broker 组成一个 Kafka 集群。</li></ul><p>每个 Broker 中又包含了 Topic 以及 Partition ：</p><ul><li>  <strong>Topic（主题）</strong> : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</li><li>  <strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition </li></ul><blockquote><p>Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。</p></blockquote><h3 id="Zookeeper-在-Kafka-中的作用是什么"><a href="#Zookeeper-在-Kafka-中的作用是什么" class="headerlink" title="Zookeeper 在 Kafka 中的作用是什么"></a>Zookeeper 在 Kafka 中的作用是什么</h3><ul><li><p>  <strong>Broker 注册</strong> ：每个 Broker 在启动时，都会到 Zookeeper 上进行注册，创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</p></li><li><p>  <strong>Topic 注册</strong> ： 同一个Topic 的消息会被分成多个分区，并将其分布在多个 Broker 上，这些分区信息及与 Broker 的对应关系也都是由 Zookeeper 在维护。</p></li><li><p>  <strong>负载均衡</strong> ： Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</p></li></ul><h3 id="如何保证Kafka消息队列的高可用"><a href="#如何保证Kafka消息队列的高可用" class="headerlink" title="如何保证Kafka消息队列的高可用"></a>如何保证Kafka消息队列的高可用</h3><ol><li><strong>多分区（Partition）</strong></li></ol><p>创建一个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上。就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。</p><ol start="2"><li><strong>多副本（Replica）</strong></li></ol><p>每个 partition 的数据都会同步到其他机器上，形成自己的多个 replica 副本。</p><p>分区（Partition）中的多个副本之间会有一个叫做 leader 的，其他副本称为 follower。发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p><p>写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上数据即可。Kafka 会均匀的将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</p><p>这两种基准极大地提高了消息存储的安全性, 保证了kafka消息队列的高可用，不过也相应的增加了所需要的存储空间。</p><h3 id="Kafka-的分区策略有哪些"><a href="#Kafka-的分区策略有哪些" class="headerlink" title="Kafka 的分区策略有哪些"></a>Kafka 的分区策略有哪些</h3><p>所谓分区策略就是决定生产者将消息发送到哪个分区的算法。</p><ol><li>轮询策略：默认的分区策略，非常优秀的负载均衡表现，总是能保证消息最大限度地被平均分配到所有分区上；</li><li>随机策略：实现随机策略版的 partition 方法；</li><li>按消息键保序策略：可以保证同一个 Key 的所有消息都进入到相同的分区里，由于每个分区下的消息处理是有顺序的，所以称之为消息键保序策略；</li></ol><h3 id="Kafka-如何保证消息的消费顺序"><a href="#Kafka-如何保证消息的消费顺序" class="headerlink" title="Kafka 如何保证消息的消费顺序"></a>Kafka 如何保证消息的消费顺序</h3><p>Topic 有多个 Partition，从不同的Partition中消费消息可能满足不了我们需要的顺序</p><p><strong>1、1 个 Topic 只对应一个 Partition</strong></p><p>Kafka 只能为我们保证一个 Partition(分区) 中的消息有序。</p><blockquote><p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p></blockquote><p><strong>2 、发送消息的时候指定 key/Partition</strong></p><p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 id 来作为 key 。</p><h3 id="Kafka-如何保证消息不丢失"><a href="#Kafka-如何保证消息不丢失" class="headerlink" title="Kafka 如何保证消息不丢失"></a>Kafka 如何保证消息不丢失</h3><h4 id="生产者丢失消息"><a href="#生产者丢失消息" class="headerlink" title="生产者丢失消息"></a>生产者丢失消息</h4><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p><p>Kafka 生产者(Producer) 使用 <code>send</code> 方法发送消息实际上是异步的操作，在项目中采用了ListenableFuture类接收返回值，为其添加回调函数，记录发送日志，发现送失败，检查失败的原因之后重新发送。设置生产者的<code>retries</code> （重试次数），一般是 3，设置重发时间间隔</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ListenableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SendResult</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>future<span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span>result <span class="token operator">-&gt;</span> logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"生产者成功发送消息到topic:{} partition:{}的消息"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        ex <span class="token operator">-&gt;</span> logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"生产者发送消失败，原因：{}"</span><span class="token punctuation">,</span> ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者设置acks = all</p><p>acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p><p>acks 的默认值即1，当我们配置 <strong>acks = all</strong> 表示只有所有副本收到消息时，生产者才会接收到来自服务器的响应。但是延迟高</p><h4 id="消费者丢失消息"><a href="#消费者丢失消息" class="headerlink" title="消费者丢失消息"></a><strong>消费者丢失消息</strong></h4><p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p><p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset，如果消费者在正式消费之前突然挂掉了，消息实际上没有消费，但是 offset 却被自动提交了。kafka就会认为这个消息已经消费过了，造成了消息丢失。</p><p>这个情况解决办法是：<strong>关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。</strong></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">enable-auto-commit: false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>手动提交 ：ack.acknowledge();</p><p>但是，这样会带来消息被重新消费的问题。比如刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p><h4 id="Kafka-丢失消息"><a href="#Kafka-丢失消息" class="headerlink" title="Kafka 丢失消息"></a><strong>Kafka 丢失消息</strong></h4><p>考虑到：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</p><p>解决办法：</p><p><strong>设置 acks = all</strong></p><p>acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p><p>acks 的默认值即1，当我们配置 <strong>acks = all</strong> 表示只有所有副本收到消息时，生产者才会接收到来自服务器的响应。</p><p><strong>设置 replication.factor &gt;= 3</strong></p><p>这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p><p><strong>设置 min.insync.replicas &gt; 1</strong></p><p>代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p><p><strong>设置 unclean.leader.election.enable = false</strong></p><p>当 leader 副本发生故障时不会从 follower 副本中和 leader 同步程度达不到要求的副本中选择出 leader ，这样降低了消息丢失的可能性。</p><h3 id="如何保证消息不被重复消费"><a href="#如何保证消息不被重复消费" class="headerlink" title="如何保证消息不被重复消费"></a>如何保证消息不被重复消费</h3><p>kafka出现消息重复消费的原因：服务端侧已经消费的数据没有成功提交 offset（根本原因）</p><p>解决方案：消费消息服务做幂等校验，比如 Redis 的set、MySQL 的主键等天然的幂等功能。保证重复消费的消息也会得出正常结果</p><p><strong>Redis 的set</strong></p><ul><li>每个消息对应一个唯一id</li><li>在消费者receive函数中，先对这个id校验，是否存在redis中</li><li>如果存在，说明该消息已经被消费过了，不用再执行</li><li>如果不存在，说明消息没有被消费，将id放入redis，然后消费这个消息</li></ul><p>幂等校验的其他方法：</p><p><strong>1、token 机制</strong></p><ol><li>客户端会先发送一个请求去获取 token，服务端会生成一个全局唯一的 ID 作为 token 保存在 redis 中，同时把这个 ID 返回给客户端</li><li>客户端第二次调用业务请求的时候必须携带这个 token</li><li>服务端会校验这个 token，如果校验成功，则执行业务，并删除 redis 中的 token</li><li>如果校验失败，说明 redis 中已经没有对应的 token，则表示重复操作，直接返回指定的结果给客户端</li></ol><p><strong>2、基于 mysql 主键唯一</strong></p><p>利用 mysql 唯一索引的特性。</p><ol><li>建立一张去重表，其中某个字段需要建立唯一索引</li><li>客户端去请求服务端，服务端会将这次请求的一些信息插入这张去重表中</li><li>因为表中某个字段带有唯一索引，如果插入成功，证明表中没有这次请求的信息，则执行后续的业务逻辑</li><li>如果插入失败，则代表已经执行过当前请求，直接返回</li></ol><h3 id="Kafka时间轮片是什么"><a href="#Kafka时间轮片是什么" class="headerlink" title="Kafka时间轮片是什么"></a>Kafka时间轮片是什么</h3><p>Kafka中的时间轮片是用于处理延迟消息的一种机制。</p><p>时间轮片的概念基于时间轮（time wheel），时间轮是一种计时器算法，用于处理定时任务或延迟任务。Kafka中的时间轮由一组时间轮片组成，每个时间轮片代表一个时间单位，例如1秒、1分钟等。</p><p>当生产者发送一个延迟消息时，Kafka会将该消息放入对应的时间轮片中。随着时间的推移，时间轮不断转动，当一个时间轮片到达指定的时间单位后，其中的消息就可以被消费者消费了。消费者会定期检查时间轮，并处理到期的消息。</p><p>时间轮片提供了一种高效的方式来管理和触发到期的延迟消息。对于某些需要处理定时任务或具有延迟要求的场景非常有用，例如实时日志处理、事件驱动架构等。</p><h3 id="大量消息在-MQ-里长时间积压，该如何解决"><a href="#大量消息在-MQ-里长时间积压，该如何解决" class="headerlink" title="大量消息在 MQ 里长时间积压，该如何解决"></a>大量消息在 MQ 里长时间积压，该如何解决</h3><p>一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：</p><ol><li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉；</li><li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量；</li><li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue；</li><li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据；</li><li>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li></ol><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="谈下你对-Zookeeper-的认识？"><a href="#谈下你对-Zookeeper-的认识？" class="headerlink" title="谈下你对 Zookeeper 的认识？"></a>谈下你对 Zookeeper 的认识？</h3><p>ZooKeeper 是一个分布式的，开源的分布式<strong>应用程序协调服务</strong></p><p>ZooKeeper主要<strong>服务于分布式系统</strong>，可以用ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理、负载均衡、分布式协调与通知、数据发布/订阅等</p><h3 id="Zookeeper-有哪些功能"><a href="#Zookeeper-有哪些功能" class="headerlink" title="Zookeeper 有哪些功能"></a>Zookeeper 有哪些功能</h3><p><strong>1. 集群管理</strong>：监控节点存活状态、运行请求等；</p><p><strong>2. 主节点选举</strong>：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 Zookeeper 可以协助完成这个过程；</p><p><strong>3. 分布式锁</strong>：Zookeeper 提供两种锁：独占锁、共享锁。</p><p><strong>4. 命名服务</strong>：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息</p><h3 id="谈下你对-ZAB-协议的了解"><a href="#谈下你对-ZAB-协议的了解" class="headerlink" title="谈下你对 ZAB 协议的了解"></a>谈下你对 ZAB 协议的了解</h3><p>ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。</p><p>ZAB 协议包括两种基本的模式：崩溃恢复和消息广播。</p><p><strong>崩溃恢复（选主）</strong></p><p>当整个 Zookeeper 集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有服务器进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步。<strong>（超半数投票）</strong></p><p><strong>消息广播（同步）</strong></p><p>当集群中超过半数机器与该 Leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求，生成事物提案来进行事务请求处理。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;消息队列&quot;&gt;&lt;a href=&quot;#消息队列&quot; class=&quot;headerlink&quot; title=&quot;消息队列&quot;&gt;&lt;/a&gt;消息队列&lt;/h2&gt;&lt;h3 id=&quot;什么是消息队列&quot;&gt;&lt;a href=&quot;#什么是消息队列&quot; class=&quot;headerlink&quot; title=&quot;什么是</summary>
      
    
    
    
    
    <category term="Kafka" scheme="http://ailiaa.github.io/tags/Kafka/"/>
    
    <category term="消息队列" scheme="http://ailiaa.github.io/tags/%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
</feed>
