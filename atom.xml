<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>艾AA</title>
  
  
  <link href="http://ailiaa.github.io/atom.xml" rel="self"/>
  
  <link href="http://ailiaa.github.io/"/>
  <updated>2023-07-24T09:40:46.736Z</updated>
  <id>http://ailiaa.github.io/</id>
  
  <author>
    <name>Aiaa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>基于kubernetes部署云原生微服务应用Online Boutique</title>
    <link href="http://ailiaa.github.io/2023/06/09/ji-yu-kubernetes-bu-shu-yun-yuan-sheng-wei-fu-wu-ying-yong-online-boutique/"/>
    <id>http://ailiaa.github.io/2023/06/09/ji-yu-kubernetes-bu-shu-yun-yuan-sheng-wei-fu-wu-ying-yong-online-boutique/</id>
    <published>2023-06-09T09:46:17.000Z</published>
    <updated>2023-07-24T09:40:46.736Z</updated>
    
    <content type="html"><![CDATA[<h3 id="配置kubernetes集群环境"><a href="#配置kubernetes集群环境" class="headerlink" title="配置kubernetes集群环境"></a>配置kubernetes集群环境</h3><p>创建三台华为云服务器，一台做k8s-master服务器，另外两台做node节点服务器。</p><p><em><strong>对这三台服务器</strong></em>，执行以下相同命令</p><p><strong>关闭swap:</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">swapoff <span class="token parameter variable">-a</span><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/.*swap.*/#&amp;/'</span> /etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>关闭防火墙：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop ufwsystemctl disable ufwsystemctl stop firewalldsystemctl disable firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修改软件源：</strong></p><p>编辑/etc/apt/sources.list</p><p>修改镜像源(阿里云/华为/清华园)</p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> update<span class="token function">apt-get</span> upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>安装docker：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> docker.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开机自启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span>systemctl daemon-reloadsystemctl restart <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><em><strong>对于master节点</strong></em></p><p><strong>配置master节点：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">hostname</span> k8s-master<span class="token function">wget</span> https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpgapt-key <span class="token function">add</span> apt-key.gpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装kubernetes：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> apt-transport-https <span class="token function">curl</span><span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token assign-left variable">kubelet</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 <span class="token assign-left variable">kubeadm</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 <span class="token assign-left variable">kubectl</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 --allow-unauthenticated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm config images list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/1.png"></p><p><strong>配置镜像：</strong></p><p>换国内源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.17<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.17 k8s.gcr.io/kube-apiserver:v1.17.17<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.17<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.17.17<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/kube-controller-manager:v1.17.17 k8s.gcr.io/kube-controller-manager:v1.17.17<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/kube-controller-manager:v1.17.17<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.17.17<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/kube-scheduler:v1.17.17 k8s.gcr.io/kube-scheduler:v1.17.17<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/kube-scheduler:v1.17.17<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-proxy:v1.17.17<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/kube-proxy:v1.17.17 k8s.gcr.io/kube-proxy:v1.17.17<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/kube-proxy:v1.17.17<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/pause:3.1<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/pause:3.1 k8s.gcr.io/pause:3.1<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/pause:3.1<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/etcd:3.4.3-0<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/etcd:3.4.3-0 k8s.gcr.io/etcd:3.4.3-0<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/etcd:3.4.3-0<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/coredns:1.6.5<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/coredns:1.6.5 k8s.gcr.io/coredns:1.6.5<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/coredns:1.6.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/2.png"></p><p><strong>初始化master节点：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm init --pod-network-cidr<span class="token operator">=</span><span class="token number">10.244</span>.0.0/16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/3.png"></p><p>保存图中node节点加入master集群的指令：</p><p>kubeadm&nbsp;join……</p><p>切换为普通用户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token environment constant">$HOME</span>/.kube<span class="token function">sudo</span> <span class="token function">cp</span> <span class="token parameter variable">-i</span> /etc/kubernetes/admin.conf <span class="token environment constant">$HOME</span>/.kube/config<span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> <span class="token parameter variable">-u</span><span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> <span class="token parameter variable">-g</span><span class="token variable">)</span></span> <span class="token environment constant">$HOME</span>/.kube/configkubectl get pods --all-namespaces<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/4.png"></p><p>如果coredns 处于pending状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get nodes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现master处于NotReady状态</p><p>需要部署pod network插件文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /usr/local/src/kube-flannel.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">node</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/5.png"></p><p><strong>配置node节点：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">hostname</span> node1<span class="token punctuation">(</span>node2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同上操作</p><p><strong>安装****kubernetes</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpgapt-key <span class="token function">add</span> apt-key.gpg<span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> apt-transport-https <span class="token function">curl</span><span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token assign-left variable">kubelet</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 <span class="token assign-left variable">kubeadm</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 <span class="token assign-left variable">kubectl</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 --allow-unauthenticated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>docker镜像换源</strong><br>……</p><p><strong>加入集群：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm <span class="token function">join</span> <span class="token number">192.168</span>.0.202:6443 <span class="token parameter variable">--token</span> 09hdi2.ogp6wujqwvhmrisk <span class="token punctuation">\</span> --discovery-token-ca-cert-hash sha256:1cffed7c52b078773c1f128ef3b7ecfd00efda14cf2c408a324cc492bf94f523<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>可能出现的问题</strong></p><p>&lt;1&gt;如果出现coredns网络异常，则可能需要部署网络插件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /usr/local/src/kube-flannel.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&lt;2&gt;如果出现</p><pre class="line-numbers language-none"><code class="language-none">Error in configuration:* unable to read client-cert /var/lib/kubelet/pki/kubelet-client-current.pem for default-auth due to open /var/lib/kubelet/pki/kubelet-client-current.pem: no such file or directory* unable to read client-key /var/lib/kubelet/pki/kubelet-client-current.pem for default-auth due to open /var/lib/kubelet/pki/kubelet-client-current.pem: no such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>则表示token过期，需要重新create及join</p><p>&lt;3&gt;如果出现</p><pre class="line-numbers language-none"><code class="language-none">error execution phase preflight: couldn't validate the identity of the API Server: Get "https://192.168.xxx.xx:6443/api/v1/namespaces/kube-public/configmaps/cluster-info?timeout=10s": net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)To see the stack trace of this error execute with --v=5 or higher<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>则可能是防火墙问题</p><p>&lt;4&gt;如果</p><pre class="line-numbers language-none"><code class="language-none">W0706 10:27:55.181115 &nbsp;&nbsp;22817 loader.go:221] Config not found: /etc/kubernetes/admin.confThe connection to the server localhost:8080 was refused - did you specify the right host or port?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>发现 Node 节点只有 kubelet.conf 配置项，而没有admin.conf</p><p>切换为普通用户</p><pre class="line-numbers language-none"><code class="language-none">mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/kubelet.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Node节点配置完成，在master节点上执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">node</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/6.png"></p><p>如果k8s-master的状态是NotReady,可能是hostname k8s-master错误，和主机命名不一致</p><h3 id="部署dashboard"><a href="#部署dashboard" class="headerlink" title="部署dashboard"></a>部署dashboard</h3><p>将配置文件create-admin.yaml和kubernetes-dashboard-v2.0.3.yml上传到master节点，执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> create-admin.yamlkubectl apply <span class="token parameter variable">-f</span> kubernetes-dashboard-v2.0.3.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get pod <span class="token parameter variable">-o</span> wide --all-namespaces<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/7.png"></p><p>登录dashboard面板</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/8.png"></p><p>获取token登录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl <span class="token parameter variable">-n</span> kubernetes-dashboard describe secret <span class="token variable"><span class="token variable">$(</span>kubectl <span class="token parameter variable">-n</span> kubernetes-dashboard get secret <span class="token operator">|</span> <span class="token function">grep</span> admin-user <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $1}'</span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/9.png"></p><h3 id="安装并部署Istio"><a href="#安装并部署Istio" class="headerlink" title="安装并部署Istio"></a>安装并部署Istio</h3><p>去<a href="https://github.com/istio/istio/releases">https://github.com/istio/istio/releases</a>下载安装包,下载安装包之后解压</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> xf istio-1.8.5-linux-amd64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-L</span> https://istio.io/downloadIstio <span class="token operator">|</span> <span class="token assign-left variable">ISTIO_VERSION</span><span class="token operator">=</span><span class="token number">1.8</span>.5 <span class="token assign-left variable">TARGET_ARCH</span><span class="token operator">=</span>x86_64 <span class="token function">sh</span> -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加到 path</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加以下内容</p><pre class="line-numbers language-none"><code class="language-none">export ISTIOCTL_HOME="/home/istio-1.8.5"export PATH="$ISTIOCTL_HOME/bin:$PATH"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行生效</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">istioctl version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/10.png"></p><p>部署 Istio Operator</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">istioctl operator init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/11.png"></p><p>init 命令创建了 istio-operator 命名空间，并部署了 CRD、Operator Deployment 以及 operator 工作所需的其他资源。</p><p>要安装 Istio，必须先创建 IstioOperator 资源，并指定要使用的配置文件。</p><p>创建目录istioyaml，用来专门存放yaml文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> istioyaml<span class="token builtin class-name">cd</span> istioyaml/<span class="token function">vim</span> istio-demo-profile.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>填入以下内容：</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1kind: Namespacemetadata:&nbsp;&nbsp;name: istio-system---apiVersion: install.istio.io/v1alpha1kind: IstioOperatormetadata:&nbsp;&nbsp;namespace: istio-system&nbsp;&nbsp;name: demo-istio-installspec:&nbsp;&nbsp;profile: demo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> istio-demo-profile.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看istio-system命名空间下的所有资源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get all <span class="token parameter variable">-o</span> wide <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/12.png"></p><p>为了检查安装的状态，查看 istio-system&nbsp;命名空间中的 Pod 的状态。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get pod <span class="token parameter variable">-o</span> wide <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/13.png"></p><p>Istio安装完成后，创建一个命名空间online-boutique，新的项目就部署在online-boutique命名空间下，给命名空间online-boutique设置上 istio-injection=enabled 标签，启用sidecar 自动注入。</p><p>创建命名空间online-boutique</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl create ns online-boutique<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>切换命名空间</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl config set-context <span class="token parameter variable">--current</span> <span class="token parameter variable">--namespace</span><span class="token operator">=</span>online-boutique<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>让命名空间online-boutique启用sidecar 自动注入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl label ns online-boutique istio-injection<span class="token operator">=</span>enabledkubectl get ns <span class="token parameter variable">-l</span> istio-injection --show-labels<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/14.png"></p><h3 id="部署-Online-Boutique-应用"><a href="#部署-Online-Boutique-应用" class="headerlink" title="部署 Online Boutique 应用"></a>部署 Online Boutique 应用</h3><p><strong>拉取项目</strong></p><p>创建online-boutique目录，项目放在该目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> online-boutique<span class="token builtin class-name">cd</span> online-boutique/<span class="token function">git</span> clone https://github.com/GoogleCloudPlatform/microservices-demo.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>配置镜像</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> microservices-demo/<span class="token builtin class-name">cd</span> release/<span class="token comment"># 查看需要下载的镜像</span><span class="token function">grep</span> image kubernetes-manifests.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/15.png"></p><p>镜像换源，换为国内</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/gcr.io/gcr.lank8s.cn/'</span> kubernetes-manifests.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>创建 Kubernetes 资源</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /home/online-boutique/microservices-demo/release/kubernetes-manifests.yaml <span class="token parameter variable">-n</span> online-boutique<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/16.png"></p><p>检查所有 Pod 都在运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get pod <span class="token parameter variable">-o</span> wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/17.png"></p><p><strong>创建 Istio 资源</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> ./istio-manifests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>获取访问地址</strong></p><p>部署了一切后，就可以得到入口网关的 IP 地址并打开前端服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">INGRESS_HOST</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span>kubectl <span class="token parameter variable">-n</span> istio-system get <span class="token function">service</span> istio-ingressgateway <span class="token parameter variable">-o</span> <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">'{.status.loadBalancer.ingress[0].ip}'</span><span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$INGRESS_HOST</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">service</span> <span class="token parameter variable">-n</span> istio-system istio-ingressgateway <span class="token parameter variable">-o</span> wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现 EXTERNAL-IP 为 pending</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl edit  <span class="token function">service</span> istio-ingressgateway <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加外部IP</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/18.png"></p><p>访问项目地址</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/19.png"></p><h3 id="Istio插件配置"><a href="#Istio插件配置" class="headerlink" title="Istio插件配置"></a>Istio插件配置</h3><h4 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h4><p>Prometheus 是一个开源的监控系统和时间序列数据库。Istio 使用 Prometheus 来记录指标，跟踪 Istio 和网格中的应用程序的健康状况。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/istio-1.8.5/samples/addons/<span class="token function">grep</span> image prometheus.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装prometheus需要用到两个镜像：</p><p>jimmidyson/configmap-reload:v0.4.0 和 prom/prometheus:v2.21.0</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/20.png"></p><p>在k8s的node节点拉取所需镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull jimmidyson/configmap-reload:v0.4.0<span class="token function">docker</span> pull prom/prometheus:v2.21.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/21.png"></p><p>安装prometheus</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /home/istio-1.8.5/samples/addons/prometheus.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/22.png"></p><p>查看部署状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get deploy <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/23.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">service</span> <span class="token parameter variable">-n</span> istio-system <span class="token parameter variable">-o</span> wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/24.png"></p><p>prometheus的service的类型为ClusterIP，外部环境访问不了</p><p>修改prometheus这个service的类型为NodePort，这样外部环境就可以访问prometheus了</p><p>把type: ClusterIP 修改为 type: NodePort即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl edit <span class="token function">service</span> prometheus <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/25.png"></p><p>之后可以根据ip加端口号访问该服务</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/26.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/27.png"></p><h4 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h4><p>Grafana 是一个用于分析和监控的开放平台。Grafana 可以连接到各种数据源，并使用图形、表格、热图等将数据可视化。通过强大的查询语言，你可以定制现有的仪表盘并创建更高级的可视化。</p><p>通过 Grafana，我们可以监控 Istio 安装和服务网格中运行的应用程序的健康状况。</p><p>我们可以使用 grafana.yaml 来部署带有预配置仪表盘的 Grafana 示例安装。该 YAML 文件在 Istio 安装包的 /samples/addons 下。</p><p>确保在部署 Grafana 之前部署 Promeheus 插件，因为 Grafana 使用 Prometheus 作为其数据源。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/istio-1.8.5/samples/addons<span class="token function">grep</span> image grafana.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/28.png"></p><p>在k8s的node节点拉取所需镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull grafana/grafana:7.2.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/29.png"></p><p>安装grafana</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /home/istio-1.8.5/samples/addons/grafana.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/30.png"></p><p>查看部署状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get pod <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/31.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">service</span> <span class="token parameter variable">-n</span> istio-system <span class="token parameter variable">-o</span> wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/32.png"></p><p>同上</p><p>可以看到grafana这个service的类型为ClusterIP，外部环境访问不了</p><p>修改grafana这个service的类型为NodePort，这样外部环境就可以访问grafana了</p><p>把type: ClusterIP 修改为 type: NodePort即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl edit <span class="token function">service</span> grafana <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后可以根据ip加端口号访问该服务</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/33.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/34.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/35.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/36.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/37.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/38.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/39.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/40.png"></p><h4 id="Kiali"><a href="#Kiali" class="headerlink" title="Kiali"></a>Kiali</h4><p>在kubernetes中为Istio配置Kiali，实现Istio服务网格的可视化，为Online Boutique项目提供服务拓扑图、全链路跟踪、指标遥测、配置校验、健康检查等功能。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/istio-1.8.5/samples/addons/kubectl apply <span class="token parameter variable">-f</span> kiali.yamlkubectl get pod <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/41.png"></p><p>同样需要把type: ClusterIP 修改为 type: NodePort</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/42.png"></p><h4 id="Jaeger"><a href="#Jaeger" class="headerlink" title="Jaeger"></a>Jaeger</h4><p>Jaeger 是Uber推出的一款开源分布式追踪系统，兼容OpenTracing API。分布式追踪系统用于记录请求范围内的信息，包括一次调用的服务链路以及每个服务的延时，能够帮助我们很好的分析微服务间链路调用的错误及瓶颈。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/istio-1.8.5/samples/addons/kubectl apply <span class="token parameter variable">-f</span> jaeger.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/43.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">service</span> <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/44.png"></p><p>同样需要把type: ClusterIP 修改为 type: NodePort</p><p>之后可以根据ip加端口号访问该服务</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/45.png"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]&nbsp;<a href="https://www.cnblogs.com/boshen-hzb/p/10679863.html">https://www.cnblogs.com/boshen-hzb/p/10679863.html</a>&nbsp;&nbsp;istio实现对外暴露服务</p><p>[2]&nbsp;<a href="https://www.cnblogs.com/fenjyang/p/14417494.html">https://www.cnblogs.com/fenjyang/p/14417494.html</a>&nbsp;K8S线上集群排查，实测排查Node节点NotReady异常状态</p><p>[3]&nbsp;<a href="https://www.cnblogs.com/renshengdezheli/p/16841875.html#32-kubernetes%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83">https://www.cnblogs.com/renshengdezheli/p/16841875.html#32-kubernetes%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83</a>&nbsp;Istio项目实际案例——Online Boutique</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;配置kubernetes集群环境&quot;&gt;&lt;a href=&quot;#配置kubernetes集群环境&quot; class=&quot;headerlink&quot; title=&quot;配置kubernetes集群环境&quot;&gt;&lt;/a&gt;配置kubernetes集群环境&lt;/h3&gt;&lt;p&gt;创建三台华为云服务器，一台做</summary>
      
    
    
    
    
    <category term="云计算" scheme="http://ailiaa.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="kubernetes" scheme="http://ailiaa.github.io/tags/kubernetes/"/>
    
    <category term="Istio" scheme="http://ailiaa.github.io/tags/Istio/"/>
    
    <category term="微服务" scheme="http://ailiaa.github.io/tags/%E5%BE%AE%E6%9C%8D%E5%8A%A1/"/>
    
  </entry>
  
  <entry>
    <title>Redis_高可用</title>
    <link href="http://ailiaa.github.io/2023/05/24/redis-gao-ke-yong/"/>
    <id>http://ailiaa.github.io/2023/05/24/redis-gao-ke-yong/</id>
    <published>2023-05-24T12:12:37.000Z</published>
    <updated>2023-05-24T12:58:36.547Z</updated>
    
    <content type="html"><![CDATA[<p>Redis 实现高可用有三种部署模式：<strong>主从模式，哨兵模式，集群模式</strong>。</p><h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>主从模式中，Redis部署了多台机器，有主节点，负责读写操作，有从节点，只负责读操作。从节点的数据来自主节点，实现原理就是<strong>主从复制机制</strong></p><p>主从复制包括全量复制，增量复制两种。一般当slave第一次启动连接master，或者认为是第一次连接，就采用<strong>全量复制</strong>，全量复制流程如下：</p><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/01.webp"></p><ul><li>  1.slave发送sync命令到master。</li><li>  2.master接收到SYNC命令后，执行bgsave命令，生成RDB全量文件。</li><li>  3.master使用缓冲区，记录RDB快照生成期间的所有写命令。</li><li>  4.master执行完bgsave后，向所有slave发送RDB快照文件。</li><li>  5.slave收到RDB快照文件后，载入、解析收到的快照。</li><li>  6.master使用缓冲区，记录RDB同步期间生成的所有写的命令。</li><li>  7.master快照发送完毕后，开始向slave发送缓冲区中的写命令;</li><li>  8.salve接受命令请求，并执行来自master缓冲区的写命令</li></ul><p>redis2.8版本之后，已经使用<strong>psync来替代sync</strong>，因为sync命令非常消耗系统资源，psync的效率更高。</p><p>slave与master全量同步之后，master上的数据，如果再次发生更新，就会触发<strong>增量复制</strong>。</p><p>当master节点发生数据增减时，就会触发<code>replicationFeedSalves()</code>函数，接下来在 Master节点上调用的每一个命令会使用<code>replicationFeedSlaves()</code>来同步到Slave节点。执行此函数之前呢，master节点会判断用户执行的命令是否有数据更新，如果有数据更新的话，并且slave节点不为空，就会执行此函数。这个函数作用就是：<strong>把用户执行的命令发送到所有的slave节点</strong>，让slave节点执行。流程如下：</p><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/02.webp"></p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>主从模式中，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址。显然，多数业务场景都不能接受这种故障处理方式。Redis从2.8开始正式提供了Redis Sentinel（哨兵）架构来解决这个问题。</p><p><strong>哨兵模式</strong>，由一个或多个Sentinel实例组成的Sentinel系统，它可以监视所有的Redis主节点和从节点，并在被监视的主节点进入下线状态时，<strong>自动将下线主服务器属下的某个从节点升级为新的主节点</strong>。但是呢，一个哨兵进程对Redis节点进行监控，就可能会出现问题（<strong>单点问题</strong>），因此，可以使用多个哨兵来进行监控Redis节点，并且各个哨兵之间还会进行监控。</p><p>简单来说，哨兵模式就三个作用：</p><ul><li>  发送命令，等待Redis服务器（包括主服务器和从服务器）返回监控其运行状态；</li><li>  哨兵监测到主节点宕机，会自动将从节点切换成主节点，然后通过发布订阅模式通知其他的从节点，修改配置文件，让它们切换主机；</li><li>  哨兵之间还会相互监控，从而达到高可用。</li></ul><p><strong>故障切换的过程是怎样的呢</strong></p><blockquote><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。</p></blockquote><p>哨兵的工作模式如下：</p><ol><li> 每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他Sentinel实例发送一个 PING命令。</li><li> 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel标记为主观下线。</li><li> 如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。</li><li> 当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线。</li><li> 在一般情况下， 每个 Sentinel 会以每10秒一次的频率向它已知的所有Master，Slave发送 INFO 命令。</li><li> 当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次</li><li> 若没有足够数量的 Sentinel同意Master已经下线， Master的客观下线状态就会被移除；若Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</li></ol><h3 id="Cluster集群模式"><a href="#Cluster集群模式" class="headerlink" title="Cluster集群模式"></a>Cluster集群模式</h3><p>哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。但是它每个节点存储的数据是一样的，浪费内存，并且不好在线扩容。 因此，Cluster集群应运而生，它在Redis3.0加入的，实现了Redis的<strong>分布式存储</strong>。对数据进行分片，也就是说<strong>每台Redis节点上存储不同的内容</strong>，来解决在线扩容的问题。并且，它也提供复制和故障转移的功能。</p><h4 id="Cluster集群节点的通讯"><a href="#Cluster集群节点的通讯" class="headerlink" title="Cluster集群节点的通讯"></a>Cluster集群节点的通讯</h4><p>一个Redis集群由多个节点组成，<strong>各个节点之间是怎么通信的呢</strong>？通过<strong>Gossip协议</strong>！</p><p>Redis Cluster集群通过Gossip协议进行通信，节点之前不断交换信息，交换的信息内容包括节点出现故障、新节点加入、主从节点变更信息、slot信息等等。常用的Gossip消息分为4种，分别是：ping、pong、meet、fail。</p><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/03.webp"></p><ul><li>  meet消息：通知新节点加入。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换。</li><li>  ping消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。</li><li>  pong消息：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新。</li><li>  fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。</li></ul><p>特别的，每个节点是通过<strong>集群总线(cluster bus)</strong> 与其他的节点进行通信的。通讯时，使用特殊的端口号，即对外服务端口号加10000。例如如果某个node的端口号是6379，那么它与其它nodes通信的端口号是 16379。nodes 之间的通信采用特殊的二进制协议。</p><h4 id="Hash-Slot插槽算法"><a href="#Hash-Slot插槽算法" class="headerlink" title="Hash Slot插槽算法"></a>Hash Slot插槽算法</h4><p>既然是分布式存储，Cluster集群使用的分布式算法是<strong>一致性Hash</strong>嘛？并不是，而是<strong>Hash Slot插槽算法</strong>。</p><p><strong>插槽算法</strong>把整个数据库被分为16384个slot（槽），每个进入Redis的键值对，根据key进行散列，分配到这16384插槽中的一个。使用的哈希映射也比较简单，用CRC16算法计算出一个16 位的值，再对16384取模。数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理这16384个槽。</p><p>集群中的每个节点负责一部分的hash槽，比如当前集群有A、B、C个节点，每个节点上的哈希槽数 =16384/3，那么就有：</p><ul><li>  节点A负责0~5460号哈希槽</li><li>  节点B负责5461~10922号哈希槽</li><li>  节点C负责10923~16383号哈希槽</li></ul><h4 id="Redis-Cluster集群"><a href="#Redis-Cluster集群" class="headerlink" title="Redis Cluster集群"></a>Redis Cluster集群</h4><p>Redis Cluster集群中，需要确保16384个槽对应的node都正常工作，如果某个node出现故障，它负责的slot也会失效，整个集群将不能工作。</p><p>因此为了保证高可用，Cluster集群引入了主从复制，一个主节点对应一个或者多个从节点。当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点宕机时，就会启用从节点。</p><p>虽然数据是分开存储在不同节点上的，但是对客户端来说，整个集群Cluster，被看做一个整体。客户端端连接任意一个node，看起来跟操作单实例的Redis一样。当客户端操作的key没有被分配到正确的node节点时，Redis会返回转向指令，最后指向正确的node，这就有点像浏览器页面的302 重定向跳转。</p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>Redis集群实现了高可用，当集群内节点出现故障时，通过<strong>故障转移</strong>，以保证集群正常对外提供服务。</p><p>redis集群通过ping/pong消息，实现故障发现。这个环境包括<strong>主观下线和客观下线</strong>。</p><p><strong>主观下线：</strong>&nbsp;某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况。</p><p><strong>客观下线：</strong> 指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移。</p><ul><li>  假如节点A标记节点B为主观下线，一段时间后，节点A通过消息把节点B的状态发到其它节点，当节点C接受到消息并解析出消息体时，如果发现节点B的pfail状态时，会触发客观下线流程；</li><li>  当下线为主节点时，此时Redis Cluster集群为统计持有槽的主节点投票，看投票数是否达到一半，当下线报告统计数大于一半时，被标记为<strong>客观下线</strong>状态。</li></ul><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/04.webp"></p><p><strong>故障恢复</strong>：故障发现后，如果下线节点的是主节点，则需要在它的从节点中选一个替换它，以保证集群的高可用。流程如下：</p><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/05.webp"></p><ul><li>  资格检查：检查从节点是否具备替换故障主节点的条件。</li><li>  准备选举时间：资格检查通过后，更新触发故障选举时间。</li><li>  发起选举：到了故障选举时间，进行选举。</li><li>  选举投票：只有持有槽的<strong>主节点</strong>才有票，从节点收集到足够的选票（大于一半），触发<strong>替换主节点操作</strong></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Redis 实现高可用有三种部署模式：&lt;strong&gt;主从模式，哨兵模式，集群模式&lt;/strong&gt;。&lt;/p&gt;
&lt;h3 id=&quot;主从模式&quot;&gt;&lt;a href=&quot;#主从模式&quot; class=&quot;headerlink&quot; title=&quot;主从模式&quot;&gt;&lt;/a&gt;主从模式&lt;/h3&gt;&lt;p&gt;主从模</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="NoSQL" scheme="http://ailiaa.github.io/tags/NoSQL/"/>
    
    <category term="redis" scheme="http://ailiaa.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Reids_分布式锁</title>
    <link href="http://ailiaa.github.io/2023/05/23/reids-fen-bu-shi-suo/"/>
    <id>http://ailiaa.github.io/2023/05/23/reids-fen-bu-shi-suo/</id>
    <published>2023-05-23T02:57:14.000Z</published>
    <updated>2023-05-24T13:40:20.918Z</updated>
    
    <content type="html"><![CDATA[<p>对于单机多线程来说，在 Java 中，我们通常使用 <code>ReetrantLock</code> 类、<code>synchronized</code> 关键字这类 JDK 自带的 <strong>本地锁</strong> 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。</p><p>分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，<strong>分布式锁</strong>&nbsp;就诞生了。</p><h3 id="基于-Redis-实现分布式锁"><a href="#基于-Redis-实现分布式锁" class="headerlink" title="基于 Redis 实现分布式锁"></a>基于 Redis 实现分布式锁</h3><h4 id="基于Redis实现一个最简易的分布式锁"><a href="#基于Redis实现一个最简易的分布式锁" class="headerlink" title="基于Redis实现一个最简易的分布式锁"></a>基于Redis实现一个最简易的分布式锁</h4><p>不论是本地锁还是分布式锁，核心都在于“互斥”。</p><p>在 Redis 中， <code>SETNX</code> 命令是可以帮助我们实现互斥。<code>SETNX</code> 即 <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists (对应 Java 中的 <code>setIfAbsent</code> 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， <code>SETNX</code> 啥也不做。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> SETNX lockKey uniqueValue<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">&gt;</span> SETNX lockKey uniqueValue<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>释放锁的话，直接通过 <code>DEL</code> 命令删除对应的 key 即可。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> DEL lockKey<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。</p><p>选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token operator">//</span> 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">then</span>    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"del"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。</p><h4 id="给锁设置一个过期时间"><a href="#给锁设置一个过期时间" class="headerlink" title="给锁设置一个过期时间"></a>给锁设置一个过期时间</h4><p>为了避免锁无法被释放，我们可以想到的一个解决办法就是：<strong>给这个 key（也就是锁） 设置一个过期时间</strong> 。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SET lockKey uniqueValue EX <span class="token number">3</span> NXOK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>  <strong>lockKey</strong>：加锁的锁名；</li><li>  <strong>uniqueValue</strong>：能够唯一标示锁的随机字符串；</li><li>  <strong>NX</strong>：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；</li><li>  <strong>EX</strong>：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。</li></ul><p><strong>一定要保证设置指定 key 的值和过期时间是一个原子操作！</strong> 不然的话，依然可能会出现锁无法被释放的问题。</p><p>这样确实可以解决问题，不过，这种解决办法同样存在漏洞：<strong>如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。</strong></p><h4 id="实现锁的续期"><a href="#实现锁的续期" class="headerlink" title="实现锁的续期"></a>实现锁的续期</h4><p>Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel、Redis Cluster 等多种部署架构。</p><p>Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。</p><p><img src="/images/image_redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/01.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//默认 30秒，支持修改</span><span class="token keyword">private</span> <span class="token keyword">long</span> lockWatchdogTimeout <span class="token operator">=</span> <span class="token number">30</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Config</span> <span class="token function">setLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token keyword">long</span> lockWatchdogTimeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>lockWatchdogTimeout <span class="token operator">=</span> lockWatchdogTimeout<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> lockWatchdogTimeout<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>renewExpiration()</code> 方法包含了看门狗的主要逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment">//......</span>        <span class="token class-name">Timeout</span> task <span class="token operator">=</span> commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newTimeout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Timeout</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>                <span class="token comment">//......</span>                <span class="token comment">// 异步续期，基于 Lua 脚本</span>                <span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token function">renewExpirationAsync</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                future<span class="token punctuation">.</span><span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">// 无法续期</span>                        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Can't update lock "</span> <span class="token operator">+</span> <span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" expiration"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">// 递归调用实现续期</span>                        <span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment">// 取消续期</span>                        <span class="token function">cancelExpirationRenewal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>         <span class="token comment">// 延迟 internalLockLeaseTime/3（默认 10s，也就是 30/3） 再调用</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> internalLockLeaseTime <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ee<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。</p><p>Watch Dog 通过调用 <code>renewExpirationAsync()</code> 方法实现锁的异步续期：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> <span class="token function">renewExpirationAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span><span class="token constant">EVAL_BOOLEAN</span><span class="token punctuation">,</span>            <span class="token comment">// 判断是否为持锁线程，如果是就执行续期操作，就锁的过期时间设置为 30s（默认）</span>            <span class="token string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                    <span class="token string">"return 1; "</span> <span class="token operator">+</span>                    <span class="token string">"end; "</span> <span class="token operator">+</span>                    <span class="token string">"return 0;"</span><span class="token punctuation">,</span>            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出， <code>renewExpirationAsync</code> 方法其实是调用 Lua 脚本实现的续期，这样做主要是为了保证续期操作的原子性。</p><p>我这里以 Redisson 的分布式可重入锁 <code>RLock</code> 为例来说明如何使用 Redisson 实现分布式锁：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 1.获取指定的分布式锁对象</span><span class="token class-name">RLock</span> lock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2.拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3.执行业务</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// 4.释放锁</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。</p><pre class="line-numbers language-none"><code class="language-none">// 手动给锁设置过期时间，不具备 Watch Dog 自动续期机制lock.lock(10, TimeUnit.SECONDS);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。</p><h4 id="实现可重入锁"><a href="#实现可重入锁" class="headerlink" title="实现可重入锁"></a>实现可重入锁</h4><p>所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 <code>synchronized</code> 和 <code>ReentrantLock</code> 都属于可重入锁。</p><p><strong>不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。</strong></p><p>可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。</p><p>实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 <strong>Redisson</strong> ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。</p><h4 id="分布式锁的可靠性"><a href="#分布式锁的可靠性" class="headerlink" title="分布式锁的可靠性"></a>分布式锁的可靠性</h4><p>为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。</p><p>Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p><p><img src="/images/image_redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/02.png"></p><p>Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。</p><p>即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。</p><p>Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。</p><p>如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 ZooKeeper 来做，只是性能会差一些。</p><h3 id="基于-ZooKeeper-实现分布式锁"><a href="#基于-ZooKeeper-实现分布式锁" class="headerlink" title="基于 ZooKeeper 实现分布式锁"></a>基于 ZooKeeper 实现分布式锁</h3><p>Redis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。实际项目中，我们应该根据业务的具体需求来选择</p><h4 id="基于-ZooKeeper-实现分布式锁-1"><a href="#基于-ZooKeeper-实现分布式锁-1" class="headerlink" title="基于 ZooKeeper 实现分布式锁"></a>基于 ZooKeeper 实现分布式锁</h4><p>ZooKeeper 分布式锁是基于 <strong>临时顺序节点</strong> 和 <strong>Watcher（事件监听器）</strong> 实现的。</p><p>获取锁：</p><ol><li> 首先我们要有一个持久节点<code>/locks</code>，客户端获取锁就是在<code>locks</code>下创建临时顺序节点。</li><li> 假设客户端 1 创建了<code>/locks/lock1</code>节点，创建成功之后，会判断 <code>lock1</code>是否是 <code>/locks</code> 下最小的子节点。</li><li> 如果 <code>lock1</code>是最小的子节点，则获取锁成功。否则，获取锁失败。</li><li> 如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如<code>/locks/lock0</code>上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。</li></ol><p>释放锁：</p><ol><li> 成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。</li><li> 成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。</li><li> 我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放</li></ol><p>实际项目中，推荐使用 Curator 来实现 ZooKeeper 分布式锁。Curator 是 Netflix 公司开源的一套 ZooKeeper Java 客户端框架，相比于 ZooKeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。</p><p><code>Curator</code>主要实现了下面四种锁：</p><ul><li>  <code>InterProcessMutex</code>：分布式可重入排它锁</li><li>  <code>InterProcessSemaphoreMutex</code>：分布式不可重入排它锁</li><li>  <code>InterProcessReadWriteLock</code>：分布式读写锁</li><li>  <code>InterProcessMultiLock</code>：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CuratorFramework</span> client <span class="token operator">=</span> <span class="token class-name">ZKUtils</span><span class="token punctuation">.</span><span class="token function">getClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>client<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 分布式可重入排它锁</span><span class="token class-name">InterProcessLock</span> lock1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessMutex</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> lockPath1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 分布式不可重入排它锁</span><span class="token class-name">InterProcessLock</span> lock2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessSemaphoreMutex</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> lockPath2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将多个锁作为一个整体</span><span class="token class-name">InterProcessMultiLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessMultiLock</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>lock1<span class="token punctuation">,</span> lock2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lock<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"不能获取多锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已获取多锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第一个锁: "</span> <span class="token operator">+</span> lock1<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第二个锁: "</span> <span class="token operator">+</span> lock2<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// 资源操作</span>    resource<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"释放多个锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第一个锁: "</span> <span class="token operator">+</span> lock1<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第二个锁: "</span> <span class="token operator">+</span> lock2<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="临时顺序节点"><a href="#临时顺序节点" class="headerlink" title="临时顺序节点"></a>临时顺序节点</h4><p>每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。</p><p>我们通常是将 znode 分为 4 大类：</p><ul><li>  <strong>持久（PERSISTENT）节点</strong>：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li><li>  <strong>临时（EPHEMERAL）节点</strong>：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，<strong>临时节点只能做叶子节点</strong> ，不能创建子节点。</li><li>  <strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong>：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 <code>/node1/app0000000001</code>、<code>/node1/app0000000002</code> 。</li><li>  <strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong>：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li></ul><p>可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。</p><p>使用 Redis 实现分布式锁的时候，我们是通过过期时间来避免锁无法被释放导致死锁问题的，而 ZooKeeper 直接利用临时节点的特性即可。</p><p>假设不适用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。</p><h4 id="设置对前一个节点的监听"><a href="#设置对前一个节点的监听" class="headerlink" title="设置对前一个节点的监听"></a>设置对前一个节点的监听</h4><blockquote><p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p></blockquote><p>同一时间段内，可能会有很多客户端同时获取锁，但只有一个可以获取成功。如果获取锁失败，则说明有其他的客户端已经成功获取锁。获取锁失败的客户端并不会不停地循环去尝试加锁，而是在前一个节点注册一个事件监听器。</p><p>这个事件监听器的作用是：<strong>当前一个节点对应的客户端释放锁之后（也就是前一个节点被删除之后，监听的是删除事件），通知获取锁失败的客户端（唤醒等待的线程，Java 中的 <code>wait/notifyAll</code> ），让它尝试去获取锁，然后就成功获取锁了。</strong></p><h4 id="实现可重入锁-1"><a href="#实现可重入锁-1" class="headerlink" title="实现可重入锁"></a>实现可重入锁</h4><p>这里以 Curator 的 <code>InterProcessMutex</code> 对可重入锁的实现来介绍</p><p>当我们调用 <code>InterProcessMutex#acquire</code>方法获取锁的时候，会调用<code>InterProcessMutex#internalLock</code>方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 获取可重入互斥锁，直到获取成功为止</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">internalLock</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOException</span><span class="token punctuation">(</span><span class="token string">"Lost connection while trying to acquire lock: "</span> <span class="token operator">+</span> basePath<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>internalLock</code> 方法会先获取当前请求锁的线程，然后从 <code>threadData</code>( <code>ConcurrentMap&lt;Thread, LockData&gt;</code> 类型)中获取当前线程对应的 <code>lockData</code> 。 <code>lockData</code> 包含锁的信息和加锁的次数，是实现可重入锁的关键。</p><p>第一次获取锁的时候，<code>lockData</code>为 <code>null</code>。获取锁成功之后，会将当前线程和对应的 <code>lockData</code> 放到 <code>threadData</code> 中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">internalLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>  <span class="token comment">// 获取当前请求锁的线程</span>  <span class="token class-name">Thread</span> currentThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 拿对应的 lockData</span>  <span class="token class-name">LockData</span> lockData <span class="token operator">=</span> threadData<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第一次获取锁的话，lockData 为 null</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lockData <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 当前线程获取过一次锁之后</span>    <span class="token comment">// 因为当前线程的锁存在， lockCount 自增后返回，实现锁重入.</span>    lockData<span class="token punctuation">.</span>lockCount<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">// 尝试获取锁</span>  <span class="token class-name">String</span> lockPath <span class="token operator">=</span> internals<span class="token punctuation">.</span><span class="token function">attemptLock</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> <span class="token function">getLockNodeBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lockPath <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">LockData</span> newLockData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LockData</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">,</span> lockPath<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 获取锁成功之后，将当前线程和对应的 lockData 放到 threadData 中</span>    threadData<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">,</span> newLockData<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>LockData</code>是 <code>InterProcessMutex</code>中的一个静态内部类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ConcurrentMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">,</span> <span class="token class-name">LockData</span><span class="token punctuation">&gt;</span></span> threadData <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newConcurrentMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LockData</span><span class="token punctuation">{</span>    <span class="token comment">// 当前持有锁的线程</span>    <span class="token keyword">final</span> <span class="token class-name">Thread</span> owningThread<span class="token punctuation">;</span>    <span class="token comment">// 锁对应的子节点</span>    <span class="token keyword">final</span> <span class="token class-name">String</span> lockPath<span class="token punctuation">;</span>    <span class="token comment">// 加锁的次数</span>    <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> lockCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">LockData</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> owningThread<span class="token punctuation">,</span> <span class="token class-name">String</span> lockPath<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>owningThread <span class="token operator">=</span> owningThread<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>lockPath <span class="token operator">=</span> lockPath<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果已经获取过一次锁，后面再来获取锁的话，直接就会在 <code>if (lockData != null)</code> 这里被拦下了，然后就会执行<code>lockData.lockCount.incrementAndGet();</code> 将加锁次数加 1。</p><p>整个可重入锁的实现逻辑非常简单，直接在客户端判断当前线程有没有获取锁，有的话直接将加锁次数加 1 就可以了。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;对于单机多线程来说，在 Java 中，我们通常使用 &lt;code&gt;ReetrantLock&lt;/code&gt; 类、&lt;code&gt;synchronized&lt;/code&gt; 关键字这类 JDK 自带的 &lt;strong&gt;本地锁&lt;/strong&gt; 来控制一个 JVM 进程内的多个线程对本地共</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="NoSQL" scheme="http://ailiaa.github.io/tags/NoSQL/"/>
    
    <category term="redis" scheme="http://ailiaa.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>华为云大数据集群搭建</title>
    <link href="http://ailiaa.github.io/2023/05/17/hua-wei-yun-da-shu-ju-ji-qun-da-jian/"/>
    <id>http://ailiaa.github.io/2023/05/17/hua-wei-yun-da-shu-ju-ji-qun-da-jian/</id>
    <published>2023-05-17T06:46:24.000Z</published>
    <updated>2023-05-17T07:11:24.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="华为云环境搭建"><a href="#华为云环境搭建" class="headerlink" title="华为云环境搭建"></a>华为云环境搭建</h3><h4 id="华为云ECS"><a href="#华为云ECS" class="headerlink" title="华为云ECS"></a>华为云ECS</h4><p>ECS购买需遵循以下规格：</p><ul><li>计费模式：按需计费</li><li>可用区：可用区一</li><li>CPU架构：x86</li><li>规格： 2vcpus|8GB</li><li>系统：CentOS7.6</li><li>系统盘：超高IO、100GB。</li><li>网络：按流量计费</li><li>其他配置：默认</li></ul><p>完成基础配置，网络配置，高级配置。购买4台ECS</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%871.png">&nbsp;</p><h4 id="对象存储服务OBS"><a href="#对象存储服务OBS" class="headerlink" title="对象存储服务OBS"></a>对象存储服务OBS</h4><p>区域选择与ECS相同。其他配置默认</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%872.png"></p><h4 id="创建并行文件系统"><a href="#创建并行文件系统" class="headerlink" title="创建并行文件系统"></a>创建并行文件系统</h4><p>配置默认</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%873.png"></p><p>进入创建的OBS桶，记录参数endpoint</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%874.png"></p><h4 id="获取AK-SK"><a href="#获取AK-SK" class="headerlink" title="获取AK/SK"></a>获取AK/SK</h4><p>华为云页面右上角“用户名”，下拉选择“我的凭证”，点击“访问秘钥”。新增访问秘钥，根据提示进行操作，得到文件“credentials.csv”，打开即可得到AK/SK</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%875.png"></p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%876.png"></p><h3 id="Hadoop集群搭建"><a href="#Hadoop集群搭建" class="headerlink" title="Hadoop集群搭建"></a>Hadoop集群搭建</h3><p>通过搭建开源Hadoop集群，掌握Hadoop搭建方法。并且使开源Hadoop与华为云OBS服务互联，使Hadoop集群可读取OBS数据。</p><h4 id="配置ECS"><a href="#配置ECS" class="headerlink" title="配置ECS"></a>配置ECS</h4><p>登录三个节点服务器<br>下载hadoop安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">wget</span> https://bigdata-tools-hw.obs.cn-north-1.myhuaweicloud.com/hadoop-2.8.3.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下载OBSFileSystem相关jar包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">wget</span> https://bigdata-tools-hw.obs.cn-north-1.myhuaweicloud.com/hadoop-huaweicloud-2.8.3-hw-39.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%877.png"></p><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><p>下载并拷贝jdk8至/usr/local/java，并解压缩</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/<span class="token function">mkdir</span> <span class="token function">java</span><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> jdk-8u351-linux-x64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置环境变量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按“i”进入编辑模式，使用hjkl键或方向键移动光标，在文件最后添加以下代码：</p><pre class="line-numbers language-none"><code class="language-none">JAVA_HOME=/usr/local/java/jdk1.8******export PATH=$PATH:$JAVA_HOME/binexport JAVA_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>按“Esc”退出编辑模式，输入“:wq”并按回车，保存退出。</p><p>执行以下命令，使新增配置生效。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，验证jdk安装并配置成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> –version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%878.png"></p><h4 id="配置hosts文件"><a href="#配置hosts文件" class="headerlink" title="配置hosts文件"></a>配置hosts文件</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加</p><pre class="line-numbers language-none"><code class="language-none">192.168.0.46&nbsp;node-0001192.168.0.123&nbsp;node-0002192.168.0.148&nbsp;node-0003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="配置节点互信"><a href="#配置节点互信" class="headerlink" title="配置节点互信"></a>配置节点互信</h4><p>各节点执行以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%879.png"></p><p>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /root/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8710.png"></p><p>复制该命令在各节点的输出内容。</p><p>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /root/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入各节点的复制内容，保存退出。</p><p>各节点执行：ssh node-0001~node-0003，选择yes后，确保能够无密码跳转到目标节点</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8711.png"></p><h4 id="搭建Hadoop集群"><a href="#搭建Hadoop集群" class="headerlink" title="搭建Hadoop集群"></a>搭建Hadoop集群</h4><p>创建目录<br>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /home/modules/data/buf<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /home/nm/localdir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>登录node-0001节点，解压hadoop安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">cp</span> hadoop-2.8.3.tar.gz /home/modules/<span class="token builtin class-name">cd</span> /home/modules/<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> hadoop-2.8.3.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置hadoop core-site.xml配置文件<br>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/core-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数配置：</p><pre class="line-numbers language-none"><code class="language-none">&lt;configuration&gt;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.readahead.inputstream.enabled&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;true&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.buffer.max.range&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;6291456&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.buffer.part.size&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;2097152&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.threads.read.core&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;500&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.threads.read.max&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;1000&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.write.buffer.size&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;8192&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.read.buffer.size&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;8192&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.connection.maximum&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;1000&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.defaultFS&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;hdfs://node-0001:8020&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;/home/modules/hadoop-2.8.3/tmp&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.access.key&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;FOR20CBUDGPBNEZDADQE&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.secret.key&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;5TZnFhulDt04EG1lfMzgdYCi8OMg6HwasWEcGBkO&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.endpoint&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;obs.cn-north-4.myhuaweicloud.com:5080&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.buffer.dir&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;/home/modules/data/buf&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.impl&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;org.apache.hadoop.fs.obs.OBSFileSystem&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.connection.ssl.enabled&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;false&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.fast.upload&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;true&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.socket.send.buffer&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;65536&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.socket.recv.buffer&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;65536&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.max.total.tasks&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;20&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.threads.max&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;20&lt;/value&gt;&nbsp;&lt;/property&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：fs.obs.access.key、fs.obs.secret.key、fs.obs.endpoint、fs.defaultFS需根据实际情况修改</p><p>配置hdfs-site.xml</p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/hdfs-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数配置如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;configuration&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.replication&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;3&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;node-0001:50090&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.namenode.secondary.https-address&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;node-0001:50091&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&nbsp;&lt;property&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;file:/home/modules/hadoop-2.8.3/data/namenode&lt;/value&gt;  &nbsp;&lt;/property&gt;  &nbsp;&lt;property&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;file:/home/modules/hadoop-2.8.3/data/datanode&lt;/value&gt;  &nbsp;&lt;/property&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：主机名node-0001需要根据实际替换。</p><p><strong>配置yarn-site.xml</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/yarn-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数配置如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;configuration&gt;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.local-dirs&lt;/name&gt;&lt;value&gt;/home/nm/localdir&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;28672&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;3072&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;28672&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.resource.cpu-vcores&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;38&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.scheduler.maximum-allocation-vcores&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;38&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;mapreduce_shuffle&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;node-0001&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;true&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;106800&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;false&lt;/value&gt;&nbsp;&nbsp;&nbsp;&lt;description&gt;Whether virtual memory limits will be enforced for containers&lt;/description&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;4&lt;/value&gt;&nbsp;&nbsp;&nbsp;&lt;description&gt;Ratio between virtual memory to physical memory when setting memory limits for containers&lt;/description&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.resourcemanager.scheduler.class&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairScheduler&lt;/value&gt;&nbsp;&nbsp;&lt;/property&gt;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.log.server.url&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;http://node-0001:19888/jobhistory/logs&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：主机名node-0001需要根据实际情况修改。</p><p><strong>配置mapred-site.xml</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/modules/hadoop-2.8.3/etc/hadoop/<span class="token function">mv</span> mapred-site.xml.template mapred-site.xml<span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/mapred-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参数配置如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;configuration&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;mapreduce.framework.name&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;yarn&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;node-0001:10020&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;node-0001:19888&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;mapred.task.timeout&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;1800000&lt;/value&gt;&nbsp;&lt;/property&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：主机名node-0001需要根据实际情况修改。</p><p><strong>配置slaves</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/slaves<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除原有内容，添加内容如下：</p><pre class="line-numbers language-none"><code class="language-none">node-0002node-0003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>配置hadoop环境变量</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/hadoop-env.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加如下内容：</p><pre class="line-numbers language-none"><code class="language-none">export JAVA_HOME=/usr/local/java/jdk1.8.0_351<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>配置jar包</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">cp</span> hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/hadoop-2.8.3/share/hadoop/common/lib/<span class="token function">cp</span> hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/hadoop-2.8.3/share/hadoop/tools/lib<span class="token function">cp</span> hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/hadoop-2.8.3/share/hadoop/httpfs/tomcat/webapps/webhdfs/WEB-INF/lib/<span class="token function">cp</span> hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/hadoop-2.8.3/share/hadoop/hdfs/lib/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分发hadoop包到各节点</strong></p><p>node-0001下执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 分发hadoop包到node2</span><span class="token function">scp</span> <span class="token parameter variable">-r</span> /home/modules/hadoop-2.8.3/ root@node-0002:/home/modules/<span class="token comment"># 分发hadoop包到node3</span><span class="token function">scp</span> <span class="token parameter variable">-r</span> /home/modules/hadoop-2.8.3/ root@node-0003:/home/modules/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>配置环境变量</strong></p><p>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在文件尾部添加如下内容：</p><pre class="line-numbers language-none"><code class="language-none">export HADOOP_HOME=/home/modules/hadoop-2.8.3export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATHexport HADOOP_CLASSPATH=/home/modules/hadoop-2.8.3/share/hadoop/tools/lib/*:$HADOOP_CLASSPATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>namenode初始化</strong><br>node-0001节点执行namenode初始化<br>执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hdfs namenode <span class="token parameter variable">-format</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化成功后，启动hdfs。<br>node-0001节点执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">start-all.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行hdfs命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hdfs dfs <span class="token parameter variable">-mkdir</span> /bigdata<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看集群部署报告</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hdfs dfsadmin <span class="token parameter variable">-report</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8712.png"></p><p>主要原因是 每台机器的/etc/hosts 错误</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1 localhost127.0.1.1 node-000*192.168.x.x node-0001192.168.x.x node-0002192.168.x.x node-0003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把127.0.1.1 node-000*这一行删掉</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8713.png"></p><p>停止HDFS<br>node-0001节点执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stop-all.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>测试Hadoop与OBS互联</strong></p><p>进入OBS桶，选择“对象”上传文件</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8714.png"></p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8715.png"></p><p>执行hdfs命令查看OBS文件 hadoop-bigdata&nbsp;是obs的命名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hdfs dfs <span class="token parameter variable">-ls</span> obs://hadoop-dataserver/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8716.png"></p><p>测试能否跑任务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hadoop jar /home/modules/hadoop-2.8.3/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.3.jar pi <span class="token number">100</span> <span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8717.png"></p><p>Hadooop集群搭建成功，hadooop成功与OBS互联，并且能跑通任务</p><h3 id="搭建Spark集群"><a href="#搭建Spark集群" class="headerlink" title="搭建Spark集群"></a>搭建Spark集群</h3><p>安装Spark集群，并使Spark能够读取OBS数据，使Spark集群能够实现存算分离，提高计算性能。</p><h4 id="搭建Spark集群-1"><a href="#搭建Spark集群-1" class="headerlink" title="搭建Spark集群"></a>搭建Spark集群</h4><p>获取spark安装包<br>node-0001节点下载Spark安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">wget</span> https://bigdata-tools-hw.obs.cn-north-1.myhuaweicloud.com/spark-2.3.0-bin-without-hadoop.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解压spark安装包"><a href="#解压spark安装包" class="headerlink" title="解压spark安装包"></a>解压spark安装包</h4><p>node-0001节点执行下列命令：</p><p>复制安装包到/home/modules目录下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> /root/spark-2.3.0-bin-without-hadoop.tgz /home/modules<span class="token builtin class-name">cd</span> /home/modules<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>解压安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> spark-2.3.0-bin-without-hadoop.tgz<span class="token function">mv</span> spark-2.3.0-bin-without-hadoop spark-2.3.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="配置spark-jar包"><a href="#配置spark-jar包" class="headerlink" title="配置spark jar包"></a>配置spark jar包</h4><p>在node-0001节点，复制jar包到spark/jar下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> /root/hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/spark-2.3.0/jars/<span class="token function">cp</span> /home/modules/hadoop-2.8.3/share/hadoop/common/lib/snappy-java-1.0.4.1.jar /home/modules/spark-2.3.0/jars/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="配置spark配置文件"><a href="#配置spark配置文件" class="headerlink" title="配置spark配置文件"></a>配置spark配置文件</h4><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/modules/spark-2.3.0/conf/<span class="token function">mv</span> spark-env.sh.template spark-env.sh<span class="token function">vim</span> spark-env.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>文件末尾添加如下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/usr/local/java/jdk1.8.0_351<span class="token builtin class-name">export</span> <span class="token assign-left variable">SCALA_HOME</span><span class="token operator">=</span>/home/modules/spark-2.3.0/examples/src/main/scala<span class="token builtin class-name">export</span> <span class="token assign-left variable">HADOOP_HOME</span><span class="token operator">=</span>/home/modules/hadoop-2.8.3<span class="token builtin class-name">export</span> <span class="token assign-left variable">HADOOP_CONF_DIR</span><span class="token operator">=</span>/home/modules/hadoop-2.8.3/etc/hadoop<span class="token builtin class-name">export</span> <span class="token assign-left variable">SPARK_HOME</span><span class="token operator">=</span>/home/modules/spark-2.3.0<span class="token builtin class-name">export</span> <span class="token assign-left variable">SPARK_DIST_CLASSPATH</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>/home/modules/hadoop-2.8.3/bin/hadoop classpath<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分发Spark"><a href="#分发Spark" class="headerlink" title="分发Spark"></a>分发Spark</h4><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> <span class="token parameter variable">-r</span> /home/modules/spark-2.3.0/ root@node-0002:/home/modules/<span class="token function">scp</span> <span class="token parameter variable">-r</span> /home/modules/spark-2.3.0/ root@node-0003:/home/modules/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加如下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">SPARK_HOME</span><span class="token operator">=</span>/home/modules/spark-2.3.0<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token variable">${SPARK_HOME}</span>/bin:<span class="token variable">${SPARK_HOME}</span>/sbin:<span class="token environment constant">$PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>各节点执行如下命令，使环境变量生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="验证存算分离"><a href="#验证存算分离" class="headerlink" title="验证存算分离"></a>验证存算分离</h4><p>查看要计算的文件</p><p>本次实验验证Spark与OBS实现存算分离，使用上传的playerinfo.txt文件。</p><p>数据如下：</p><pre class="line-numbers language-none"><code class="language-none">Alex James Lax GenuKerry Mary Olivia WilliamHale Edith Vera RobertMary Olivia James LaxEdith Vera Robertm Genu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计算上述数据的wordcount<br>启动yarn</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">start-yarn.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：前面如果使用的是start-all.sh，此命令可以省略</p><p>启动pyspark</p><p>在node-0001节点下执行以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pyspark<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8718.png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">lines <span class="token operator">=</span> spark<span class="token punctuation">.</span>read<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token string">"obs://hadoop-bigdata/playerinfo.txt"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rdd<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> r<span class="token punctuation">:</span> r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>counts <span class="token operator">=</span> lines<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reduceByKey<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span>output <span class="token operator">=</span> counts<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span>word<span class="token punctuation">,</span> count<span class="token punctuation">)</span> <span class="token keyword">in</span> output<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s: %i"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>word<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者使用以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$SPARK_HOME</span>/bin/run-example org.apache.spark.examples.JavaWordCount obs://hadoop-dataserver/playerinfo.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8719.png"></p><p>成功安装Spark集群，并使Spark能够读取OBS数据，使Spark集群能够实现存算分离，提高计算性能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;华为云环境搭建&quot;&gt;&lt;a href=&quot;#华为云环境搭建&quot; class=&quot;headerlink&quot; title=&quot;华为云环境搭建&quot;&gt;&lt;/a&gt;华为云环境搭建&lt;/h3&gt;&lt;h4 id=&quot;华为云ECS&quot;&gt;&lt;a href=&quot;#华为云ECS&quot; class=&quot;headerlink&quot; </summary>
      
    
    
    
    
    <category term="云计算" scheme="http://ailiaa.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="hadoop" scheme="http://ailiaa.github.io/tags/hadoop/"/>
    
    <category term="spark" scheme="http://ailiaa.github.io/tags/spark/"/>
    
  </entry>
  
  <entry>
    <title>华为云平台应用高可用部署</title>
    <link href="http://ailiaa.github.io/2023/04/25/hua-wei-yun-ping-tai-ying-yong-gao-ke-yong-bu-shu/"/>
    <id>http://ailiaa.github.io/2023/04/25/hua-wei-yun-ping-tai-ying-yong-gao-ke-yong-bu-shu/</id>
    <published>2023-04-25T07:37:20.000Z</published>
    <updated>2023-04-25T08:09:03.949Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过使用华为云弹性负载均衡ELB和弹性伸缩AS服务，实现华为云平台OA系统应用的高可用部署。</p></blockquote><h3 id="配置应用开机启动"><a href="#配置应用开机启动" class="headerlink" title="配置应用开机启动"></a>配置应用开机启动</h3><p><strong>获取启动脚本</strong></p><p>执行以下命令，下载启动脚本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># cd /home/</span><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># wget https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/autostart.sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行以下命令，打开脚本文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># vim autostart.sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，修改脚本代码。</p><p>修改JAVA_HOME为当前操作系统Java虚拟机的目录。</p><pre class="line-numbers language-none"><code class="language-none">/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.oe1.aarch64/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改app为当前OA系统jar包地址。</p><pre class="line-numbers language-none"><code class="language-none">/home/oasys_mysql/target/oasys.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，为脚本添加可执行权限。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># chmod +x autostart.sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>自定义开机启动命令</strong></p><p>执行以下命令，进入系统目录，下载服务脚本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># cd /etc/systemd/system/</span><span class="token punctuation">[</span>root@ecs-oa system<span class="token punctuation">]</span><span class="token comment"># wget [https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/oa-service.service](https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/oa-service.service)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行以下命令，为脚本添加可执行权限。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa system<span class="token punctuation">]</span><span class="token comment"># chmod +x oa-service.service</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，添加开机启动服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> oa-service.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8736.png"></p><p><strong>验证开机启动</strong></p><p>重启名为ecs-oa的云服务器。等待1-2分钟，通过ecs-oa弹性公网IP地址加8088端口访问OA系统登录页，如<a href="http://123.60.210.240:8088/%E3%80%82%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E5%90%8D%E2%80%9Csoli%E2%80%9D%E5%92%8C%E5%AF%86%E7%A0%81%E2%80%9C123456%E2%80%9D%E7%99%BB%E5%BD%95%E8%BF%9B%E5%85%A5OA%E7%B3%BB%E7%BB%9F%E4%B8%BB%E7%95%8C%E9%9D%A2%E3%80%82">http://123.60.210.240:8088/。使用用户名“soli”和密码“123456”登录进入OA系统主界面。</a></p><p>配置自启动后，根据弹性伸缩策略分发服务器的时候才能访问到项目（之后会构建这个oa服务器的镜像，供弹性负载均衡服务器运行）</p><h3 id="配置弹性负载均衡"><a href="#配置弹性负载均衡" class="headerlink" title="配置弹性负载均衡"></a>配置弹性负载均衡</h3><h4 id="购买华为云ELB弹性负载均衡"><a href="#购买华为云ELB弹性负载均衡" class="headerlink" title="购买华为云ELB弹性负载均衡"></a>购买华为云ELB弹性负载均衡</h4><p>进入华为云控制台操作页面。选择区域“北京四”，单击“服务列表”，选择“网络 弹性负载均衡ELB”，进入弹性负载均衡列表页面。页面右上角的“购买弹性负载均衡”。</p><p>选择与ecs-oa相同的“所属VPC”和“网络”，选择“按流量计费”，输入名称“elb-oa”，点击右下角“立即购买”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8737.png"></p><h4 id="配置监听器"><a href="#配置监听器" class="headerlink" title="配置监听器"></a>配置监听器</h4><p>在负载均衡器列表中，点击“点我开始配置”。在“监听器”标签中，点击“添加监听器”。默认配置，点击“下一步”。修改名称为“server_group-kunpeng”，点击“完成”。点击“现在添加”。在“后端服务器组”标签中，点击“添加”。选择名为“ecs-oa”的云服务器，点击“下一步”。添加端口输入“8088”，点击“完成”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8738.png"></p><p>等待约30秒之后，点击“刷新”按钮，ecs-oa健康检查结果显示“正常”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8739.png"></p><p>返回负载均衡器列表，记录“elb-oa”的弹性公网IP，使用该IP地址直接访问OA系统登录页，如<a href="http://http//http://123.249.75.243/%E3%80%82%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E5%90%8D%E2%80%9Csoli%E2%80%9D%E5%92%8C%E5%AF%86%E7%A0%81%E2%80%9C123456%E2%80%9D%E7%99%BB%E5%BD%95%E8%BF%9B%E5%85%A5OA%E7%B3%BB%E7%BB%9F%E4%B8%BB%E7%95%8C%E9%9D%A2%E3%80%82">http://http://http://123.249.75.243/。使用用户名“soli”和密码“123456”登录进入OA系统主界面。</a></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8740.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8741.png"></p><h3 id="配置弹性伸缩"><a href="#配置弹性伸缩" class="headerlink" title="配置弹性伸缩"></a>配置弹性伸缩</h3><h4 id="创建华为云云服务器镜像"><a href="#创建华为云云服务器镜像" class="headerlink" title="创建华为云云服务器镜像"></a>创建华为云云服务器镜像</h4><p>返回弹性云服务器列表，点击“更多 -&gt; 镜像/磁盘 -&gt; 创建镜像”。选择名为“ecs-oa”的云服务器，操作系统centos。名称“img-oa-kunpeng”，点击“立即创建”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8742.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8743.png"></p><h4 id="购买华为云AS弹性伸缩服务"><a href="#购买华为云AS弹性伸缩服务" class="headerlink" title="购买华为云AS弹性伸缩服务"></a>购买华为云AS弹性伸缩服务</h4><p>进入华为云控制台操作页面。选择区域“北京四”，单击“服务列表”，选择“弹性伸缩AS”，进入弹性伸缩列表页面。页面右上方，点击“创建弹性伸缩组”。输入名称“as-group-oa-kunpeng”，最大、期望、最小实例数分别为3、2和1台。点击加号按钮，增加伸缩配置。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8744.png"></p><h4 id="创建伸缩配置"><a href="#创建伸缩配置" class="headerlink" title="创建伸缩配置"></a>创建伸缩配置</h4><p>点击“创建伸缩配置”。输入名称为“as-config-oa-kunpeng”。选择配置为CPU架构“X86计算”，规格“华为云计算，华为云通用计算增强型，kc1.large.2 2vCPUs | 4GB”。</p><p>在“私有镜像”标签内，选择名为“img-oa-kunpeng”的私有镜像，安全组选择“sg-FullAccess”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8745.png"></p><p>返回伸缩配置列表，显示名为“as-config-oa-kunpeng”的伸缩配置</p><p>确认使用和ecs-oa同样的虚拟私有云和子网，负载均衡选择“使用弹性负载均衡”，负载均衡器选择“elb-oa”，后端服务器组选择“server_group-kunpeng”，后端端口填写“8088”，点击“立即创建”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8746.png"></p><h4 id="添加弹性策略"><a href="#添加弹性策略" class="headerlink" title="添加弹性策略"></a>添加弹性策略</h4><p>点击“添加伸缩策略”，在伸缩策略页面，点击“添加伸缩策略”。将伸缩策略命名为“as-policy-oa-kunpeng”，使用“告警策略”，设置触发条件为“CPU使用率最大值&gt;50%”，连续出现次数填写“3”，点击“确定”。</p><p>点击“概览”标签，显示当前实例数为2台，即设置的“期望实例数”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8747.png"></p><p>返回弹性云服务器列表，点击刷新按钮，显示通过AS创建的华为云实例。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8748.png"></p><p>进入弹性负载均衡器“elb-oa”的后端服务器组”标签，显示这两台华为云实例已加入。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8749.png"></p><p>返回伸缩实例as-group-oa-kunpeng的“伸缩策略”页面，点击“立即执行”，在对话框中点击“是”。在“概览”页面、云服务器列表和弹性负载均衡后端服务器组中都可显示新创建的华为云实例。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8750.png"></p><p>返回负载均衡器列表，记录“elb-oa”的弹性公网IP，使用该IP地址直接访问OA系统登录页，如<a href="http://123.249.75.243/%E3%80%82%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E5%90%8D%E2%80%9Csoli%E2%80%9D%E5%92%8C%E5%AF%86%E7%A0%81%E2%80%9C123456%E2%80%9D%E7%99%BB%E5%BD%95%E8%BF%9B%E5%85%A5OA%E7%B3%BB%E7%BB%9F%E4%B8%BB%E7%95%8C%E9%9D%A2%E3%80%82">http://123.249.75.243/。使用用户名“soli”和密码“123456”登录进入OA系统主界面。</a></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8751.png"></p><p>成功使用华为云弹性负载均衡ELB和弹性伸缩AS服务，实现华为云平台OA系统应用的高可用部署。</p><p>使用弹性负载均衡ELB公网IP访问项目的时候，可能会出现登录页面嵌套问题。</p><p>因为该OA项目的单体项目，不是分布式项目，在不同服务器中无法共享session。所以当刷新页面的时候，会把请求分发到不同服务器，这个服务器没有保存之前的信息，属于项目接口的非法访问，就跳转到登录页面。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;通过使用华为云弹性负载均衡ELB和弹性伸缩AS服务，实现华为云平台OA系统应用的高可用部署。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;配置应用开机启动&quot;&gt;&lt;a href=&quot;#配置应用开机启动&quot; class=&quot;headerlink&quot; ti</summary>
      
    
    
    
    
    <category term="云计算" scheme="http://ailiaa.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
    <category term="分布式" scheme="http://ailiaa.github.io/tags/%E5%88%86%E5%B8%83%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>华为云平台数据库迁移与部署</title>
    <link href="http://ailiaa.github.io/2023/04/25/hua-wei-yun-ping-tai-shu-ju-ku-qian-yi-yu-bu-shu/"/>
    <id>http://ailiaa.github.io/2023/04/25/hua-wei-yun-ping-tai-shu-ju-ku-qian-yi-yu-bu-shu/</id>
    <published>2023-04-25T07:28:12.000Z</published>
    <updated>2023-04-25T08:09:12.563Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过配置华为云平台OA系统的数据库配置文件、将数据从华为云ECS自建数据库迁移至GaussDB(for MySQL)数据库，实现可供华为云平台OA系统接入的GaussDB(for MySQL)数据库部署。</p></blockquote><h3 id="部署云数据库GaussDB"><a href="#部署云数据库GaussDB" class="headerlink" title="部署云数据库GaussDB"></a>部署云数据库GaussDB</h3><p><strong>购买云数据库GaussDB</strong></p><p>进入控制台操作页面。选择区域“北京四”，单击“服务列表”，选择“数据库 &gt; 云数据库GaussDB”，进入服务列表页面。页面右上角的“购买数据库实例”。</p><p>进入云数据库GaussDB基础配置页面，选择配置如下所示，点击“立即购买”。计费模式：按需计费；区域：华北-北京四；实例名称：gauss-oa；性能规格：16核 | 64 GB；虚拟私有云：vpc-default；子网：subnet-default；内网安全组：sg-FullAccess；管理员密码&amp;确认密码。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8725.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8726.png"></p><p>查看云数据库信息，记录gauss-oa的内网地址</p><h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><h4 id="导出ecs-mysql数据"><a href="#导出ecs-mysql数据" class="headerlink" title="导出ecs-mysql数据"></a>导出ecs-mysql数据</h4><p>使用登录ecs-mysql的PuTTY，或者重新使用PuTTY登录ecs-mysql。执行以下命令，导出数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-mysql ~<span class="token punctuation">]</span><span class="token comment"># mysqldump -uroot -p oasys &gt; oasys-dump.sql</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8727.png"></p><p>因为我们的mysql是在docker中运行的，需要进入docker下的mysql</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysqlserver <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqldump <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span> oasys <span class="token operator">&gt;</span> oasys-dump.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导出的oasys-dump.sql文件在共享文件夹/opt/docker_mysql/data/中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Enter password:<span class="token punctuation">[</span>root@ecs-mysql ~<span class="token punctuation">]</span><span class="token comment"># ls</span>oasys-dump.sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8728.png"></p><h4 id="导入数据到gauss-oa"><a href="#导入数据到gauss-oa" class="headerlink" title="导入数据到gauss-oa"></a>导入数据到gauss-oa</h4><p>通过MySQL客户端登录gauss-oa，其中192.168.0.XXX修改为gauss-oa相应的内网地址。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-mysql ~<span class="token punctuation">]</span><span class="token comment"># mysql -h 192.168.0.xxx -P 3306 -u root -p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8729.png"></p><p>这里也需要先执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysqlserver <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导入oasys-dump.sql到gauss-oa</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> create database oasys<span class="token punctuation">;</span>Query OK, <span class="token number">1</span> row affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">&gt;</span> use oasys<span class="token punctuation">;</span>Database changedmysql<span class="token operator">&gt;</span> <span class="token builtin class-name">source</span> /var/lib/mysql/oasys-dump.sql<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（/opt/docker_mysql/data/oasys-dump.sql路径是主机下docker中的mysql共享文件夹,这里在docker下执行,路径是/var/lib/mysql/oasys-dump.sql，安装mysql的时候设置的data目录）</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8730.png"></p><p>查看数据库表并退出。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> show tables<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8731.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">exit</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>在使用putty登录ecs-oa，执行以下命令，打开并修改数据库连接信息。其中IP地址为gauss-oa的内网地址，密码为gauss-oa的root登录密码。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa ~<span class="token punctuation">]</span><span class="token comment"># cd /home/oasys_mysql/src/main/resources/</span><span class="token punctuation">[</span>root@ecs-oa resources<span class="token punctuation">]</span><span class="token comment"># vim application.properties</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8732.png"></p><h4 id="编译安装系统"><a href="#编译安装系统" class="headerlink" title="编译安装系统"></a>编译安装系统</h4><p>安装Maven。执行以下命令，进入项目目录，使用Maven本地安装。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa resources<span class="token punctuation">]</span><span class="token comment"># cd /home/oasys_mysql/</span><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># mvn install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行以下命令，启动应用。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># java -jar target/oasys.jar</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8733.png"></p><p>通过ecs-oa的弹性公网IP地址加8088端口访问OA系统登录页，使用用户名“soli”和密码“123456”登录OA系统主界面。</p><p>成功将数据从华为云ECS自建数据库迁移至GaussDB(for MySQL)数据库，实现可供华为云平台OA系统接入的GaussDB(for MySQL)数据库部署。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8734.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8735.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;通过配置华为云平台OA系统的数据库配置文件、将数据从华为云ECS自建数据库迁移至GaussDB(for MySQL)数据库，实现可供华为云平台OA系统接入的GaussDB(for MySQL)数据库部署。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="云计算" scheme="http://ailiaa.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>华为云平台部署OA系统</title>
    <link href="http://ailiaa.github.io/2023/04/25/hua-wei-yun-ping-tai-bu-shu-oa-xi-tong/"/>
    <id>http://ailiaa.github.io/2023/04/25/hua-wei-yun-ping-tai-bu-shu-oa-xi-tong/</id>
    <published>2023-04-25T07:01:42.000Z</published>
    <updated>2023-04-25T07:27:25.224Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>通过一个开源的OA(自动化办公 Office Automation)系统实例<br>实现OA系统在华为云服务器上的部署</p></blockquote><h3 id="数据库部署"><a href="#数据库部署" class="headerlink" title="数据库部署"></a>数据库部署</h3><h4 id="ECS云服务器搭建"><a href="#ECS云服务器搭建" class="headerlink" title="ECS云服务器搭建"></a>ECS云服务器搭建</h4><p>访问<a href="https://www.huaweicloud.com/?locale=zh-cn">华为云官网</a>，注册登录账号，然后进入控制台。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%871.png"></p><p>在页面左上角，选择区域“北京四”，单击“服务列表”，选择“计算 -&gt; 弹性云服务器ECS”，进入弹性云服务器列表页面。购买弹性云服务器。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%872.png"></p><p>购买后，进入弹性云服务器的基础配置页面，选择基础配置（按需计费，华为云计算，X86架构，通用计算增强型，1核2G内存，CentOS/Ubuntu），单击“下一步：网络配置”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%873.png"></p><p>进入弹性云服务器的网络配置页面，其中网络选择“vpc-default –&gt; subnet-default -&gt; 自动分配地址”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%874.png"></p><p>新建安全组，检查安全组中是否有“Sys-FullAccess”，若没有则点击“创建安全组”。选择模板为“开放全部端口”，输入名称“sg-FullAccess”，点击“确定”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%875.png"></p><p>点击安全组刷新按钮，选择“sg-FullAccess”，公网带宽选择“按流量计费”和“5”Mbit/s带宽大小，单击“下一步：高级配置”</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%876.png"></p><p>进入弹性云服务器的高级配置页面，高级配置如下图所示：</p><p>云服务器名称：ecs-mysql</p><p>输入自定义密码，密码需大于8位并带有特殊字符，再次确认密码</p><p>单击“下一步：确认配置</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%877.png"></p><p>进入弹性云服务器的确认配置页面，核对信息无误后，勾选下方的“我已经阅读并同意《华为镜像免责声明》”，如果有企业项目使用下拉框选择企业项目，单击“立即购买”，完成用于部署MySQL的云服务器购买。</p><p>返回弹性云服务器列表页面，查看刚刚购买的弹性云服务器ecs-mysql，等待其状态变为“运行中”， 记录其弹性IP地址。</p><h4 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h4><p>安装必要的docker 工具</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> <span class="token parameter variable">-y</span> yum-utils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>yum-config-manager，这个命令可以设置docker仓库源，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum-config-manager <span class="token punctuation">\</span>    --add-repo <span class="token punctuation">\</span>    https://download.docker.com/linux/centos/docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置阿里云镜像加速：登录阿里云，找到镜像加速服务，粘贴代码，运行即可，目的是为了加速镜像的获取</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%878.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%879.png"></p><p>查看docker可安装版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum list docker-ce <span class="token parameter variable">--showduplicates</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token parameter variable">-r</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定版本安装：yum -y install docker-ce-&lt; VERSION STRING &gt;<br>或者直接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> <span class="token parameter variable">-y</span> docker-ce docker-ce-cli http://containerd.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看docker版本、启动，停止以及自启动<br>查看： docker -v(或version) ；<br>启动： service docker start/systemctl start docker ;<br>停止：systemctl stop docker ;<br>自启动： systemctl enable docker .<br>查看镜像： docker images ；<br>删除镜像： docker rmi 镜像id ；<br>查看所有容器： docker ps -a ;<br>查看运行中的容器： docker ps ；<br>删除容器: docker rm &nbsp;容器id &nbsp;</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8710.png"></p><p>docker安装MySQL<br>查看可安装的MySQL：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> search mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装mysql：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8711.png"></p><p>启动mysql：</p><p>在opt目录下创建docker_mysql文件夹：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span>  /opt/ <span class="token punctuation">;</span><span class="token function">mkdir</span>  docker_mysql <span class="token punctuation">;</span><span class="token builtin class-name">cd</span> docker_mysql ；<span class="token builtin class-name">echo</span> <span class="token environment constant">$PWD</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>启动mysql容器，在var/lib/docker/containers/下查看容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">--name</span> mysqlserver <span class="token punctuation">\</span><span class="token parameter variable">-v</span> <span class="token environment constant">$PWD</span>/conf:/etc/mysql/conf.d <span class="token punctuation">\</span><span class="token parameter variable">-v</span> <span class="token environment constant">$PWD</span>/logs:/logs <span class="token punctuation">\</span><span class="token parameter variable">-v</span> <span class="token environment constant">$PWD</span>/data:/var/lib/mysql <span class="token punctuation">\</span><span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> <span class="token parameter variable">-d</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-p</span> <span class="token number">3306</span>:3306 mysql:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看mysql进程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8712.png"></p><p>进入mysql容器，并登陆mysql</p><p>进入MySQL： </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysqlserver <span class="token function">bash</span><span class="token comment"># 或 docker attach 容器ID</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>登录mysql </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-uroot</span> -p；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>退出MySQL容器： exit 或者 Ctrl+P+Q</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8713.png"></p><p><strong>导入数据：</strong></p><p>下载原始sql文件到/home目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">exit</span><span class="token punctuation">[</span>root@ecs-mysql run<span class="token punctuation">]</span><span class="token comment"># cd /home/</span><span class="token punctuation">[</span>root@ecs-mysql home<span class="token punctuation">]</span><span class="token comment"># wget [https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/oasys_mysql.sql](https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/oasys_mysql.sql)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>登录mysql，下述命令中的“mypassword”需要根据实际修改成要配置的密码。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-mysql home<span class="token punctuation">]</span><span class="token comment"># mysql -uroot -pmypassword</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建名为“oasys”的数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> create database oasys<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用“oasys”数据库，执行原始sql文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> use oasys<span class="token punctuation">;</span>mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">source</span> /home/oasys_mysql.sql<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>找不到/home/oasys_mysql.sql，因为MySQL在docker下运行，需要把oasys_mysql.sql文件放在/data:/var/lib/mysql。放在data目录下。</p><p>执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">source</span> /var/lib/mysql/oasys_mysql.sql<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8714.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8715.png"></p><h3 id="OA应用部署"><a href="#OA应用部署" class="headerlink" title="OA应用部署"></a>OA应用部署</h3><h4 id="ECS云服务器搭建-1"><a href="#ECS云服务器搭建-1" class="headerlink" title="ECS云服务器搭建"></a>ECS云服务器搭建</h4><p>同上操作</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8716.png"></p><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><p>下载并拷贝jdk8至/usr/local/java，并解压缩</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/<span class="token function">mkdir</span> <span class="token function">java</span><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> jdk-8-linux-i586<span class="token punctuation">(</span>x86<span class="token punctuation">)</span>.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置环境变量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按“i”进入编辑模式，使用hjkl键或方向键移动光标，在文件最后添加以下代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/usr/local/java/jdk1.8******<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$JAVA_HOME</span>/bin<span class="token builtin class-name">export</span> JAVA_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>按“Esc”退出编辑模式，输入“:wq”并按回车，保存退出。<br>执行以下命令，使新增配置生效。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，验证jdk安装并配置成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> –version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8717.png"><br>解决方法：<br>执行命令 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> yum <span class="token function">install</span> glibc.i686<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8718.png"></p><h4 id="安装Maven"><a href="#安装Maven" class="headerlink" title="安装Maven"></a>安装Maven</h4><p>执行以下命令，创建Maven安装目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa ~<span class="token punctuation">]</span><span class="token comment"># mkdir /usr/local/maven</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，切换到Maven安装目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa ~<span class="token punctuation">]</span><span class="token comment"># cd /usr/local/maven</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，获取Maven二进制包。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># wget [http://mirrors.huaweicloud.com/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz](http://mirrors.huaweicloud.com/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，解压Maven二进制包。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># tar -xvzf apache-maven-3.6.3-bin.tar.gz</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>步骤 5执行以下命令，打开环境变量配置文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># vim /etc/profile</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按“i”进入编辑模式，使用hjkl键或方向键移动光标，在文件最后添加以下代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">MAVEN_HOME</span><span class="token operator">=</span>/usr/local/maven/apache-maven-3.6.3<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$MAVEN_HOME</span>/bin<span class="token builtin class-name">export</span> MAVEN_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>按“Esc”退出编辑模式，输入“:wq”并按回车，保存退出。<br>执行以下命令，使新增配置生效。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># source /etc/profile</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，验证Maven安装。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># mvn -v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8719.png"></p><h4 id="Maven换源"><a href="#Maven换源" class="headerlink" title="Maven换源"></a>Maven换源</h4><p>执行以下命令，进入Maven配置文件目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># cd /usr/local/maven/apache-maven-3.6.3/conf/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，打开配置文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa conf<span class="token punctuation">]</span><span class="token comment"># vim settings.xml</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入”:158”后按回车键，在<mirrors>和</mirrors>中间，插入以下代码。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&lt;</span>mirror<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>id<span class="token operator">&gt;</span>mirror<span class="token operator">&lt;</span>/id<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>mirrorOf<span class="token operator">&gt;</span>*<span class="token operator">&lt;</span>/mirrorOf<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span>cmc-cd-mirror<span class="token operator">&lt;</span>/name<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>url<span class="token operator">&gt;</span>https://mirrors.huaweicloud.com/repository/maven/<span class="token operator">&lt;</span>/url<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/mirror<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h4><p>执行以下命令，安装Git。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa conf<span class="token punctuation">]</span><span class="token comment"># yum install -y git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，验证Git版本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa conf<span class="token punctuation">]</span><span class="token comment"># git version</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8720.png"></p><p>执行以下命令，Clone源码到本地。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa conf<span class="token punctuation">]</span><span class="token comment"># cd /home</span><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># git clone -b mysql-8 https://gitee.com/github-5407963/oasys_mysql.git</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="配置MySQL连接"><a href="#配置MySQL连接" class="headerlink" title="配置MySQL连接"></a>配置MySQL连接</h4><p>执行以下命令，进入OA系统数据库配置文件目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># cd /home/oasys_mysql/src/main/resources/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，编辑应用配置文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa resources<span class="token punctuation">]</span><span class="token comment"># vim application.properties</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改url、username和password为ecs-mysql的内网地址、mysql的登录用户名和密码，保存文件，退出。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">server.port</span><span class="token operator">=</span><span class="token number">8088</span>spring.datasource.driver-class-name<span class="token operator">=</span>com.mysql.cj.jdbc.Driver<span class="token assign-left variable">spring.datasource.url</span><span class="token operator">=</span>jdbc:mysql://192.168.0.25:3306/oasys?autoReconnect<span class="token operator">=</span>true<span class="token operator">&amp;</span><span class="token assign-left variable">useSSL</span><span class="token operator">=</span>false<span class="token operator">&amp;</span><span class="token assign-left variable">characterEncoding</span><span class="token operator">=</span>utf-8<span class="token operator">&amp;</span><span class="token assign-left variable">serverTimezone</span><span class="token operator">=</span>Hongkong<span class="token operator">&amp;</span><span class="token assign-left variable">rewriteBatchedStatements</span><span class="token operator">=</span>true<span class="token operator">&amp;</span><span class="token assign-left variable">allowPublicKeyRetrieval</span><span class="token operator">=</span>true<span class="token assign-left variable">spring.datasource.username</span><span class="token operator">=</span>root<span class="token assign-left variable">spring.datasource.password</span><span class="token operator">=</span>mypassword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以下命令，进入OA系统目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa resources<span class="token punctuation">]</span><span class="token comment"># cd /home/oasys_mysql/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，重新Maven本地编译安装。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># mvn install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8721.png"></p><p>执行以下命令，启动项目应用。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># java -jar target/oasys.jar</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8722.png"></p><p>通过ecs-oa弹性公网IP地址加8088端口访问OA系统登录页，如<a href="http://123.60.210.240:8088/%E3%80%82%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E5%90%8D%E2%80%9Csoli%E2%80%9D%E5%92%8C%E5%AF%86%E7%A0%81%E2%80%9C123456%E2%80%9D%E7%99%BB%E5%BD%95%E8%BF%9B%E5%85%A5OA%E7%B3%BB%E7%BB%9F%E4%B8%BB%E7%95%8C%E9%9D%A2%E3%80%82">http://123.60.210.240:8088/。使用用户名“soli”和密码“123456”登录进入OA系统主界面。</a></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8723.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8724.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;通过一个开源的OA(自动化办公 Office Automation)系统实例&lt;br&gt;实现OA系统在华为云服务器上的部署&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3 id=&quot;数据库部署&quot;&gt;&lt;a href=&quot;#数据库部署&quot; class=&quot;headerl</summary>
      
    
    
    
    
    <category term="云计算" scheme="http://ailiaa.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>基于ECS搭建云上博客</title>
    <link href="http://ailiaa.github.io/2023/04/25/ji-yu-a-li-ecs-da-jian-yun-shang-bo-ke/"/>
    <id>http://ailiaa.github.io/2023/04/25/ji-yu-a-li-ecs-da-jian-yun-shang-bo-ke/</id>
    <published>2023-04-25T06:24:34.000Z</published>
    <updated>2023-04-25T07:00:21.740Z</updated>
    
    <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p><strong>LAMP</strong></p><p>LAMP是指Linux（操作系统）+Apache（HTTP 服务器）+MySQL（数据库）和PHP（网络编程语言），一般用来建立Web应用平台。</p><p><strong>WordPress</strong></p><p>WordPress是一种使用PHP语言开发的博客平台，用户可以在支持PHP和MySQ数据库的服务器上架设WordPress。可以使用WordPress搭建一个简单的独立博客。</p><p><strong>云服务器ECS</strong></p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/1.png"></p><h4 id="安装并配置Apache服务"><a href="#安装并配置Apache服务" class="headerlink" title="安装并配置Apache服务"></a>安装并配置Apache服务</h4><p>Apache是Web服务器软件。<br>在实验室切换至Web Terminal。输入ECS服务器登录用户名和密码，登录ECS。<br>执行如下命令，安装Apache服务及其扩展包。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token parameter variable">-y</span> <span class="token function">install</span> httpd mod_ssl mod_perl mod_auth_mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/2.png"></p><p>执行如下命令，查看Apache是否安装成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">httpd <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/3.png"></p><p>执行如下命令，启动Apache服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start httpd.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在本机浏览器的地址栏中，访问<a href="http://ecs公网地址./">http://ECS公网地址。</a></p><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/4.png"></p><h4 id="安装MariaDB数据库"><a href="#安装MariaDB数据库" class="headerlink" title="安装MariaDB数据库"></a>安装MariaDB数据库</h4><p>执行一下命令安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> <span class="token parameter variable">-y</span> mariadb-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/5.png"></p><p>执行如下命令，启动MariaDB Server。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start mariadb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/6.png"></p><p>执行如下命令，查看MariaDB Server运行状态。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status mariadb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/7.png"></p><p>执行如下命令，设置数据库root用户的初始密码。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqladmin <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span> password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/8.png"></p><p>123456789</p><p>执行如下命令，连接数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/9.png"></p><p>执行如下命令，创建WordPress数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">create database wordpress<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行如下命令，查看数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">show databases<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/10.png"></p><p>执行如下命令，退出数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exit</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h4><p>PHP是一种广泛使用的通用开源脚本语言，适合于Web网站开发，它可以嵌入HTML中。</p><p>执行如下命令，安装PHP。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token parameter variable">-y</span> <span class="token function">install</span> php php-mysql gd php-gd gd-devel php-xml php-common php-mbstring php-ldap php-pear php-xmlrpc php-imap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/11.png"></p><p>执行如下命令，创建PHP测试页面。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"&lt;?php phpinfo(); ?&gt;"</span> <span class="token operator">&gt;</span> /var/www/html/phpinfo.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行如下命令，重启Apache服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart httpd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在浏览器的地址栏中，访问http://&lt;ECS公网地址&gt;/phpinfo.php。</p><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/12.png"></p><h4 id="安装和配置WordPress"><a href="#安装和配置WordPress" class="headerlink" title="安装和配置WordPress"></a>安装和配置WordPress</h4><p>在实验室页面右侧，单击 图标，切换至Web Terminal。</p><p>执行如下命令，安装WordPress。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token parameter variable">-y</span> <span class="token function">install</span> wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/13.png"></p><p>修改WordPress配置文件。</p><p>执行如下命令，修改wp-config.php指向路径为绝对路径。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 进入/usr/share/wordpress目录。</span><span class="token builtin class-name">cd</span> /usr/share/wordpress<span class="token comment"># 修改路径。</span><span class="token function">ln</span> <span class="token parameter variable">-snf</span> /etc/wordpress/wp-config.php wp-config.php<span class="token comment"># 查看修改后的目录结构。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/14.png"></p><p>执行如下命令，移动wordpress文件到Apache根目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 在Apache的根目录/var/www/html下，创建一个wp-blog文件夹。</span><span class="token function">mkdir</span> /var/www/html/wp-blog<span class="token function">mv</span> * /var/www/html/wp-blog/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以下命令，修改wp-config.php配置文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/database_name_here/wordpress/'</span> /var/www/html/wp-blog/wp-config.php<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/username_here/root/'</span> /var/www/html/wp-blog/wp-config.php<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/password_here/123456789/'</span> /var/www/html/wp-blog/wp-config.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以下命令，查看配置文件信息是否修改成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token parameter variable">-n</span> /var/www/html/wp-blog/wp-config.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/15.png"></p><p>执行如下命令，重启Apache服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart httpd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="测试WordPress"><a href="#测试WordPress" class="headerlink" title="测试WordPress"></a>测试WordPress</h3><p>在浏览器地址栏中，访问http://&lt;ECS公网地址&gt;/wp-blog/wp-admin/install.php。</p><p>在WordPress配置页面，配置相关信息，然后单击Install WordPress。</p><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/16.png"></p><p>成功发布一篇博文</p><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/17.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;环境&quot;&gt;&lt;a href=&quot;#环境&quot; class=&quot;headerlink&quot; title=&quot;环境&quot;&gt;&lt;/a&gt;环境&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;LAMP&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;LAMP是指Linux（操作系统）+Apache（HTTP 服务器）+MySQL（</summary>
      
    
    
    
    
    <category term="云计算" scheme="http://ailiaa.github.io/tags/%E4%BA%91%E8%AE%A1%E7%AE%97/"/>
    
  </entry>
  
  <entry>
    <title>MySQL版本升级5.5-8.0.20</title>
    <link href="http://ailiaa.github.io/2023/04/15/mysql-ban-ben-sheng-ji-5.5-8.0.20/"/>
    <id>http://ailiaa.github.io/2023/04/15/mysql-ban-ben-sheng-ji-5.5-8.0.20/</id>
    <published>2023-04-15T07:58:16.000Z</published>
    <updated>2023-04-25T08:15:23.393Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-备份数据库"><a href="#1-备份数据库" class="headerlink" title="1. 备份数据库"></a>1. 备份数据库</h3><p>在数据库编辑器中对重要的数据库导出为<code>.sql</code>文件<br>版本升级后，可以在新版本的MySQL中新建数据库执行<code>.sql</code>文件，恢复数据</p><p><em><strong>（在此升级过程中并不会删掉原有数据库，数据备份是一个好习惯）</strong></em></p><h3 id="2-下载对应版本的MySQL"><a href="#2-下载对应版本的MySQL" class="headerlink" title="2. 下载对应版本的MySQL"></a>2. 下载对应版本的MySQL</h3><p><a href="https://downloads.mysql.com/archives/community/">官网：https://downloads.mysql.com/archives/community/</a></p><p><img src="/images/image_MySQL%E5%8D%87%E7%BA%A7/1.png"></p><p>然后将安装包解压，最好和MySQL5.5（老版本）放在一起，方便查找</p><h3 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3. 配置环境变量"></a>3. 配置环境变量</h3><p><code>D:\MySQL\mysql-8.0.20\bin</code></p><p>在用户变量path 中添加MySQL的bin文件夹目录</p><p>删除老版本MySQL的环境变量</p><h3 id="4-配置文件"><a href="#4-配置文件" class="headerlink" title="4. 配置文件"></a>4. 配置文件</h3><p>在<code>mysql-8.0.20</code>目录下新建<code>my.ini</code>文件</p><p><img src="/images/image_MySQL%E5%8D%87%E7%BA%A7/2.png"></p><p>写入：</p><pre class="line-numbers language-none"><code class="language-none"># 设置3306端口port=3306# 设置mysql的安装目录，写你的目录basedir=D:\MySQL# 设置mysql数据库的数据的存放目录，这是隐藏的文件夹datadir=C:\ProgramData\MySQL/MySQL Server 8.0\Data\# 允许最大连接数max_connections=200# 允许连接失败的次数。防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-停止MySQL5-5服务"><a href="#5-停止MySQL5-5服务" class="headerlink" title="5. 停止MySQL5.5服务"></a>5. 停止MySQL5.5服务</h3><p>在任务管理器-&gt;服务 : 找到MySQL</p><p>停止MySQL服务</p><p>以管理员运行命令窗口</p><pre class="line-numbers language-none"><code class="language-none">C:\Windows\system32&gt;cd D:\MySQL\MySQL5.5\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入该文件夹，执行</p><pre class="line-numbers language-none"><code class="language-none">mysqld --remove mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-安装运行MySQL-8-0-2"><a href="#6-安装运行MySQL-8-0-2" class="headerlink" title="6. 安装运行MySQL 8.0.2"></a>6. 安装运行MySQL 8.0.2</h3><pre class="line-numbers language-none"><code class="language-none"># 设置mysql数据库的数据的存放目录，这是隐藏的文件夹datadir=C:\ProgramData\MySQL/MySQL Server 8.0\Data\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建文件夹，存放数据<br>需要查看隐藏文件夹ProgramData<br><code>C:\ProgramData\MySQL/MySQL Server 8.0\Data\</code></p><pre class="line-numbers language-none"><code class="language-none">cd D:\MySQL\mysql-8.0.20\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到mysql-8.0.20的bin目录下</p><p>执行安装命令</p><pre class="line-numbers language-none"><code class="language-none">mysqld -install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行初始化命令</p><pre class="line-numbers language-none"><code class="language-none">mysqld --initialize --user=mysql --console<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化成功后会给个root临时密码，类似 DQybZ_HT#76B</p><p>以root账号进入数据库  </p><pre class="line-numbers language-none"><code class="language-none">mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接</p><pre class="line-numbers language-none"><code class="language-none">net start mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改密码</p><pre class="line-numbers language-none"><code class="language-none">ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到此MySQL升级成功，在SQLyog编辑器中已经自动连接上8.0.20版本MySQL</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-备份数据库&quot;&gt;&lt;a href=&quot;#1-备份数据库&quot; class=&quot;headerlink&quot; title=&quot;1. 备份数据库&quot;&gt;&lt;/a&gt;1. 备份数据库&lt;/h3&gt;&lt;p&gt;在数据库编辑器中对重要的数据库导出为&lt;code&gt;.sql&lt;/code&gt;文件&lt;br&gt;版本升级后，可</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://ailiaa.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>DevOps流水线搭建03</title>
    <link href="http://ailiaa.github.io/2023/04/15/devops-liu-shui-xian-da-jian-03/"/>
    <id>http://ailiaa.github.io/2023/04/15/devops-liu-shui-xian-da-jian-03/</id>
    <published>2023-04-15T07:02:48.000Z</published>
    <updated>2023-04-15T07:07:21.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-测试DevOps流水线"><a href="#1-测试DevOps流水线" class="headerlink" title="1. 测试DevOps流水线"></a>1. 测试DevOps流水线</h2><h3 id="gitlab创建项目并拉取到本地"><a href="#gitlab创建项目并拉取到本地" class="headerlink" title="gitlab创建项目并拉取到本地"></a>gitlab创建项目并拉取到本地</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8730.png"><br>关闭防火墙，让本机访问gitlab</p><pre class="line-numbers language-none"><code class="language-none">$systemctl stop firewalld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>clone项目，将我们需要打包发布的项目推送到gitlab</p><pre class="line-numbers language-none"><code class="language-none">git add .git commit -m "first push"git tag 1.0.0git push origin 1.0.0git push -u origin --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="harbor-server上构建基础镜像"><a href="#harbor-server上构建基础镜像" class="headerlink" title="harbor-server上构建基础镜像"></a>harbor-server上构建基础镜像</h3><p>遇到小问题</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8732.png"></p><p>重启harbor解决</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker-compose down$sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>拉取openjdk镜像</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker pull openjdk:8u201-jdk-alpine3.9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8733.png"></p><pre class="line-numbers language-none"><code class="language-none">$sudo docker tag openjdk:8u201-jdk-alpine3.9 192.168.159.131:8077/library/openjdk8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8734.png"><br>登录harbor仓库</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker login 192.168.159.131:8077<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>推送</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker push 192.168.159.131:8077/library/openjdk8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8735.png"></p><h3 id="构建jenkins应用"><a href="#构建jenkins应用" class="headerlink" title="构建jenkins应用"></a>构建jenkins应用</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8736.png"><br>遇到问题：</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8737.png"></p><p>我这里是因为gitlab-server上没安装ssh服务,安装后解决<br>其他原因可能是私钥密钥配置错误</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8738.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8739.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8740.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8741.png"></p><p>开始构建</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8742.png"></p><p>构建成功<br>访问</p><p><img src="/images/image_DevOps/2.jpg"></p><p>修改代码后，再次push</p><p><img src="/images/image_DevOps/1.jpg"></p><p><img src="/images/image_DevOps/3.jpg"></p><p>流水线测试成功！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-测试DevOps流水线&quot;&gt;&lt;a href=&quot;#1-测试DevOps流水线&quot; class=&quot;headerlink&quot; title=&quot;1. 测试DevOps流水线&quot;&gt;&lt;/a&gt;1. 测试DevOps流水线&lt;/h2&gt;&lt;h3 id=&quot;gitlab创建项目并拉取到本地&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="docker" scheme="http://ailiaa.github.io/tags/docker/"/>
    
    <category term="harbor" scheme="http://ailiaa.github.io/tags/harbor/"/>
    
    <category term="jenkins" scheme="http://ailiaa.github.io/tags/jenkins/"/>
    
    <category term="DevOps" scheme="http://ailiaa.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>DevOps流水线搭建02</title>
    <link href="http://ailiaa.github.io/2023/04/10/devops-liu-shui-xian-da-jian-02/"/>
    <id>http://ailiaa.github.io/2023/04/10/devops-liu-shui-xian-da-jian-02/</id>
    <published>2023-04-10T01:30:18.000Z</published>
    <updated>2023-04-15T07:04:27.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-各主机中的工具配置"><a href="#1-各主机中的工具配置" class="headerlink" title="1. 各主机中的工具配置"></a>1. 各主机中的工具配置</h2><h3 id="jenkins-server"><a href="#jenkins-server" class="headerlink" title="jenkins-server"></a>jenkins-server</h3><p><strong>docker配置</strong><br>配置docker主机使用harbor，添加信任harbor-server中的私有仓库<br>（harbor仓库ip+端口号）</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/docker/daemon.json# 写入{"insecure-registries": ["http://192.168.159.131:8077"]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启docker</p><pre class="line-numbers language-none"><code class="language-none">$systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>登录harbor主机中的docker仓库服务</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker login 192.168.159.131:8077<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8712.png"><br><strong>配置jenkins使用docker</strong></p><p>验证系统中是否有jenkins用户</p><pre class="line-numbers language-none"><code class="language-none">$grep jenkins /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证系统中是否有docker用户及用户组</p><pre class="line-numbers language-none"><code class="language-none">$grep docker /etc/group<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8713.png"><br>添加jenkins用户到docker用户组</p><pre class="line-numbers language-none"><code class="language-none">$sudo usermod -G docker jenkins$grep docker /etc/group<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8714.png"><br>重启jenkins服务</p><pre class="line-numbers language-none"><code class="language-none">$systemctl restart jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="harbor-server"><a href="#harbor-server" class="headerlink" title="harbor-server"></a>harbor-server</h3><p><strong>docker配置</strong><br>同上</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/docker/daemon.json# 写入{        "insecure-registries": ["http://192.168.159.131:8077"]}$cat /etc/docker/daemon.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启docker-compose</p><pre class="line-numbers language-none"><code class="language-none">$docker-compose down$systemctl restart docker$docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="web-server"><a href="#web-server" class="headerlink" title="web-server"></a>web-server</h3><p><strong>docker配置</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/docker/daemon.json# 写入{        "insecure-registries": ["http://192.168.159.131:8077"]}$cat /etc/docker/daemon.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启docker</p><pre class="line-numbers language-none"><code class="language-none">$systemctl restart docker$sudo docker login 192.168.159.131:8077<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-配置gitlab相关密钥"><a href="#2-配置gitlab相关密钥" class="headerlink" title="2. 配置gitlab相关密钥"></a>2. 配置gitlab相关密钥</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p><strong>Windows下生成ssh密钥，并用ssh免密访问Linux服务器</strong></p><pre class="line-numbers language-none"><code class="language-none">$ssh-keygen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8715.png"></p><p>可以在 C:\User\XXX\ 文件夹下看到一个.ssh的文件夹，里面有两个文件</p><p>id_rsa.pub，就是公钥文件，需要给Linux服务器的管理者，让他将id_rsa.pub文件中的公钥内容注册到Linux中，以便能够通过ssh来访问该Linux服务器。公钥注册到Linux服务器后，就可以在本机ssh到远端Linux服务器，并访问了。</p><p>添加到gitlab ssh密钥中:</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8716.png"></p><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p><strong>jenkins-server主机生成公钥，添加公钥至gitlab-ce</strong></p><pre class="line-numbers language-none"><code class="language-none">$ssh-keygen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8717.png"></p><pre class="line-numbers language-none"><code class="language-none">$cat /home/l/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8718.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8719.png"><br><strong>配置jenkins-sever主机的私钥到凭据列表</strong></p><pre class="line-numbers language-none"><code class="language-none">$cat /home/l/.ssh/id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8720.png"></p><p><em><strong>（注意这里要全部复制，包括首尾）</strong></em></p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8721.png"><br>修改jenkins配置文件</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/default/jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以root用户运行(因为上述操在作root用户下生成的公钥和私钥)</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8722.png"></p><h2 id="3-jenkins插件安装"><a href="#3-jenkins插件安装" class="headerlink" title="3. jenkins插件安装"></a>3. jenkins插件安装</h2><ul><li>maven integration：用于编译JAVA项目</li><li>git parameter：用于基于git版本提交进行参数构建项目</li><li>gitlab：用于jenkins-server拉取项目</li><li>Generic Webhook Trigger：用于项目自动化构建</li><li>ssh：用于jenkins-server对web-server实施项目部署</li></ul><h2 id="4-Jenkins全局工具配置"><a href="#4-Jenkins全局工具配置" class="headerlink" title="4. Jenkins全局工具配置"></a>4. Jenkins全局工具配置</h2><h3 id="JDK配置"><a href="#JDK配置" class="headerlink" title="JDK配置"></a>JDK配置</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8723.png"></p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8724.png"></p><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8725.png"></p><h3 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8726.png"></p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8727.png"></p><h2 id="5-jenkins系统配置"><a href="#5-jenkins系统配置" class="headerlink" title="5. jenkins系统配置"></a>5. jenkins系统配置</h2><p>主要配置jenkins-server通过ssh协议连接web-server<br>添加jenkins-server访问web-server凭据<br>测试连接是否成功（web-server对应的主机需要修改ssh配置允许用root账号密码连接）：</p><pre class="line-numbers language-none"><code class="language-none">$sudo vi /etc/ssh/sshd_config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8728.png"><br>重启</p><pre class="line-numbers language-none"><code class="language-none">$service sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不行，应该是root密码错误，root密码不是开机解锁密码，忘记root密码可以修改root密码</p><pre class="line-numbers language-none"><code class="language-none">$sudo passwd root <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功连接</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8729.png"><br>各工具配置完成，接下来可以测试DevOps流水线是否搭建成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-各主机中的工具配置&quot;&gt;&lt;a href=&quot;#1-各主机中的工具配置&quot; class=&quot;headerlink&quot; title=&quot;1. 各主机中的工具配置&quot;&gt;&lt;/a&gt;1. 各主机中的工具配置&lt;/h2&gt;&lt;h3 id=&quot;jenkins-server&quot;&gt;&lt;a href=&quot;#j</summary>
      
    
    
    
    
    <category term="docker" scheme="http://ailiaa.github.io/tags/docker/"/>
    
    <category term="harbor" scheme="http://ailiaa.github.io/tags/harbor/"/>
    
    <category term="jenkins" scheme="http://ailiaa.github.io/tags/jenkins/"/>
    
    <category term="DevOps" scheme="http://ailiaa.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>DevOps流水线搭建01</title>
    <link href="http://ailiaa.github.io/2023/04/07/devops-liu-shui-xian-da-jian-01/"/>
    <id>http://ailiaa.github.io/2023/04/07/devops-liu-shui-xian-da-jian-01/</id>
    <published>2023-04-07T05:41:13.000Z</published>
    <updated>2023-04-15T07:01:51.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><p>个人主机，三台ubuntu虚拟机</p><p>工具安装：</p><ul><li>Git:用于提交业务代码或克隆业务代码仓库</li><li>Gitlab:用于存储业务代码</li><li>Jenkins:用于利用插件完成业务代码编译、构建、推送至Harbor容器镜像仓库及项目部署</li><li>Tomcat:用于运行JAVA业务代码</li><li>Maven:用于编译业务代码</li><li>Harbor:用于存储业务代码构建的容器镜像存储</li><li>Docker:用于构建容器镜像，部署项目</li></ul><h2 id="2-主机"><a href="#2-主机" class="headerlink" title="2. 主机"></a>2. 主机</h2><table><thead><tr><th>主机</th><th>主机IP</th><th>业务功能</th><th>安装软件</th></tr></thead><tbody><tr><td>Windows本机</td><td>192.168.159.1</td><td>开发项目代码</td><td>git</td></tr><tr><td>harbor-server</td><td>192.168.159.131</td><td>存储容器镜像</td><td>harbor、docker</td></tr><tr><td>jenkins-server</td><td>192.168.159.129</td><td>编译代码、打包镜像、项目构建</td><td>jenkins、docker、git</td></tr><tr><td>gitlab-server</td><td>192.168.159.130</td><td>代码仓库</td><td>gitlab-ce</td></tr><tr><td>web-server</td><td>192.168.159.129</td><td>运行容器，项目上线</td><td>docker</td></tr></tbody></table><h2 id="3-各主机工具安装"><a href="#3-各主机工具安装" class="headerlink" title="3. 各主机工具安装"></a>3. 各主机工具安装</h2><h3 id="windows本机"><a href="#windows本机" class="headerlink" title="windows本机"></a>windows本机</h3><p>安装git,直接去官网下载安装<br>控制台<code>git --version</code>,打印版本信息即成功安装</p><h3 id="Jenkins-server"><a href="#Jenkins-server" class="headerlink" title="Jenkins-server"></a>Jenkins-server</h3><p><strong>安装jdk</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo apt-get update$sudo apt-get install openjdk-17-jdk$java -version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（如果没有版本信息，需要将路径添加到环境变量中）<br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%871.png"><br><strong>安装jenkins</strong><br>安装</p><pre class="line-numbers language-none"><code class="language-none">$wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -$sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list'$sudo apt-get install jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>启动</p><pre class="line-numbers language-none"><code class="language-none">$systemctl start jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动成功后访问，默认端口8080</p><p>登录admin账号，密钥获取</p><pre class="line-numbers language-none"><code class="language-none">$cat /var/lib/jenkins/secrets/initialAdminPassword<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装推荐插件<br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%872.png"><br>如果有插件安装失败，之后点击重试安装即可</p><p>完成安装：<br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%873.png"><br><strong>安装git</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo apt-get update$git --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>安装maven</strong></p><p>在这新建maven文件夹(随便)<br>/usr/local/src/maven/</p><p>在这个文件夹中执行命令，下载解压删除安装包</p><pre class="line-numbers language-none"><code class="language-none">$wget https://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz$tar -zxvf apache-maven-3.8.8-bin.tar.gz$rm apache-maven-3.8.8-bin.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>添加环境变量（注意路径和版本）</p><pre class="line-numbers language-none"><code class="language-none">$export MAVEN_HOME=/usr/local/src/maven/apache-maven-3.8.8 $export CLASSPATH=${MAVEN_HOME}/lib:$CLASSPATH$export PATH=${MAVEN_HOME}/bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>检查是否成功</p><pre class="line-numbers language-none"><code class="language-none">$mvn -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%874.png"></p><h3 id="gitlib-server"><a href="#gitlib-server" class="headerlink" title="gitlib-server"></a>gitlib-server</h3><p><strong>安装gitlab</strong></p><pre class="line-numbers language-none"><code class="language-none">$wget --content-disposition https://packages.gitlab.com/gitlab/gitlab-ce/packages/ubuntu/focal/gitlab-ce_15.5.2-ce.0_amd64.deb/download.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压</p><pre class="line-numbers language-none"><code class="language-none">$sudo dpkg -i gitlab-ce_15.5.2-ce.0_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%875.png"><br>查看当前gitlab网页ip和端口号：</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/gitlab/gitlab.rb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只要修改配置文件就要reconfigure</p><pre class="line-numbers language-none"><code class="language-none">$sudo gitlab-ctl reconfigure<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动</p><pre class="line-numbers language-none"><code class="language-none">$sudo gitlab-ctl start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看状态</p><pre class="line-numbers language-none"><code class="language-none">$sudo gitlab-ctl status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>root密码</p><pre class="line-numbers language-none"><code class="language-none">$cat /etc/gitlab/initial_root_password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改root密码</p><pre class="line-numbers language-none"><code class="language-none">#进入gitlab控制台$sudo gitlab-rails console production#获取root用户$user = User.where(id: 1).first#设置新密码，注意新密码要大于8位$user.password = newPwd#再次确认新密码$user.password_confirmation = newPwd#保存密码$user.save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%876.png"></p><h3 id="web-server"><a href="#web-server" class="headerlink" title="web-server"></a>web-server</h3><p>只需安装docker</p><h3 id="harbor-server"><a href="#harbor-server" class="headerlink" title="harbor-server"></a>harbor-server</h3><p><strong>安装docker-compose</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo apt-get update$sudo apt-get install docker-compose-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%877.png"><br>检查安装</p><pre class="line-numbers language-none"><code class="language-none">$docker compose version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%878.png"><br><strong>安装harbor</strong><br>下载</p><pre class="line-numbers language-none"><code class="language-none">$wget https://github.com/goharbor/harbor/releases/download/v2.3.2/harbor-offline-installer-v2.3.2.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压<br><strong>$sudo tar -zxvf harbor-offline-installer-v2.3.2.tgz</strong></p><p>修改配置文件</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%879.png"></p><p>修改hostname和port</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8710.png"><br>执行修改</p><pre class="line-numbers language-none"><code class="language-none">$sudo ./install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认admin账号密码：Harbor12345<br>访问登录</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8711.png"></p><pre class="line-numbers language-none"><code class="language-none">#停止harbor$sudo docker-compose down -v#修改yml文件后需要重新加载$./prepare#重启harbor$sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>各主机工具安装完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-环境搭建&quot;&gt;&lt;a href=&quot;#1-环境搭建&quot; class=&quot;headerlink&quot; title=&quot;1. 环境搭建&quot;&gt;&lt;/a&gt;1. 环境搭建&lt;/h2&gt;&lt;p&gt;个人主机，三台ubuntu虚拟机&lt;/p&gt;
&lt;p&gt;工具安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git:用于提交业</summary>
      
    
    
    
    
    <category term="docker" scheme="http://ailiaa.github.io/tags/docker/"/>
    
    <category term="harbor" scheme="http://ailiaa.github.io/tags/harbor/"/>
    
    <category term="jenkins" scheme="http://ailiaa.github.io/tags/jenkins/"/>
    
    <category term="DevOps" scheme="http://ailiaa.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch</title>
    <link href="http://ailiaa.github.io/2023/03/15/elasticsearch/"/>
    <id>http://ailiaa.github.io/2023/03/15/elasticsearch/</id>
    <published>2023-03-15T08:11:07.000Z</published>
    <updated>2023-03-15T08:29:28.836Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ElasticSearch的简介"><a href="#1-ElasticSearch的简介" class="headerlink" title="1. ElasticSearch的简介"></a>1. ElasticSearch的简介</h3><p>ElasticSearch：智能搜索，分布式的全文搜索引擎</p><p>是ELK的一个组成部分, 是一个产品，而且是非常完善的产品，ELK代表的是：E就是ElasticSearch，L就是Logstach，K就是kibana</p><p>E：EalsticSearch 搜索和分析的功能</p><p>L：Logstach 搜集数据的功能，类似于flume（使用方法几乎跟flume一模一样），是日志收集系统</p><p>K：Kibana 数据可视化（分析），可以用图表的方式来去展示，文不如表，表不如图，是数据可视化平台</p><h3 id="2-全文检索"><a href="#2-全文检索" class="headerlink" title="2. 全文检索"></a>2. 全文检索</h3><p>全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。</p><p>全文检索的方法主要分为按字检索和按词检索两种。</p><p>按字检索是指对于文章中的每一个字都建立索引，检索时将词分解为字的组合。对于各种不同的语言而言，字有不同的含义，比如英文中字与词实际上是合一的，而中文中字与词有很大分别。按词检索指对文章中的词，即语义单位建立索引，检索时按词检索，并且可以处理同义项等。英文等西方文字由于按照空白切分词，因此实现上与按字处理类似，添加同义处理也很容易。中文等东方文字则需要切分字词，以达到按词索引的目的，关于这方面的问题，是当前全文检索技术尤其是中文全文检索技术中的难点。</p><h3 id="3-倒排索引"><a href="#3-倒排索引" class="headerlink" title="3. 倒排索引"></a>3. 倒排索引</h3><p>以前是根据ID查内容，倒排索引之后是根据内容查ID，然后再拿着ID去查询出来真正需要的东西。</p><p><img src="/images/image_ElasticSearch/01.png"></p><h3 id="4-Lucene"><a href="#4-Lucene" class="headerlink" title="4. Lucene"></a>4. Lucene</h3><p>Lucene就是一个jar包，里面包含了各种建立倒排索引的方法，java开发的时候只需要导入这个jar包就可以开发了。</p><p>ES 和 Lucene的区别:</p><p>Lucene不是分布式的。<br>ES的底层就是Lucene，ES是分布式的</p><h3 id="5-为什么不用数据库去实现搜索功能"><a href="#5-为什么不用数据库去实现搜索功能" class="headerlink" title="5. 为什么不用数据库去实现搜索功能"></a>5. 为什么不用数据库去实现搜索功能</h3><p>我们用搜索“牙膏”商品为例</p><p><img src="/images/image_ElasticSearch/02.png"></p><p>数据库来实现搜索的功能在性能上就很差。</p><h3 id="6-ES的核心概念"><a href="#6-ES的核心概念" class="headerlink" title="6. ES的核心概念"></a>6. ES的核心概念</h3><h4 id="NRT-Near-Realtime-近实时"><a href="#NRT-Near-Realtime-近实时" class="headerlink" title="NRT(Near Realtime)近实时"></a>NRT(Near Realtime)近实时</h4><p><img src="/images/image_ElasticSearch/03.png"></p><h4 id="cluster集群，ES是一个分布式的系统"><a href="#cluster集群，ES是一个分布式的系统" class="headerlink" title="cluster集群，ES是一个分布式的系统"></a>cluster集群，ES是一个分布式的系统</h4><p>ES直接解压不需要配置就可以使用，在hadoop1上解压一个ES，在hadoop2上解压了一个ES，接下来把这两个ES启动起来。他们就构成了一个集群。</p><p>在ES里面默认有一个配置，clustername 默认值就是ElasticSearch,如果这个值是一样的就属于同一个集群，不一样的值就是不一样的集群。</p><h4 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h4><p>就是集群中的一台服务器</p><h4 id="index-索引（索引库）"><a href="#index-索引（索引库）" class="headerlink" title="index 索引（索引库）"></a>index 索引（索引库）</h4><p>我们为什么使用ES？因为想把数据存进去，然后再查询出来。</p><p>我们在使用Mysql或者Oracle的时候，为了区分数据，我们会建立不同的数据库，库下面还有表的。</p><p>其实ES功能就像一个关系型数据库，在这个数据库我们可以往里面添加数据，查询数据。</p><p>ES中的索引非传统索引的含义，ES中的索引是存放数据的地方，是ES中的一个概念词汇</p><p>index类似于我们Mysql里面的一个数据库 create database user; 就像就是一个索引库</p><h4 id="type类型"><a href="#type类型" class="headerlink" title="type类型"></a>type类型</h4><p>类型是用来定义数据结构的</p><p>在每一个index下面，可以有一个或者多个type，就像数据库里面的一张表。</p><p>相当于表结构的描述，描述每个字段的类型。</p><h4 id="document：文档"><a href="#document：文档" class="headerlink" title="document：文档"></a>document：文档</h4><p>文档就是最终的数据了，可以认为一个文档就是一条记录。</p><p>是ES里面最小的数据单元，就像表里面的一条数据</p><h4 id="Field-字段"><a href="#Field-字段" class="headerlink" title="Field 字段"></a>Field 字段</h4><p>就像关系型数据库中列的概念，一个document有一个或者多个field组成。</p><h4 id="shard：分片"><a href="#shard：分片" class="headerlink" title="shard：分片"></a>shard：分片</h4><p>一台服务器，无法存储大量的数据，ES把一个index里面的数据，分为多个shard，分布式的存储在各个服务器上面。</p><p>kafka：为什么支持分布式的功能，因为里面是有topic，还支持分区的概念。所以topic A可以存在不同的节点上面。就可以支持海量数据和高并发，提升性能和吞吐量</p><h4 id="replica：副本"><a href="#replica：副本" class="headerlink" title="replica：副本"></a>replica：副本</h4><p>一个分布式的集群，难免会有一台或者多台服务器宕机，如果没有副本，就会造成我们的shard发生故障，无法提供正常服务。</p><p>为了保证数据的安全，引入了replica的概念</p><p>在ES集群中，我们一模一样的数据有多份，能正常提供查询和插入的分片我们叫做 primary shard，其余的我们就管他们叫做 replica shard（备份的分片） </p><p>当我们去查询数据的时候，我们数据是有备份的，它会同时发出命令让我们有数据的机器去查询结果，最后谁的查询结果快，我们就要谁的数据（这个不需要我们去控制，它内部就自己控制了）</p><h3 id="7-ES写数据过程"><a href="#7-ES写数据过程" class="headerlink" title="7. ES写数据过程"></a>7. ES写数据过程</h3><ul><li>客户端选择一个 node 发送请求过去，这个 node 就是&nbsp;<code>coordinating node</code>（协调节点）。</li><li><code>coordinating node</code>&nbsp;对 document 进行路由，将请求转发给对应的 node（有 primary shard）。</li><li>实际的 node 上的&nbsp;<code>primary shard</code>&nbsp;处理请求，然后将数据同步到&nbsp;<code>replica node</code>。</li><li>  <code>coordinating node</code>&nbsp;如果发现&nbsp;<code>primary node</code>&nbsp;和所有&nbsp;<code>replica node</code>&nbsp;都搞定之后，就返回响应结果给客户端。</li></ul><p><img src="/images/image_ElasticSearch/04.jpg"></p><h3 id="8-写数据底层原理"><a href="#8-写数据底层原理" class="headerlink" title="8. 写数据底层原理"></a>8. 写数据底层原理</h3><p><img src="/images/image_ElasticSearch/05.jpg"></p><p>先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。</p><p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据&nbsp;<code>refresh</code>&nbsp;到一个新的&nbsp;<code>segment file</code>&nbsp;中，但是此时数据不是直接进入&nbsp;<code>segment file</code>&nbsp;磁盘文件，而是先进入&nbsp;<code>os cache</code>&nbsp;。这个过程就是&nbsp;<code>refresh</code>。</p><p>每隔 1 秒钟，es 将 buffer 中的数据写入一个新的&nbsp;<code>segment file</code>，每秒钟会产生一个新的磁盘文件&nbsp;<code>segment file</code>，这个&nbsp;<code>segment file</code>&nbsp;中就存储最近 1 秒内 buffer 中写入的数据。</p><p>但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p><p>操作系统里面，磁盘文件其实都有一个东西，叫做&nbsp;<code>os cache</code>，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入&nbsp;<code>os cache</code>，先进入操作系统级别的一个内存缓存中去。只要&nbsp;<code>buffer</code>中的数据被 refresh 操作刷入&nbsp;<code>os cache</code>中，这个数据就可以被搜索到了。</p><p>为什么叫 es 是准实时的？&nbsp;<code>NRT</code>，全称&nbsp;<code>near real-time</code>。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。可以通过 es 的&nbsp;<code>restful api</code>&nbsp;或者&nbsp;<code>java api</code>，手动执行一次 refresh 操作，就是手动将 buffer 中的数据刷入&nbsp;<code>os cache</code>中，让数据立马就可以被搜索到。只要数据被输入&nbsp;<code>os cache</code>&nbsp;中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</p><p>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将&nbsp;<code>buffer</code>&nbsp;数据写入一个又一个新的&nbsp;<code>segment file</code>&nbsp;中去，每次&nbsp;<code>refresh</code>&nbsp;完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发&nbsp;<code>commit</code>&nbsp;操作。</p><p>commit 操作发生第一步，就是将 buffer 中现有数据&nbsp;<code>refresh</code>&nbsp;到&nbsp;<code>os cache</code>&nbsp;中去，清空 buffer。然后，将一个&nbsp;<code>commit point</code>写入磁盘文件，里面标识着这个&nbsp;<code>commit point</code>&nbsp;对应的所有&nbsp;<code>segment file</code>，同时强行将&nbsp;<code>os cache</code>&nbsp;中目前所有的数据都&nbsp;<code>fsync</code>&nbsp;到磁盘文件中去。最后清空&nbsp;现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</p><p>这个 commit 操作叫做&nbsp;<code>flush</code>。默认 30 分钟自动执行一次&nbsp;<code>flush</code>，但如果 translog 过大，也会触发&nbsp;<code>flush</code>。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</p><p>translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件&nbsp;<code>translog</code>&nbsp;中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</p><p>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会丢失&nbsp;5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接&nbsp;<code>fsync</code>&nbsp;到磁盘，但是性能会差很多。</p><p><strong>总结</strong>：数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。</p><h3 id="9-ES读数据过程"><a href="#9-ES读数据过程" class="headerlink" title="9. ES读数据过程"></a>9. ES读数据过程</h3><p>可以通过&nbsp;<code>doc id</code>&nbsp;来查询，会根据&nbsp;<code>doc id</code>&nbsp;进行 hash，判断出来当时把&nbsp;<code>doc id</code>&nbsp;分配到了哪个 shard 上面去，从那个 shard 去查询。</p><ul><li>客户端发送请求到任意一个 node，成为&nbsp;<code>coordinate node</code>。</li><li><code>coordinate node</code>&nbsp;对&nbsp;<code>doc id</code>&nbsp;进行哈希路由，将请求转发到对应的 node，此时会使用&nbsp;<code>round-robin</code>随机轮询算法，在&nbsp;<code>primary shard</code>&nbsp;以及其所有 replica 中随机选择一个，让读请求负载均衡。</li><li>接收请求的 node 返回 document 给&nbsp;<code>coordinate node</code>。</li><li>  <code>coordinate node</code>&nbsp;返回 document 给客户端。</li></ul><blockquote><p>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或replica shard 读取，采用的是随机轮询算法。</p></blockquote><h3 id="10-ES搜索数据过程"><a href="#10-ES搜索数据过程" class="headerlink" title="10. ES搜索数据过程"></a>10. ES搜索数据过程</h3><p>es 最强大的是做全文检索，就是比如有三条数据：</p><p><code>java真好玩儿啊</code><br><code>java好难学啊</code><br><code>j2ee特别牛</code></p><p>根据&nbsp;<code>java</code>&nbsp;关键词来搜索，将包含&nbsp;<code>java</code>的&nbsp;<code>document</code>&nbsp;给搜索出来。es 就会给你返回：java真好玩儿啊，java好难学啊。</p><ul><li>客户端发送请求到一个&nbsp;<code>coordinate node</code>。</li><li>协调节点将搜索请求转发到所有的 shard 对应的&nbsp;<code>primary shard</code>&nbsp;或&nbsp;<code>replica shard</code>，都可以。</li><li>query phase：每个 shard 将自己的搜索结果（其实就是一些&nbsp;<code>doc id</code>）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li><li>  fetch phase：接着由协调节点根据&nbsp;<code>doc id</code>&nbsp;去各个节点上拉取实际的&nbsp;<code>document</code>&nbsp;数据，最终返回给客户端。</li></ul><h3 id="11-删除-更新数据底层原理"><a href="#11-删除-更新数据底层原理" class="headerlink" title="11. 删除/更新数据底层原理"></a>11. 删除/更新数据底层原理</h3><p>如果是删除操作，commit 的时候会生成一个&nbsp;<code>.del</code>&nbsp;文件，里面将某个 doc 标识为&nbsp;<code>deleted</code>&nbsp;状态，那么搜索的时候根据&nbsp;<code>.del</code>&nbsp;文件就知道这个 doc 是否被删除了。</p><p>如果是更新操作，就是将原来的 doc 标识为&nbsp;<code>deleted</code>&nbsp;状态，然后新写入一条数据。</p><p>buffer 每 refresh 一次，就会产生一个&nbsp;<code>segment file</code>，所以默认情况下是 1 秒钟一个&nbsp;<code>segment file</code>，这样下来&nbsp;<code>segment file</code>&nbsp;会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个&nbsp;<code>segment file</code>&nbsp;合并成一个，同时这里会将标识为&nbsp;<code>deleted</code>&nbsp;的 doc 给物理删除掉，然后将新的&nbsp;<code>segment file</code>&nbsp;写入磁盘，这里会写一个&nbsp;<code>commit point</code>，标识所有新的&nbsp;<code>segment file</code>，然后打开&nbsp;<code>segment file</code>&nbsp;供搜索使用，同时删除旧的&nbsp;<code>segment file</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-ElasticSearch的简介&quot;&gt;&lt;a href=&quot;#1-ElasticSearch的简介&quot; class=&quot;headerlink&quot; title=&quot;1. ElasticSearch的简介&quot;&gt;&lt;/a&gt;1. ElasticSearch的简介&lt;/h3&gt;&lt;p&gt;Elas</summary>
      
    
    
    
    
    <category term="ElasticSearch" scheme="http://ailiaa.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://ailiaa.github.io/2023/03/15/kafka/"/>
    <id>http://ailiaa.github.io/2023/03/15/kafka/</id>
    <published>2023-03-15T07:33:26.000Z</published>
    <updated>2023-03-15T08:05:31.611Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是消息队列"><a href="#1-什么是消息队列" class="headerlink" title="1. 什么是消息队列"></a>1. 什么是消息队列</h3><p>可以把消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。由于队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。</p><p>参与消息传递的双方称为&nbsp;<strong>生产者</strong>&nbsp;和&nbsp;<strong>消费者</strong>&nbsp;，生产者负责发送消息，消费者负责处理消息。</p><p>操作系统中的进程通信的一种很重要的方式就是消息队列。我们这里提到的消息队列稍微有点区别，更多指的是各个服务以及系统内部各个组件/模块之前的通信，属于一种&nbsp;<strong>中间件</strong>&nbsp;。</p><h3 id="2-消息队列的作用"><a href="#2-消息队列的作用" class="headerlink" title="2. 消息队列的作用"></a>2. 消息队列的作用</h3><p>通常来说，使用消息队列能为我们的系统带来下面三点好处：</p><ol><li> <strong>通过异步处理提高系统性能（减少响应所需时间）</strong></li><li> <strong>削峰/限流</strong></li><li> <strong>降低系统耦合性。</strong></li></ol><h3 id="3-使用消息队列会带来哪些问题"><a href="#3-使用消息队列会带来哪些问题" class="headerlink" title="3. 使用消息队列会带来哪些问题"></a>3. 使用消息队列会带来哪些问题</h3><ul><li>  <strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li><li>  <strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li>  <strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了</li></ul><h3 id="4-JMS-和-AMQP"><a href="#4-JMS-和-AMQP" class="headerlink" title="4. JMS 和 AMQP"></a>4. JMS 和 AMQP</h3><h4 id="JMS-是什么"><a href="#JMS-是什么" class="headerlink" title="JMS 是什么"></a>JMS 是什么</h4><p>JMS（JAVA Message Service,java 消息服务）是 Java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。<strong>JMS（JAVA Message Service，Java 消息服务）API 是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p><p>JMS 定义了五种不同的消息正文格式以及调用的消息类型，允许你发送并接收以一些不同形式的数据：</p><ul><li>  <code>StreamMessage：Java</code> 原始值的数据流</li><li>  <code>MapMessage</code>：一套名称-值对</li><li>  <code>TextMessage</code>：一个字符串对象</li><li>  <code>ObjectMessage</code>：一个序列化的 Java 对象</li><li>  <code>BytesMessage</code>：一个字节的数据流</li></ul><h4 id="JMS-两种消息模型"><a href="#JMS-两种消息模型" class="headerlink" title="JMS 两种消息模型"></a>JMS 两种消息模型</h4><h5 id="点到点（P2P）模型"><a href="#点到点（P2P）模型" class="headerlink" title="点到点（P2P）模型"></a>点到点（P2P）模型</h5><p><img src="/images/image_Kafka/01.png"></p><p>使用<strong>队列（Queue）</strong>作为消息通信载体；满足<strong>生产者与消费者模式</strong>，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。</p><h5 id="发布-订阅（Pub-Sub）模型"><a href="#发布-订阅（Pub-Sub）模型" class="headerlink" title="发布/订阅（Pub/Sub）模型"></a>发布/订阅（Pub/Sub）模型</h5><p><img src="/images/image_Kafka/02.png"></p><p>发布订阅模型（Pub/Sub） 使用<strong>主题（Topic）</strong>作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p><h4 id="AMQP-是什么"><a href="#AMQP-是什么" class="headerlink" title="AMQP 是什么"></a>AMQP 是什么</h4><p>AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</p><p><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></p><h4 id="JMS-vs-AMQP"><a href="#JMS-vs-AMQP" class="headerlink" title="JMS vs AMQP"></a>JMS vs AMQP</h4><p><img src="/images/image_Kafka/03.png"></p><p><strong>总结：</strong></p><ul><li>  AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。</li><li>  JMS 支持 <code>TextMessage</code>、<code>MapMessage</code> 等复杂的消息类型；而 AMQP 仅支持 <code>byte[]</code> 消息类型（复杂的类型可序列化后发送）。</li><li>  由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。</li></ul><h3 id="4-RPC-远程过程调用协议-和消息队列的区别"><a href="#4-RPC-远程过程调用协议-和消息队列的区别" class="headerlink" title="4. RPC( 远程过程调用协议 )和消息队列的区别"></a>4. RPC( 远程过程调用协议 )和消息队列的区别</h3><p>RPC 和消息队列都是分布式微服务系统中重要的组件之一，下面我们来简单对比一下两者：</p><ul><li>  <strong>从用途来看</strong> ：RPC 主要用来解决两个服务的远程通信问题，不需要了解底层网络的通信机制。通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。消息队列主要用来降低系统耦合性、实现任务异步、有效地进行流量削峰。</li><li>  <strong>从通信方式来看</strong> ：RPC 是双向直接网络通讯，消息队列是单向引入中间载体的网络通讯。</li><li>  <strong>从架构上来看</strong> ：消息队列需要把消息存储起来，RPC 则没有这个要求，因为前面也说了 RPC 是双向直接网络通讯。</li><li>  <strong>从请求处理的时效性来看</strong> ：通过 RPC 发出的调用一般会立即被处理，存放在消息队列中的消息并不一定会立即被处理。</li></ul><p>RPC 和消息队列本质上是网络通讯的两种不同的实现机制，两者的用途不同，万不可将两者混为一谈。</p><h3 id="5-Kafka-是什么？主要应用场景有哪些"><a href="#5-Kafka-是什么？主要应用场景有哪些" class="headerlink" title="5. Kafka 是什么？主要应用场景有哪些"></a>5. Kafka 是什么？主要应用场景有哪些</h3><p>Kafka 是一个分布式流式处理平台。</p><p>流平台具有三个关键功能：</p><ol><li> <strong>消息队列</strong>：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li><li> <strong>容错的持久方式存储记录消息流</strong>： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</li><li> <strong>流式处理平台：</strong> 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li></ol><p>Kafka 主要有两大应用场景：</p><ol><li> <strong>消息队列</strong> ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li><li> <strong>数据处理：</strong> 构建实时的流数据处理程序来转换或处理数据流</li></ol><h3 id="6-Kafka的优势"><a href="#6-Kafka的优势" class="headerlink" title="6. Kafka的优势"></a>6. Kafka的优势</h3><p>我们现在经常提到 Kafka 的时候就已经默认它是一个非常优秀的消息队列了，我们也会经常拿它跟 RocketMQ、RabbitMQ 对比。：</p><ol><li> <strong>极致的性能</strong> ：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。</li><li> <strong>生态系统兼容性无可匹敌</strong> ：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。</li></ol><h3 id="7-什么是Producer、Consumer、Broker、Topic、Partition"><a href="#7-什么是Producer、Consumer、Broker、Topic、Partition" class="headerlink" title="7. 什么是Producer、Consumer、Broker、Topic、Partition"></a>7. 什么是Producer、Consumer、Broker、Topic、Partition</h3><p><strong>Kafka 采用的是发布 - 订阅模型。</strong></p><p>Kafka 将生产者发布的消息发送到&nbsp;<strong>Topic（主题）</strong>&nbsp;中，需要这些消息的消费者可以订阅这些&nbsp;<strong>Topic（主题）</strong>，如下图所示：</p><p><img src="/images/image_Kafka/04.png"></p><p>上面这张图也为我们引出了，Kafka 比较重要的几个概念：</p><ol><li> <strong>Producer（生产者）</strong> : 产生消息的一方。</li><li> <strong>Consumer（消费者）</strong> : 消费消息的一方。</li><li> <strong>Broker（代理）</strong> : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</li></ol><p>每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：</p><ul><li>  <strong>Topic（主题）</strong> : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</li><li>  <strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。这正如我上面所画的图一样。</li></ul><blockquote><p><strong>Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。</strong></p></blockquote><h3 id="8-Kafka-的多副本机制"><a href="#8-Kafka-的多副本机制" class="headerlink" title="8. Kafka 的多副本机制"></a>8. Kafka 的多副本机制</h3><p>Kafka 为分区（Partition）引入了多副本（Replica）机制。</p><p>分区（Partition）中的多个副本之间会有一个叫做 leader 的，其他副本称为 follower。</p><p>我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p><blockquote><p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader,但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p></blockquote><p><strong>Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢</strong></p><ol><li> Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。</li><li> Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li></ol><h3 id="9-Zookeeper-在-Kafka-中的作用"><a href="#9-Zookeeper-在-Kafka-中的作用" class="headerlink" title="9. Zookeeper 在 Kafka 中的作用"></a>9. Zookeeper 在 Kafka 中的作用</h3><ul><li>  <strong>Broker 注册</strong> ：在 Zookeeper 上会有一个专门<strong>用来进行 Broker 服务器列表记录</strong>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 <code>/brokers/ids</code> 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li><li>  <strong>Topic 注册</strong> ： 在 Kafka 中，同一个<strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></li><li>  <strong>负载均衡</strong> ：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li></ul><h3 id="10-Kafka-如何保证消息的消费顺序？"><a href="#10-Kafka-如何保证消息的消费顺序？" class="headerlink" title="10. Kafka 如何保证消息的消费顺序？"></a>10. Kafka 如何保证消息的消费顺序？</h3><p>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p><ol><li> 更改用户会员等级。</li><li> 根据会员等级计算订单价格。</li></ol><p>假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p><p>我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。</p><p><img src="/images/image_Kafka/05.png"></p><p>每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 <strong>Kafka 只能为我们保证 Partition(分区) 中的消息有序。</strong></p><blockquote><p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p></blockquote><p>所以，我们就有一种很简单的保证消息消费顺序的方法：<strong>1 个 Topic 只对应一个 Partition</strong>。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p><p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 id 来作为 key 。</p><p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p><ol><li> 1 个 Topic 只对应一个 Partition。</li><li> （推荐）发送消息的时候指定 key/Partition。</li></ol><h3 id="11-Kafka-如何保证消息不丢失"><a href="#11-Kafka-如何保证消息不丢失" class="headerlink" title="11. Kafka 如何保证消息不丢失"></a>11. Kafka 如何保证消息不丢失</h3><h4 id="生产者丢失消息的情况"><a href="#生产者丢失消息的情况" class="headerlink" title="生产者丢失消息的情况"></a>生产者丢失消息的情况</h4><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p><p>所以，不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。为了确定消息是发送成功，要判断消息发送的结果。但是要注意的是 Kafka 生产者(Producer) 使用 <code>send</code> 方法发送消息实际上是异步的操作，可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SendResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> sendResult <span class="token operator">=</span> kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sendResult<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"生产者成功发送消息到"</span> <span class="token operator">+</span> sendResult<span class="token punctuation">.</span><span class="token function">getProducerRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-&gt; "</span> <span class="token operator">+</span> sendRe              sult<span class="token punctuation">.</span><span class="token function">getProducerRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ListenableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SendResult</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>future<span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span>result <span class="token operator">-&gt;</span> logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"生产者成功发送消息到topic:{} partition:{}的消息"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        ex <span class="token operator">-&gt;</span> logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"生产者发送消失败，原因：{}"</span><span class="token punctuation">,</span> ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p><p><strong>这里推荐为 Producer 的<code>retries</code> （重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你3次一下子就重试完了</strong></p><h4 id="消费者丢失消息的情况"><a href="#消费者丢失消息的情况" class="headerlink" title="消费者丢失消息的情况"></a>消费者丢失消息的情况</h4><p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p><p><img src="/images/image_Kafka/06.jpg"></p><p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p><p><strong>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。</strong> 但是，这样会带来消息被重新消费的问题。比如刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p><h4 id="Kafka-弄丢了消息"><a href="#Kafka-弄丢了消息" class="headerlink" title="Kafka 弄丢了消息"></a>Kafka 弄丢了消息</h4><p>Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p><p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p><p><strong>设置 acks = all</strong></p><p>解决办法就是我们设置 <strong>acks = all</strong>。acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p><p>acks 的默认值即为1，代表我们的消息被leader副本接收之后就算被成功发送。当我们配置 <strong>acks = all</strong> 表示只有所有 ISR 列表的副本全部收到消息时，生产者才会接收到来自服务器的响应. 这种模式是最高级别的，也是最安全的，可以确保不止一个 Broker 接收到了消息. 该模式的延迟会很高.</p><p><strong>设置 replication.factor &gt;= 3</strong></p><p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;= 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p><p><strong>设置 min.insync.replicas &gt; 1</strong></p><p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p><p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor = min.insync.replicas + 1</strong>。</p><p><strong>设置 unclean.leader.election.enable = false</strong></p><p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 <strong>unclean.leader.election.enable = false</strong> 的话，当 leader 副本发生故障时就不会从 follower 副本中和 leader 同步程度达不到要求的副本中选择出 leader ，这样降低了消息丢失的可能性。</p><h3 id="12-Kafka-如何保证消息不重复消费"><a href="#12-Kafka-如何保证消息不重复消费" class="headerlink" title="12. Kafka 如何保证消息不重复消费"></a>12. Kafka 如何保证消息不重复消费</h3><p><strong>kafka出现消息重复消费的原因：</strong></p><ul><li>  服务端侧已经消费的数据没有成功提交 offset（根本原因）。</li><li>  Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。</li></ul><p><strong>解决方案：</strong></p><ul><li>  消费消息服务做幂等校验，比如 Redis 的set、MySQL 的主键等天然的幂等功能。这种方法最有效。</li><li>将 <strong><code>enable.auto.commit</code></strong> 参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：<strong>什么时候提交offset合适？</strong><ul><li>  处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li><li>  拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-什么是消息队列&quot;&gt;&lt;a href=&quot;#1-什么是消息队列&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是消息队列&quot;&gt;&lt;/a&gt;1. 什么是消息队列&lt;/h3&gt;&lt;p&gt;可以把消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取</summary>
      
    
    
    
    
    <category term="Kafka" scheme="http://ailiaa.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot</title>
    <link href="http://ailiaa.github.io/2023/03/12/spring-boot/"/>
    <id>http://ailiaa.github.io/2023/03/12/spring-boot/</id>
    <published>2023-03-12T09:23:44.000Z</published>
    <updated>2023-05-27T08:28:01.096Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-对Spring-Boot的理解"><a href="#1-对Spring-Boot的理解" class="headerlink" title="1. 对Spring Boot的理解"></a>1. 对Spring Boot的理解</h3><p>从本质上来说，Spring Boot就是Spring，它做了那些没有它你自己也会去做的Spring Bean配置。Spring Boot使用“习惯优于配置”的理念让你的项目快速地运行起来，使用Spring Boot很容易创建一个能独立运行、准生产级别、基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。</p><p>简而言之，Spring Boot本身并不提供Spring的核心功能，而是作为Spring的脚手架框架，以达到快速构建项目、预置三方配置、开箱即用的目的。Spring Boot有如下的优点：</p><ul><li>可以快速构建项目；</li><li>可以对主流开发框架的无配置集成；</li><li>项目可独立运行，无需外部依赖Servlet容器；</li><li>提供运行时的应用监控；</li><li>可以极大地提高开发、部署效率；</li><li>  可以与云计算天然集成。</li></ul><h3 id="2-Spring-Boot-Starter的作用"><a href="#2-Spring-Boot-Starter的作用" class="headerlink" title="2. Spring Boot Starter的作用"></a>2. Spring Boot Starter的作用</h3><p>Spring Boot项目通过Spring Boot Starter导入包</p><p>Spring Boot通过提供众多起步依赖（Starter）<strong>降低项目依赖的复杂度</strong>。起步依赖本质上是一个Maven项目对象模型（Project Object Model, POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或某类功能。</p><p>举例来说，你打算把这个阅读列表应用程序做成一个Web应用程序。与其向项目的构建文件里添加一堆单独的库依赖，还不如声明这是一个Web应用程序来得简单。你只要添加Spring Boot的Web起步依赖就好了。</p><h3 id="3-Spring-Boot的启动流程"><a href="#3-Spring-Boot的启动流程" class="headerlink" title="3. Spring Boot的启动流程"></a>3. Spring Boot的启动流程</h3><p>首先，Spring Boot项目创建完成会默认生成一个名为&nbsp;*Application&nbsp;的入口类，我们是通过该类的main方法启动Spring Boot项目的。在main方法中，通过SpringApplication的静态方法，即run方法进行SpringApplication类的实例化操作，然后再针对实例化对象调用另外一个run方法来完成整个项目的初始化和启动。</p><p>SpringApplication调用的run方法的大致流程，如下图：</p><p><img src="/images/image_Spring/08.jpg"></p><p>其中，SpringApplication在run方法中重点做了以下操作：</p><ul><li>获取监听器和参数配置；</li><li>打印Banner信息；</li><li>创建并初始化容器；</li><li>监听器发送通知。</li></ul><p>当然，除了上述核心操作，run方法运行过程中还涉及启动时长统计、异常报告、启动日志、异常处理等辅助操作。</p><h3 id="4-Spring-Boot自动装配的过程"><a href="#4-Spring-Boot自动装配的过程" class="headerlink" title="4. Spring Boot自动装配的过程"></a>4. Spring Boot自动装配的过程</h3><p>使用Spring Boot时，我们只需引入对应的Starters，Spring Boot启动时便会自动加载相关依赖，配置相应的初始化参数，以最快捷、简单的形式对第三方软件进行集成，这便是Spring Boot的自动配置功能。Spring Boot实现该运作机制锁涉及的核心部分如下图所示：</p><p><img src="/images/image_Spring/09.jpg"></p><p>整个自动装配的过程是：Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类，当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。</p><h3 id="5-Spring-Boot常用注解"><a href="#5-Spring-Boot常用注解" class="headerlink" title="5. Spring Boot常用注解"></a>5. Spring Boot常用注解</h3><ol><li>@SpringBootApplication：该注解是Spring Boot项目的入口注解，用于标识一个类是Spring Boot的主配置类。</li><li>@RestController：该注解用于创建RESTful风格的Controller，相当于@Controller和@ResponseBody的组合。</li><li>@GetMapping/@PostMapping：这两个注解用于处理HTTP GET/POST请求，根据请求路径匹配到相应的处理方法。</li><li>@PathVariable：该注解配合@RequestMapping使用，用于获取URL路径中的参数值。</li><li>@RequestParam：该注解也配合@RequestMapping使用，用于获取请求参数的值。</li><li>@Autowired：该注解用于自动装配一个Bean，Spring容器会自动找到合适的Bean进行注入。</li><li>@ConfigurationProperties：该注解用于将配置文件中的属性值注入到Java Bean中。</li><li>@EnableAutoConfiguration：该注解用于自动配置Spring Boot应用程序，它会根据classpath中的jar包和当前环境的情况来决定项目的配置。</li><li>@Component：该注解用于将一个普通的Java类定义为一个Bean，使其能够被Spring容器管理。</li><li>@SpringBootTest：该注解用于测试Spring Boot应用程序，可以模拟出完整的Web服务接口供测试调用。</li></ol><h3 id="6-Mybatis"><a href="#6-Mybatis" class="headerlink" title="6. Mybatis"></a>6. Mybatis</h3><p>MyBatis底层技术主要包括以下几个方面：</p><ol><li>JDBC：JDBC是Java语言中用于访问关系型数据库的API，MyBatis框架基于JDBC技术来实现与数据库的交互。MyBatis使用JDBC来执行SQL语句和处理结果集，同时还通过JDBC提供了事务管理支持。</li><li>SQL解析：MyBatis使用OGNL表达式语言进行SQL解析。在XML中配置的SQL语句会被解析成一个可执行的SQL对象。该SQL对象中存储了SQL语句的各种信息（例如参数、返回值等），以及与之对应的Java类和属性信息。</li><li>映射器：MyBatis使用映射器（Mapper）来定义SQL语句与Java类之间的映射关系。映射器中定义了方法与SQL语句之间的对应关系，以及方法的返回值类型等信息。MyBatis可以通过注解或XML文件来定义映射器。</li><li>缓存：MyBatis提供了强大的缓存机制，缓存可以大幅提高系统性能。MyBatis支持一级缓存和二级缓存。一级缓存指的是SqlSession级别的缓存，二级缓存指的是Mapper级别的缓存。</li><li>插件机制：MyBatis提供了插件机制，可以在框架的运行过程中对SQL语句进行拦截和修改。开发人员可以通过插件机制拓展MyBatis的功能，提高框架的灵活性和可扩展性。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-对Spring-Boot的理解&quot;&gt;&lt;a href=&quot;#1-对Spring-Boot的理解&quot; class=&quot;headerlink&quot; title=&quot;1. 对Spring Boot的理解&quot;&gt;&lt;/a&gt;1. 对Spring Boot的理解&lt;/h3&gt;&lt;p&gt;从本质上来说，S</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://ailiaa.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="http://ailiaa.github.io/2023/03/12/spring/"/>
    <id>http://ailiaa.github.io/2023/03/12/spring/</id>
    <published>2023-03-12T08:13:32.000Z</published>
    <updated>2023-05-27T08:27:14.027Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Spring-包含的模块有哪些？"><a href="#1-Spring-包含的模块有哪些？" class="headerlink" title="1. Spring 包含的模块有哪些？"></a>1. Spring 包含的模块有哪些？</h3><p><img src="/images/image_Spring/01.png"></p><h4 id="Core-Container"><a href="#Core-Container" class="headerlink" title="Core Container"></a>Core Container</h4><p>Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。</p><ul><li>  <strong>spring-core</strong> ：Spring 框架基本的核心工具类。</li><li>  <strong>spring-beans</strong> ：提供对 bean 的创建、配置和管理等功能的支持。</li><li>  <strong>spring-context</strong> ：提供对国际化、事件传播、资源加载等功能的支持。</li><li>  <strong>spring-expression</strong> ：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li></ul><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><ul><li>  <strong>spring-aspects</strong> ：该模块为与 AspectJ 的集成提供支持。</li><li>  <strong>spring-aop</strong> ：提供了面向切面的编程实现。</li><li>  <strong>spring-instrument</strong> ：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。</li></ul><h4 id="Data-Access-Integration"><a href="#Data-Access-Integration" class="headerlink" title="Data Access/Integration"></a>Data Access/Integration</h4><ul><li>  <strong>spring-jdbc</strong> ：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li>  <strong>spring-tx</strong> ：提供对事务的支持。</li><li>  <strong>spring-orm</strong> ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。</li><li>  <strong>spring-oxm</strong> ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li><li>  <strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</li></ul><h4 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h4><ul><li>  <strong>spring-web</strong> ：对 Web 功能的实现提供一些最基础的支持。</li><li>  <strong>spring-webmvc</strong> ： 提供对 Spring MVC 的实现。</li><li>  <strong>spring-websocket</strong> ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li>  <strong>spring-webflux</strong> ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。</li></ul><h4 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h4><p><strong>spring-messaging</strong> 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</p><h4 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h4><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p><h3 id="2-Spring的核心是什么"><a href="#2-Spring的核心是什么" class="headerlink" title="2. Spring的核心是什么"></a>2. Spring的核心是什么</h3><p>Spring框架包含众多模块，如Core、Testing、Data Access、Web Servlet等，其中Core是整个Spring框架的核心模块。Core模块提供了IoC容器、AOP功能、数据绑定、类型转换等一系列的基础功能，而这些功能以及其他模块的功能都是建立在IoC和AOP之上的，所以IoC和AOP是Spring框架的核心。</p><p>IoC（Inversion of Control）是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。</p><p>说到IoC就不得不说DI（Dependency Injection），DI是依赖注入的意思，它是IoC实现的实现方式，就是说IoC是通过DI来实现的。由于IoC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。</p><p>AOP（Aspect Oriented Programing）是面向切面编程思想，这种思想是对OOP的补充，它可以在OOP的基础上进一步提高编程的效率。简单来说，它可以统一解决一批组件的共性需求（如权限检查、记录日志、事务管理等）。在AOP思想下，我们可以将解决共性需求的代码独立出来，然后通过配置的方式，声明这些代码在什么地方、什么时机调用。当满足调用条件时，AOP会将该业务代码织入到我们指定的位置，从而统一解决了问题，又不需要修改这一批组件的代码。</p><h3 id="3-Spring容器"><a href="#3-Spring容器" class="headerlink" title="3. Spring容器"></a>3. Spring容器</h3><p>Spring主要提供了两种类型的容器：BeanFactory和ApplicationContext。</p><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><ul><li>  BeanFactory：是基础类型的IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延&nbsp;迟初始化策略。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。</li></ul><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><ul><li>  ApplicationContext：它是在BeanFactory的基础上构建的，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容&nbsp;器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。</li></ul><h3 id="4-Spring-Spring-MVC-Spring-Boot-之间的关系"><a href="#4-Spring-Spring-MVC-Spring-Boot-之间的关系" class="headerlink" title="4. Spring,Spring MVC,Spring Boot 之间的关系"></a>4. Spring,Spring MVC,Spring Boot 之间的关系</h3><p>Spring 包含了多个功能模块（上面刚刚提到过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p><p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</p><h3 id="5-Spring-IoC"><a href="#5-Spring-IoC" class="headerlink" title="5.  Spring IoC"></a>5.  Spring IoC</h3><h4 id="什么是IoC"><a href="#什么是IoC" class="headerlink" title="什么是IoC"></a>什么是IoC</h4><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><p><strong>为什么叫控制反转？</strong></p><ul><li>  <strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li><li>  <strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p><img src="/images/image_Spring/02.png"></p><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><h4 id="什么是-Spring-Bean？"><a href="#什么是-Spring-Bean？" class="headerlink" title="什么是 Spring Bean？"></a>什么是 Spring Bean？</h4><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Constructor-arg with 'value' attribute --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="将一个类声明为-Bean-的注解"><a href="#将一个类声明为-Bean-的注解" class="headerlink" title="将一个类声明为 Bean 的注解"></a>将一个类声明为 Bean 的注解</h4><ul><li>  <code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li>  <code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li>  <code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li>  <code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面。</li></ul><h4 id="Component-和-Bean-的区别"><a href="#Component-和-Bean-的区别" class="headerlink" title="@Component 和 @Bean 的区别"></a>@Component 和 @Bean 的区别</h4><ul><li>  <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li>  <code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li>  <code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ul><p><code>@Bean</code>注解使用示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">TransferService</span> <span class="token function">transferService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TransferServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码相当于下面的 xml 配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transferService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.acme.TransferServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">OneService</span> <span class="token function">getService</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>  <span class="token punctuation">{</span>        when <span class="token number">1</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        when <span class="token number">2</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        when <span class="token number">3</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注入-Bean-的注解"><a href="#注入-Bean-的注解" class="headerlink" title="注入 Bean 的注解"></a>注入 Bean 的注解</h4><p>Spring 内置的&nbsp;<code>@Autowired</code>&nbsp;以及 JDK 内置的&nbsp;<code>@Resource</code>&nbsp;和&nbsp;<code>@Inject</code>&nbsp;都可以用于注入 Bean。</p><p><code>@Autowired</code> 和<code>@Resource</code>使用的比较多一些。</p><h4 id="Autowired-和-Resource-的区别"><a href="#Autowired-和-Resource-的区别" class="headerlink" title="@Autowired 和 @Resource 的区别"></a>@Autowired 和 @Resource 的区别</h4><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p><p><strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p><p>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 <code>smsService</code> 就是我这里所说的名称，这样应该比较好理解了吧。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// smsService 就是我们上面所说的名称</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>举个例子，<code>SmsService</code> 接口有两个实现类: <code>SmsServiceImpl1</code>和 <code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 报错，byName 和 byType 都无法匹配到 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsServiceImpl1<span class="token punctuation">;</span><span class="token comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><span class="token comment">// smsServiceImpl1 就是我们上面所说的名称</span><span class="token annotation punctuation">@Autowired</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"smsServiceImpl1"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还是建议通过 <code>@Qualifier</code> 注解来显式指定名称而不是依赖变量的名称。</p><p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p><p><code>@Resource</code> 有两个比较重要且日常开发常用的属性：<code>name</code>（名称）、<code>type</code>（类型）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Resource</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果仅指定 <code>name</code> 属性则注入方式为<code>byName</code>，如果仅指定<code>type</code>属性则注入方式为<code>byType</code>，如果同时指定<code>name</code> 和<code>type</code>属性（不建议这么做）则注入方式为<code>byType</code>+<code>byName</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 报错，byName 和 byType 都无法匹配到 bean</span><span class="token annotation punctuation">@Resource</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><span class="token annotation punctuation">@Resource</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsServiceImpl1<span class="token punctuation">;</span><span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span><span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"smsServiceImpl1"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单总结一下：</p><ul><li>  <code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li><li>  <code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li><li>  当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</li></ul><h4 id="三种注入方式"><a href="#三种注入方式" class="headerlink" title="三种注入方式"></a>三种注入方式</h4><ol><li>构造方法注入 就是被注入对象可以在它的构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。然后，IoC Service Provider会检查被注入的对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。</li><li>setter方法注入 通过setter方法，可以更改相应的对象属性。所以，当前对象只要为其依赖对象所对应的属性添加setter方法，就可以通过setter方法将相应的依赖对象设置到被注入对象中。setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些，&nbsp;可以在对象构造完成后再注入。</li><li>接口注入 相对于前两种注入方式来说，接口注入没有那么简单明了。被注入对象如果想要IoC Service Provider为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。IoC Service Provider最终通过这些接口来了解应该为被注入对象注入什么依赖对象。相对于前两种依赖注入方式，接口注入比较死板和烦琐。</li></ol><p>总体来说，构造方法注入和setter方法注入因为其侵入性较弱，且易于理解和使用，所以是现在使用最多的注入方式。而接口注入因为侵入性较强，近年来已经不流行了。</p><h4 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h4><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li>  <strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li>  <strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li>  <strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li>  <strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li>  <strong>application/global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li>  <strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><p><strong>如何配置 bean 的作用域呢？</strong></p><p>xml 方式：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>singleton<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注解方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ConfigurableBeanFactory</span><span class="token punctuation">.</span><span class="token constant">SCOPE_PROTOTYPE</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">personPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="单例-Bean-的线程安全问题"><a href="#单例-Bean-的线程安全问题" class="headerlink" title="单例 Bean 的线程安全问题"></a>单例 Bean 的线程安全问题</h4><p>单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p><p>常见的有两种解决办法：</p><ol><li> 在 Bean 中尽量避免定义可变的成员变量。</li><li> 在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ol><p>不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p><h4 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h4><ul><li>  实例化 Instantiation</li><li>  属性赋值 Populate</li><li>  初始化 Initialization</li><li>  销毁 Destruction</li></ul><p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">Object</span> <span class="token function">doCreateBean</span><span class="token punctuation">(</span><span class="token class-name">String</span> beanName<span class="token punctuation">,</span> <span class="token class-name">RootBeanDefinition</span> mbd<span class="token punctuation">,</span> <span class="token annotation punctuation">@Nullable</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">BeanCreationException</span> <span class="token punctuation">{</span>    <span class="token class-name">BeanWrapper</span> instanceWrapper <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>mbd<span class="token punctuation">.</span><span class="token function">isSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        instanceWrapper <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">BeanWrapper</span><span class="token punctuation">)</span><span class="token keyword">this</span><span class="token punctuation">.</span>factoryBeanInstanceCache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>beanName<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>instanceWrapper <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 实例化阶段</span>        instanceWrapper <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">createBeanInstance</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token class-name">Object</span> exposedObject <span class="token operator">=</span> bean<span class="token punctuation">;</span>    <span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// 属性赋值阶段</span>        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">populateBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> mbd<span class="token punctuation">,</span> instanceWrapper<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 初始化阶段</span>        exposedObject <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">initializeBean</span><span class="token punctuation">(</span>beanName<span class="token punctuation">,</span> exposedObject<span class="token punctuation">,</span> mbd<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">Throwable</span> var18<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    <span class="token punctuation">}</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_Spring/10.webp"></p><ol><li> <strong>Spring启动，查找并加载需要被Spring管理的bean，进行Bean的实例化</strong></li><li> <strong>Bean实例化后对将Bean的引入和值注入到Bean的属性中</strong></li><li> <strong>如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法</strong></li><li> <strong>如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入</strong></li><li> <strong>如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来</strong></li><li> <strong>如果Bean实现了BeanPostProcessor接口，Spring就将调用他们的postProcessBeforeInitialization()方法。</strong></li><li> <strong>如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用</strong></li><li> <strong>如果Bean 实现了BeanPostProcessor接口，Spring就将调用他们的postProcessAfterInitialization()方法。</strong></li><li> <strong>此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。</strong></li><li> <strong>如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。</strong></li></ol><h3 id="6-Spring-AoP"><a href="#6-Spring-AoP" class="headerlink" title="6. Spring AoP"></a>6. Spring AoP</h3><h4 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h4><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="/images/image_Spring/04.jpg"></p><p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><p>AOP 切面编程设计到的一些专业术语：</p><p><img src="/images/image_Spring/05.png"></p><h4 id="CGLib和JDK-Proxy的区别"><a href="#CGLib和JDK-Proxy的区别" class="headerlink" title="CGLib和JDK Proxy的区别"></a>CGLib和JDK Proxy的区别</h4><p>在性能方面，CGLib创建的代理对象比JDK动态代理创建的代理对象高很多。</p><p>但是，CGLib在创建代理对象时所花费的时间比JDK动态代理多很多。</p><p>所以，对于单例的对象因为无需频繁创建代理对象，采用CGLib动态代理比较合适。反之，对于多例的对象因为需要频繁的创建代理对象，则JDK动态代理更合适。</p><h4 id="Spring-AOP-和-AspectJ-AOP-的区别"><a href="#Spring-AOP-和-AspectJ-AOP-的区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 的区别"></a>Spring AOP 和 AspectJ AOP 的区别</h4><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p><h4 id="AspectJ-定义的通知类型"><a href="#AspectJ-定义的通知类型" class="headerlink" title="AspectJ 定义的通知类型"></a>AspectJ 定义的通知类型</h4><ul><li>  <strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</li><li>  <strong>After</strong> （后置通知）：目标对象的方法调用之后触发</li><li>  <strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li><li>  <strong>AfterThrowing</strong>（异常通知） ：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li><li>  <strong>Around</strong> （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li></ul><h4 id="多个切面的执行顺序如何控制"><a href="#多个切面的执行顺序如何控制" class="headerlink" title="多个切面的执行顺序如何控制"></a>多个切面的执行顺序如何控制</h4><p>1、通常使用<code>@Order</code> 注解直接定义切面顺序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 值越小优先级越高</span><span class="token annotation punctuation">@Order</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingAspect</span> <span class="token keyword">implements</span> <span class="token class-name">Ordered</span> <span class="token punctuation">{</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingAspect</span> <span class="token keyword">implements</span> <span class="token class-name">Ordered</span> <span class="token punctuation">{</span>    <span class="token comment">// ....</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 返回值越小优先级越高</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-Spring-MVC"><a href="#7-Spring-MVC" class="headerlink" title="7. Spring MVC"></a>7. Spring MVC</h3><h4 id="什么是-Spring-MVC"><a href="#什么是-Spring-MVC" class="headerlink" title="什么是 Spring MVC"></a>什么是 Spring MVC</h4><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p><h4 id="Spring-MVC-的核心组件"><a href="#Spring-MVC-的核心组件" class="headerlink" title="Spring MVC 的核心组件"></a>Spring MVC 的核心组件</h4><p>记住了下面这些组件，也就记住了 SpringMVC 的工作原理。</p><ul><li>  <strong>DispatcherServlet</strong> ：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li>  <strong>HandlerMapping</strong> ：<strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li>  <strong>HandlerAdapter</strong> ：<strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li>  <strong>Handler</strong> ：<strong>请求处理器</strong>，处理实际请求的处理器。</li><li>  <strong>ViewResolver</strong> ：<strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul><h4 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h4><p><strong>Spring MVC 原理如下图所示：</strong></p><p><img src="/images/image_Spring/06.png"></p><p><strong>流程说明（重要）：</strong></p><ol><li>整个过程开始于客户端发出的一个HTTP请求，Web应用服务器接收到这个请求。如果匹配DispatcherServlet的请求映射路径，则Web容器将该请求转交给DispatcherServlet处理。</li><li>DispatcherServlet接收到这个请求后，将根据请求的信息（包括URL、HTTP方法、请求报文头、请求参数、Cookie等）及HandlerMapping的配置找到处理请求的处理器（Handler）。可将HandlerMapping看做路由控制器，将Handler看做目标主机。值得注意的是，在Spring MVC中并没有定义一个Handler接口，实际上任何一个Object都可以成为请求处理器。</li><li>当DispatcherServlet根据HandlerMapping得到对应当前请求的Handler后，通过HandlerAdapter对Handler进行封装，再以统一的适配器接口调用Handler。HandlerAdapter是Spring MVC框架级接口，顾名思义，HandlerAdapter是一个适配器，它用统一的接口对各种Handler方法进行调用。</li><li>处理器完成业务逻 辑的处理后，将返回一个ModelAndView给DispatcherServlet，ModelAndView包含了视图逻辑名和模型数据信息。</li><li>ModelAndView中包含的是“逻辑视图名”而非真正的视图对象，DispatcherServlet借由ViewResolver完成逻辑视图名到真实视图对象的解析工作。</li><li>当得到真实的视图对象View后，DispatcherServlet就使用这个View对象对ModelAndView中的模型数据进行视图渲染。</li><li> 最终客户端得到的响应消息可能是一个普通的HTML页面，也可能是一个XML或JSON串，甚至是一张图片或一个PDF文档等不同的媒体形式。</li></ol><h4 id="Spring-MVC注解"><a href="#Spring-MVC注解" class="headerlink" title="Spring MVC注解"></a>Spring MVC注解</h4><h5 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h5><p>Spring MVC框架中，@Controller注解用于标识一个类是控制器，主要用于处理HTTP请求和响应。当一个类被标注了@Controller注解后，Spring将会对其进行如下操作：</p><ol><li>创建Bean：Spring将会创建一个Controller Bean，并将其纳入到Spring容器中管理。</li><li>处理请求：当客户端发送请求时，DispatcherServlet将会检查所有的Controller Bean，并找到@RequestMapping注解中匹配的Controller类和处理方法。</li><li>调用方法：当匹配到Controller类和处理方法后，DispatcherServlet将会调用这个方法，并传递进来请求参数（如果有的话）。</li><li>处理返回值：处理方法执行完成后，将会返回一个结果对象。DispatcherServlet将会根据结果对象找到对应的View，并将处理结果发送给客户端。</li></ol><h5 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h5><p>作用：该注解的作用就是用来处理请求地址映射的，也就是说将其中的处理器方法映射到url路径上。</p><p>属性：</p><ul><li>method：是让你指定请求的method的类型，比如常用的有get和post。</li><li>value：是指请求的实际地址，如果是多个地址就用{}来指定就可以了。</li><li>produces：指定返回的内容类型，当request请求头中的Accept类型中包含指定的类型才可以返回的。</li><li>consumes：指定处理请求的提交内容类型，比如一些json、html、text等的类型。</li><li>headers：指定request中必须包含那些的headed值时，它才会用该方法处理请求的。</li><li>params：指定request中一定要有的参数值，它才会使用该方法处理请求。</li></ul><h5 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h5><p>作用：是将请求参数绑定到你的控制器的方法参数上，是Spring MVC中的接收普通参数的注解。</p><p>属性：</p><ul><li>value是请求参数中的名称。</li><li>required是请求参数是否必须提供参数，它的默认是true，意思是表示必须提供。</li></ul><h5 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h5><p>作用：如果作用在方法上，就表示该方法的返回结果是直接按写入的Http responsebody中（一般在异步获取数据时使用的注解）。</p><p>属性：required，是否必须有请求体。它的默认值是true，在使用该注解时，值得注意的当为true时get的请求方式是报错的，如果你取值为false的话，get的请求是null。</p><h5 id="PathVaribale"><a href="#PathVaribale" class="headerlink" title="@PathVaribale"></a>@PathVaribale</h5><p>作用：该注解是用于绑定url中的占位符，但是注意，spring3.0以后，url才开始支持占位符的，它是Spring MVC支持的rest风格url的一个重要的标志。</p><h4 id="Spring-MVC的拦截器"><a href="#Spring-MVC的拦截器" class="headerlink" title="Spring MVC的拦截器"></a>Spring MVC的拦截器</h4><p>拦截器会对处理器进行拦截，这样通过拦截器就可以增强处理器的功能。Spring MVC中，所有的拦截器都需要实现HandlerInterceptor接口，该接口包含如下三个方法：preHandle()、postHandle()、afterCompletion()。</p><p>这些方法的执行流程如下图：</p><p><img src="/images/image_Spring/07.png"></p><p>通过上图可以看出，Spring MVC拦截器的执行流程如下：</p><ul><li>执行preHandle方法，它会返回一个布尔值。如果为false，则结束所有流程，如果为true，则执行下一步。</li><li>执行处理器逻辑，它包含控制器的功能。</li><li>执行postHandle方法。</li><li>执行视图解析和视图渲染。</li><li>执行afterCompletion方法。</li></ul><p>Spring MVC拦截器的开发步骤如下：</p><ol><li>开发拦截器： 实现handlerInterceptor接口，从三个方法中选择合适的方法，实现拦截时要执行的具体业务逻辑。</li><li>注册拦截器： 定义配置类，并让它实现WebMvcConfigurer接口，在接口的addInterceptors方法中，注册拦截器，并定义该拦截器匹配哪些请求路径。</li></ol><h4 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h4><p>推荐使用注解的方式统一异常处理，具体会使用到 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 这两个注解 。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ControllerAdvice</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">BaseException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">handleAppException</span><span class="token punctuation">(</span><span class="token class-name">BaseException</span> ex<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//......</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ResourceNotFoundException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ErrorReponse</span><span class="token punctuation">&gt;</span></span> <span class="token function">handleResourceNotFoundException</span><span class="token punctuation">(</span><span class="token class-name">ResourceNotFoundException</span> ex<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//......</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种异常处理方式下，会给所有或者指定的 <code>Controller</code> 织入异常处理的逻辑（AOP），当 <code>Controller</code> 中的方法抛出异常的时候，由被<code>@ExceptionHandler</code> 注解修饰的方法进行处理。</p><p><code>ExceptionHandlerMethodResolver</code> 中 <code>getMappedMethod</code> 方法决定了异常具体被哪个被 <code>@ExceptionHandler</code> 注解修饰的方法处理异常。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Nullable</span><span class="token keyword">private</span> <span class="token class-name">Method</span> <span class="token function">getMappedMethod</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> exceptionType<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> matches <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> mappedException <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mappedMethods<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mappedException<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>exceptionType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>matches<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>mappedException<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token comment">// 不为空说明有方法处理异常</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>matches<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 按照匹配程度从小到大排序</span>matches<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ExceptionDepthComparator</span><span class="token punctuation">(</span>exceptionType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 返回处理异常的方法</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mappedMethods<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>matches<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源代码看出： <strong><code>getMappedMethod()</code>会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。</strong></p><h3 id="8-Spring-框架中用到了哪些设计模式？"><a href="#8-Spring-框架中用到了哪些设计模式？" class="headerlink" title="8. Spring 框架中用到了哪些设计模式？"></a>8. Spring 框架中用到了哪些设计模式？</h3><ul><li>  <strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li>  <strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li>  <strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li>  <strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li>  <strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li>  <strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li>  <strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li></ul><h3 id="9-Spring-事务"><a href="#9-Spring-事务" class="headerlink" title="9. Spring 事务"></a>9. Spring 事务</h3><h4 id="Spring-管理事务的方式"><a href="#Spring-管理事务的方式" class="headerlink" title="Spring 管理事务的方式"></a>Spring 管理事务的方式</h4><ul><li>  <strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li><li>  <strong>声明式事务</strong> ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li></ul><h4 id="Spring-事务中的事务传播行为"><a href="#Spring-事务中的事务传播行为" class="headerlink" title="Spring 事务中的事务传播行为"></a>Spring 事务中的事务传播行为</h4><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><p>正确的事务传播行为可能的值如下:</p><p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p><p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p><p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p><p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p><p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p><p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p><p>这个使用的很少。</p><p>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：</p><ul><li>  <strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>  <strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>  <strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><h4 id="Spring-事务中的隔离级别"><a href="#Spring-事务中的隔离级别" class="headerlink" title="Spring 事务中的隔离级别"></a>Spring 事务中的隔离级别</h4><p>和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Isolation</span> <span class="token punctuation">{</span>    <span class="token function">DEFAULT</span><span class="token punctuation">(</span><span class="token class-name">TransactionDefinition</span><span class="token punctuation">.</span><span class="token constant">ISOLATION_DEFAULT</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">READ_UNCOMMITTED</span><span class="token punctuation">(</span><span class="token class-name">TransactionDefinition</span><span class="token punctuation">.</span><span class="token constant">ISOLATION_READ_UNCOMMITTED</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">READ_COMMITTED</span><span class="token punctuation">(</span><span class="token class-name">TransactionDefinition</span><span class="token punctuation">.</span><span class="token constant">ISOLATION_READ_COMMITTED</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">REPEATABLE_READ</span><span class="token punctuation">(</span><span class="token class-name">TransactionDefinition</span><span class="token punctuation">.</span><span class="token constant">ISOLATION_REPEATABLE_READ</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">SERIALIZABLE</span><span class="token punctuation">(</span><span class="token class-name">TransactionDefinition</span><span class="token punctuation">.</span><span class="token constant">ISOLATION_SERIALIZABLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token class-name">Isolation</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我依次对每一种事务隔离级别进行介绍：</p><ul><li>  <strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li><li>  <strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li>  <strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li>  <strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li>  <strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h4 id="Transactional-rollbackFor-Exception-class-注解"><a href="#Transactional-rollbackFor-Exception-class-注解" class="headerlink" title="@Transactional(rollbackFor = Exception.class)注解"></a>@Transactional(rollbackFor = Exception.class)注解</h4><p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以<strong>保证数据的一致性</strong>。</p><p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p><p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，<strong>加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</strong></p><h3 id="10-Spring-Data-JPA"><a href="#10-Spring-Data-JPA" class="headerlink" title="10. Spring Data JPA"></a>10. Spring Data JPA</h3><p>JPA 重要的是实战，这里仅对小部分知识点进行总结。</p><h4 id="使用-JPA-在数据库中非持久化一个字段"><a href="#使用-JPA-在数据库中非持久化一个字段" class="headerlink" title="使用 JPA 在数据库中非持久化一个字段"></a>使用 JPA 在数据库中非持久化一个字段</h4><p>假如我们有下面一个类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"USER"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span>    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span><span class="token constant">AUTO</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"ID"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"USER_NAME"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"PASSWORD"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> secrect<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们想让<code>secrect</code> 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token class-name">String</span> transient1<span class="token punctuation">;</span> <span class="token comment">// not persistent because of static</span><span class="token keyword">final</span> <span class="token class-name">String</span> transient2 <span class="token operator">=</span> <span class="token string">"Satish"</span><span class="token punctuation">;</span> <span class="token comment">// not persistent because of final</span><span class="token keyword">transient</span> <span class="token class-name">String</span> transient3<span class="token punctuation">;</span> <span class="token comment">// not persistent because of transient</span><span class="token annotation punctuation">@Transient</span><span class="token class-name">String</span> transient4<span class="token punctuation">;</span> <span class="token comment">// not persistent because of @Transient</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般使用后面两种方式比较多，我个人使用注解的方式比较多。</p><h4 id="JPA-的审计功能的作用"><a href="#JPA-的审计功能的作用" class="headerlink" title="JPA 的审计功能的作用"></a>JPA 的审计功能的作用</h4><p>审计功能主要是帮助我们记录数据库操作的具体行为，比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@MappedSuperclass</span><span class="token annotation punctuation">@EntityListeners</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">AuditingEntityListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractAuditBase</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@CreatedDate</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">Instant</span> createdAt<span class="token punctuation">;</span>    <span class="token annotation punctuation">@LastModifiedDate</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">Instant</span> updatedAt<span class="token punctuation">;</span>    <span class="token annotation punctuation">@CreatedBy</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> createdBy<span class="token punctuation">;</span>    <span class="token annotation punctuation">@LastModifiedBy</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> updatedBy<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>@CreatedDate</code>: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</li><li><code>@CreatedBy</code> :表示该字段为创建人，在这个实体被 insert 的时候，会设置值  <code>@LastModifiedDate</code>、<code>@LastModifiedBy</code>同理。</li></ul><h4 id="实体之间的关联关系注解"><a href="#实体之间的关联关系注解" class="headerlink" title="实体之间的关联关系注解"></a>实体之间的关联关系注解</h4><ul><li>  <code>@OneToOne</code> : 一对一。</li><li>  <code>@ManyToMany</code> ：多对多。</li><li>  <code>@OneToMany</code> : 一对多。</li><li>  <code>@ManyToOne</code> ：多对一。</li></ul><p>利用 <code>@ManyToOne</code> 和 <code>@OneToMany</code> 也可以表达多对多的关联关系。</p><h3 id="11-Spring-Security"><a href="#11-Spring-Security" class="headerlink" title="11. Spring Security"></a>11. Spring Security</h3><h4 id="控制请求访问权限的方法"><a href="#控制请求访问权限的方法" class="headerlink" title="控制请求访问权限的方法"></a>控制请求访问权限的方法</h4><ul><li>  <code>permitAll()</code> ：无条件允许任何形式访问，不管你登录还是没有登录。</li><li>  <code>anonymous()</code> ：允许匿名访问，也就是没有登录才可以访问。</li><li>  <code>denyAll()</code> ：无条件决绝任何形式的访问。</li><li>  <code>authenticated()</code>：只允许已认证的用户访问。</li><li>  <code>fullyAuthenticated()</code> ：只允许已经登录或者通过 remember-me 登录的用户访问。</li><li>  <code>hasRole(String)</code> : 只允许指定的角色访问。</li><li>  <code>hasAnyRole(String)</code> : 指定一个或者多个角色，满足其一的用户即可访问。</li><li>  <code>hasAuthority(String)</code> ：只允许具有指定权限的用户访问</li><li>  <code>hasAnyAuthority(String)</code> ：指定一个或者多个权限，满足其一的用户即可访问。</li><li>  <code>hasIpAddress(String)</code> : 只允许指定 ip 的用户访问。</li></ul><p><strong>hasRole 和 hasAuthority 的区别</strong></p><p>代码上来说，hasRole 和 hasAuthority 写代码时前缀不同，但是最终执行是一样的；设计上来说，role 和 authority 这是两个层面的权限设计思路，一个是角色，一个是权限，角色是权限的集合。</p><h4 id="如何对密码进行加密"><a href="#如何对密码进行加密" class="headerlink" title="如何对密码进行加密"></a>如何对密码进行加密</h4><p>如果我们需要保存密码这类敏感数据到数据库的话，需要先加密再保存。</p><p>Spring Security 提供了多种加密算法的实现，开箱即用，非常方便。这些加密算法实现类的父类是 <code>PasswordEncoder</code> ，如果你想要自己实现一个加密算法的话，也需要继承 <code>PasswordEncoder</code>。</p><p><code>PasswordEncoder</code> 接口一共也就 3 个必须实现的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PasswordEncoder</span> <span class="token punctuation">{</span>    <span class="token comment">// 加密也就是对原始密码进行编码</span>    <span class="token class-name">String</span> <span class="token function">encode</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 比对原始密码和数据库中保存的密码</span>    <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> var1<span class="token punctuation">,</span> <span class="token class-name">String</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断加密密码是否需要再次进行加密，默认返回 false</span>    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">upgradeEncoding</span><span class="token punctuation">(</span><span class="token class-name">String</span> encodedPassword<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="如何更换系统使用的加密算法"><a href="#如何更换系统使用的加密算法" class="headerlink" title="如何更换系统使用的加密算法"></a>如何更换系统使用的加密算法</h4><p>如果我们在开发过程中，突然发现现有的加密算法无法满足我们的需求，需要更换成另外一个加密算法，这个时候应该怎么办呢？</p><p>推荐的做法是通过 <code>DelegatingPasswordEncoder</code> 兼容多种不同的密码加密方案，以适应不同的业务需求。</p><p>从名字也能看出来，<code>DelegatingPasswordEncoder</code> 其实就是一个代理类，并非是一种全新的加密算法，它做的事情就是代理上面提到的加密算法实现类。在 Spring Security 5.0之后，默认就是基于 <code>DelegatingPasswordEncoder</code> 进行密码加密的。</p><h3 id="12-Spring是怎么解决循环依赖的？"><a href="#12-Spring是怎么解决循环依赖的？" class="headerlink" title="12. Spring是怎么解决循环依赖的？"></a>12. Spring是怎么解决循环依赖的？</h3><p>首先，需要明确的是spring对循环依赖的处理有三种情况：</p><ol><li>构造器的循环依赖：这种依赖spring是处理不了的，直接抛出BeanCurrentlylnCreationException异常。</li><li>单例模式下的setter循环依赖：通过“三级缓存”处理循环依赖。</li><li>非单例循环依赖：无法处理。</li></ol><p>接下来，我们具体看看spring是如何处理第二种循环依赖的。</p><p>Spring单例对象的初始化大略分为三步：</p><ol><li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象；</li><li>populateBean：填充属性，这一步主要是多bean的依赖属性进行填充；</li><li>initializeBean：调用spring xml中的init 方法。</li></ol><p>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一步、第二步。也就是构造器循环依赖和field循环依赖。 Spring为了解决单例的循环依赖问题，使用了三级缓存。</p><p>这三级缓存的作用分别是：</p><ul><li>singletonFactories ： 进入实例化阶段的单例对象工厂的cache （三级缓存）；</li><li>earlySingletonObjects ：完成实例化但是尚未初始化的，提前暴光的单例对象的Cache （二级缓存）；</li><li>  singletonObjects：完成初始化的单例对象的cache（一级缓存）。</li></ul><p>这样做有什么好处呢？让我们来分析一下</p><p>“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Spring-包含的模块有哪些？&quot;&gt;&lt;a href=&quot;#1-Spring-包含的模块有哪些？&quot; class=&quot;headerlink&quot; title=&quot;1. Spring 包含的模块有哪些？&quot;&gt;&lt;/a&gt;1. Spring 包含的模块有哪些？&lt;/h3&gt;&lt;p&gt;&lt;img</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://ailiaa.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://ailiaa.github.io/2023/03/11/she-ji-mo-shi/"/>
    <id>http://ailiaa.github.io/2023/03/11/she-ji-mo-shi/</id>
    <published>2023-03-11T12:28:49.000Z</published>
    <updated>2023-03-11T13:30:29.948Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-软件设计原则"><a href="#1-软件设计原则" class="headerlink" title="1. 软件设计原则"></a>1. 软件设计原则</h3><p>常⽤的⾯向对象设计原则包括7个，这些原则并不是孤⽴存在的，它们相互 依赖，相互补充。</p><ul><li>开闭原则（Open Closed Principle，OCP）</li><li>单⼀职责原则（Single Responsibility Principle, SRP） </li><li>⾥⽒替换原则（Liskov Substitution Principle，LSP） </li><li>依赖倒置原则（Dependency Inversion Principle，DIP） </li><li>接⼝隔离原则（Interface Segregation Principle，ISP） </li><li>合成/聚合复⽤原则（Composite/Aggregate Reuse Principle， C/ARP） </li><li>最少知识原则（Least Knowledge Principle，LKP）</li><li>或者迪⽶特法则 （Law of Demeter，LOD</li></ul><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.png"></p><h3 id="1-什么是设计模式？"><a href="#1-什么是设计模式？" class="headerlink" title="1. 什么是设计模式？"></a>1. 什么是设计模式？</h3><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的⾯向对象 的软件开发⼈员所采⽤。设计模式是软件开发⼈员在软件开发过程中⾯临的⼀般问题的<strong>解决⽅案</strong>。这些解决⽅案是众多软件开发⼈员经过相当⻓的 ⼀段时间的试验和错误总结出来的。 </p><p>设计模式是⼀套被反复使⽤的、多数⼈知晓的、经过分类编⽬的、代码设计经验的总结。使⽤设计模式是为了重⽤代码、让代码更容易被他⼈理解、保证代码可靠性。 毫⽆疑问，设计模式于⼰于他⼈于系统都是多赢的，设计模式使代码编制真正⼯程化，设计模式是软件⼯程的基⽯，如同⼤厦的⼀块块砖⽯⼀样。项⽬中合理地运⽤设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了 ⼀个在我们周围不断重复发⽣的问题，以及该问题的核⼼解决⽅案，这也 是设计模式能被⼴泛应⽤的原因。 </p><h3 id="2-设计模式的分类"><a href="#2-设计模式的分类" class="headerlink" title="2. 设计模式的分类"></a>2. 设计模式的分类</h3><p><strong>创建型</strong>： 在创建对象的同时隐藏创建逻辑，不使⽤ new 直接实例化对象，程序在判断需要创建哪些对象时更灵活。包括⼯⼚/抽象⼯⼚/单例/ 建造者/原型模式。 </p><p><strong>结构型</strong>： 通过类和接⼝间的继承和引⽤实现创建复杂结构的对象。包 括适配器/桥接模式/过滤器/组合/装饰器/外观/享元/代理模式。 </p><p><strong>⾏为型</strong>： 通过类之间不同通信⽅式实现不同⾏为。包括责任链/命名/解 释器/迭代器/中介者/备忘录/观察者/状态/策略/模板/访问者模式</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.png"></p><h3 id="4-简单⼯⼚模式"><a href="#4-简单⼯⼚模式" class="headerlink" title="4. 简单⼯⼚模式"></a>4. 简单⼯⼚模式</h3><p>简单⼯⼚模式指由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻辑，只需提供传⼊⼯⼚的参数。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.png"></p><p>适⽤于⼯⼚类负责创建对象较少的情况，缺点是如果要增加新产品，就需 要修改⼯⼚类的判断逻辑，违背开闭原则，且产品多的话会使⼯⼚类⽐较 复杂。</p><p>Calendar 抽象类的 getInstance ⽅法，调⽤ createCalendar ⽅法根据不同 的地区参数创建不同的⽇历对象。</p><p>Spring 中的 BeanFactory 使⽤简单⼯⼚模式，根据传⼊⼀个唯⼀的标识来 获得 Bean 对象</p><h3 id="5-⼯⼚⽅法模式？"><a href="#5-⼯⼚⽅法模式？" class="headerlink" title="5. ⼯⼚⽅法模式？"></a>5. ⼯⼚⽅法模式？</h3><p>和简单⼯⼚模式中⼯⼚负责⽣产所有产品相⽐，⼯⼚⽅法模式将⽣成具体 产品的任务分发给具体的产品⼯⼚。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04.png"></p><p>也就是定义⼀个抽象⼯⼚，其定义了产品的⽣产接⼝，但不负责具体的产 品，将⽣产任务交给不同的派⽣类⼯⼚。这样不⽤通过指定类型来创建对 象了。</p><h3 id="6-抽象⼯⼚模式"><a href="#6-抽象⼯⼚模式" class="headerlink" title="6. 抽象⼯⼚模式"></a>6. 抽象⼯⼚模式</h3><p>简单⼯⼚模式和⼯⼚⽅法模式不管⼯⼚怎么拆分抽象，都只是针对⼀类产 品，如果要⽣成另⼀种产品，就⽐较难办了！ </p><p>抽象⼯⼚模式通过在 AbstarctFactory 中增加创建产品的接⼝，并在具体⼦ ⼯⼚中实现新加产品的创建，当然前提是⼦⼯⼚⽀持⽣产该产品。否则继 承的这个接⼝可以什么也不⼲</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05.png"></p><h3 id="7-单例模式"><a href="#7-单例模式" class="headerlink" title="7. 单例模式"></a>7. 单例模式</h3><h4 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h4><p>单例模式属于创建型模式，⼀个单例类在任何情况下都只存在⼀个实例， 构造⽅法必须是私有的、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀ 个静态公有⽅法获取实例。 </p><h4 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h4><p>优点是内存中只有⼀个实例，减少了开销，尤其是频繁创建和销毁实例的 情况下并且可以避免对资源的多重占⽤。缺点是没有抽象层，难以扩展， 与单⼀职责原则冲突。</p><h4 id="单例模式的常⻅写法"><a href="#单例模式的常⻅写法" class="headerlink" title="单例模式的常⻅写法"></a>单例模式的常⻅写法</h4><h5 id="饿汉式，线程安全"><a href="#饿汉式，线程安全" class="headerlink" title="饿汉式，线程安全"></a>饿汉式，线程安全</h5><p>饿汉式单例模式，顾名思义，类⼀加载就创建对象，这种⽅式⽐较常⽤， 但容易产⽣垃圾对象，浪费内存空间。 </p><p>优点：线程安全，没有加锁，执⾏效率较⾼<br>缺点：不是懒加载，类加载时就初始化，浪费内存空间</p><blockquote><p>懒加载 （lazy loading）：使⽤的时候再创建对象</p></blockquote><p>饿汉式单例是如何保证线程安全的呢？它是基于类加载机制避免了多线程 的同步问题，但是如果类被不同的类加载器加载就会创建不同的实例。</p><p><strong>代码实现，以及使⽤反射破坏单例：</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-软件设计原则&quot;&gt;&lt;a href=&quot;#1-软件设计原则&quot; class=&quot;headerlink&quot; title=&quot;1. 软件设计原则&quot;&gt;&lt;/a&gt;1. 软件设计原则&lt;/h3&gt;&lt;p&gt;常⽤的⾯向对象设计原则包括7个，这些原则并不是孤⽴存在的，它们相互 依赖，相互补充。&lt;/</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://ailiaa.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis_02</title>
    <link href="http://ailiaa.github.io/2023/03/11/redis-02/"/>
    <id>http://ailiaa.github.io/2023/03/11/redis-02/</id>
    <published>2023-03-11T09:42:04.000Z</published>
    <updated>2023-05-24T13:12:25.707Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Redis事务"><a href="#1-Redis事务" class="headerlink" title="1. Redis事务"></a>1. Redis事务</h3><p>Redis通过<strong>MULTI、EXEC、WATCH</strong>等一组命令集合，来实现事务机制。事务支持一次执行多个命令，一个事务中所有命令都会被序列化。在事务执行过程，会按照顺序串行化执行队列中的命令，其他客户端提交的命令请求不会插入到事务执行命令序列中。</p><p>简言之，Redis事务就是<strong>顺序性、一次性、排他性</strong>的执行一个队列中的一系列命令。</p><p>Redis执行事务的流程如下：</p><ul><li>  开始事务（MULTI）</li><li>  命令入队</li><li>  执行事务（EXEC）、撤销事务（DISCARD ）</li></ul><h4 id="Redis-事务支持原子性吗？"><a href="#Redis-事务支持原子性吗？" class="headerlink" title="Redis 事务支持原子性吗？"></a>Redis 事务支持原子性吗？</h4><p>Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： <strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p><ol><li> <strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li> <strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li> <strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li><li> <strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li></ol><p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的（而且不满足持久性）。</p><p><strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p><p>除了不满足原子性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。</p><p>因此，Redis 事务是不建议在日常开发中使用的。</p><h4 id="如何解决-Redis-事务的缺陷？"><a href="#如何解决-Redis-事务的缺陷？" class="headerlink" title="如何解决 Redis 事务的缺陷？"></a>如何解决 Redis 事务的缺陷？</h4><p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p><p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</p><p>不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， <strong>严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></p><p>如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。</p><h3 id="2-Redis-性能优化"><a href="#2-Redis-性能优化" class="headerlink" title="2. Redis 性能优化"></a>2. Redis 性能优化</h3><h4 id="Redis-bigkey"><a href="#Redis-bigkey" class="headerlink" title="Redis bigkey"></a>Redis bigkey</h4><h5 id="什么是-bigkey？"><a href="#什么是-bigkey？" class="headerlink" title="什么是 bigkey？"></a>什么是 bigkey？</h5><p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p><h5 id="bigkey-有什么危害？"><a href="#bigkey-有什么危害？" class="headerlink" title="bigkey 有什么危害？"></a>bigkey 有什么危害？</h5><p>除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。</p><p>因此，我们应该尽量避免写入 bigkey！</p><h5 id="如何发现-bigkey？"><a href="#如何发现-bigkey？" class="headerlink" title="如何发现 bigkey？"></a>如何发现 bigkey？</h5><p><strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># redis-cli -p 6379 --bigkeys</span><span class="token comment"># Scanning the entire keyspace to find biggest keys as well as</span><span class="token comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span><span class="token comment"># per 100 SCAN commands (not usually needed).</span><span class="token punctuation">[</span>00.00%<span class="token punctuation">]</span> Biggest string found so far <span class="token string">'"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20"'</span> with <span class="token number">4437</span> bytes<span class="token punctuation">[</span>00.00%<span class="token punctuation">]</span> Biggest list   found so far <span class="token string">'"my-list"'</span> with <span class="token number">17</span> items-------- summary -------Sampled <span class="token number">5</span> keys <span class="token keyword">in</span> the keyspace<span class="token operator">!</span>Total key length <span class="token keyword">in</span> bytes is <span class="token number">264</span> <span class="token punctuation">(</span>avg len <span class="token number">52.80</span><span class="token punctuation">)</span>Biggest   list found <span class="token string">'"my-list"'</span> has <span class="token number">17</span> itemsBiggest string found <span class="token string">'"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20"'</span> has <span class="token number">4437</span> bytes<span class="token number">1</span> lists with <span class="token number">17</span> items <span class="token punctuation">(</span><span class="token number">20.00</span>% of keys, avg size <span class="token number">17.00</span><span class="token punctuation">)</span><span class="token number">0</span> hashs with <span class="token number">0</span> fields <span class="token punctuation">(</span>00.00% of keys, avg size <span class="token number">0.00</span><span class="token punctuation">)</span><span class="token number">4</span> strings with <span class="token number">4831</span> bytes <span class="token punctuation">(</span><span class="token number">80.00</span>% of keys, avg size <span class="token number">1207.75</span><span class="token punctuation">)</span><span class="token number">0</span> streams with <span class="token number">0</span> entries <span class="token punctuation">(</span>00.00% of keys, avg size <span class="token number">0.00</span><span class="token punctuation">)</span><span class="token number">0</span> sets with <span class="token number">0</span> members <span class="token punctuation">(</span>00.00% of keys, avg size <span class="token number">0.00</span><span class="token punctuation">)</span><span class="token number">0</span> zsets with <span class="token number">0</span> members <span class="token punctuation">(</span>00.00% of keys, avg size <span class="token number">0.00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。</p><p><strong>2、分析 RDB 文件</strong></p><p>通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p><p>网上有现成的代码/工具可以直接拿来使用：</p><ul><li>  redis-rdb-tools：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li><li>  rdb_bigkeys: Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li></ul><h4 id="大量-key-集中过期问题"><a href="#大量-key-集中过期问题" class="headerlink" title="大量 key 集中过期问题"></a>大量 key 集中过期问题</h4><p>我在上面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 策略。</p><p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p><p>如何解决呢？下面是两种常见的方法：</p><ol><li> 给 key 设置随机过期时间。</li><li> 开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li></ol><p>个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</p><h4 id="使用批量操作减少网络传输"><a href="#使用批量操作减少网络传输" class="headerlink" title="使用批量操作减少网络传输"></a>使用批量操作减少网络传输</h4><p>一个 Redis 命令的执行可以简化为以下 4 步：</p><ol><li> 发送命令</li><li> 命令排队</li><li> 命令执行</li><li> 返回结果</li></ol><p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间。</p><p><strong>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</strong></p><h5 id="原生批量操作命令"><a href="#原生批量操作命令" class="headerlink" title="原生批量操作命令"></a>原生批量操作命令</h5><p>Redis 中有一些原生支持批量操作的命令，比如：</p><ul><li>  <code>mget</code>(获取一个或多个指定 key 的值)、<code>mset</code>(设置一个或多个指定 key 的值)、</li><li>  <code>hmget</code>(获取指定哈希表中一个或者多个指定字段的值)、<code>hmset</code>(同时将一个或多个 field-value 对设置到指定哈希表中)、</li><li>  <code>sadd</code>（向指定集合添加一个或多个元素）</li><li>  ……</li></ul><p>不过，在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决。就比如说 <code>mget</code> 无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上，<code>mget</code>可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。</p><p>整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：</p><ol><li> 找到 key 对应的所有 hash slot；</li><li> 分别向对应的 Redis 节点发起 <code>mget</code> 请求获取数据；</li><li> 等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。</li></ol><p>如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。</p><blockquote><p>Redis Cluster 并没有使用一致性哈希，采用的是 <strong>哈希槽分区</strong> ，每一个键值对都属于一个 <strong>hash slot</strong>（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。</p></blockquote><h5 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h5><p>对于不支持批量操作的命令，我们可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 <strong>元素个数</strong>(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。</p><p>与<code>mget</code>、<code>mset</code>等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。</p><p>原生批量操作命令和 pipeline 的是有区别的，使用的时候需要注意：</p><ul><li>  原生批量操作命令是原子操作，pipeline 是非原子操作；</li><li>  pipeline 可以打包不同的命令，原生批量操作命令不可以；</li><li>  原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。</li></ul><p>另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 <strong>Lua 脚本</strong> 。</p><h5 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h5><p>Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是原子操作。一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。</p><p>并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。</p><p>不过， Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。</p><h3 id="3-Redis-生产问题"><a href="#3-Redis-生产问题" class="headerlink" title="3. Redis 生产问题"></a>3. Redis 生产问题</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><h5 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h5><p>缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><img src="/images/image_redis/04.png"></p><p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p><h5 id="有哪些解决办法？"><a href="#有哪些解决办法？" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h5><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p><strong>1）缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getObjectInclNullById</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 从缓存中获取数据</span>    <span class="token class-name">Object</span> cacheValue <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 缓存为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 从数据库中获取</span>        <span class="token class-name">Object</span> storageValue <span class="token operator">=</span> storage<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 缓存空对象</span>        cache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> storageValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>storageValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 必须设置过期时间，否则有被攻击的风险</span>            cache<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> storageValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cacheValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2）布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下。</p><p><img src="/images/image_redis/05.png"></p><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是：&nbsp;<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><h5 id="什么是缓存击穿？"><a href="#什么是缓存击穿？" class="headerlink" title="什么是缓存击穿？"></a>什么是缓存击穿？</h5><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><img src="/images/image_redis/06.png"></p><p>举个例子 ：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p><h5 id="有哪些解决办法？-1"><a href="#有哪些解决办法？-1" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h5><ul><li>  设置热点数据永不过期或者过期时间比较长。</li><li>  针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>  请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li></ul><h5 id="缓存穿透和缓存击穿的区别"><a href="#缓存穿透和缓存击穿的区别" class="headerlink" title="缓存穿透和缓存击穿的区别"></a>缓存穿透和缓存击穿的区别</h5><p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong></p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><h5 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h5><p>缓存雪崩描述的是这样一个场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p><p>另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p><p><img src="/images/image_redis/07.png"></p><p>举个例子 ：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p><h5 id="有哪些解决办法？-2"><a href="#有哪些解决办法？-2" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h5><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li> 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li> 限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li> 设置不同的失效时间比如随机设置缓存的失效时间。</li><li> 缓存永不失效（不太推荐，实用性太差）。</li><li> 设置二级缓存。</li></ol><h5 id="缓存雪崩和缓存击穿的区别"><a href="#缓存雪崩和缓存击穿的区别" class="headerlink" title="缓存雪崩和缓存击穿的区别"></a>缓存雪崩和缓存击穿的区别</h5><p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</p><h3 id="4-Redis-使用规范"><a href="#4-Redis-使用规范" class="headerlink" title="4. Redis 使用规范"></a>4. Redis 使用规范</h3><p>实际使用 Redis 的过程中，我们尽量要准守一些常见的规范，比如：</p><ol><li> 使用连接池：避免频繁创建关闭客户端连接。</li><li> 尽量不使用 O(n)指令，使用 O(N)命令时要关注 N 的数量 ：例如 <code>hgetall</code>、<code>lrange</code>、<code>smembers</code>、<code>zrange</code>、<code>sinter</code> 、<code>sunion</code> 命令并非不能使用，但是需要明确 N 的值。有遍历的需求可以使用 <code>hscan</code>、<code>sscan</code>、<code>zscan</code> 代替。</li><li> 使用批量操作减少网络传输 ：原生批量操作命令（比如 <code>mget</code>、<code>mset</code>等等）、pipeline、Lua 脚本。</li><li> 尽量不适用 Redis 事务：Redis 事务实现的功能比较鸡肋，可以使用 Lua 脚本代替。</li><li> 禁止长时间开启 monitor：对性能影响比较大。</li><li> 控制 key 的生命周期：避免 Redis 中存放了太多不经常被访问的数据。</li></ol><h3 id="5-Redis跳跃表"><a href="#5-Redis跳跃表" class="headerlink" title="5. Redis跳跃表"></a>5. Redis跳跃表</h3><p><img src="/images/image_redis/08.webp"></p><ul><li>  跳跃表是有序集合zset的底层实现之一</li><li>  跳跃表支持平均<strong>O（logN）</strong>,最坏 O（N）复杂度的节点查找，还可以通过顺序性操作批量处理节点。</li><li>  跳跃表实现由<strong>zskiplist和zskiplistNode</strong>两个结构组成，其中zskiplist用于保存跳跃表信息（如表头节点、表尾节点、长度），而zskiplistNode则用于表示跳跃表节点。</li><li>  跳跃表就是在链表的基础上，增加多级索引提升查找效率。</li></ul><h3 id="6-MySQL与Redis-如何保证双写一致性"><a href="#6-MySQL与Redis-如何保证双写一致性" class="headerlink" title="6. MySQL与Redis 如何保证双写一致性"></a>6. MySQL与Redis 如何保证双写一致性</h3><h4 id="延时双删"><a href="#延时双删" class="headerlink" title="延时双删"></a>延时双删</h4><p><img src="/images/image_redis/09.webp"></p><ol><li> 先删除缓存</li><li> 再更新数据库</li><li> 休眠一会（比如1秒），再次删除缓存。</li></ol><p>这种方案还算可以，只有休眠那一会（比如就那1秒），可能有脏数据，一般业务也会接受的。<br>但是如果<strong>第二次删除缓存失败</strong>呢？缓存和数据库的数据还是可能不一致</p><h4 id="删除缓存重试机制"><a href="#删除缓存重试机制" class="headerlink" title="删除缓存重试机制"></a>删除缓存重试机制</h4><p>因为延时双删可能会存在第二步的删除缓存失败，导致的数据不一致问题。<br>可以使用这个方案优化：删除失败就多删除几次,保证删除缓存成功就可以了</p><p><img src="/images/image_redis/10.webp"></p><ol><li> 写请求更新数据库</li><li> 缓存因为某些原因，删除失败</li><li> 把删除失败的key放到消息队列</li><li> 消费消息队列的消息，获取要删除的key</li><li> 重试删除缓存操作</li></ol><h3 id="读取biglog异步删除缓存"><a href="#读取biglog异步删除缓存" class="headerlink" title="读取biglog异步删除缓存"></a>读取biglog异步删除缓存</h3><p>重试删除缓存机制，就是会造成好多<strong>业务代码入侵</strong>。<br>还可以这样优化：通过数据库的binlog来异步淘汰key。</p><p><img src="/images/image_redis/11.webp"></p><p>以mysql为例</p><ul><li>  可以使用阿里的canal将binlog日志采集发送到MQ队列里面</li><li>  然后通过ACK机制确认处理这条更新消息，删除缓存，保证数据缓存一致性</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Redis事务&quot;&gt;&lt;a href=&quot;#1-Redis事务&quot; class=&quot;headerlink&quot; title=&quot;1. Redis事务&quot;&gt;&lt;/a&gt;1. Redis事务&lt;/h3&gt;&lt;p&gt;Redis通过&lt;strong&gt;MULTI、EXEC、WATCH&lt;/strong&gt;</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="NoSQL" scheme="http://ailiaa.github.io/tags/NoSQL/"/>
    
    <category term="redis" scheme="http://ailiaa.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>Redis_01</title>
    <link href="http://ailiaa.github.io/2023/03/11/redis-01/"/>
    <id>http://ailiaa.github.io/2023/03/11/redis-01/</id>
    <published>2023-03-11T09:24:42.000Z</published>
    <updated>2023-05-24T13:17:14.141Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Redis-基础"><a href="#1-Redis-基础" class="headerlink" title="1. Redis 基础"></a>1. Redis 基础</h3><h4 id="什么是-Redis？"><a href="#什么是-Redis？" class="headerlink" title="什么是 Redis？"></a>什么是 Redis？</h4><p>Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。</p><p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap）。并且，Redis 还支持事务 、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</p><h4 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h4><p>Redis 内部做了非常多的性能优化，比较重要的主要有下面 3 点：</p><ul><li>  Redis 基于内存，内存的访问速度是磁盘的上千倍；</li><li>  Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</li><li>  Redis 内置了多种优化过后的数据结构实现，性能非常高。</li></ul><h4 id="分布式缓存常见的技术选型方案"><a href="#分布式缓存常见的技术选型方案" class="headerlink" title="分布式缓存常见的技术选型方案"></a>分布式缓存常见的技术选型方案</h4><p>分布式缓存的话，比较老牌同时也是使用的比较多的还是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，现在基本没有看过还有项目使用 <strong>Memcached</strong> 来做缓存，都是直接用 <strong>Redis</strong>。</p><p>另外，腾讯也开源了一款类似于 Redis 的分布式高性能 KV 存储数据库，名为 Tendis</p><h4 id="Redis-和-Memcached-的区别和共同点"><a href="#Redis-和-Memcached-的区别和共同点" class="headerlink" title="Redis 和 Memcached 的区别和共同点"></a>Redis 和 Memcached 的区别和共同点</h4><p><strong>共同点</strong> ：</p><ol><li> 都是基于内存的数据库，一般都用来当做缓存使用。</li><li> 都有过期策略。</li><li> 两者的性能都非常高。</li></ol><p><strong>区别</strong> ：</p><ol><li> <strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li><li> <strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li><li> <strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li><li> <strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li><li> <strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li><li> <strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li><li> <strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li><li> <strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li></ol><h4 id="为什么要用-Redis-为什么要用缓存"><a href="#为什么要用-Redis-为什么要用缓存" class="headerlink" title="为什么要用 Redis/为什么要用缓存"></a>为什么要用 Redis/为什么要用缓存</h4><p>下面我们主要从“高性能”和“高并发”这两点来回答这个问题。</p><p><strong>高性能</strong></p><p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p><p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p><p><strong>高并发</strong></p><p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p><blockquote><p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p></blockquote><p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p><h4 id="Redis-除了做缓存，还能做什么？"><a href="#Redis-除了做缓存，还能做什么？" class="headerlink" title="Redis 除了做缓存，还能做什么？"></a>Redis 除了做缓存，还能做什么？</h4><ul><li>  <strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</li><li>  <strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。</li><li>  <strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li><li>  <strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li></ul><h4 id="Redis-可以做消息队列么？"><a href="#Redis-可以做消息队列么？" class="headerlink" title="Redis 可以做消息队列么？"></a>Redis 可以做消息队列么？</h4><p>Redis 5.0 新增加的一个数据结构 <code>Stream</code> 可以用来做消息队列，<code>Stream</code> 支持：</p><ul><li>  发布 / 订阅模式</li><li>  按照消费者组进行消费</li><li>  消息持久化（ RDB 和 AOF）</li></ul><p>不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议是不使用 Redis 来做消息队列的，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p><h3 id="2-Redis-数据结构"><a href="#2-Redis-数据结构" class="headerlink" title="2. Redis 数据结构"></a>2. Redis 数据结构</h3><h4 id="Redis-常用的数据结构"><a href="#Redis-常用的数据结构" class="headerlink" title="Redis 常用的数据结构"></a>Redis 常用的数据结构</h4><ul><li>  <strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li><li>  <strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li></ul><h4 id="String-的应用场景有哪些？"><a href="#String-的应用场景有哪些？" class="headerlink" title="String 的应用场景有哪些？"></a>String 的应用场景有哪些？</h4><ul><li>  常规数据（比如 session、token、、序列化后的对象）的缓存；</li><li>  计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li><li>  分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li></ul><h4 id="String-还是-Hash-存储对象数据更好呢？"><a href="#String-还是-Hash-存储对象数据更好呢？" class="headerlink" title="String 还是 Hash 存储对象数据更好呢？"></a>String 还是 Hash 存储对象数据更好呢？</h4><ul><li>  String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li><li>  String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li></ul><p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p><h4 id="String-的底层实现"><a href="#String-的底层实现" class="headerlink" title="String 的底层实现"></a>String 的底层实现</h4><p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 <code>\0</code> 结尾的字符数组），而是自己编写了 SDS（Simple Dynamic String，简单动态字符串） 来作为底层实现。</p><p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。</p><p>Redis7.0 的 SDS 的部分源码如下（<a href="https://github.com/redis/redis/blob/7.0/src/sds.h%EF%BC%89%EF%BC%9A">https://github.com/redis/redis/blob/7.0/src/sds.h）：</a></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr5</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, and 5 msb of string length */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span>    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr16</span> <span class="token punctuation">{</span>    <span class="token class-name">uint16_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>    <span class="token class-name">uint16_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr32</span> <span class="token punctuation">{</span>    <span class="token class-name">uint32_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>    <span class="token class-name">uint32_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr64</span> <span class="token punctuation">{</span>    <span class="token class-name">uint64_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>    <span class="token class-name">uint64_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。</p><p>对于后四种实现都包含了下面这 4 个属性：</p><ul><li>  <code>len</code> ：字符串的长度也就是已经使用的字节数</li><li>  <code>alloc</code>：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小</li><li>  <code>buf[]</code> ：实际存储字符串的数组</li><li>  <code>flags</code> ：低三位保存类型标志</li></ul><p>SDS 相比于 C 语言中的字符串有如下提升：</p><ol><li> <strong>可以避免缓冲区溢出</strong> ：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li><li> <strong>获取字符串长度的复杂度较低</strong> ： C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li><li> <strong>减少内存分配次数</strong> ： 为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li><li> <strong>二进制安全</strong> ：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li></ol><h4 id="购物车信息用-String-还是-Hash-存储更好"><a href="#购物车信息用-String-还是-Hash-存储更好" class="headerlink" title="购物车信息用 String 还是 Hash 存储更好"></a>购物车信息用 String 还是 Hash 存储更好</h4><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p><ul><li>  用户 id 为 key</li><li>  商品 id 为 field，商品数量为 value<br><img src="/images/image_redis/01.png"></li></ul><p>用户购物车信息的维护具体操作</p><ul><li>  用户添加商品就是往 Hash 里面增加新的 field 与 value；</li><li>  查询购物车信息就是遍历对应的 Hash；</li><li>  更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li><li>  删除商品就是删除 Hash 中对应的 field；</li><li>  清空购物车直接删除对应的 key 即可。</li></ul><p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p><h4 id="使用-Redis-实现一个排行榜"><a href="#使用-Redis-实现一个排行榜" class="headerlink" title="使用 Redis 实现一个排行榜"></a>使用 Redis 实现一个排行榜</h4><p>Redis 中有一个叫做 <code>sorted set</code> 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p><p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p><h4 id="使用-Set-实现抽奖系统用到的命令"><a href="#使用-Set-实现抽奖系统用到的命令" class="headerlink" title="使用 Set 实现抽奖系统用到的命令"></a>使用 Set 实现抽奖系统用到的命令</h4><ul><li>  <code>SPOP key count</code> ： 随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li><li>  <code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li></ul><h4 id="使用-Bitmap-统计活跃用户怎"><a href="#使用-Bitmap-统计活跃用户怎" class="headerlink" title="使用 Bitmap 统计活跃用户怎"></a>使用 Bitmap 统计活跃用户怎</h4><p>使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p><p>初始化数据：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> SETBIT <span class="token number">20210308</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token operator">&gt;</span> SETBIT <span class="token number">20210308</span> <span class="token number">2</span> <span class="token number">1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token operator">&gt;</span> SETBIT <span class="token number">20210309</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>统计 20210308~20210309 总活跃用户数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> BITOP and desk1 <span class="token number">20210308</span> <span class="token number">20210309</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">&gt;</span> BITCOUNT desk1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>统计 20210308~20210309 在线活跃用户数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> BITOP or desk2 <span class="token number">20210308</span> <span class="token number">20210309</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">&gt;</span> BITCOUNT desk2<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Redis-线程模型"><a href="#3-Redis-线程模型" class="headerlink" title="3. Redis 线程模型"></a>3. Redis 线程模型</h3><p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p><h4 id="Redis-单线程模型"><a href="#Redis-单线程模型" class="headerlink" title="Redis 单线程模型"></a>Redis 单线程模型</h4><p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><blockquote><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。</p><ul><li>  文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>  当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p></blockquote><p><strong>既然是单线程，那怎么监听大量的客户端连接？</strong></p><p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p><p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p><p>文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>  多个 socket（客户端连接）</li><li>  IO 多路复用程序（支持多个客户端连接的关键）</li><li>  文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>  事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p><img src="/images/image_redis/02.png"></p><h4 id="Redis6-0-之前为什么不使用多线程？"><a href="#Redis6-0-之前为什么不使用多线程？" class="headerlink" title="Redis6.0 之前为什么不使用多线程？"></a>Redis6.0 之前为什么不使用多线程？</h4><p>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p><p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。</p><p>为此，Redis 4.0 之后新增了<code>UNLINK</code>（可以看作是 <code>DEL</code> 的异步版本）、<code>FLUSHALL ASYNC</code>（清空所有数据库的所有 key，不仅仅是当前 <code>SELECT</code> 的数据库）、<code>FLUSHDB ASYNC</code>（清空当前 <code>SELECT</code> 数据库中的所有 key）等异步命令。</p><p>大体上来说，Redis 6.0 之前主要还是单线程处理。</p><p><strong>那 Redis6.0 之前为什么不使用多线程？</strong> 我觉得主要原因有 3 点：</p><ul><li>  单线程编程容易并且更容易维护；</li><li>  Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>  多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ul><h4 id="Redis6-0-之后为何引入了多线程？"><a href="#Redis6-0-之后为何引入了多线程？" class="headerlink" title="Redis6.0 之后为何引入了多线程？"></a>Redis6.0 之后为何引入了多线程？</h4><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p><p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p><h3 id="4-Redis-内存管理"><a href="#4-Redis-内存管理" class="headerlink" title="4. Redis 内存管理"></a>4. Redis 内存管理</h3><h4 id="Redis-给缓存数据设置过期时间"><a href="#Redis-给缓存数据设置过期时间" class="headerlink" title="Redis 给缓存数据设置过期时间"></a>Redis 给缓存数据设置过期时间</h4><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p><p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p><p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> expire key <span class="token number">60</span> <span class="token comment"># 数据在 60s 后过期</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setex key <span class="token number">60</span> value <span class="token comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span>OK<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ttl key <span class="token comment"># 查看数据还有多久过期</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">56</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p><p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p><p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。</p><p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p><h4 id="Redis-是如何判断数据是否过期"><a href="#Redis-是如何判断数据是否过期" class="headerlink" title="Redis 是如何判断数据是否过期"></a>Redis 是如何判断数据是否过期</h4><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p><p>过期字典是存储在 redisDb 这个结构里的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>     <span class="token comment">//数据库键空间,保存着数据库中所有键值对</span>    dict <span class="token operator">*</span>expires   <span class="token comment">// 过期字典,保存着键的过期时间</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="过期的数据的删除策略"><a href="#过期的数据的删除策略" class="headerlink" title="过期的数据的删除策略"></a>过期的数据的删除策略</h4><p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p><p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p><ol><li> <strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li> <strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p><p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p><h4 id="Redis-内存淘汰机制"><a href="#Redis-内存淘汰机制" class="headerlink" title="Redis 内存淘汰机制"></a>Redis 内存淘汰机制</h4><blockquote><p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p></blockquote><p>Redis 提供 6 种数据淘汰策略：</p><ol><li> <strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li> <strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li> <strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li> <strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li> <strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li> <strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol start="7"><li> <strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li><li> <strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ol><h3 id="5-Redis-持久化机制"><a href="#5-Redis-持久化机制" class="headerlink" title="5. Redis 持久化机制"></a>5. Redis 持久化机制</h3><h4 id="怎么保证-Redis-挂掉之后再重启数据可以进行恢复"><a href="#怎么保证-Redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="怎么保证 Redis 挂掉之后再重启数据可以进行恢复"></a>怎么保证 Redis 挂掉之后再重启数据可以进行恢复</h4><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p><p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p><h4 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h4><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">save <span class="token number">900</span> <span class="token number">1</span>           <span class="token comment">#在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。</span>save <span class="token number">300</span> <span class="token number">10</span>          <span class="token comment">#在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。</span>save <span class="token number">60</span> <span class="token number">10000</span>        <span class="token comment">#在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="RDB-创建快照时会阻塞主线程吗？"><a href="#RDB-创建快照时会阻塞主线程吗？" class="headerlink" title="RDB 创建快照时会阻塞主线程吗？"></a>RDB 创建快照时会阻塞主线程吗？</h4><p>Redis 提供了两个命令来生成 RDB 快照文件：</p><ul><li>  <code>save</code> : 主线程执行，会阻塞主线程；</li><li>  <code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</li></ul><h4 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h4><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">appendonly <span class="token function">yes</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">appendfsync always    <span class="token comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span>appendfsync everysec  <span class="token comment">#每秒钟同步一次，显式地将多个写命令同步到硬盘</span>appendfsync no        <span class="token comment">#让操作系统决定何时进行同步</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><h4 id="AOF-日志实现"><a href="#AOF-日志实现" class="headerlink" title="AOF 日志实现"></a>AOF 日志实现</h4><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</p><p><img src="/images/image_redis/03.png"></p><p><strong>为什么是在执行完命令之后记录日志呢？</strong></p><ul><li>  避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li><li>  在命令执行完之后再记录，不会阻塞当前的命令执行。</li></ul><p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p><ul><li>  如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li><li>  可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li></ul><h4 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h4><p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p><p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p><p>在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p><p>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</p><h4 id="如何选择-RDB-和-AOF"><a href="#如何选择-RDB-和-AOF" class="headerlink" title="如何选择 RDB 和 AOF"></a>如何选择 RDB 和 AOF</h4><p><strong>RDB 比 AOF 优秀的地方</strong> ：</p><ul><li>  RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会必 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li><li>  使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li></ul><p><strong>AOF 比 RDB 优秀的地方</strong> ：</p><ul><li>  RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li><li>  RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li><li>  AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li></ul><h4 id="Redis-4-0-对于持久化机制做了什么优化"><a href="#Redis-4-0-对于持久化机制做了什么优化" class="headerlink" title="Redis 4.0 对于持久化机制做了什么优化"></a>Redis 4.0 对于持久化机制做了什么优化</h4><p>由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Redis-基础&quot;&gt;&lt;a href=&quot;#1-Redis-基础&quot; class=&quot;headerlink&quot; title=&quot;1. Redis 基础&quot;&gt;&lt;/a&gt;1. Redis 基础&lt;/h3&gt;&lt;h4 id=&quot;什么是-Redis？&quot;&gt;&lt;a href=&quot;#什么是-Redis</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="NoSQL" scheme="http://ailiaa.github.io/tags/NoSQL/"/>
    
    <category term="redis" scheme="http://ailiaa.github.io/tags/redis/"/>
    
  </entry>
  
  <entry>
    <title>MySQL高性能优化</title>
    <link href="http://ailiaa.github.io/2023/03/11/mysql-gao-xing-neng-you-hua/"/>
    <id>http://ailiaa.github.io/2023/03/11/mysql-gao-xing-neng-you-hua/</id>
    <published>2023-03-11T07:51:24.000Z</published>
    <updated>2023-03-11T08:00:39.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数据库命名规范"><a href="#1-数据库命名规范" class="headerlink" title="1. 数据库命名规范"></a>1. 数据库命名规范</h3><ul><li>  所有数据库对象名称必须使用小写字母并用下划线分割</li><li>  所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li><li>  数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li><li>  临时库表必须以 <code>tmp_</code> 为前缀并以日期为后缀，备份表必须以 <code>bak_</code> 为前缀并以日期 (时间戳) 为后缀</li><li>  所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li></ul><h3 id="2-数据库基本设计规范"><a href="#2-数据库基本设计规范" class="headerlink" title="2. 数据库基本设计规范"></a>2. 数据库基本设计规范</h3><h4 id="所有表必须使用-InnoDB-存储引擎"><a href="#所有表必须使用-InnoDB-存储引擎" class="headerlink" title="所有表必须使用 InnoDB 存储引擎"></a>所有表必须使用 InnoDB 存储引擎</h4><p>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）。</p><p>InnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p><h4 id="数据库和表的字符集统一使用-UTF8"><a href="#数据库和表的字符集统一使用-UTF8" class="headerlink" title="数据库和表的字符集统一使用 UTF8"></a>数据库和表的字符集统一使用 UTF8</h4><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p><h4 id="所有表和字段都需要添加注释"><a href="#所有表和字段都需要添加注释" class="headerlink" title="所有表和字段都需要添加注释"></a>所有表和字段都需要添加注释</h4><p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p><h4 id="尽量控制单表数据量的大小，建议控制在-500-万以内"><a href="#尽量控制单表数据量的大小，建议控制在-500-万以内" class="headerlink" title="尽量控制单表数据量的大小，建议控制在 500 万以内"></a>尽量控制单表数据量的大小，建议控制在 500 万以内</h4><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p><p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p><h4 id="谨慎使用-MySQL-分区表"><a href="#谨慎使用-MySQL-分区表" class="headerlink" title="谨慎使用 MySQL 分区表"></a>谨慎使用 MySQL 分区表</h4><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p><p>谨慎选择分区键，跨分区查询效率可能更低；</p><p>建议采用物理分表的方式管理大数据。</p><h4 id="经常一起使用的列放到一个表中"><a href="#经常一起使用的列放到一个表中" class="headerlink" title="经常一起使用的列放到一个表中"></a>经常一起使用的列放到一个表中</h4><p>避免更多的关联操作。</p><h4 id="禁止在表中建立预留字段"><a href="#禁止在表中建立预留字段" class="headerlink" title="禁止在表中建立预留字段"></a>禁止在表中建立预留字段</h4><ul><li>  预留字段的命名很难做到见名识义。</li><li>  预留字段无法确认存储的数据类型，所以无法选择合适的类型。</li><li>  对预留字段类型的修改，会对表进行锁定。</li></ul><h4 id="禁止在数据库中存储文件（比如图片）这类大的二进制数据"><a href="#禁止在数据库中存储文件（比如图片）这类大的二进制数据" class="headerlink" title="禁止在数据库中存储文件（比如图片）这类大的二进制数据"></a>禁止在数据库中存储文件（比如图片）这类大的二进制数据</h4><p>在数据库中存储文件会严重影响数据库性能，消耗过多存储空间。</p><p>文件（比如图片）这类大的二进制数据通常存储于文件服务器，数据库只存储文件地址信息。</p><h4 id="不要被数据库范式所束缚"><a href="#不要被数据库范式所束缚" class="headerlink" title="不要被数据库范式所束缚"></a>不要被数据库范式所束缚</h4><p>一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度。</p><h4 id="禁止在线上做数据库压力测试"><a href="#禁止在线上做数据库压力测试" class="headerlink" title="禁止在线上做数据库压力测试"></a>禁止在线上做数据库压力测试</h4><h4 id="禁止从开发环境-测试环境直接连接生产环境数据库"><a href="#禁止从开发环境-测试环境直接连接生产环境数据库" class="headerlink" title="禁止从开发环境,测试环境直接连接生产环境数据库"></a>禁止从开发环境,测试环境直接连接生产环境数据库</h4><p>安全隐患极大，要对生产环境抱有敬畏之心！</p><h3 id="3-数据库字段设计规范"><a href="#3-数据库字段设计规范" class="headerlink" title="3. 数据库字段设计规范"></a>3. 数据库字段设计规范</h3><h4 id="优先选择符合存储需要的最小的数据类型"><a href="#优先选择符合存储需要的最小的数据类型" class="headerlink" title="优先选择符合存储需要的最小的数据类型"></a>优先选择符合存储需要的最小的数据类型</h4><p>存储字节越小，占用也就空间越小，性能也越好。</p><p><strong>a.某些字符串可以转换成数字类型存储比如可以将 IP 地址转换成整型数据。</strong></p><p>数字是连续的，性能更好，占用空间也更小。</p><p>MySQL 提供了两个方法来处理 ip 地址</p><ul><li>  <code>INET_ATON()</code> ： 把 ip 转为无符号整型 (4-8 位)</li><li>  <code>INET_NTOA()</code> :把整型的 ip 转为地址</li></ul><p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p><p><strong>b.对于非负型的数据 (如自增 ID,整型 IP，年龄) 来说,要优先使用无符号整型来存储。</strong></p><p>无符号相对于有符号可以多出一倍的存储空间</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SIGNED <span class="token keyword">INT</span> <span class="token operator">-</span><span class="token number">2147483648</span><span class="token operator">~</span><span class="token number">2147483647</span><span class="token keyword">UNSIGNED</span> <span class="token keyword">INT</span> <span class="token number">0</span><span class="token operator">~</span><span class="token number">4294967295</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>c.小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型。</strong></p><h4 id="避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据"><a href="#避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据" class="headerlink" title="避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据"></a>避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h4><p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。</strong></p><p>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p><p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 <code>select *</code>而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p><p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p><p>因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p><h4 id="避免使用-ENUM-类型"><a href="#避免使用-ENUM-类型" class="headerlink" title="避免使用 ENUM 类型"></a>避免使用 ENUM 类型</h4><ul><li>  修改 ENUM 值需要使用 ALTER 语句；</li><li>  ENUM 类型的 ORDER BY 操作效率低，需要额外操作；</li><li>  ENUM 数据类型存在一些限制比如建议不要使用数值作为 ENUM 的枚举值。</li></ul><h4 id="尽可能把所有列定义为-NOT-NULL"><a href="#尽可能把所有列定义为-NOT-NULL" class="headerlink" title="尽可能把所有列定义为 NOT NULL"></a>尽可能把所有列定义为 NOT NULL</h4><p>除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。</p><ul><li>  索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；</li><li>  进行比较和计算时要对 NULL 值做特别的处理。</li></ul><h4 id="使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间"><a href="#使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间" class="headerlink" title="使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间"></a>使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</h4><p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p><p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p><p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p><p><strong>经常会有人用字符串存储日期型的数据（不正确的做法）</strong></p><ul><li>  缺点 1：无法用日期函数进行计算和比较</li><li>  缺点 2：用字符串存储日期要占用更多的空间</li></ul><h4 id="同财务相关的金额类数据必须使用-decimal-类型"><a href="#同财务相关的金额类数据必须使用-decimal-类型" class="headerlink" title="同财务相关的金额类数据必须使用 decimal 类型"></a>同财务相关的金额类数据必须使用 decimal 类型</h4><ul><li>  <strong>非精准浮点</strong> ：float,double</li><li>  <strong>精准浮点</strong> ：decimal</li></ul><p>decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据</p><p>不过， 由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 。</p><h4 id="单表不要包含过多字段"><a href="#单表不要包含过多字段" class="headerlink" title="单表不要包含过多字段"></a>单表不要包含过多字段</h4><p>如果一个表包含过多字段的话，可以考虑将其分解成多个表，必要时增加中间表进行关联。</p><h3 id="4-索引设计规范"><a href="#4-索引设计规范" class="headerlink" title="4. 索引设计规范"></a>4. 索引设计规范</h3><h4 id="限制每张表上的索引数量-建议单张表索引不超过-5-个"><a href="#限制每张表上的索引数量-建议单张表索引不超过-5-个" class="headerlink" title="限制每张表上的索引数量,建议单张表索引不超过 5 个"></a>限制每张表上的索引数量,建议单张表索引不超过 5 个</h4><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p><p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p><p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p><h4 id="禁止使用全文索引"><a href="#禁止使用全文索引" class="headerlink" title="禁止使用全文索引"></a>禁止使用全文索引</h4><p>全文索引不适用于 OLTP 场景。</p><h4 id="禁止给表中的每一列都建立单独的索引"><a href="#禁止给表中的每一列都建立单独的索引" class="headerlink" title="禁止给表中的每一列都建立单独的索引"></a>禁止给表中的每一列都建立单独的索引</h4><p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p><h4 id="每个-InnoDB-表必须有个主键"><a href="#每个-InnoDB-表必须有个主键" class="headerlink" title="每个 InnoDB 表必须有个主键"></a>每个 InnoDB 表必须有个主键</h4><p>InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p><p>InnoDB 是按照主键索引的顺序来组织表的</p><ul><li>  不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li><li>  不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li><li>  主键建议使用自增 ID 值</li></ul><h4 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="常见索引列建议"></a>常见索引列建议</h4><ul><li>  出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li><li>  包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li><li>  并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li><li>  多表 join 的关联列</li></ul><h4 id="如何选择索引列的顺序"><a href="#如何选择索引列的顺序" class="headerlink" title="如何选择索引列的顺序"></a>如何选择索引列的顺序</h4><p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p><ul><li>  区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li><li>  尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li><li>  使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li></ul><h4 id="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"></a>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h4><ul><li>  重复索引示例：primary key(id)、index(id)、unique index(id)</li><li>  冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li></ul><h4 id="对于频繁的查询优先考虑使用覆盖索引"><a href="#对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="对于频繁的查询优先考虑使用覆盖索引"></a>对于频繁的查询优先考虑使用覆盖索引</h4><blockquote><p>覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引</p></blockquote><p><strong>覆盖索引的好处：</strong></p><ul><li>  <strong>避免 InnoDB 表进行索引的二次查询:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li><li>  <strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li></ul><h4 id="索引-SET-规范"><a href="#索引-SET-规范" class="headerlink" title="索引 SET 规范"></a>索引 SET 规范</h4><p><strong>尽量避免使用外键约束</strong></p><ul><li>  不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li><li>  外键可用于保证数据的参照完整性，但建议在业务端实现</li><li>  外键会影响父表和子表的写操作从而降低性能</li></ul><h3 id="5-数据库-SQL-开发规范"><a href="#5-数据库-SQL-开发规范" class="headerlink" title="5. 数据库 SQL 开发规范"></a>5. 数据库 SQL 开发规范</h3><h4 id="优化对性能影响较大的-SQL-语句"><a href="#优化对性能影响较大的-SQL-语句" class="headerlink" title="优化对性能影响较大的 SQL 语句"></a>优化对性能影响较大的 SQL 语句</h4><p>要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句；</p><h4 id="充分利用表上已经存在的索引"><a href="#充分利用表上已经存在的索引" class="headerlink" title="充分利用表上已经存在的索引"></a>充分利用表上已经存在的索引</h4><p>避免使用双%号的查询条件。如：<code>a like '%123%'</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p><p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p><p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p><h4 id="禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询"><a href="#禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询" class="headerlink" title="禁止使用 SELECT * 必须使用 SELECT <字段列表> 查询"></a>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h4><ul><li>  <code>SELECT *</code> 消耗更多的 CPU 和 IO 以网络带宽资源</li><li>  <code>SELECT *</code> 无法使用覆盖索引</li><li>  <code>SELECT &lt;字段列表&gt;</code> 可减少表结构变更带来的影响</li></ul><h4 id="禁止使用不含字段列表的-INSERT-语句"><a href="#禁止使用不含字段列表的-INSERT-语句" class="headerlink" title="禁止使用不含字段列表的 INSERT 语句"></a>禁止使用不含字段列表的 INSERT 语句</h4><p>如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应使用：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> t<span class="token punctuation">(</span>c1<span class="token punctuation">,</span>c2<span class="token punctuation">,</span>c3<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="建议使用预编译语句进行数据库操作"><a href="#建议使用预编译语句进行数据库操作" class="headerlink" title="建议使用预编译语句进行数据库操作"></a>建议使用预编译语句进行数据库操作</h4><ul><li>  预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</li><li>  只传参数，比传递 SQL 语句更高效。</li><li>  相同语句可以一次解析，多次使用，提高处理效率。</li></ul><h4 id="避免数据类型的隐式转换"><a href="#避免数据类型的隐式转换" class="headerlink" title="避免数据类型的隐式转换"></a>避免数据类型的隐式转换</h4><p>隐式转换会导致索引失效如:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> name<span class="token punctuation">,</span>phone <span class="token keyword">from</span> customer <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token string">'111'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="避免使用子查询，可以把子查询优化为-join-操作"><a href="#避免使用子查询，可以把子查询优化为-join-操作" class="headerlink" title="避免使用子查询，可以把子查询优化为 join 操作"></a>避免使用子查询，可以把子查询优化为 join 操作</h4><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p><p><strong>子查询性能差的原因：</strong> 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p><h4 id="避免使用-JOIN-关联太多的表"><a href="#避免使用-JOIN-关联太多的表" class="headerlink" title="避免使用 JOIN 关联太多的表"></a>避免使用 JOIN 关联太多的表</h4><p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p><p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p><p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p><p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p><h4 id="减少同数据库的交互次数"><a href="#减少同数据库的交互次数" class="headerlink" title="减少同数据库的交互次数"></a>减少同数据库的交互次数</h4><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p><h4 id="对应同一列进行-or-判断时，使用-in-代替-or"><a href="#对应同一列进行-or-判断时，使用-in-代替-or" class="headerlink" title="对应同一列进行 or 判断时，使用 in 代替 or"></a>对应同一列进行 or 判断时，使用 in 代替 or</h4><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p><h4 id="禁止使用-order-by-rand-进行随机排序"><a href="#禁止使用-order-by-rand-进行随机排序" class="headerlink" title="禁止使用 order by rand() 进行随机排序"></a>禁止使用 order by rand() 进行随机排序</h4><p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p><p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p><h4 id="WHERE-从句中禁止对列进行函数转换和计算"><a href="#WHERE-从句中禁止对列进行函数转换和计算" class="headerlink" title="WHERE 从句中禁止对列进行函数转换和计算"></a>WHERE 从句中禁止对列进行函数转换和计算</h4><p>对列进行函数转换或计算时会导致无法使用索引</p><p><strong>不推荐：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">where</span> <span class="token keyword">date</span><span class="token punctuation">(</span>create_time<span class="token punctuation">)</span><span class="token operator">=</span><span class="token string">'20190101'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>推荐：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">where</span> create_time <span class="token operator">&gt;=</span> <span class="token string">'20190101'</span> <span class="token operator">and</span> create_time <span class="token operator">&lt;</span> <span class="token string">'20190102'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="在明显不会有重复值时使用-UNION-ALL-而不是-UNION"><a href="#在明显不会有重复值时使用-UNION-ALL-而不是-UNION" class="headerlink" title="在明显不会有重复值时使用 UNION ALL 而不是 UNION"></a>在明显不会有重复值时使用 UNION ALL 而不是 UNION</h4><ul><li>  UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li><li>  UNION ALL 不会再对结果集进行去重操作</li></ul><h4 id="拆分复杂的大-SQL-为多个小-SQL"><a href="#拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="拆分复杂的大 SQL 为多个小 SQL"></a>拆分复杂的大 SQL 为多个小 SQL</h4><ul><li>  大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li><li>  MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li><li>  SQL 拆分后可以通过并行执行来提高处理效率</li></ul><h4 id="程序连接不同的数据库使用不同的账号，禁止跨库查询"><a href="#程序连接不同的数据库使用不同的账号，禁止跨库查询" class="headerlink" title="程序连接不同的数据库使用不同的账号，禁止跨库查询"></a>程序连接不同的数据库使用不同的账号，禁止跨库查询</h4><ul><li>  为数据库迁移和分库分表留出余地</li><li>  降低业务耦合度</li><li>  避免权限过大而产生的安全风险</li></ul><h3 id="6-数据库操作行为规范"><a href="#6-数据库操作行为规范" class="headerlink" title="6. 数据库操作行为规范"></a>6. 数据库操作行为规范</h3><h4 id="超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作"><a href="#超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作" class="headerlink" title="超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作"></a>超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h4><p><strong>大批量操作可能会造成严重的主从延迟</strong></p><p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p><p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p><p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p><p><strong>避免产生大事务操作</strong></p><p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p><p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p><h4 id="对于大表使用-pt-online-schema-change-修改表结构"><a href="#对于大表使用-pt-online-schema-change-修改表结构" class="headerlink" title="对于大表使用 pt-online-schema-change 修改表结构"></a>对于大表使用 pt-online-schema-change 修改表结构</h4><ul><li>  避免大表修改产生的主从延迟</li><li>  避免在对表字段进行修改时进行锁表</li></ul><p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p><p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p><h4 id="禁止为程序使用的账号赋予-super-权限"><a href="#禁止为程序使用的账号赋予-super-权限" class="headerlink" title="禁止为程序使用的账号赋予 super 权限"></a>禁止为程序使用的账号赋予 super 权限</h4><ul><li>  当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li><li>  super 权限只能留给 DBA 处理问题的账号使用</li></ul><h4 id="对于程序连接数据库账号-遵循权限最小原则"><a href="#对于程序连接数据库账号-遵循权限最小原则" class="headerlink" title="对于程序连接数据库账号,遵循权限最小原则"></a>对于程序连接数据库账号,遵循权限最小原则</h4><ul><li>  程序使用数据库账号只能在一个 DB 下使用，不准跨库</li><li>  程序使用的账号原则上不准有 drop 权限</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-数据库命名规范&quot;&gt;&lt;a href=&quot;#1-数据库命名规范&quot; class=&quot;headerlink&quot; title=&quot;1. 数据库命名规范&quot;&gt;&lt;/a&gt;1. 数据库命名规范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;  所有数据库对象名称必须使用小写字母并用下划线分割&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://ailiaa.github.io/tags/MySQL/"/>
    
  </entry>
  
</feed>
