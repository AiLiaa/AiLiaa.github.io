<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>艾AA</title>
  
  
  <link href="http://ailiaa.github.io/atom.xml" rel="self"/>
  
  <link href="http://ailiaa.github.io/"/>
  <updated>2023-04-15T07:58:45.547Z</updated>
  <id>http://ailiaa.github.io/</id>
  
  <author>
    <name>Aiaa</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>MySQL</title>
    <link href="http://ailiaa.github.io/2023/04/15/mysql-ban-ben-sheng-ji-5.5-8.0.20/"/>
    <id>http://ailiaa.github.io/2023/04/15/mysql-ban-ben-sheng-ji-5.5-8.0.20/</id>
    <published>2023-04-15T07:58:16.000Z</published>
    <updated>2023-04-15T07:58:45.547Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-备份数据库"><a href="#1-备份数据库" class="headerlink" title="1. 备份数据库"></a>1. 备份数据库</h3><p>在数据库编辑器中对重要的数据库导出为<code>.sql</code>文件<br>版本升级后，可以在新版本的MySQL中新建数据库执行<code>.sql</code>文件，恢复数据</p><p><em><strong>（在此升级过程中并不会删掉原有数据库，数据备份是一个好习惯）</strong></em></p><h3 id="2-下载对应版本的MySQL"><a href="#2-下载对应版本的MySQL" class="headerlink" title="2. 下载对应版本的MySQL"></a>2. 下载对应版本的MySQL</h3><p><a href="https://downloads.mysql.com/archives/community/">官网：https://downloads.mysql.com/archives/community/</a></p><p><img src="/images/image_MySQL%E5%8D%87%E7%BA%A7/1.png"></p><p>然后将安装包解压，最好和MySQL5.5（老版本）放在一起，方便查找</p><h3 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3. 配置环境变量"></a>3. 配置环境变量</h3><p><code>D:\MySQL\mysql-8.0.20\bin</code></p><p>在用户变量path 中添加MySQL的bin文件夹目录</p><p>删除老版本MySQL的环境变量</p><h3 id="4-配置文件"><a href="#4-配置文件" class="headerlink" title="4. 配置文件"></a>4. 配置文件</h3><p>在<code>mysql-8.0.20</code>目录下新建<code>my.ini</code>文件</p><p><img src="/images/image_MySQL%E5%8D%87%E7%BA%A7/2.png"></p><p>写入：</p><pre class="line-numbers language-none"><code class="language-none"># 设置3306端口port=3306# 设置mysql的安装目录，写你的目录basedir=D:\MySQL# 设置mysql数据库的数据的存放目录，这是隐藏的文件夹datadir=C:\ProgramData\MySQL/MySQL Server 8.0\Data\# 允许最大连接数max_connections=200# 允许连接失败的次数。防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-停止MySQL5-5服务"><a href="#5-停止MySQL5-5服务" class="headerlink" title="5. 停止MySQL5.5服务"></a>5. 停止MySQL5.5服务</h3><p>在任务管理器-&gt;服务 : 找到MySQL</p><p>停止MySQL服务</p><p>以管理员运行命令窗口</p><pre class="line-numbers language-none"><code class="language-none">C:\Windows\system32&gt;cd D:\MySQL\MySQL5.5\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入该文件夹，执行</p><pre class="line-numbers language-none"><code class="language-none">mysqld --remove mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-安装运行MySQL-8-0-2"><a href="#6-安装运行MySQL-8-0-2" class="headerlink" title="6. 安装运行MySQL 8.0.2"></a>6. 安装运行MySQL 8.0.2</h3><pre class="line-numbers language-none"><code class="language-none"># 设置mysql数据库的数据的存放目录，这是隐藏的文件夹datadir=C:\ProgramData\MySQL/MySQL Server 8.0\Data\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建文件夹，存放数据<br>需要查看隐藏文件夹ProgramData<br><code>C:\ProgramData\MySQL/MySQL Server 8.0\Data\</code></p><pre class="line-numbers language-none"><code class="language-none">cd D:\MySQL\mysql-8.0.20\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到mysql-8.0.20的bin目录下</p><p>执行安装命令</p><pre class="line-numbers language-none"><code class="language-none">mysqld -install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行初始化命令</p><pre class="line-numbers language-none"><code class="language-none">mysqld --initialize --user=mysql --console<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化成功后会给个root临时密码，类似 DQybZ_HT#76B</p><p>以root账号进入数据库  </p><pre class="line-numbers language-none"><code class="language-none">mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接</p><pre class="line-numbers language-none"><code class="language-none">net start mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改密码</p><pre class="line-numbers language-none"><code class="language-none">ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到此MySQL升级成功，在SQLyog编辑器中已经自动连接上8.0.20版本MySQL</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-备份数据库&quot;&gt;&lt;a href=&quot;#1-备份数据库&quot; class=&quot;headerlink&quot; title=&quot;1. 备份数据库&quot;&gt;&lt;/a&gt;1. 备份数据库&lt;/h3&gt;&lt;p&gt;在数据库编辑器中对重要的数据库导出为&lt;code&gt;.sql&lt;/code&gt;文件&lt;br&gt;版本升级后，可</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://ailiaa.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>DevOps流水线搭建03</title>
    <link href="http://ailiaa.github.io/2023/04/15/devops-liu-shui-xian-da-jian-03/"/>
    <id>http://ailiaa.github.io/2023/04/15/devops-liu-shui-xian-da-jian-03/</id>
    <published>2023-04-15T07:02:48.000Z</published>
    <updated>2023-04-15T07:07:21.481Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-测试DevOps流水线"><a href="#1-测试DevOps流水线" class="headerlink" title="1. 测试DevOps流水线"></a>1. 测试DevOps流水线</h2><h3 id="gitlab创建项目并拉取到本地"><a href="#gitlab创建项目并拉取到本地" class="headerlink" title="gitlab创建项目并拉取到本地"></a>gitlab创建项目并拉取到本地</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8730.png"><br>关闭防火墙，让本机访问gitlab</p><pre class="line-numbers language-none"><code class="language-none">$systemctl stop firewalld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>clone项目，将我们需要打包发布的项目推送到gitlab</p><pre class="line-numbers language-none"><code class="language-none">git add .git commit -m "first push"git tag 1.0.0git push origin 1.0.0git push -u origin --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="harbor-server上构建基础镜像"><a href="#harbor-server上构建基础镜像" class="headerlink" title="harbor-server上构建基础镜像"></a>harbor-server上构建基础镜像</h3><p>遇到小问题</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8732.png"></p><p>重启harbor解决</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker-compose down$sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>拉取openjdk镜像</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker pull openjdk:8u201-jdk-alpine3.9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8733.png"></p><pre class="line-numbers language-none"><code class="language-none">$sudo docker tag openjdk:8u201-jdk-alpine3.9 192.168.159.131:8077/library/openjdk8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8734.png"><br>登录harbor仓库</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker login 192.168.159.131:8077<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>推送</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker push 192.168.159.131:8077/library/openjdk8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8735.png"></p><h3 id="构建jenkins应用"><a href="#构建jenkins应用" class="headerlink" title="构建jenkins应用"></a>构建jenkins应用</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8736.png"><br>遇到问题：</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8737.png"></p><p>我这里是因为gitlab-server上没安装ssh服务,安装后解决<br>其他原因可能是私钥密钥配置错误</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8738.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8739.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8740.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8741.png"></p><p>开始构建</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8742.png"></p><p>构建成功<br>访问</p><p><img src="/images/image_DevOps/2.jpg"></p><p>修改代码后，再次push</p><p><img src="/images/image_DevOps/1.jpg"></p><p><img src="/images/image_DevOps/3.jpg"></p><p>流水线测试成功！</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-测试DevOps流水线&quot;&gt;&lt;a href=&quot;#1-测试DevOps流水线&quot; class=&quot;headerlink&quot; title=&quot;1. 测试DevOps流水线&quot;&gt;&lt;/a&gt;1. 测试DevOps流水线&lt;/h2&gt;&lt;h3 id=&quot;gitlab创建项目并拉取到本地&quot;&gt;&lt;</summary>
      
    
    
    
    
    <category term="docker" scheme="http://ailiaa.github.io/tags/docker/"/>
    
    <category term="harbor" scheme="http://ailiaa.github.io/tags/harbor/"/>
    
    <category term="jenkins" scheme="http://ailiaa.github.io/tags/jenkins/"/>
    
    <category term="DevOps" scheme="http://ailiaa.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>DevOps流水线搭建02</title>
    <link href="http://ailiaa.github.io/2023/04/10/devops-liu-shui-xian-da-jian-02/"/>
    <id>http://ailiaa.github.io/2023/04/10/devops-liu-shui-xian-da-jian-02/</id>
    <published>2023-04-10T01:30:18.000Z</published>
    <updated>2023-04-15T07:04:27.966Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-各主机中的工具配置"><a href="#1-各主机中的工具配置" class="headerlink" title="1. 各主机中的工具配置"></a>1. 各主机中的工具配置</h2><h3 id="jenkins-server"><a href="#jenkins-server" class="headerlink" title="jenkins-server"></a>jenkins-server</h3><p><strong>docker配置</strong><br>配置docker主机使用harbor，添加信任harbor-server中的私有仓库<br>（harbor仓库ip+端口号）</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/docker/daemon.json# 写入{"insecure-registries": ["http://192.168.159.131:8077"]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启docker</p><pre class="line-numbers language-none"><code class="language-none">$systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>登录harbor主机中的docker仓库服务</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker login 192.168.159.131:8077<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8712.png"><br><strong>配置jenkins使用docker</strong></p><p>验证系统中是否有jenkins用户</p><pre class="line-numbers language-none"><code class="language-none">$grep jenkins /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证系统中是否有docker用户及用户组</p><pre class="line-numbers language-none"><code class="language-none">$grep docker /etc/group<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8713.png"><br>添加jenkins用户到docker用户组</p><pre class="line-numbers language-none"><code class="language-none">$sudo usermod -G docker jenkins$grep docker /etc/group<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8714.png"><br>重启jenkins服务</p><pre class="line-numbers language-none"><code class="language-none">$systemctl restart jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="harbor-server"><a href="#harbor-server" class="headerlink" title="harbor-server"></a>harbor-server</h3><p><strong>docker配置</strong><br>同上</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/docker/daemon.json# 写入{        "insecure-registries": ["http://192.168.159.131:8077"]}$cat /etc/docker/daemon.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启docker-compose</p><pre class="line-numbers language-none"><code class="language-none">$docker-compose down$systemctl restart docker$docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="web-server"><a href="#web-server" class="headerlink" title="web-server"></a>web-server</h3><p><strong>docker配置</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/docker/daemon.json# 写入{        "insecure-registries": ["http://192.168.159.131:8077"]}$cat /etc/docker/daemon.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启docker</p><pre class="line-numbers language-none"><code class="language-none">$systemctl restart docker$sudo docker login 192.168.159.131:8077<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-配置gitlab相关密钥"><a href="#2-配置gitlab相关密钥" class="headerlink" title="2. 配置gitlab相关密钥"></a>2. 配置gitlab相关密钥</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p><strong>Windows下生成ssh密钥，并用ssh免密访问Linux服务器</strong></p><pre class="line-numbers language-none"><code class="language-none">$ssh-keygen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8715.png"></p><p>可以在 C:\User\XXX\ 文件夹下看到一个.ssh的文件夹，里面有两个文件</p><p>id_rsa.pub，就是公钥文件，需要给Linux服务器的管理者，让他将id_rsa.pub文件中的公钥内容注册到Linux中，以便能够通过ssh来访问该Linux服务器。公钥注册到Linux服务器后，就可以在本机ssh到远端Linux服务器，并访问了。</p><p>添加到gitlab ssh密钥中:</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8716.png"></p><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p><strong>jenkins-server主机生成公钥，添加公钥至gitlab-ce</strong></p><pre class="line-numbers language-none"><code class="language-none">$ssh-keygen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8717.png"></p><pre class="line-numbers language-none"><code class="language-none">$cat /home/l/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8718.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8719.png"><br><strong>配置jenkins-sever主机的私钥到凭据列表</strong></p><pre class="line-numbers language-none"><code class="language-none">$cat /home/l/.ssh/id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8720.png"></p><p><em><strong>（注意这里要全部复制，包括首尾）</strong></em></p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8721.png"><br>修改jenkins配置文件</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/default/jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以root用户运行(因为上述操在作root用户下生成的公钥和私钥)</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8722.png"></p><h2 id="3-jenkins插件安装"><a href="#3-jenkins插件安装" class="headerlink" title="3. jenkins插件安装"></a>3. jenkins插件安装</h2><ul><li>maven integration：用于编译JAVA项目</li><li>git parameter：用于基于git版本提交进行参数构建项目</li><li>gitlab：用于jenkins-server拉取项目</li><li>Generic Webhook Trigger：用于项目自动化构建</li><li>ssh：用于jenkins-server对web-server实施项目部署</li></ul><h2 id="4-Jenkins全局工具配置"><a href="#4-Jenkins全局工具配置" class="headerlink" title="4. Jenkins全局工具配置"></a>4. Jenkins全局工具配置</h2><h3 id="JDK配置"><a href="#JDK配置" class="headerlink" title="JDK配置"></a>JDK配置</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8723.png"></p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8724.png"></p><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8725.png"></p><h3 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8726.png"></p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8727.png"></p><h2 id="5-jenkins系统配置"><a href="#5-jenkins系统配置" class="headerlink" title="5. jenkins系统配置"></a>5. jenkins系统配置</h2><p>主要配置jenkins-server通过ssh协议连接web-server<br>添加jenkins-server访问web-server凭据<br>测试连接是否成功（web-server对应的主机需要修改ssh配置允许用root账号密码连接）：</p><pre class="line-numbers language-none"><code class="language-none">$sudo vi /etc/ssh/sshd_config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8728.png"><br>重启</p><pre class="line-numbers language-none"><code class="language-none">$service sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不行，应该是root密码错误，root密码不是开机解锁密码，忘记root密码可以修改root密码</p><pre class="line-numbers language-none"><code class="language-none">$sudo passwd root <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功连接</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8729.png"><br>各工具配置完成，接下来可以测试DevOps流水线是否搭建成功。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-各主机中的工具配置&quot;&gt;&lt;a href=&quot;#1-各主机中的工具配置&quot; class=&quot;headerlink&quot; title=&quot;1. 各主机中的工具配置&quot;&gt;&lt;/a&gt;1. 各主机中的工具配置&lt;/h2&gt;&lt;h3 id=&quot;jenkins-server&quot;&gt;&lt;a href=&quot;#j</summary>
      
    
    
    
    
    <category term="docker" scheme="http://ailiaa.github.io/tags/docker/"/>
    
    <category term="harbor" scheme="http://ailiaa.github.io/tags/harbor/"/>
    
    <category term="jenkins" scheme="http://ailiaa.github.io/tags/jenkins/"/>
    
    <category term="DevOps" scheme="http://ailiaa.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>DevOps流水线搭建01</title>
    <link href="http://ailiaa.github.io/2023/04/07/devops-liu-shui-xian-da-jian-01/"/>
    <id>http://ailiaa.github.io/2023/04/07/devops-liu-shui-xian-da-jian-01/</id>
    <published>2023-04-07T05:41:13.000Z</published>
    <updated>2023-04-15T07:01:51.271Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><p>个人主机，三台ubuntu虚拟机</p><p>工具安装：</p><ul><li>Git:用于提交业务代码或克隆业务代码仓库</li><li>Gitlab:用于存储业务代码</li><li>Jenkins:用于利用插件完成业务代码编译、构建、推送至Harbor容器镜像仓库及项目部署</li><li>Tomcat:用于运行JAVA业务代码</li><li>Maven:用于编译业务代码</li><li>Harbor:用于存储业务代码构建的容器镜像存储</li><li>Docker:用于构建容器镜像，部署项目</li></ul><h2 id="2-主机"><a href="#2-主机" class="headerlink" title="2. 主机"></a>2. 主机</h2><table><thead><tr><th>主机</th><th>主机IP</th><th>业务功能</th><th>安装软件</th></tr></thead><tbody><tr><td>Windows本机</td><td>192.168.159.1</td><td>开发项目代码</td><td>git</td></tr><tr><td>harbor-server</td><td>192.168.159.131</td><td>存储容器镜像</td><td>harbor、docker</td></tr><tr><td>jenkins-server</td><td>192.168.159.129</td><td>编译代码、打包镜像、项目构建</td><td>jenkins、docker、git</td></tr><tr><td>gitlab-server</td><td>192.168.159.130</td><td>代码仓库</td><td>gitlab-ce</td></tr><tr><td>web-server</td><td>192.168.159.129</td><td>运行容器，项目上线</td><td>docker</td></tr></tbody></table><h2 id="3-各主机工具安装"><a href="#3-各主机工具安装" class="headerlink" title="3. 各主机工具安装"></a>3. 各主机工具安装</h2><h3 id="windows本机"><a href="#windows本机" class="headerlink" title="windows本机"></a>windows本机</h3><p>安装git,直接去官网下载安装<br>控制台<code>git --version</code>,打印版本信息即成功安装</p><h3 id="Jenkins-server"><a href="#Jenkins-server" class="headerlink" title="Jenkins-server"></a>Jenkins-server</h3><p><strong>安装jdk</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo apt-get update$sudo apt-get install openjdk-17-jdk$java -version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（如果没有版本信息，需要将路径添加到环境变量中）<br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%871.png"><br><strong>安装jenkins</strong><br>安装</p><pre class="line-numbers language-none"><code class="language-none">$wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -$sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list'$sudo apt-get install jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>启动</p><pre class="line-numbers language-none"><code class="language-none">$systemctl start jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动成功后访问，默认端口8080</p><p>登录admin账号，密钥获取</p><pre class="line-numbers language-none"><code class="language-none">$cat /var/lib/jenkins/secrets/initialAdminPassword<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装推荐插件<br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%872.png"><br>如果有插件安装失败，之后点击重试安装即可</p><p>完成安装：<br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%873.png"><br><strong>安装git</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo apt-get update$git --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>安装maven</strong></p><p>在这新建maven文件夹(随便)<br>/usr/local/src/maven/</p><p>在这个文件夹中执行命令，下载解压删除安装包</p><pre class="line-numbers language-none"><code class="language-none">$wget https://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz$tar -zxvf apache-maven-3.8.8-bin.tar.gz$rm apache-maven-3.8.8-bin.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>添加环境变量（注意路径和版本）</p><pre class="line-numbers language-none"><code class="language-none">$export MAVEN_HOME=/usr/local/src/maven/apache-maven-3.8.8 $export CLASSPATH=${MAVEN_HOME}/lib:$CLASSPATH$export PATH=${MAVEN_HOME}/bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>检查是否成功</p><pre class="line-numbers language-none"><code class="language-none">$mvn -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%874.png"></p><h3 id="gitlib-server"><a href="#gitlib-server" class="headerlink" title="gitlib-server"></a>gitlib-server</h3><p><strong>安装gitlab</strong></p><pre class="line-numbers language-none"><code class="language-none">$wget --content-disposition https://packages.gitlab.com/gitlab/gitlab-ce/packages/ubuntu/focal/gitlab-ce_15.5.2-ce.0_amd64.deb/download.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压</p><pre class="line-numbers language-none"><code class="language-none">$sudo dpkg -i gitlab-ce_15.5.2-ce.0_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%875.png"><br>查看当前gitlab网页ip和端口号：</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/gitlab/gitlab.rb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只要修改配置文件就要reconfigure</p><pre class="line-numbers language-none"><code class="language-none">$sudo gitlab-ctl reconfigure<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动</p><pre class="line-numbers language-none"><code class="language-none">$sudo gitlab-ctl start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看状态</p><pre class="line-numbers language-none"><code class="language-none">$sudo gitlab-ctl status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>root密码</p><pre class="line-numbers language-none"><code class="language-none">$cat /etc/gitlab/initial_root_password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改root密码</p><pre class="line-numbers language-none"><code class="language-none">#进入gitlab控制台$sudo gitlab-rails console production#获取root用户$user = User.where(id: 1).first#设置新密码，注意新密码要大于8位$user.password = newPwd#再次确认新密码$user.password_confirmation = newPwd#保存密码$user.save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%876.png"></p><h3 id="web-server"><a href="#web-server" class="headerlink" title="web-server"></a>web-server</h3><p>只需安装docker</p><h3 id="harbor-server"><a href="#harbor-server" class="headerlink" title="harbor-server"></a>harbor-server</h3><p><strong>安装docker-compose</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo apt-get update$sudo apt-get install docker-compose-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%877.png"><br>检查安装</p><pre class="line-numbers language-none"><code class="language-none">$docker compose version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%878.png"><br><strong>安装harbor</strong><br>下载</p><pre class="line-numbers language-none"><code class="language-none">$wget https://github.com/goharbor/harbor/releases/download/v2.3.2/harbor-offline-installer-v2.3.2.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压<br><strong>$sudo tar -zxvf harbor-offline-installer-v2.3.2.tgz</strong></p><p>修改配置文件</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%879.png"></p><p>修改hostname和port</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8710.png"><br>执行修改</p><pre class="line-numbers language-none"><code class="language-none">$sudo ./install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认admin账号密码：Harbor12345<br>访问登录</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8711.png"></p><pre class="line-numbers language-none"><code class="language-none">#停止harbor$sudo docker-compose down -v#修改yml文件后需要重新加载$./prepare#重启harbor$sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>各主机工具安装完成。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-环境搭建&quot;&gt;&lt;a href=&quot;#1-环境搭建&quot; class=&quot;headerlink&quot; title=&quot;1. 环境搭建&quot;&gt;&lt;/a&gt;1. 环境搭建&lt;/h2&gt;&lt;p&gt;个人主机，三台ubuntu虚拟机&lt;/p&gt;
&lt;p&gt;工具安装：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Git:用于提交业</summary>
      
    
    
    
    
    <category term="docker" scheme="http://ailiaa.github.io/tags/docker/"/>
    
    <category term="harbor" scheme="http://ailiaa.github.io/tags/harbor/"/>
    
    <category term="jenkins" scheme="http://ailiaa.github.io/tags/jenkins/"/>
    
    <category term="DevOps" scheme="http://ailiaa.github.io/tags/DevOps/"/>
    
  </entry>
  
  <entry>
    <title>ElasticSearch</title>
    <link href="http://ailiaa.github.io/2023/03/15/elasticsearch/"/>
    <id>http://ailiaa.github.io/2023/03/15/elasticsearch/</id>
    <published>2023-03-15T08:11:07.000Z</published>
    <updated>2023-03-15T08:29:28.836Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-ElasticSearch的简介"><a href="#1-ElasticSearch的简介" class="headerlink" title="1. ElasticSearch的简介"></a>1. ElasticSearch的简介</h3><p>ElasticSearch：智能搜索，分布式的全文搜索引擎</p><p>是ELK的一个组成部分, 是一个产品，而且是非常完善的产品，ELK代表的是：E就是ElasticSearch，L就是Logstach，K就是kibana</p><p>E：EalsticSearch 搜索和分析的功能</p><p>L：Logstach 搜集数据的功能，类似于flume（使用方法几乎跟flume一模一样），是日志收集系统</p><p>K：Kibana 数据可视化（分析），可以用图表的方式来去展示，文不如表，表不如图，是数据可视化平台</p><h3 id="2-全文检索"><a href="#2-全文检索" class="headerlink" title="2. 全文检索"></a>2. 全文检索</h3><p>全文检索是指计算机索引程序通过扫描文章中的每一个词，对每一个词建立一个索引，指明该词在文章中出现的次数和位置，当用户查询时，检索程序就根据事先建立的索引进行查找，并将查找的结果反馈给用户的检索方式。这个过程类似于通过字典中的检索字表查字的过程。</p><p>全文检索的方法主要分为按字检索和按词检索两种。</p><p>按字检索是指对于文章中的每一个字都建立索引，检索时将词分解为字的组合。对于各种不同的语言而言，字有不同的含义，比如英文中字与词实际上是合一的，而中文中字与词有很大分别。按词检索指对文章中的词，即语义单位建立索引，检索时按词检索，并且可以处理同义项等。英文等西方文字由于按照空白切分词，因此实现上与按字处理类似，添加同义处理也很容易。中文等东方文字则需要切分字词，以达到按词索引的目的，关于这方面的问题，是当前全文检索技术尤其是中文全文检索技术中的难点。</p><h3 id="3-倒排索引"><a href="#3-倒排索引" class="headerlink" title="3. 倒排索引"></a>3. 倒排索引</h3><p>以前是根据ID查内容，倒排索引之后是根据内容查ID，然后再拿着ID去查询出来真正需要的东西。</p><p><img src="/images/image_ElasticSearch/01.png"></p><h3 id="4-Lucene"><a href="#4-Lucene" class="headerlink" title="4. Lucene"></a>4. Lucene</h3><p>Lucene就是一个jar包，里面包含了各种建立倒排索引的方法，java开发的时候只需要导入这个jar包就可以开发了。</p><p>ES 和 Lucene的区别:</p><p>Lucene不是分布式的。<br>ES的底层就是Lucene，ES是分布式的</p><h3 id="5-为什么不用数据库去实现搜索功能"><a href="#5-为什么不用数据库去实现搜索功能" class="headerlink" title="5. 为什么不用数据库去实现搜索功能"></a>5. 为什么不用数据库去实现搜索功能</h3><p>我们用搜索“牙膏”商品为例</p><p><img src="/images/image_ElasticSearch/02.png"></p><p>数据库来实现搜索的功能在性能上就很差。</p><h3 id="6-ES的核心概念"><a href="#6-ES的核心概念" class="headerlink" title="6. ES的核心概念"></a>6. ES的核心概念</h3><h4 id="NRT-Near-Realtime-近实时"><a href="#NRT-Near-Realtime-近实时" class="headerlink" title="NRT(Near Realtime)近实时"></a>NRT(Near Realtime)近实时</h4><p><img src="/images/image_ElasticSearch/03.png"></p><h4 id="cluster集群，ES是一个分布式的系统"><a href="#cluster集群，ES是一个分布式的系统" class="headerlink" title="cluster集群，ES是一个分布式的系统"></a>cluster集群，ES是一个分布式的系统</h4><p>ES直接解压不需要配置就可以使用，在hadoop1上解压一个ES，在hadoop2上解压了一个ES，接下来把这两个ES启动起来。他们就构成了一个集群。</p><p>在ES里面默认有一个配置，clustername 默认值就是ElasticSearch,如果这个值是一样的就属于同一个集群，不一样的值就是不一样的集群。</p><h4 id="Node节点"><a href="#Node节点" class="headerlink" title="Node节点"></a>Node节点</h4><p>就是集群中的一台服务器</p><h4 id="index-索引（索引库）"><a href="#index-索引（索引库）" class="headerlink" title="index 索引（索引库）"></a>index 索引（索引库）</h4><p>我们为什么使用ES？因为想把数据存进去，然后再查询出来。</p><p>我们在使用Mysql或者Oracle的时候，为了区分数据，我们会建立不同的数据库，库下面还有表的。</p><p>其实ES功能就像一个关系型数据库，在这个数据库我们可以往里面添加数据，查询数据。</p><p>ES中的索引非传统索引的含义，ES中的索引是存放数据的地方，是ES中的一个概念词汇</p><p>index类似于我们Mysql里面的一个数据库 create database user; 就像就是一个索引库</p><h4 id="type类型"><a href="#type类型" class="headerlink" title="type类型"></a>type类型</h4><p>类型是用来定义数据结构的</p><p>在每一个index下面，可以有一个或者多个type，就像数据库里面的一张表。</p><p>相当于表结构的描述，描述每个字段的类型。</p><h4 id="document：文档"><a href="#document：文档" class="headerlink" title="document：文档"></a>document：文档</h4><p>文档就是最终的数据了，可以认为一个文档就是一条记录。</p><p>是ES里面最小的数据单元，就像表里面的一条数据</p><h4 id="Field-字段"><a href="#Field-字段" class="headerlink" title="Field 字段"></a>Field 字段</h4><p>就像关系型数据库中列的概念，一个document有一个或者多个field组成。</p><h4 id="shard：分片"><a href="#shard：分片" class="headerlink" title="shard：分片"></a>shard：分片</h4><p>一台服务器，无法存储大量的数据，ES把一个index里面的数据，分为多个shard，分布式的存储在各个服务器上面。</p><p>kafka：为什么支持分布式的功能，因为里面是有topic，还支持分区的概念。所以topic A可以存在不同的节点上面。就可以支持海量数据和高并发，提升性能和吞吐量</p><h4 id="replica：副本"><a href="#replica：副本" class="headerlink" title="replica：副本"></a>replica：副本</h4><p>一个分布式的集群，难免会有一台或者多台服务器宕机，如果没有副本，就会造成我们的shard发生故障，无法提供正常服务。</p><p>为了保证数据的安全，引入了replica的概念</p><p>在ES集群中，我们一模一样的数据有多份，能正常提供查询和插入的分片我们叫做 primary shard，其余的我们就管他们叫做 replica shard（备份的分片） </p><p>当我们去查询数据的时候，我们数据是有备份的，它会同时发出命令让我们有数据的机器去查询结果，最后谁的查询结果快，我们就要谁的数据（这个不需要我们去控制，它内部就自己控制了）</p><h3 id="7-ES写数据过程"><a href="#7-ES写数据过程" class="headerlink" title="7. ES写数据过程"></a>7. ES写数据过程</h3><ul><li>客户端选择一个 node 发送请求过去，这个 node 就是&nbsp;<code>coordinating node</code>（协调节点）。</li><li><code>coordinating node</code>&nbsp;对 document 进行路由，将请求转发给对应的 node（有 primary shard）。</li><li>实际的 node 上的&nbsp;<code>primary shard</code>&nbsp;处理请求，然后将数据同步到&nbsp;<code>replica node</code>。</li><li>  <code>coordinating node</code>&nbsp;如果发现&nbsp;<code>primary node</code>&nbsp;和所有&nbsp;<code>replica node</code>&nbsp;都搞定之后，就返回响应结果给客户端。</li></ul><p><img src="/images/image_ElasticSearch/04.jpg"></p><h3 id="8-写数据底层原理"><a href="#8-写数据底层原理" class="headerlink" title="8. 写数据底层原理"></a>8. 写数据底层原理</h3><p><img src="/images/image_ElasticSearch/05.jpg"></p><p>先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。</p><p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据&nbsp;<code>refresh</code>&nbsp;到一个新的&nbsp;<code>segment file</code>&nbsp;中，但是此时数据不是直接进入&nbsp;<code>segment file</code>&nbsp;磁盘文件，而是先进入&nbsp;<code>os cache</code>&nbsp;。这个过程就是&nbsp;<code>refresh</code>。</p><p>每隔 1 秒钟，es 将 buffer 中的数据写入一个新的&nbsp;<code>segment file</code>，每秒钟会产生一个新的磁盘文件&nbsp;<code>segment file</code>，这个&nbsp;<code>segment file</code>&nbsp;中就存储最近 1 秒内 buffer 中写入的数据。</p><p>但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p><p>操作系统里面，磁盘文件其实都有一个东西，叫做&nbsp;<code>os cache</code>，即操作系统缓存，就是说数据写入磁盘文件之前，会先进入&nbsp;<code>os cache</code>，先进入操作系统级别的一个内存缓存中去。只要&nbsp;<code>buffer</code>中的数据被 refresh 操作刷入&nbsp;<code>os cache</code>中，这个数据就可以被搜索到了。</p><p>为什么叫 es 是准实时的？&nbsp;<code>NRT</code>，全称&nbsp;<code>near real-time</code>。默认是每隔 1 秒 refresh 一次的，所以 es 是准实时的，因为写入的数据 1 秒之后才能被看到。可以通过 es 的&nbsp;<code>restful api</code>&nbsp;或者&nbsp;<code>java api</code>，手动执行一次 refresh 操作，就是手动将 buffer 中的数据刷入&nbsp;<code>os cache</code>中，让数据立马就可以被搜索到。只要数据被输入&nbsp;<code>os cache</code>&nbsp;中，buffer 就会被清空了，因为不需要保留 buffer 了，数据在 translog 里面已经持久化到磁盘去一份了。</p><p>重复上面的步骤，新的数据不断进入 buffer 和 translog，不断将&nbsp;<code>buffer</code>&nbsp;数据写入一个又一个新的&nbsp;<code>segment file</code>&nbsp;中去，每次&nbsp;<code>refresh</code>&nbsp;完 buffer 清空，translog 保留。随着这个过程推进，translog 会变得越来越大。当 translog 达到一定长度的时候，就会触发&nbsp;<code>commit</code>&nbsp;操作。</p><p>commit 操作发生第一步，就是将 buffer 中现有数据&nbsp;<code>refresh</code>&nbsp;到&nbsp;<code>os cache</code>&nbsp;中去，清空 buffer。然后，将一个&nbsp;<code>commit point</code>写入磁盘文件，里面标识着这个&nbsp;<code>commit point</code>&nbsp;对应的所有&nbsp;<code>segment file</code>，同时强行将&nbsp;<code>os cache</code>&nbsp;中目前所有的数据都&nbsp;<code>fsync</code>&nbsp;到磁盘文件中去。最后清空&nbsp;现有 translog 日志文件，重启一个 translog，此时 commit 操作完成。</p><p>这个 commit 操作叫做&nbsp;<code>flush</code>。默认 30 分钟自动执行一次&nbsp;<code>flush</code>，但如果 translog 过大，也会触发&nbsp;<code>flush</code>。flush 操作就对应着 commit 的全过程，我们可以通过 es api，手动执行 flush 操作，手动将 os cache 中的数据 fsync 强刷到磁盘上去。</p><p>translog 日志文件的作用是什么？你执行 commit 操作之前，数据要么是停留在 buffer 中，要么是停留在 os cache 中，无论是 buffer 还是 os cache 都是内存，一旦这台机器死了，内存中的数据就全丢了。所以需要将数据对应的操作写入一个专门的日志文件&nbsp;<code>translog</code>&nbsp;中，一旦此时机器宕机，再次重启的时候，es 会自动读取 translog 日志文件中的数据，恢复到内存 buffer 和 os cache 中去。</p><p>translog 其实也是先写入 os cache 的，默认每隔 5 秒刷一次到磁盘中去，所以默认情况下，可能有 5 秒的数据会仅仅停留在 buffer 或者 translog 文件的 os cache 中，如果此时机器挂了，会丢失&nbsp;5 秒钟的数据。但是这样性能比较好，最多丢 5 秒的数据。也可以将 translog 设置成每次写操作必须是直接&nbsp;<code>fsync</code>&nbsp;到磁盘，但是性能会差很多。</p><p><strong>总结</strong>：数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。</p><h3 id="9-ES读数据过程"><a href="#9-ES读数据过程" class="headerlink" title="9. ES读数据过程"></a>9. ES读数据过程</h3><p>可以通过&nbsp;<code>doc id</code>&nbsp;来查询，会根据&nbsp;<code>doc id</code>&nbsp;进行 hash，判断出来当时把&nbsp;<code>doc id</code>&nbsp;分配到了哪个 shard 上面去，从那个 shard 去查询。</p><ul><li>客户端发送请求到任意一个 node，成为&nbsp;<code>coordinate node</code>。</li><li><code>coordinate node</code>&nbsp;对&nbsp;<code>doc id</code>&nbsp;进行哈希路由，将请求转发到对应的 node，此时会使用&nbsp;<code>round-robin</code>随机轮询算法，在&nbsp;<code>primary shard</code>&nbsp;以及其所有 replica 中随机选择一个，让读请求负载均衡。</li><li>接收请求的 node 返回 document 给&nbsp;<code>coordinate node</code>。</li><li>  <code>coordinate node</code>&nbsp;返回 document 给客户端。</li></ul><blockquote><p>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或replica shard 读取，采用的是随机轮询算法。</p></blockquote><h3 id="10-ES搜索数据过程"><a href="#10-ES搜索数据过程" class="headerlink" title="10. ES搜索数据过程"></a>10. ES搜索数据过程</h3><p>es 最强大的是做全文检索，就是比如有三条数据：</p><p><code>java真好玩儿啊</code><br><code>java好难学啊</code><br><code>j2ee特别牛</code></p><p>根据&nbsp;<code>java</code>&nbsp;关键词来搜索，将包含&nbsp;<code>java</code>的&nbsp;<code>document</code>&nbsp;给搜索出来。es 就会给你返回：java真好玩儿啊，java好难学啊。</p><ul><li>客户端发送请求到一个&nbsp;<code>coordinate node</code>。</li><li>协调节点将搜索请求转发到所有的 shard 对应的&nbsp;<code>primary shard</code>&nbsp;或&nbsp;<code>replica shard</code>，都可以。</li><li>query phase：每个 shard 将自己的搜索结果（其实就是一些&nbsp;<code>doc id</code>）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li><li>  fetch phase：接着由协调节点根据&nbsp;<code>doc id</code>&nbsp;去各个节点上拉取实际的&nbsp;<code>document</code>&nbsp;数据，最终返回给客户端。</li></ul><h3 id="11-删除-更新数据底层原理"><a href="#11-删除-更新数据底层原理" class="headerlink" title="11. 删除/更新数据底层原理"></a>11. 删除/更新数据底层原理</h3><p>如果是删除操作，commit 的时候会生成一个&nbsp;<code>.del</code>&nbsp;文件，里面将某个 doc 标识为&nbsp;<code>deleted</code>&nbsp;状态，那么搜索的时候根据&nbsp;<code>.del</code>&nbsp;文件就知道这个 doc 是否被删除了。</p><p>如果是更新操作，就是将原来的 doc 标识为&nbsp;<code>deleted</code>&nbsp;状态，然后新写入一条数据。</p><p>buffer 每 refresh 一次，就会产生一个&nbsp;<code>segment file</code>，所以默认情况下是 1 秒钟一个&nbsp;<code>segment file</code>，这样下来&nbsp;<code>segment file</code>&nbsp;会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个&nbsp;<code>segment file</code>&nbsp;合并成一个，同时这里会将标识为&nbsp;<code>deleted</code>&nbsp;的 doc 给物理删除掉，然后将新的&nbsp;<code>segment file</code>&nbsp;写入磁盘，这里会写一个&nbsp;<code>commit point</code>，标识所有新的&nbsp;<code>segment file</code>，然后打开&nbsp;<code>segment file</code>&nbsp;供搜索使用，同时删除旧的&nbsp;<code>segment file</code>。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-ElasticSearch的简介&quot;&gt;&lt;a href=&quot;#1-ElasticSearch的简介&quot; class=&quot;headerlink&quot; title=&quot;1. ElasticSearch的简介&quot;&gt;&lt;/a&gt;1. ElasticSearch的简介&lt;/h3&gt;&lt;p&gt;Elas</summary>
      
    
    
    
    
    <category term="ElasticSearch" scheme="http://ailiaa.github.io/tags/ElasticSearch/"/>
    
  </entry>
  
  <entry>
    <title>Kafka</title>
    <link href="http://ailiaa.github.io/2023/03/15/kafka/"/>
    <id>http://ailiaa.github.io/2023/03/15/kafka/</id>
    <published>2023-03-15T07:33:26.000Z</published>
    <updated>2023-03-15T08:05:31.611Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是消息队列"><a href="#1-什么是消息队列" class="headerlink" title="1. 什么是消息队列"></a>1. 什么是消息队列</h3><p>可以把消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。由于队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。</p><p>参与消息传递的双方称为&nbsp;<strong>生产者</strong>&nbsp;和&nbsp;<strong>消费者</strong>&nbsp;，生产者负责发送消息，消费者负责处理消息。</p><p>操作系统中的进程通信的一种很重要的方式就是消息队列。我们这里提到的消息队列稍微有点区别，更多指的是各个服务以及系统内部各个组件/模块之前的通信，属于一种&nbsp;<strong>中间件</strong>&nbsp;。</p><h3 id="2-消息队列的作用"><a href="#2-消息队列的作用" class="headerlink" title="2. 消息队列的作用"></a>2. 消息队列的作用</h3><p>通常来说，使用消息队列能为我们的系统带来下面三点好处：</p><ol><li> <strong>通过异步处理提高系统性能（减少响应所需时间）</strong></li><li> <strong>削峰/限流</strong></li><li> <strong>降低系统耦合性。</strong></li></ol><h3 id="3-使用消息队列会带来哪些问题"><a href="#3-使用消息队列会带来哪些问题" class="headerlink" title="3. 使用消息队列会带来哪些问题"></a>3. 使用消息队列会带来哪些问题</h3><ul><li>  <strong>系统可用性降低：</strong> 系统可用性在某种程度上降低，为什么这样说呢？在加入 MQ 之前，你不用考虑消息丢失或者说 MQ 挂掉等等的情况，但是，引入 MQ 之后你就需要去考虑了！</li><li>  <strong>系统复杂性提高：</strong> 加入 MQ 之后，你需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题！</li><li>  <strong>一致性问题：</strong> 我上面讲了消息队列可以实现异步，消息队列带来的异步确实可以提高系统响应速度。但是，万一消息的真正消费者并没有正确消费消息怎么办？这样就会导致数据不一致的情况了</li></ul><h3 id="4-JMS-和-AMQP"><a href="#4-JMS-和-AMQP" class="headerlink" title="4. JMS 和 AMQP"></a>4. JMS 和 AMQP</h3><h4 id="JMS-是什么"><a href="#JMS-是什么" class="headerlink" title="JMS 是什么"></a>JMS 是什么</h4><p>JMS（JAVA Message Service,java 消息服务）是 Java 的消息服务，JMS 的客户端之间可以通过 JMS 服务进行异步的消息传输。<strong>JMS（JAVA Message Service，Java 消息服务）API 是一个消息服务的标准或者说是规范</strong>，允许应用程序组件基于 JavaEE 平台创建、发送、接收和读取消息。它使分布式通信耦合度更低，消息服务更加可靠以及异步性。</p><p>JMS 定义了五种不同的消息正文格式以及调用的消息类型，允许你发送并接收以一些不同形式的数据：</p><ul><li>  <code>StreamMessage：Java</code> 原始值的数据流</li><li>  <code>MapMessage</code>：一套名称-值对</li><li>  <code>TextMessage</code>：一个字符串对象</li><li>  <code>ObjectMessage</code>：一个序列化的 Java 对象</li><li>  <code>BytesMessage</code>：一个字节的数据流</li></ul><h4 id="JMS-两种消息模型"><a href="#JMS-两种消息模型" class="headerlink" title="JMS 两种消息模型"></a>JMS 两种消息模型</h4><h5 id="点到点（P2P）模型"><a href="#点到点（P2P）模型" class="headerlink" title="点到点（P2P）模型"></a>点到点（P2P）模型</h5><p><img src="/images/image_Kafka/01.png"></p><p>使用<strong>队列（Queue）</strong>作为消息通信载体；满足<strong>生产者与消费者模式</strong>，一条消息只能被一个消费者使用，未被消费的消息在队列中保留直到被消费或超时。</p><h5 id="发布-订阅（Pub-Sub）模型"><a href="#发布-订阅（Pub-Sub）模型" class="headerlink" title="发布/订阅（Pub/Sub）模型"></a>发布/订阅（Pub/Sub）模型</h5><p><img src="/images/image_Kafka/02.png"></p><p>发布订阅模型（Pub/Sub） 使用<strong>主题（Topic）</strong>作为消息通信载体，类似于<strong>广播模式</strong>；发布者发布一条消息，该消息通过主题传递给所有的订阅者，<strong>在一条消息广播之后才订阅的用户则是收不到该条消息的</strong>。</p><h4 id="AMQP-是什么"><a href="#AMQP-是什么" class="headerlink" title="AMQP 是什么"></a>AMQP 是什么</h4><p>AMQP，即 Advanced Message Queuing Protocol，一个提供统一消息服务的应用层标准 <strong>高级消息队列协议</strong>（二进制应用层协议），是应用层协议的一个开放标准，为面向消息的中间件设计，兼容 JMS。基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件同产品，不同的开发语言等条件的限制。</p><p><strong>RabbitMQ 就是基于 AMQP 协议实现的。</strong></p><h4 id="JMS-vs-AMQP"><a href="#JMS-vs-AMQP" class="headerlink" title="JMS vs AMQP"></a>JMS vs AMQP</h4><p><img src="/images/image_Kafka/03.png"></p><p><strong>总结：</strong></p><ul><li>  AMQP 为消息定义了线路层（wire-level protocol）的协议，而 JMS 所定义的是 API 规范。在 Java 体系中，多个 client 均可以通过 JMS 进行交互，不需要应用修改代码，但是其对跨平台的支持较差。而 AMQP 天然具有跨平台、跨语言特性。</li><li>  JMS 支持 <code>TextMessage</code>、<code>MapMessage</code> 等复杂的消息类型；而 AMQP 仅支持 <code>byte[]</code> 消息类型（复杂的类型可序列化后发送）。</li><li>  由于 Exchange 提供的路由算法，AMQP 可以提供多样化的路由方式来传递消息到消息队列，而 JMS 仅支持 队列 和 主题/订阅 方式两种。</li></ul><h3 id="4-RPC-远程过程调用协议-和消息队列的区别"><a href="#4-RPC-远程过程调用协议-和消息队列的区别" class="headerlink" title="4. RPC( 远程过程调用协议 )和消息队列的区别"></a>4. RPC( 远程过程调用协议 )和消息队列的区别</h3><p>RPC 和消息队列都是分布式微服务系统中重要的组件之一，下面我们来简单对比一下两者：</p><ul><li>  <strong>从用途来看</strong> ：RPC 主要用来解决两个服务的远程通信问题，不需要了解底层网络的通信机制。通过 RPC 可以帮助我们调用远程计算机上某个服务的方法，这个过程就像调用本地方法一样简单。消息队列主要用来降低系统耦合性、实现任务异步、有效地进行流量削峰。</li><li>  <strong>从通信方式来看</strong> ：RPC 是双向直接网络通讯，消息队列是单向引入中间载体的网络通讯。</li><li>  <strong>从架构上来看</strong> ：消息队列需要把消息存储起来，RPC 则没有这个要求，因为前面也说了 RPC 是双向直接网络通讯。</li><li>  <strong>从请求处理的时效性来看</strong> ：通过 RPC 发出的调用一般会立即被处理，存放在消息队列中的消息并不一定会立即被处理。</li></ul><p>RPC 和消息队列本质上是网络通讯的两种不同的实现机制，两者的用途不同，万不可将两者混为一谈。</p><h3 id="5-Kafka-是什么？主要应用场景有哪些"><a href="#5-Kafka-是什么？主要应用场景有哪些" class="headerlink" title="5. Kafka 是什么？主要应用场景有哪些"></a>5. Kafka 是什么？主要应用场景有哪些</h3><p>Kafka 是一个分布式流式处理平台。</p><p>流平台具有三个关键功能：</p><ol><li> <strong>消息队列</strong>：发布和订阅消息流，这个功能类似于消息队列，这也是 Kafka 也被归类为消息队列的原因。</li><li> <strong>容错的持久方式存储记录消息流</strong>： Kafka 会把消息持久化到磁盘，有效避免了消息丢失的风险。</li><li> <strong>流式处理平台：</strong> 在消息发布的时候进行处理，Kafka 提供了一个完整的流式处理类库。</li></ol><p>Kafka 主要有两大应用场景：</p><ol><li> <strong>消息队列</strong> ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li><li> <strong>数据处理：</strong> 构建实时的流数据处理程序来转换或处理数据流</li></ol><h3 id="6-Kafka的优势"><a href="#6-Kafka的优势" class="headerlink" title="6. Kafka的优势"></a>6. Kafka的优势</h3><p>我们现在经常提到 Kafka 的时候就已经默认它是一个非常优秀的消息队列了，我们也会经常拿它跟 RocketMQ、RabbitMQ 对比。：</p><ol><li> <strong>极致的性能</strong> ：基于 Scala 和 Java 语言开发，设计中大量使用了批量处理和异步的思想，最高可以每秒处理千万级别的消息。</li><li> <strong>生态系统兼容性无可匹敌</strong> ：Kafka 与周边生态系统的兼容性是最好的没有之一，尤其在大数据和流计算领域。</li></ol><h3 id="7-什么是Producer、Consumer、Broker、Topic、Partition"><a href="#7-什么是Producer、Consumer、Broker、Topic、Partition" class="headerlink" title="7. 什么是Producer、Consumer、Broker、Topic、Partition"></a>7. 什么是Producer、Consumer、Broker、Topic、Partition</h3><p><strong>Kafka 采用的是发布 - 订阅模型。</strong></p><p>Kafka 将生产者发布的消息发送到&nbsp;<strong>Topic（主题）</strong>&nbsp;中，需要这些消息的消费者可以订阅这些&nbsp;<strong>Topic（主题）</strong>，如下图所示：</p><p><img src="/images/image_Kafka/04.png"></p><p>上面这张图也为我们引出了，Kafka 比较重要的几个概念：</p><ol><li> <strong>Producer（生产者）</strong> : 产生消息的一方。</li><li> <strong>Consumer（消费者）</strong> : 消费消息的一方。</li><li> <strong>Broker（代理）</strong> : 可以看作是一个独立的 Kafka 实例。多个 Kafka Broker 组成一个 Kafka Cluster。</li></ol><p>每个 Broker 中又包含了 Topic 以及 Partition 这两个重要的概念：</p><ul><li>  <strong>Topic（主题）</strong> : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</li><li>  <strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition ，并且同一 Topic 下的 Partition 可以分布在不同的 Broker 上，这也就表明一个 Topic 可以横跨多个 Broker 。这正如我上面所画的图一样。</li></ul><blockquote><p><strong>Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。</strong></p></blockquote><h3 id="8-Kafka-的多副本机制"><a href="#8-Kafka-的多副本机制" class="headerlink" title="8. Kafka 的多副本机制"></a>8. Kafka 的多副本机制</h3><p>Kafka 为分区（Partition）引入了多副本（Replica）机制。</p><p>分区（Partition）中的多个副本之间会有一个叫做 leader 的，其他副本称为 follower。</p><p>我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p><blockquote><p>生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。当 leader 副本发生故障时会从 follower 中选举出一个 leader,但是 follower 中如果有和 leader 同步程度达不到要求的参加不了 leader 的竞选。</p></blockquote><p><strong>Kafka 的多分区（Partition）以及多副本（Replica）机制有什么好处呢</strong></p><ol><li> Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力（负载均衡）。</li><li> Partition 可以指定对应的 Replica 数, 这也极大地提高了消息存储的安全性, 提高了容灾能力，不过也相应的增加了所需要的存储空间。</li></ol><h3 id="9-Zookeeper-在-Kafka-中的作用"><a href="#9-Zookeeper-在-Kafka-中的作用" class="headerlink" title="9. Zookeeper 在 Kafka 中的作用"></a>9. Zookeeper 在 Kafka 中的作用</h3><ul><li>  <strong>Broker 注册</strong> ：在 Zookeeper 上会有一个专门<strong>用来进行 Broker 服务器列表记录</strong>的节点。每个 Broker 在启动时，都会到 Zookeeper 上进行注册，即到 <code>/brokers/ids</code> 下创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</li><li>  <strong>Topic 注册</strong> ： 在 Kafka 中，同一个<strong>Topic 的消息会被分成多个分区</strong>并将其分布在多个 Broker 上，<strong>这些分区信息及与 Broker 的对应关系</strong>也都是由 Zookeeper 在维护。比如我创建了一个名字为 my-topic 的主题并且它有两个分区，对应到 zookeeper 中会创建这些文件夹：<code>/brokers/topics/my-topic/Partitions/0</code>、<code>/brokers/topics/my-topic/Partitions/1</code></li><li>  <strong>负载均衡</strong> ：上面也说过了 Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</li></ul><h3 id="10-Kafka-如何保证消息的消费顺序？"><a href="#10-Kafka-如何保证消息的消费顺序？" class="headerlink" title="10. Kafka 如何保证消息的消费顺序？"></a>10. Kafka 如何保证消息的消费顺序？</h3><p>我们在使用消息队列的过程中经常有业务场景需要严格保证消息的消费顺序，比如我们同时发了 2 个消息，这 2 个消息对应的操作分别对应的数据库操作是：</p><ol><li> 更改用户会员等级。</li><li> 根据会员等级计算订单价格。</li></ol><p>假如这两条消息的消费顺序不一样造成的最终结果就会截然不同。</p><p>我们知道 Kafka 中 Partition(分区)是真正保存消息的地方，我们发送的消息都被放在了这里。而我们的 Partition(分区) 又存在于 Topic(主题) 这个概念中，并且我们可以给特定 Topic 指定多个 Partition。</p><p><img src="/images/image_Kafka/05.png"></p><p>每次添加消息到 Partition(分区) 的时候都会采用尾加法，如上图所示。 <strong>Kafka 只能为我们保证 Partition(分区) 中的消息有序。</strong></p><blockquote><p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p></blockquote><p>所以，我们就有一种很简单的保证消息消费顺序的方法：<strong>1 个 Topic 只对应一个 Partition</strong>。这样当然可以解决问题，但是破坏了 Kafka 的设计初衷。</p><p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 id 来作为 key 。</p><p>总结一下，对于如何保证 Kafka 中消息消费的顺序，有了下面两种方法：</p><ol><li> 1 个 Topic 只对应一个 Partition。</li><li> （推荐）发送消息的时候指定 key/Partition。</li></ol><h3 id="11-Kafka-如何保证消息不丢失"><a href="#11-Kafka-如何保证消息不丢失" class="headerlink" title="11. Kafka 如何保证消息不丢失"></a>11. Kafka 如何保证消息不丢失</h3><h4 id="生产者丢失消息的情况"><a href="#生产者丢失消息的情况" class="headerlink" title="生产者丢失消息的情况"></a>生产者丢失消息的情况</h4><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p><p>所以，不能默认在调用<code>send</code>方法发送消息之后消息发送成功了。为了确定消息是发送成功，要判断消息发送的结果。但是要注意的是 Kafka 生产者(Producer) 使用 <code>send</code> 方法发送消息实际上是异步的操作，可以通过 <code>get()</code>方法获取调用结果，但是这样也让它变为了同步操作，示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">SendResult</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> sendResult <span class="token operator">=</span> kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span>sendResult<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"生产者成功发送消息到"</span> <span class="token operator">+</span> sendResult<span class="token punctuation">.</span><span class="token function">getProducerRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"-&gt; "</span> <span class="token operator">+</span> sendRe              sult<span class="token punctuation">.</span><span class="token function">getProducerRecord</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>但是一般不推荐这么做！可以采用为其添加回调函数的形式，示例代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ListenableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SendResult</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>future<span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span>result <span class="token operator">-&gt;</span> logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"生产者成功发送消息到topic:{} partition:{}的消息"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        ex <span class="token operator">-&gt;</span> logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"生产者发送消失败，原因：{}"</span><span class="token punctuation">,</span> ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>如果消息发送失败的话，我们检查失败的原因之后重新发送即可！</p><p><strong>这里推荐为 Producer 的<code>retries</code> （重试次数）设置一个比较合理的值，一般是 3 ，但是为了保证消息不丢失的话一般会设置比较大一点。设置完成之后，当出现网络问题之后能够自动重试消息发送，避免消息丢失。另外，建议还要设置重试间隔，因为间隔太小的话重试的效果就不明显了，网络波动一次你3次一下子就重试完了</strong></p><h4 id="消费者丢失消息的情况"><a href="#消费者丢失消息的情况" class="headerlink" title="消费者丢失消息的情况"></a>消费者丢失消息的情况</h4><p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p><p><img src="/images/image_Kafka/06.jpg"></p><p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset。自动提交的话会有一个问题，试想一下，当消费者刚拿到这个消息准备进行真正消费的时候，突然挂掉了，消息实际上并没有被消费，但是 offset 却被自动提交了。</p><p><strong>解决办法也比较粗暴，我们手动关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。</strong> 但是，这样会带来消息被重新消费的问题。比如刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p><h4 id="Kafka-弄丢了消息"><a href="#Kafka-弄丢了消息" class="headerlink" title="Kafka 弄丢了消息"></a>Kafka 弄丢了消息</h4><p>Kafka 为分区（Partition）引入了多副本（Replica）机制。分区（Partition）中的多个副本之间会有一个叫做 leader 的家伙，其他副本称为 follower。我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。生产者和消费者只与 leader 副本交互。你可以理解为其他副本只是 leader 副本的拷贝，它们的存在只是为了保证消息存储的安全性。</p><p><strong>试想一种情况：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</strong></p><p><strong>设置 acks = all</strong></p><p>解决办法就是我们设置 <strong>acks = all</strong>。acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p><p>acks 的默认值即为1，代表我们的消息被leader副本接收之后就算被成功发送。当我们配置 <strong>acks = all</strong> 表示只有所有 ISR 列表的副本全部收到消息时，生产者才会接收到来自服务器的响应. 这种模式是最高级别的，也是最安全的，可以确保不止一个 Broker 接收到了消息. 该模式的延迟会很高.</p><p><strong>设置 replication.factor &gt;= 3</strong></p><p>为了保证 leader 副本能有 follower 副本能同步消息，我们一般会为 topic 设置 <strong>replication.factor &gt;= 3</strong>。这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p><p><strong>设置 min.insync.replicas &gt; 1</strong></p><p>一般情况下我们还需要设置 <strong>min.insync.replicas&gt; 1</strong> ，这样配置代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p><p>但是，为了保证整个 Kafka 服务的高可用性，你需要确保 <strong>replication.factor &gt; min.insync.replicas</strong> 。为什么呢？设想一下假如两者相等的话，只要是有一个副本挂掉，整个分区就无法正常工作了。这明显违反高可用性！一般推荐设置成 <strong>replication.factor = min.insync.replicas + 1</strong>。</p><p><strong>设置 unclean.leader.election.enable = false</strong></p><p>我们最开始也说了我们发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。多个 follower 副本之间的消息同步情况不一样，当我们配置了 <strong>unclean.leader.election.enable = false</strong> 的话，当 leader 副本发生故障时就不会从 follower 副本中和 leader 同步程度达不到要求的副本中选择出 leader ，这样降低了消息丢失的可能性。</p><h3 id="12-Kafka-如何保证消息不重复消费"><a href="#12-Kafka-如何保证消息不重复消费" class="headerlink" title="12. Kafka 如何保证消息不重复消费"></a>12. Kafka 如何保证消息不重复消费</h3><p><strong>kafka出现消息重复消费的原因：</strong></p><ul><li>  服务端侧已经消费的数据没有成功提交 offset（根本原因）。</li><li>  Kafka 侧 由于服务端处理业务时间长或者网络链接等等原因让 Kafka 认为服务假死，触发了分区 rebalance。</li></ul><p><strong>解决方案：</strong></p><ul><li>  消费消息服务做幂等校验，比如 Redis 的set、MySQL 的主键等天然的幂等功能。这种方法最有效。</li><li>将 <strong><code>enable.auto.commit</code></strong> 参数设置为 false，关闭自动提交，开发者在代码中手动提交 offset。那么这里会有个问题：<strong>什么时候提交offset合适？</strong><ul><li>  处理完消息再提交：依旧有消息重复消费的风险，和自动提交一样</li><li>  拉取到消息即提交：会有消息丢失的风险。允许消息延时的场景，一般会采用这种方式。然后，通过定时任务在业务不繁忙（比如凌晨）的时候做数据兜底。</li></ul></li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-什么是消息队列&quot;&gt;&lt;a href=&quot;#1-什么是消息队列&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是消息队列&quot;&gt;&lt;/a&gt;1. 什么是消息队列&lt;/h3&gt;&lt;p&gt;可以把消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取</summary>
      
    
    
    
    
    <category term="Kafka" scheme="http://ailiaa.github.io/tags/Kafka/"/>
    
  </entry>
  
  <entry>
    <title>Spring Boot</title>
    <link href="http://ailiaa.github.io/2023/03/12/spring-boot/"/>
    <id>http://ailiaa.github.io/2023/03/12/spring-boot/</id>
    <published>2023-03-12T09:23:44.000Z</published>
    <updated>2023-03-12T09:32:24.977Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-对Spring-Boot的理解"><a href="#1-对Spring-Boot的理解" class="headerlink" title="1. 对Spring Boot的理解"></a>1. 对Spring Boot的理解</h3><p>从本质上来说，Spring Boot就是Spring，它做了那些没有它你自己也会去做的Spring Bean配置。Spring Boot使用“习惯优于配置”的理念让你的项目快速地运行起来，使用Spring Boot很容易创建一个能独立运行、准生产级别、基于Spring框架的项目，使用Spring Boot你可以不用或者只需要很少的Spring配置。</p><p>简而言之，Spring Boot本身并不提供Spring的核心功能，而是作为Spring的脚手架框架，以达到快速构建项目、预置三方配置、开箱即用的目的。Spring Boot有如下的优点：</p><ul><li>可以快速构建项目；</li><li>可以对主流开发框架的无配置集成；</li><li>项目可独立运行，无需外部依赖Servlet容器；</li><li>提供运行时的应用监控；</li><li>可以极大地提高开发、部署效率；</li><li>  可以与云计算天然集成。</li></ul><h3 id="2-Spring-Boot-Starter的作用"><a href="#2-Spring-Boot-Starter的作用" class="headerlink" title="2. Spring Boot Starter的作用"></a>2. Spring Boot Starter的作用</h3><p>Spring Boot项目通过Spring Boot Starter导入包</p><p>Spring Boot通过提供众多起步依赖（Starter）<strong>降低项目依赖的复杂度</strong>。起步依赖本质上是一个Maven项目对象模型（Project Object Model, POM），定义了对其他库的传递依赖，这些东西加在一起即支持某项功能。很多起步依赖的命名都暗示了它们提供的某种或某类功能。</p><p>举例来说，你打算把这个阅读列表应用程序做成一个Web应用程序。与其向项目的构建文件里添加一堆单独的库依赖，还不如声明这是一个Web应用程序来得简单。你只要添加Spring Boot的Web起步依赖就好了。</p><h3 id="3-Spring-Boot的启动流程"><a href="#3-Spring-Boot的启动流程" class="headerlink" title="3. Spring Boot的启动流程"></a>3. Spring Boot的启动流程</h3><p>首先，Spring Boot项目创建完成会默认生成一个名为&nbsp;*Application&nbsp;的入口类，我们是通过该类的main方法启动Spring Boot项目的。在main方法中，通过SpringApplication的静态方法，即run方法进行SpringApplication类的实例化操作，然后再针对实例化对象调用另外一个run方法来完成整个项目的初始化和启动。</p><p>SpringApplication调用的run方法的大致流程，如下图：</p><p><img src="/images/image_Spring/08.jpg"></p><p>其中，SpringApplication在run方法中重点做了以下操作：</p><ul><li>获取监听器和参数配置；</li><li>打印Banner信息；</li><li>创建并初始化容器；</li><li>监听器发送通知。</li></ul><p>当然，除了上述核心操作，run方法运行过程中还涉及启动时长统计、异常报告、启动日志、异常处理等辅助操作。</p><h3 id="4-Spring-Boot自动装配的过程"><a href="#4-Spring-Boot自动装配的过程" class="headerlink" title="4. Spring Boot自动装配的过程"></a>4. Spring Boot自动装配的过程</h3><p>使用Spring Boot时，我们只需引入对应的Starters，Spring Boot启动时便会自动加载相关依赖，配置相应的初始化参数，以最快捷、简单的形式对第三方软件进行集成，这便是Spring Boot的自动配置功能。Spring Boot实现该运作机制锁涉及的核心部分如下图所示：</p><p><img src="/images/image_Spring/09.jpg"></p><p>整个自动装配的过程是：Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类，当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。</p><h3 id="5-Spring-Boot注解"><a href="#5-Spring-Boot注解" class="headerlink" title="5. Spring Boot注解"></a>5. Spring Boot注解</h3><p>@SpringBootApplication注解：</p><p>在Spring Boot入口类中，唯一的一个注解就是@SpringBootApplication。它是Spring Boot项目的核心注解，用于开启自动配置，准确说是通过该注解内组合的@EnableAutoConfiguration开启了自动配置。</p><p>@EnableAutoConfiguration注解：</p><p>@EnableAutoConfiguration的主要功能是启动Spring应用程序上下文时进行自动配置，它会尝试猜测并配置项目可能需要的Bean。自动配置通常是基于项目classpath中引入的类和已定义的Bean来实现的。在此过程中，被自动配置的组件来自项目自身和项目依赖的jar包中。</p><p>@Import注解：</p><p>@EnableAutoConfiguration的关键功能是通过@Import注解导入的ImportSelector来完成的。从源代码得知@Import(AutoConfigurationImportSelector.class)是@EnableAutoConfiguration注解的组成部分，也是自动配置功能的核心实现者。</p><p>@Conditional注解：</p><p>@Conditional注解是由Spring 4.0版本引入的新特性，可根据是否满足指定的条件来决定是否进行Bean的实例化及装配，比如，设定当类路径下包含某个jar包的时候才会对注解的类进行实例化操作。总之，就是根据一些特定条件来控制Bean实例化的行为。</p><p>@Conditional衍生注解：</p><p>在Spring Boot的autoconfigure项目中提供了各类基于@Conditional注解的衍生注解，它们适用不同的场景并提供了不同的功能。通过阅读这些注解的源码，你会发现它们其实都组合了@Conditional注解，不同之处是它们在注解中指定的条件（Condition）不同。</p><ul><li>@ConditionalOnBean：在容器中有指定Bean的条件下。</li><li>@ConditionalOnClass：在classpath类路径下有指定类的条件下。</li><li>@ConditionalOnCloudPlatform：当指定的云平台处于active状态时。</li><li>@ConditionalOnExpression：基于SpEL表达式的条件判断。</li><li>@ConditionalOnJava：基于JVM版本作为判断条件。</li><li>@ConditionalOnJndi：在JNDI存在的条件下查找指定的位置。</li><li>@ConditionalOnMissingBean：当容器里没有指定Bean的条件时。</li><li>@ConditionalOnMissingClass：当类路径下没有指定类的条件时。</li><li>@ConditionalOnNotWebApplication：在项目不是一个Web项目的条件下。</li><li>@ConditionalOnProperty：在指定的属性有指定值的条件下。</li><li>@ConditionalOnResource：类路径是否有指定的值。</li><li>@ConditionalOnSingleCandidate：当指定的Bean在容器中只有一个或者有多个但是指定了首选的Bean时。</li><li>  @ConditionalOnWebApplication：在项目是一个Web项目的条件下。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-对Spring-Boot的理解&quot;&gt;&lt;a href=&quot;#1-对Spring-Boot的理解&quot; class=&quot;headerlink&quot; title=&quot;1. 对Spring Boot的理解&quot;&gt;&lt;/a&gt;1. 对Spring Boot的理解&lt;/h3&gt;&lt;p&gt;从本质上来说，S</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://ailiaa.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>Spring</title>
    <link href="http://ailiaa.github.io/2023/03/12/spring/"/>
    <id>http://ailiaa.github.io/2023/03/12/spring/</id>
    <published>2023-03-12T08:13:32.000Z</published>
    <updated>2023-03-12T09:23:23.835Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Spring-包含的模块有哪些？"><a href="#1-Spring-包含的模块有哪些？" class="headerlink" title="1. Spring 包含的模块有哪些？"></a>1. Spring 包含的模块有哪些？</h3><p><img src="/images/image_Spring/01.png"></p><h4 id="Core-Container"><a href="#Core-Container" class="headerlink" title="Core Container"></a>Core Container</h4><p>Spring 框架的核心模块，也可以说是基础模块，主要提供 IoC 依赖注入功能的支持。Spring 其他所有的功能基本都需要依赖于该模块，我们从上面那张 Spring 各个模块的依赖关系图就可以看出来。</p><ul><li>  <strong>spring-core</strong> ：Spring 框架基本的核心工具类。</li><li>  <strong>spring-beans</strong> ：提供对 bean 的创建、配置和管理等功能的支持。</li><li>  <strong>spring-context</strong> ：提供对国际化、事件传播、资源加载等功能的支持。</li><li>  <strong>spring-expression</strong> ：提供对表达式语言（Spring Expression Language） SpEL 的支持，只依赖于 core 模块，不依赖于其他模块，可以单独使用。</li></ul><h4 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h4><ul><li>  <strong>spring-aspects</strong> ：该模块为与 AspectJ 的集成提供支持。</li><li>  <strong>spring-aop</strong> ：提供了面向切面的编程实现。</li><li>  <strong>spring-instrument</strong> ：提供了为 JVM 添加代理（agent）的功能。 具体来讲，它为 Tomcat 提供了一个织入代理，能够为 Tomcat 传递类文 件，就像这些文件是被类加载器加载的一样。没有理解也没关系，这个模块的使用场景非常有限。</li></ul><h4 id="Data-Access-Integration"><a href="#Data-Access-Integration" class="headerlink" title="Data Access/Integration"></a>Data Access/Integration</h4><ul><li>  <strong>spring-jdbc</strong> ：提供了对数据库访问的抽象 JDBC。不同的数据库都有自己独立的 API 用于操作数据库，而 Java 程序只需要和 JDBC API 交互，这样就屏蔽了数据库的影响。</li><li>  <strong>spring-tx</strong> ：提供对事务的支持。</li><li>  <strong>spring-orm</strong> ： 提供对 Hibernate、JPA 、iBatis 等 ORM 框架的支持。</li><li>  <strong>spring-oxm</strong> ：提供一个抽象层支撑 OXM(Object-to-XML-Mapping)，例如：JAXB、Castor、XMLBeans、JiBX 和 XStream 等。</li><li>  <strong>spring-jms</strong> : 消息服务。自 Spring Framework 4.1 以后，它还提供了对 spring-messaging 模块的继承。</li></ul><h4 id="Spring-Web"><a href="#Spring-Web" class="headerlink" title="Spring Web"></a>Spring Web</h4><ul><li>  <strong>spring-web</strong> ：对 Web 功能的实现提供一些最基础的支持。</li><li>  <strong>spring-webmvc</strong> ： 提供对 Spring MVC 的实现。</li><li>  <strong>spring-websocket</strong> ： 提供了对 WebSocket 的支持，WebSocket 可以让客户端和服务端进行双向通信。</li><li>  <strong>spring-webflux</strong> ：提供对 WebFlux 的支持。WebFlux 是 Spring Framework 5.0 中引入的新的响应式框架。与 Spring MVC 不同，它不需要 Servlet API，是完全异步。</li></ul><h4 id="Messaging"><a href="#Messaging" class="headerlink" title="Messaging"></a>Messaging</h4><p><strong>spring-messaging</strong> 是从 Spring4.0 开始新加入的一个模块，主要职责是为 Spring 框架集成一些基础的报文传送应用。</p><h4 id="Spring-Test"><a href="#Spring-Test" class="headerlink" title="Spring Test"></a>Spring Test</h4><p>Spring 团队提倡测试驱动开发（TDD）。有了控制反转 (IoC)的帮助，单元测试和集成测试变得更简单。</p><p>Spring 的测试模块对 JUnit（单元测试框架）、TestNG（类似 JUnit）、Mockito（主要用来 Mock 对象）、PowerMock（解决 Mockito 的问题比如无法模拟 final, static， private 方法）等等常用的测试框架支持的都比较好。</p><h3 id="2-Spring的核心是什么"><a href="#2-Spring的核心是什么" class="headerlink" title="2. Spring的核心是什么"></a>2. Spring的核心是什么</h3><p>Spring框架包含众多模块，如Core、Testing、Data Access、Web Servlet等，其中Core是整个Spring框架的核心模块。Core模块提供了IoC容器、AOP功能、数据绑定、类型转换等一系列的基础功能，而这些功能以及其他模块的功能都是建立在IoC和AOP之上的，所以IoC和AOP是Spring框架的核心。</p><p>IoC（Inversion of Control）是控制反转的意思，这是一种面向对象编程的设计思想。在不采用这种思想的情况下，我们需要自己维护对象与对象之间的依赖关系，很容易造成对象之间的耦合度过高，在一个大型的项目中这十分的不利于代码的维护。IoC则可以解决这种问题，它可以帮我们维护对象与对象之间的依赖关系，降低对象之间的耦合度。</p><p>说到IoC就不得不说DI（Dependency Injection），DI是依赖注入的意思，它是IoC实现的实现方式，就是说IoC是通过DI来实现的。由于IoC这个词汇比较抽象而DI却更直观，所以很多时候我们就用DI来代替它，在很多时候我们简单地将IoC和DI划等号，这是一种习惯。而实现依赖注入的关键是IoC容器，它的本质就是一个工厂。</p><p>AOP（Aspect Oriented Programing）是面向切面编程思想，这种思想是对OOP的补充，它可以在OOP的基础上进一步提高编程的效率。简单来说，它可以统一解决一批组件的共性需求（如权限检查、记录日志、事务管理等）。在AOP思想下，我们可以将解决共性需求的代码独立出来，然后通过配置的方式，声明这些代码在什么地方、什么时机调用。当满足调用条件时，AOP会将该业务代码织入到我们指定的位置，从而统一解决了问题，又不需要修改这一批组件的代码。</p><h3 id="3-Spring容器"><a href="#3-Spring容器" class="headerlink" title="3. Spring容器"></a>3. Spring容器</h3><p>Spring主要提供了两种类型的容器：BeanFactory和ApplicationContext。</p><h4 id="BeanFactory"><a href="#BeanFactory" class="headerlink" title="BeanFactory"></a>BeanFactory</h4><ul><li>  BeanFactory：是基础类型的IoC容器，提供完整的IoC服务支持。如果没有特殊指定，默认采用延&nbsp;迟初始化策略。只有当客户端对象需要访问容器中的某个受管对象的时候，才对该受管对象进行初始化以及依赖注入操作。所以，相对来说，容器启动初期速度较快，所需要的资源有限。对于资源有限，并且功能要求不是很严格的场景，BeanFactory是比较合适的IoC容器选择。</li></ul><h4 id="ApplicationContext"><a href="#ApplicationContext" class="headerlink" title="ApplicationContext"></a>ApplicationContext</h4><ul><li>  ApplicationContext：它是在BeanFactory的基础上构建的，是相对比较高级的容器实现，除了拥有BeanFactory的所有支持，ApplicationContext还提供了其他高级特性，比如事件发布、国际化信息支持等。ApplicationContext所管理的对象，在该类型容器启动之后，默认全部初始化并绑定完成。所以，相对于BeanFactory来说，ApplicationContext要求更多的系统资源，同时，因为在启动时就完成所有初始化，容&nbsp;器启动时间较之BeanFactory也会长一些。在那些系统资源充足，并且要求更多功能的场景中，ApplicationContext类型的容器是比较合适的选择。</li></ul><h3 id="4-Spring-Spring-MVC-Spring-Boot-之间的关系"><a href="#4-Spring-Spring-MVC-Spring-Boot-之间的关系" class="headerlink" title="4. Spring,Spring MVC,Spring Boot 之间的关系"></a>4. Spring,Spring MVC,Spring Boot 之间的关系</h3><p>Spring 包含了多个功能模块（上面刚刚提到过），其中最重要的是 Spring-Core（主要提供 IoC 依赖注入功能的支持） 模块， Spring 中的其他模块（比如 Spring MVC）的功能实现基本都需要依赖于该模块。</p><p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p>Spring Boot 只是简化了配置，如果你需要构建 MVC 架构的 Web 程序，你还是需要使用 Spring MVC 作为 MVC 框架，只是说 Spring Boot 帮你简化了 Spring MVC 的很多配置，真正做到开箱即用！</p><h3 id="5-Spring-IoC"><a href="#5-Spring-IoC" class="headerlink" title="5.  Spring IoC"></a>5.  Spring IoC</h3><h4 id="什么是IoC"><a href="#什么是IoC" class="headerlink" title="什么是IoC"></a>什么是IoC</h4><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。不过， IoC 并非 Spring 特有，在其他语言中也有应用。</p><p><strong>为什么叫控制反转？</strong></p><ul><li>  <strong>控制</strong> ：指的是对象创建（实例化、管理）的权力</li><li>  <strong>反转</strong> ：控制权交给外部环境（Spring 框架、IoC 容器）</li></ul><p><img src="/images/image_Spring/02.png"></p><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。这样可以很大程度上简化应用的开发，把应用从复杂的依赖关系中解放出来。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p><p>在 Spring 中， IoC 容器是 Spring 用来实现 IoC 的载体， IoC 容器实际上就是个 Map（key，value），Map 中存放的是各种对象。</p><h4 id="什么是-Spring-Bean？"><a href="#什么是-Spring-Bean？" class="headerlink" title="什么是 Spring Bean？"></a>什么是 Spring Bean？</h4><p>简单来说，Bean 代指的就是那些被 IoC 容器所管理的对象。</p><p>我们需要告诉 IoC 容器帮助我们管理哪些对象，这个是通过配置元数据来定义的。配置元数据可以是 XML 文件、注解或者 Java 配置类。</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- Constructor-arg with 'value' attribute --&gt;</span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>constructor-arg</span> <span class="token attr-name">value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="将一个类声明为-Bean-的注解"><a href="#将一个类声明为-Bean-的注解" class="headerlink" title="将一个类声明为 Bean 的注解"></a>将一个类声明为 Bean 的注解</h4><ul><li>  <code>@Component</code> ：通用的注解，可标注任意类为 <code>Spring</code> 组件。如果一个 Bean 不知道属于哪个层，可以使用<code>@Component</code> 注解标注。</li><li>  <code>@Repository</code> : 对应持久层即 Dao 层，主要用于数据库相关操作。</li><li>  <code>@Service</code> : 对应服务层，主要涉及一些复杂的逻辑，需要用到 Dao 层。</li><li>  <code>@Controller</code> : 对应 Spring MVC 控制层，主要用于接受用户请求并调用 <code>Service</code> 层返回数据给前端页面。</li></ul><h4 id="Component-和-Bean-的区别"><a href="#Component-和-Bean-的区别" class="headerlink" title="@Component 和 @Bean 的区别"></a>@Component 和 @Bean 的区别</h4><ul><li>  <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</li><li>  <code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</li><li>  <code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</li></ul><p><code>@Bean</code>注解使用示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">TransferService</span> <span class="token function">transferService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TransferServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>上面的代码相当于下面的 xml 配置</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>beans</span><span class="token punctuation">&gt;</span></span>    <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>transferService<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>com.acme.TransferServiceImpl<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>beans</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">OneService</span> <span class="token function">getService</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>  <span class="token punctuation">{</span>        when <span class="token number">1</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        when <span class="token number">2</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        when <span class="token number">3</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="注入-Bean-的注解"><a href="#注入-Bean-的注解" class="headerlink" title="注入 Bean 的注解"></a>注入 Bean 的注解</h4><p>Spring 内置的&nbsp;<code>@Autowired</code>&nbsp;以及 JDK 内置的&nbsp;<code>@Resource</code>&nbsp;和&nbsp;<code>@Inject</code>&nbsp;都可以用于注入 Bean。</p><p><code>@Autowired</code> 和<code>@Resource</code>使用的比较多一些。</p><h4 id="Autowired-和-Resource-的区别"><a href="#Autowired-和-Resource-的区别" class="headerlink" title="@Autowired 和 @Resource 的区别"></a>@Autowired 和 @Resource 的区别</h4><p><code>Autowired</code> 属于 Spring 内置的注解，默认的注入方式为<code>byType</code>（根据类型进行匹配），也就是说会优先根据接口类型去匹配并注入 Bean （接口的实现类）。</p><p><strong>这会有什么问题呢？</strong> 当一个接口存在多个实现类的话，<code>byType</code>这种方式就无法正确注入对象了，因为这个时候 Spring 会同时找到多个满足条件的选择，默认情况下它自己不知道选择哪一个。</p><p>这种情况下，注入方式会变为 <code>byName</code>（根据名称进行匹配），这个名称通常就是类名（首字母小写）。就比如说下面代码中的 <code>smsService</code> 就是我这里所说的名称，这样应该比较好理解了吧。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// smsService 就是我们上面所说的名称</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>举个例子，<code>SmsService</code> 接口有两个实现类: <code>SmsServiceImpl1</code>和 <code>SmsServiceImpl2</code>，且它们都已经被 Spring 容器所管理。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 报错，byName 和 byType 都无法匹配到 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsServiceImpl1<span class="token punctuation">;</span><span class="token comment">// 正确注入  SmsServiceImpl1 对象对应的 bean</span><span class="token comment">// smsServiceImpl1 就是我们上面所说的名称</span><span class="token annotation punctuation">@Autowired</span><span class="token annotation punctuation">@Qualifier</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token string">"smsServiceImpl1"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>我们还是建议通过 <code>@Qualifier</code> 注解来显式指定名称而不是依赖变量的名称。</p><p><code>@Resource</code>属于 JDK 提供的注解，默认注入方式为 <code>byName</code>。如果无法通过名称匹配到对应的 Bean 的话，注入方式会变为<code>byType</code>。</p><p><code>@Resource</code> 有两个比较重要且日常开发常用的属性：<code>name</code>（名称）、<code>type</code>（类型）。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token annotation punctuation">@interface</span> <span class="token class-name">Resource</span> <span class="token punctuation">{</span>    <span class="token class-name">String</span> <span class="token function">name</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token string">""</span><span class="token punctuation">;</span>    <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">type</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">default</span> <span class="token class-name">Object</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>如果仅指定 <code>name</code> 属性则注入方式为<code>byName</code>，如果仅指定<code>type</code>属性则注入方式为<code>byType</code>，如果同时指定<code>name</code> 和<code>type</code>属性（不建议这么做）则注入方式为<code>byType</code>+<code>byName</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 报错，byName 和 byType 都无法匹配到 bean</span><span class="token annotation punctuation">@Resource</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean</span><span class="token annotation punctuation">@Resource</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsServiceImpl1<span class="token punctuation">;</span><span class="token comment">// 正确注入 SmsServiceImpl1 对象对应的 bean（比较推荐这种方式）</span><span class="token annotation punctuation">@Resource</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"smsServiceImpl1"</span><span class="token punctuation">)</span><span class="token keyword">private</span> <span class="token class-name">SmsService</span> smsService<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>简单总结一下：</p><ul><li>  <code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</li><li>  <code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</li><li>  当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</li></ul><h4 id="三种注入方式"><a href="#三种注入方式" class="headerlink" title="三种注入方式"></a>三种注入方式</h4><ol><li>构造方法注入 就是被注入对象可以在它的构造方法中声明依赖对象的参数列表，让外部知道它需要哪些依赖对象。然后，IoC Service Provider会检查被注入的对象的构造方法，取得它所需要的依赖对象列表，进而为其注入相应的对象。构造方法注入方式比较直观，对象被构造完成后，即进入就绪状态，可以马上使用。</li><li>setter方法注入 通过setter方法，可以更改相应的对象属性。所以，当前对象只要为其依赖对象所对应的属性添加setter方法，就可以通过setter方法将相应的依赖对象设置到被注入对象中。setter方法注入虽不像构造方法注入那样，让对象构造完成后即可使用，但相对来说更宽松一些，&nbsp;可以在对象构造完成后再注入。</li><li>接口注入 相对于前两种注入方式来说，接口注入没有那么简单明了。被注入对象如果想要IoC Service Provider为其注入依赖对象，就必须实现某个接口。这个接口提供一个方法，用来为其注入依赖对象。IoC Service Provider最终通过这些接口来了解应该为被注入对象注入什么依赖对象。相对于前两种依赖注入方式，接口注入比较死板和烦琐。</li></ol><p>总体来说，构造方法注入和setter方法注入因为其侵入性较弱，且易于理解和使用，所以是现在使用最多的注入方式。而接口注入因为侵入性较强，近年来已经不流行了。</p><h4 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h4><p>Spring 中 Bean 的作用域通常有下面几种：</p><ul><li>  <strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li>  <strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li>  <strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li>  <strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li>  <strong>application/global-session</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li>  <strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li></ul><p><strong>如何配置 bean 的作用域呢？</strong></p><p>xml 方式：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>singleton<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注解方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ConfigurableBeanFactory</span><span class="token punctuation">.</span><span class="token constant">SCOPE_PROTOTYPE</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">personPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="单例-Bean-的线程安全问题"><a href="#单例-Bean-的线程安全问题" class="headerlink" title="单例 Bean 的线程安全问题"></a>单例 Bean 的线程安全问题</h4><p>单例 Bean 存在线程问题，主要是因为当多个线程操作同一个对象的时候是存在资源竞争的。</p><p>常见的有两种解决办法：</p><ol><li> 在 Bean 中尽量避免定义可变的成员变量。</li><li> 在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐的一种方式）。</li></ol><p>不过，大部分 Bean 实际都是无状态（没有实例变量）的（比如 Dao、Service），这种情况下， Bean 是线程安全的。</p><h4 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h4><ul><li>  Bean 容器找到配置文件中 Spring Bean 的定义。</li><li>  Bean 容器利用 Java Reflection API 创建一个 Bean 的实例。</li><li>  如果涉及到一些属性值 利用 <code>set()</code>方法设置一些属性值。</li><li>  如果 Bean 实现了 <code>BeanNameAware</code> 接口，调用 <code>setBeanName()</code>方法，传入 Bean 的名字。</li><li>  如果 Bean 实现了 <code>BeanClassLoaderAware</code> 接口，调用 <code>setBeanClassLoader()</code>方法，传入 <code>ClassLoader</code>对象的实例。</li><li>  如果 Bean 实现了 <code>BeanFactoryAware</code> 接口，调用 <code>setBeanFactory()</code>方法，传入 <code>BeanFactory</code>对象的实例。</li><li>  与上面的类似，如果实现了其他 <code>*.Aware</code>接口，就调用相应的方法。</li><li>  如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessBeforeInitialization()</code> 方法</li><li>  如果 Bean 实现了<code>InitializingBean</code>接口，执行<code>afterPropertiesSet()</code>方法。</li><li>  如果 Bean 在配置文件中的定义包含 init-method 属性，执行指定的方法。</li><li>  如果有和加载这个 Bean 的 Spring 容器相关的 <code>BeanPostProcessor</code> 对象，执行<code>postProcessAfterInitialization()</code> 方法</li><li>  当要销毁 Bean 的时候，如果 Bean 实现了 <code>DisposableBean</code> 接口，执行 <code>destroy()</code> 方法。</li><li>  当要销毁 Bean 的时候，如果 Bean 在配置文件中的定义包含 destroy-method 属性，执行指定的方法。</li></ul><p><img src="/images/image_Spring/03.png"></p><p>这个过程是由Spring容器自动管理的，其中有两个环节我们可以进行干预。</p><ol><li>我们可以自定义初始化方法，并在该方法前增加@PostConstruct注解，届时Spring容器将在调用SetBeanFactory方法之后调用该方法。</li><li> 我们可以自定义销毁方法，并在该方法前增加@PreDestroy注解，届时Spring容器将在自身销毁前，调用这个方法。</li></ol><h3 id="6-Spring-AoP"><a href="#6-Spring-AoP" class="headerlink" title="6. Spring AoP"></a>6. Spring AoP</h3><h4 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h4><p>AOP(Aspect-Oriented Programming:面向切面编程)能够将那些与业务无关，却为业务模块所共同调用的逻辑或责任（例如事务处理、日志管理、权限控制等）封装起来，便于减少系统的重复代码，降低模块间的耦合度，并有利于未来的可拓展性和可维护性。</p><p>Spring AOP 就是基于动态代理的，如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理，如下图所示：</p><p><img src="/images/image_Spring/04.jpg"></p><p>当然你也可以使用 <strong>AspectJ</strong> ！Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。</p><p>AOP 切面编程设计到的一些专业术语：</p><p><img src="/images/image_Spring/05.png"></p><h4 id="CGLib和JDK-Proxy的区别"><a href="#CGLib和JDK-Proxy的区别" class="headerlink" title="CGLib和JDK Proxy的区别"></a>CGLib和JDK Proxy的区别</h4><p>在性能方面，CGLib创建的代理对象比JDK动态代理创建的代理对象高很多。</p><p>但是，CGLib在创建代理对象时所花费的时间比JDK动态代理多很多。</p><p>所以，对于单例的对象因为无需频繁创建代理对象，采用CGLib动态代理比较合适。反之，对于多例的对象因为需要频繁的创建代理对象，则JDK动态代理更合适。</p><h4 id="Spring-AOP-和-AspectJ-AOP-的区别"><a href="#Spring-AOP-和-AspectJ-AOP-的区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 的区别"></a>Spring AOP 和 AspectJ AOP 的区别</h4><p><strong>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</strong> Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p><p>Spring AOP 已经集成了 AspectJ ，AspectJ 应该算的上是 Java 生态系统中最完整的 AOP 框架了。AspectJ 相比于 Spring AOP 功能更加强大，但是 Spring AOP 相对来说更简单，</p><p>如果我们的切面比较少，那么两者性能差异不大。但是，当切面太多的话，最好选择 AspectJ ，它比 Spring AOP 快很多。</p><h4 id="AspectJ-定义的通知类型"><a href="#AspectJ-定义的通知类型" class="headerlink" title="AspectJ 定义的通知类型"></a>AspectJ 定义的通知类型</h4><ul><li>  <strong>Before</strong>（前置通知）：目标对象的方法调用之前触发</li><li>  <strong>After</strong> （后置通知）：目标对象的方法调用之后触发</li><li>  <strong>AfterReturning</strong>（返回通知）：目标对象的方法调用完成，在返回结果值之后触发</li><li>  <strong>AfterThrowing</strong>（异常通知） ：目标对象的方法运行中抛出 / 触发异常后触发。AfterReturning 和 AfterThrowing 两者互斥。如果方法调用成功无异常，则会有返回值；如果方法抛出了异常，则不会有返回值。</li><li>  <strong>Around</strong> （环绕通知）：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法，所以环绕通知可以任意的在目标对象的方法调用前后搞事，甚至不调用目标对象的方法</li></ul><h4 id="多个切面的执行顺序如何控制"><a href="#多个切面的执行顺序如何控制" class="headerlink" title="多个切面的执行顺序如何控制"></a>多个切面的执行顺序如何控制</h4><p>1、通常使用<code>@Order</code> 注解直接定义切面顺序</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 值越小优先级越高</span><span class="token annotation punctuation">@Order</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingAspect</span> <span class="token keyword">implements</span> <span class="token class-name">Ordered</span> <span class="token punctuation">{</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2、实现<code>Ordered</code> 接口重写 <code>getOrder</code> 方法。</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span><span class="token annotation punctuation">@Aspect</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoggingAspect</span> <span class="token keyword">implements</span> <span class="token class-name">Ordered</span> <span class="token punctuation">{</span>    <span class="token comment">// ....</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOrder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 返回值越小优先级越高</span>        <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="7-Spring-MVC"><a href="#7-Spring-MVC" class="headerlink" title="7. Spring MVC"></a>7. Spring MVC</h3><h4 id="什么是-Spring-MVC"><a href="#什么是-Spring-MVC" class="headerlink" title="什么是 Spring MVC"></a>什么是 Spring MVC</h4><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架。Spring MVC 可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p><h4 id="Spring-MVC-的核心组件"><a href="#Spring-MVC-的核心组件" class="headerlink" title="Spring MVC 的核心组件"></a>Spring MVC 的核心组件</h4><p>记住了下面这些组件，也就记住了 SpringMVC 的工作原理。</p><ul><li>  <strong><code>DispatcherServlet</code></strong> ：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li>  <strong><code>HandlerMapping</code></strong> ：<strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li>  <strong><code>HandlerAdapter</code></strong> ：<strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；</li><li>  <strong><code>Handler</code></strong> ：<strong>请求处理器</strong>，处理实际请求的处理器。</li><li>  <strong><code>ViewResolver</code></strong> ：<strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图，并传递给 <code>DispatcherServlet</code> 响应客户端</li></ul><h4 id="SpringMVC-工作原理"><a href="#SpringMVC-工作原理" class="headerlink" title="SpringMVC 工作原理"></a>SpringMVC 工作原理</h4><p><strong>Spring MVC 原理如下图所示：</strong></p><p><img src="/images/image_Spring/06.png"></p><p><strong>流程说明（重要）：</strong></p><ol><li>整个过程开始于客户端发出的一个HTTP请求，Web应用服务器接收到这个请求。如果匹配DispatcherServlet的请求映射路径，则Web容器将该请求转交给DispatcherServlet处理。</li><li>DispatcherServlet接收到这个请求后，将根据请求的信息（包括URL、HTTP方法、请求报文头、请求参数、Cookie等）及HandlerMapping的配置找到处理请求的处理器（Handler）。可将HandlerMapping看做路由控制器，将Handler看做目标主机。值得注意的是，在Spring MVC中并没有定义一个Handler接口，实际上任何一个Object都可以成为请求处理器。</li><li>当DispatcherServlet根据HandlerMapping得到对应当前请求的Handler后，通过HandlerAdapter对Handler进行封装，再以统一的适配器接口调用Handler。HandlerAdapter是Spring MVC框架级接口，顾名思义，HandlerAdapter是一个适配器，它用统一的接口对各种Handler方法进行调用。</li><li>处理器完成业务逻 辑的处理后，将返回一个ModelAndView给DispatcherServlet，ModelAndView包含了视图逻辑名和模型数据信息。</li><li>ModelAndView中包含的是“逻辑视图名”而非真正的视图对象，DispatcherServlet借由ViewResolver完成逻辑视图名到真实视图对象的解析工作。</li><li>当得到真实的视图对象View后，DispatcherServlet就使用这个View对象对ModelAndView中的模型数据进行视图渲染。</li><li> 最终客户端得到的响应消息可能是一个普通的HTML页面，也可能是一个XML或JSON串，甚至是一张图片或一个PDF文档等不同的媒体形式。</li></ol><h4 id="Spring-MVC注解"><a href="#Spring-MVC注解" class="headerlink" title="Spring MVC注解"></a>Spring MVC注解</h4><h5 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h5><p>作用：该注解的作用就是用来处理请求地址映射的，也就是说将其中的处理器方法映射到url路径上。</p><p>属性：</p><ul><li>method：是让你指定请求的method的类型，比如常用的有get和post。</li><li>value：是指请求的实际地址，如果是多个地址就用{}来指定就可以了。</li><li>produces：指定返回的内容类型，当request请求头中的Accept类型中包含指定的类型才可以返回的。</li><li>consumes：指定处理请求的提交内容类型，比如一些json、html、text等的类型。</li><li>headers：指定request中必须包含那些的headed值时，它才会用该方法处理请求的。</li><li>params：指定request中一定要有的参数值，它才会使用该方法处理请求。</li></ul><h5 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h5><p>作用：是将请求参数绑定到你的控制器的方法参数上，是Spring MVC中的接收普通参数的注解。</p><p>属性：</p><ul><li>value是请求参数中的名称。</li><li>required是请求参数是否必须提供参数，它的默认是true，意思是表示必须提供。</li></ul><h5 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h5><p>作用：如果作用在方法上，就表示该方法的返回结果是直接按写入的Http responsebody中（一般在异步获取数据时使用的注解）。</p><p>属性：required，是否必须有请求体。它的默认值是true，在使用该注解时，值得注意的当为true时get的请求方式是报错的，如果你取值为false的话，get的请求是null。</p><h5 id="PathVaribale"><a href="#PathVaribale" class="headerlink" title="@PathVaribale"></a>@PathVaribale</h5><p>作用：该注解是用于绑定url中的占位符，但是注意，spring3.0以后，url才开始支持占位符的，它是Spring MVC支持的rest风格url的一个重要的标志。</p><h4 id="Spring-MVC的拦截器"><a href="#Spring-MVC的拦截器" class="headerlink" title="Spring MVC的拦截器"></a>Spring MVC的拦截器</h4><p>拦截器会对处理器进行拦截，这样通过拦截器就可以增强处理器的功能。Spring MVC中，所有的拦截器都需要实现HandlerInterceptor接口，该接口包含如下三个方法：preHandle()、postHandle()、afterCompletion()。</p><p>这些方法的执行流程如下图：</p><p><img src="/images/image_Spring/07.png"></p><p>通过上图可以看出，Spring MVC拦截器的执行流程如下：</p><ul><li>执行preHandle方法，它会返回一个布尔值。如果为false，则结束所有流程，如果为true，则执行下一步。</li><li>执行处理器逻辑，它包含控制器的功能。</li><li>执行postHandle方法。</li><li>执行视图解析和视图渲染。</li><li>执行afterCompletion方法。</li></ul><p>Spring MVC拦截器的开发步骤如下：</p><ol><li>开发拦截器： 实现handlerInterceptor接口，从三个方法中选择合适的方法，实现拦截时要执行的具体业务逻辑。</li><li>注册拦截器： 定义配置类，并让它实现WebMvcConfigurer接口，在接口的addInterceptors方法中，注册拦截器，并定义该拦截器匹配哪些请求路径。</li></ol><h4 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h4><p>推荐使用注解的方式统一异常处理，具体会使用到 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 这两个注解 。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@ControllerAdvice</span><span class="token annotation punctuation">@ResponseBody</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">GlobalExceptionHandler</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span><span class="token class-name">BaseException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">handleAppException</span><span class="token punctuation">(</span><span class="token class-name">BaseException</span> ex<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//......</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@ExceptionHandler</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ResourceNotFoundException</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token class-name">ResponseEntity</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">ErrorReponse</span><span class="token punctuation">&gt;</span></span> <span class="token function">handleResourceNotFoundException</span><span class="token punctuation">(</span><span class="token class-name">ResourceNotFoundException</span> ex<span class="token punctuation">,</span> <span class="token class-name">HttpServletRequest</span> request<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">//......</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这种异常处理方式下，会给所有或者指定的 <code>Controller</code> 织入异常处理的逻辑（AOP），当 <code>Controller</code> 中的方法抛出异常的时候，由被<code>@ExceptionHandler</code> 注解修饰的方法进行处理。</p><p><code>ExceptionHandlerMethodResolver</code> 中 <code>getMappedMethod</code> 方法决定了异常具体被哪个被 <code>@ExceptionHandler</code> 注解修饰的方法处理异常。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Nullable</span><span class="token keyword">private</span> <span class="token class-name">Method</span> <span class="token function">getMappedMethod</span><span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> exceptionType<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Class</span><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> matches <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//找到可以处理的所有异常信息。mappedMethods 中存放了异常和处理异常的方法的对应关系</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Throwable</span><span class="token punctuation">&gt;</span></span> mappedException <span class="token operator">:</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mappedMethods<span class="token punctuation">.</span><span class="token function">keySet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token keyword">if</span> <span class="token punctuation">(</span>mappedException<span class="token punctuation">.</span><span class="token function">isAssignableFrom</span><span class="token punctuation">(</span>exceptionType<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>matches<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>mappedException<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span>    <span class="token comment">// 不为空说明有方法处理异常</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>matches<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 按照匹配程度从小到大排序</span>matches<span class="token punctuation">.</span><span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ExceptionDepthComparator</span><span class="token punctuation">(</span>exceptionType<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 返回处理异常的方法</span><span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>mappedMethods<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>matches<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从源代码看出： <strong><code>getMappedMethod()</code>会首先找到可以匹配处理异常的所有方法信息，然后对其进行从小到大的排序，最后取最小的那一个匹配的方法(即匹配度最高的那个)。</strong></p><h3 id="8-Spring-框架中用到了哪些设计模式？"><a href="#8-Spring-框架中用到了哪些设计模式？" class="headerlink" title="8. Spring 框架中用到了哪些设计模式？"></a>8. Spring 框架中用到了哪些设计模式？</h3><ul><li>  <strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li>  <strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li>  <strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li>  <strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li>  <strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li>  <strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li>  <strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li></ul><h3 id="9-Spring-事务"><a href="#9-Spring-事务" class="headerlink" title="9. Spring 事务"></a>9. Spring 事务</h3><h4 id="Spring-管理事务的方式"><a href="#Spring-管理事务的方式" class="headerlink" title="Spring 管理事务的方式"></a>Spring 管理事务的方式</h4><ul><li>  <strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li><li>  <strong>声明式事务</strong> ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）</li></ul><h4 id="Spring-事务中的事务传播行为"><a href="#Spring-事务中的事务传播行为" class="headerlink" title="Spring 事务中的事务传播行为"></a>Spring 事务中的事务传播行为</h4><p><strong>事务传播行为是为了解决业务层方法之间互相调用的事务问题</strong>。</p><p>当事务方法被另一个事务方法调用时，必须指定事务应该如何传播。例如：方法可能继续在现有事务中运行，也可能开启一个新事务，并在自己的事务中运行。</p><p>正确的事务传播行为可能的值如下:</p><p><strong>1.<code>TransactionDefinition.PROPAGATION_REQUIRED</code></strong></p><p>使用的最多的一个事务传播行为，我们平时经常使用的<code>@Transactional</code>注解默认使用就是这个事务传播行为。如果当前存在事务，则加入该事务；如果当前没有事务，则创建一个新的事务。</p><p><strong><code>2.TransactionDefinition.PROPAGATION_REQUIRES_NEW</code></strong></p><p>创建一个新的事务，如果当前存在事务，则把当前事务挂起。也就是说不管外部方法是否开启事务，<code>Propagation.REQUIRES_NEW</code>修饰的内部方法会新开启自己的事务，且开启的事务相互独立，互不干扰。</p><p><strong>3.<code>TransactionDefinition.PROPAGATION_NESTED</code></strong></p><p>如果当前存在事务，则创建一个事务作为当前事务的嵌套事务来运行；如果当前没有事务，则该取值等价于<code>TransactionDefinition.PROPAGATION_REQUIRED</code>。</p><p><strong>4.<code>TransactionDefinition.PROPAGATION_MANDATORY</code></strong></p><p>如果当前存在事务，则加入该事务；如果当前没有事务，则抛出异常。（mandatory：强制性）</p><p>这个使用的很少。</p><p>若是错误的配置以下 3 种事务传播行为，事务将不会发生回滚：</p><ul><li>  <strong><code>TransactionDefinition.PROPAGATION_SUPPORTS</code></strong>: 如果当前存在事务，则加入该事务；如果当前没有事务，则以非事务的方式继续运行。</li><li>  <strong><code>TransactionDefinition.PROPAGATION_NOT_SUPPORTED</code></strong>: 以非事务方式运行，如果当前存在事务，则把当前事务挂起。</li><li>  <strong><code>TransactionDefinition.PROPAGATION_NEVER</code></strong>: 以非事务方式运行，如果当前存在事务，则抛出异常。</li></ul><h4 id="Spring-事务中的隔离级别"><a href="#Spring-事务中的隔离级别" class="headerlink" title="Spring 事务中的隔离级别"></a>Spring 事务中的隔离级别</h4><p>和事务传播行为这块一样，为了方便使用，Spring 也相应地定义了一个枚举类：<code>Isolation</code></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">enum</span> <span class="token class-name">Isolation</span> <span class="token punctuation">{</span>    <span class="token function">DEFAULT</span><span class="token punctuation">(</span><span class="token class-name">TransactionDefinition</span><span class="token punctuation">.</span><span class="token constant">ISOLATION_DEFAULT</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">READ_UNCOMMITTED</span><span class="token punctuation">(</span><span class="token class-name">TransactionDefinition</span><span class="token punctuation">.</span><span class="token constant">ISOLATION_READ_UNCOMMITTED</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">READ_COMMITTED</span><span class="token punctuation">(</span><span class="token class-name">TransactionDefinition</span><span class="token punctuation">.</span><span class="token constant">ISOLATION_READ_COMMITTED</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">REPEATABLE_READ</span><span class="token punctuation">(</span><span class="token class-name">TransactionDefinition</span><span class="token punctuation">.</span><span class="token constant">ISOLATION_REPEATABLE_READ</span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token function">SERIALIZABLE</span><span class="token punctuation">(</span><span class="token class-name">TransactionDefinition</span><span class="token punctuation">.</span><span class="token constant">ISOLATION_SERIALIZABLE</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token keyword">int</span> value<span class="token punctuation">;</span>    <span class="token class-name">Isolation</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面我依次对每一种事务隔离级别进行介绍：</p><ul><li>  <strong><code>TransactionDefinition.ISOLATION_DEFAULT</code></strong> :使用后端数据库默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li><li>  <strong><code>TransactionDefinition.ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，使用这个隔离级别很少，因为它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li>  <strong><code>TransactionDefinition.ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li>  <strong><code>TransactionDefinition.ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li>  <strong><code>TransactionDefinition.ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。通常情况下也不会用到该级别。</li></ul><h4 id="Transactional-rollbackFor-Exception-class-注解"><a href="#Transactional-rollbackFor-Exception-class-注解" class="headerlink" title="@Transactional(rollbackFor = Exception.class)注解"></a>@Transactional(rollbackFor = Exception.class)注解</h4><p><code>Exception</code> 分为运行时异常 <code>RuntimeException</code> 和非运行时异常。事务管理对于企业应用来说是至关重要的，即使出现异常情况，它也可以<strong>保证数据的一致性</strong>。</p><p>当 <code>@Transactional</code> 注解作用于类上时，该类的所有 public 方法将都具有该类型的事务属性，同时，我们也可以在方法级别使用该标注来覆盖类级别的定义。如果类或者方法加了这个注解，那么这个类里面的方法抛出异常，就会回滚，数据库里面的数据也会回滚。</p><p>在 <code>@Transactional</code> 注解中如果不配置<code>rollbackFor</code>属性,那么事务只会在遇到<code>RuntimeException</code>的时候才会回滚，<strong>加上 <code>rollbackFor=Exception.class</code>,可以让事务在遇到非运行时异常时也回滚。</strong></p><h3 id="10-Spring-Data-JPA"><a href="#10-Spring-Data-JPA" class="headerlink" title="10. Spring Data JPA"></a>10. Spring Data JPA</h3><p>JPA 重要的是实战，这里仅对小部分知识点进行总结。</p><h4 id="使用-JPA-在数据库中非持久化一个字段"><a href="#使用-JPA-在数据库中非持久化一个字段" class="headerlink" title="使用 JPA 在数据库中非持久化一个字段"></a>使用 JPA 在数据库中非持久化一个字段</h4><p>假如我们有下面一个类：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Entity</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"USER"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Id</span>    <span class="token annotation punctuation">@GeneratedValue</span><span class="token punctuation">(</span>strategy <span class="token operator">=</span> <span class="token class-name">GenerationType</span><span class="token punctuation">.</span><span class="token constant">AUTO</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name <span class="token operator">=</span> <span class="token string">"ID"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">Long</span> id<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"USER_NAME"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> userName<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>name<span class="token operator">=</span><span class="token string">"PASSWORD"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> secrect<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果我们想让<code>secrect</code> 这个字段不被持久化，也就是不被数据库存储怎么办？我们可以采用下面几种方法：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token class-name">String</span> transient1<span class="token punctuation">;</span> <span class="token comment">// not persistent because of static</span><span class="token keyword">final</span> <span class="token class-name">String</span> transient2 <span class="token operator">=</span> <span class="token string">"Satish"</span><span class="token punctuation">;</span> <span class="token comment">// not persistent because of final</span><span class="token keyword">transient</span> <span class="token class-name">String</span> transient3<span class="token punctuation">;</span> <span class="token comment">// not persistent because of transient</span><span class="token annotation punctuation">@Transient</span><span class="token class-name">String</span> transient4<span class="token punctuation">;</span> <span class="token comment">// not persistent because of @Transient</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>一般使用后面两种方式比较多，我个人使用注解的方式比较多。</p><h4 id="JPA-的审计功能的作用"><a href="#JPA-的审计功能的作用" class="headerlink" title="JPA 的审计功能的作用"></a>JPA 的审计功能的作用</h4><p>审计功能主要是帮助我们记录数据库操作的具体行为，比如某条记录是谁创建的、什么时间创建的、最后修改人是谁、最后修改时间是什么时候。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span><span class="token annotation punctuation">@AllArgsConstructor</span><span class="token annotation punctuation">@NoArgsConstructor</span><span class="token annotation punctuation">@MappedSuperclass</span><span class="token annotation punctuation">@EntityListeners</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">AuditingEntityListener</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">abstract</span> <span class="token keyword">class</span> <span class="token class-name">AbstractAuditBase</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@CreatedDate</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">Instant</span> createdAt<span class="token punctuation">;</span>    <span class="token annotation punctuation">@LastModifiedDate</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">Instant</span> updatedAt<span class="token punctuation">;</span>    <span class="token annotation punctuation">@CreatedBy</span>    <span class="token annotation punctuation">@Column</span><span class="token punctuation">(</span>updatable <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">)</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> createdBy<span class="token punctuation">;</span>    <span class="token annotation punctuation">@LastModifiedBy</span>    <span class="token annotation punctuation">@JsonIgnore</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> updatedBy<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li><code>@CreatedDate</code>: 表示该字段为创建时间字段，在这个实体被 insert 的时候，会设置值</li><li><code>@CreatedBy</code> :表示该字段为创建人，在这个实体被 insert 的时候，会设置值  <code>@LastModifiedDate</code>、<code>@LastModifiedBy</code>同理。</li></ul><h4 id="实体之间的关联关系注解"><a href="#实体之间的关联关系注解" class="headerlink" title="实体之间的关联关系注解"></a>实体之间的关联关系注解</h4><ul><li>  <code>@OneToOne</code> : 一对一。</li><li>  <code>@ManyToMany</code> ：多对多。</li><li>  <code>@OneToMany</code> : 一对多。</li><li>  <code>@ManyToOne</code> ：多对一。</li></ul><p>利用 <code>@ManyToOne</code> 和 <code>@OneToMany</code> 也可以表达多对多的关联关系。</p><h3 id="11-Spring-Security"><a href="#11-Spring-Security" class="headerlink" title="11. Spring Security"></a>11. Spring Security</h3><h4 id="控制请求访问权限的方法"><a href="#控制请求访问权限的方法" class="headerlink" title="控制请求访问权限的方法"></a>控制请求访问权限的方法</h4><ul><li>  <code>permitAll()</code> ：无条件允许任何形式访问，不管你登录还是没有登录。</li><li>  <code>anonymous()</code> ：允许匿名访问，也就是没有登录才可以访问。</li><li>  <code>denyAll()</code> ：无条件决绝任何形式的访问。</li><li>  <code>authenticated()</code>：只允许已认证的用户访问。</li><li>  <code>fullyAuthenticated()</code> ：只允许已经登录或者通过 remember-me 登录的用户访问。</li><li>  <code>hasRole(String)</code> : 只允许指定的角色访问。</li><li>  <code>hasAnyRole(String)</code> : 指定一个或者多个角色，满足其一的用户即可访问。</li><li>  <code>hasAuthority(String)</code> ：只允许具有指定权限的用户访问</li><li>  <code>hasAnyAuthority(String)</code> ：指定一个或者多个权限，满足其一的用户即可访问。</li><li>  <code>hasIpAddress(String)</code> : 只允许指定 ip 的用户访问。</li></ul><p><strong>hasRole 和 hasAuthority 的区别</strong></p><p>代码上来说，hasRole 和 hasAuthority 写代码时前缀不同，但是最终执行是一样的；设计上来说，role 和 authority 这是两个层面的权限设计思路，一个是角色，一个是权限，角色是权限的集合。</p><h4 id="如何对密码进行加密"><a href="#如何对密码进行加密" class="headerlink" title="如何对密码进行加密"></a>如何对密码进行加密</h4><p>如果我们需要保存密码这类敏感数据到数据库的话，需要先加密再保存。</p><p>Spring Security 提供了多种加密算法的实现，开箱即用，非常方便。这些加密算法实现类的父类是 <code>PasswordEncoder</code> ，如果你想要自己实现一个加密算法的话，也需要继承 <code>PasswordEncoder</code>。</p><p><code>PasswordEncoder</code> 接口一共也就 3 个必须实现的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">PasswordEncoder</span> <span class="token punctuation">{</span>    <span class="token comment">// 加密也就是对原始密码进行编码</span>    <span class="token class-name">String</span> <span class="token function">encode</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> var1<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 比对原始密码和数据库中保存的密码</span>    <span class="token keyword">boolean</span> <span class="token function">matches</span><span class="token punctuation">(</span><span class="token class-name">CharSequence</span> var1<span class="token punctuation">,</span> <span class="token class-name">String</span> var2<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 判断加密密码是否需要再次进行加密，默认返回 false</span>    <span class="token keyword">default</span> <span class="token keyword">boolean</span> <span class="token function">upgradeEncoding</span><span class="token punctuation">(</span><span class="token class-name">String</span> encodedPassword<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="如何更换系统使用的加密算法"><a href="#如何更换系统使用的加密算法" class="headerlink" title="如何更换系统使用的加密算法"></a>如何更换系统使用的加密算法</h4><p>如果我们在开发过程中，突然发现现有的加密算法无法满足我们的需求，需要更换成另外一个加密算法，这个时候应该怎么办呢？</p><p>推荐的做法是通过 <code>DelegatingPasswordEncoder</code> 兼容多种不同的密码加密方案，以适应不同的业务需求。</p><p>从名字也能看出来，<code>DelegatingPasswordEncoder</code> 其实就是一个代理类，并非是一种全新的加密算法，它做的事情就是代理上面提到的加密算法实现类。在 Spring Security 5.0之后，默认就是基于 <code>DelegatingPasswordEncoder</code> 进行密码加密的。</p><h3 id="12-Spring是怎么解决循环依赖的？"><a href="#12-Spring是怎么解决循环依赖的？" class="headerlink" title="12. Spring是怎么解决循环依赖的？"></a>12. Spring是怎么解决循环依赖的？</h3><p>首先，需要明确的是spring对循环依赖的处理有三种情况：</p><ol><li>构造器的循环依赖：这种依赖spring是处理不了的，直接抛出BeanCurrentlylnCreationException异常。</li><li>单例模式下的setter循环依赖：通过“三级缓存”处理循环依赖。</li><li>非单例循环依赖：无法处理。</li></ol><p>接下来，我们具体看看spring是如何处理第二种循环依赖的。</p><p>Spring单例对象的初始化大略分为三步：</p><ol><li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象；</li><li>populateBean：填充属性，这一步主要是多bean的依赖属性进行填充；</li><li>initializeBean：调用spring xml中的init 方法。</li></ol><p>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一步、第二步。也就是构造器循环依赖和field循环依赖。 Spring为了解决单例的循环依赖问题，使用了三级缓存。</p><p>这三级缓存的作用分别是：</p><ul><li>singletonFactories ： 进入实例化阶段的单例对象工厂的cache （三级缓存）；</li><li>earlySingletonObjects ：完成实例化但是尚未初始化的，提前暴光的单例对象的Cache （二级缓存）；</li><li>  singletonObjects：完成初始化的单例对象的cache（一级缓存）。</li></ul><p>这样做有什么好处呢？让我们来分析一下</p><p>“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Spring-包含的模块有哪些？&quot;&gt;&lt;a href=&quot;#1-Spring-包含的模块有哪些？&quot; class=&quot;headerlink&quot; title=&quot;1. Spring 包含的模块有哪些？&quot;&gt;&lt;/a&gt;1. Spring 包含的模块有哪些？&lt;/h3&gt;&lt;p&gt;&lt;img</summary>
      
    
    
    
    
    <category term="Spring" scheme="http://ailiaa.github.io/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>设计模式</title>
    <link href="http://ailiaa.github.io/2023/03/11/she-ji-mo-shi/"/>
    <id>http://ailiaa.github.io/2023/03/11/she-ji-mo-shi/</id>
    <published>2023-03-11T12:28:49.000Z</published>
    <updated>2023-03-11T13:30:29.948Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-软件设计原则"><a href="#1-软件设计原则" class="headerlink" title="1. 软件设计原则"></a>1. 软件设计原则</h3><p>常⽤的⾯向对象设计原则包括7个，这些原则并不是孤⽴存在的，它们相互 依赖，相互补充。</p><ul><li>开闭原则（Open Closed Principle，OCP）</li><li>单⼀职责原则（Single Responsibility Principle, SRP） </li><li>⾥⽒替换原则（Liskov Substitution Principle，LSP） </li><li>依赖倒置原则（Dependency Inversion Principle，DIP） </li><li>接⼝隔离原则（Interface Segregation Principle，ISP） </li><li>合成/聚合复⽤原则（Composite/Aggregate Reuse Principle， C/ARP） </li><li>最少知识原则（Least Knowledge Principle，LKP）</li><li>或者迪⽶特法则 （Law of Demeter，LOD</li></ul><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.png"></p><h3 id="1-什么是设计模式？"><a href="#1-什么是设计模式？" class="headerlink" title="1. 什么是设计模式？"></a>1. 什么是设计模式？</h3><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的⾯向对象 的软件开发⼈员所采⽤。设计模式是软件开发⼈员在软件开发过程中⾯临的⼀般问题的<strong>解决⽅案</strong>。这些解决⽅案是众多软件开发⼈员经过相当⻓的 ⼀段时间的试验和错误总结出来的。 </p><p>设计模式是⼀套被反复使⽤的、多数⼈知晓的、经过分类编⽬的、代码设计经验的总结。使⽤设计模式是为了重⽤代码、让代码更容易被他⼈理解、保证代码可靠性。 毫⽆疑问，设计模式于⼰于他⼈于系统都是多赢的，设计模式使代码编制真正⼯程化，设计模式是软件⼯程的基⽯，如同⼤厦的⼀块块砖⽯⼀样。项⽬中合理地运⽤设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了 ⼀个在我们周围不断重复发⽣的问题，以及该问题的核⼼解决⽅案，这也 是设计模式能被⼴泛应⽤的原因。 </p><h3 id="2-设计模式的分类"><a href="#2-设计模式的分类" class="headerlink" title="2. 设计模式的分类"></a>2. 设计模式的分类</h3><p><strong>创建型</strong>： 在创建对象的同时隐藏创建逻辑，不使⽤ new 直接实例化对象，程序在判断需要创建哪些对象时更灵活。包括⼯⼚/抽象⼯⼚/单例/ 建造者/原型模式。 </p><p><strong>结构型</strong>： 通过类和接⼝间的继承和引⽤实现创建复杂结构的对象。包 括适配器/桥接模式/过滤器/组合/装饰器/外观/享元/代理模式。 </p><p><strong>⾏为型</strong>： 通过类之间不同通信⽅式实现不同⾏为。包括责任链/命名/解 释器/迭代器/中介者/备忘录/观察者/状态/策略/模板/访问者模式</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.png"></p><h3 id="4-简单⼯⼚模式"><a href="#4-简单⼯⼚模式" class="headerlink" title="4. 简单⼯⼚模式"></a>4. 简单⼯⼚模式</h3><p>简单⼯⼚模式指由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻辑，只需提供传⼊⼯⼚的参数。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.png"></p><p>适⽤于⼯⼚类负责创建对象较少的情况，缺点是如果要增加新产品，就需 要修改⼯⼚类的判断逻辑，违背开闭原则，且产品多的话会使⼯⼚类⽐较 复杂。</p><p>Calendar 抽象类的 getInstance ⽅法，调⽤ createCalendar ⽅法根据不同 的地区参数创建不同的⽇历对象。</p><p>Spring 中的 BeanFactory 使⽤简单⼯⼚模式，根据传⼊⼀个唯⼀的标识来 获得 Bean 对象</p><h3 id="5-⼯⼚⽅法模式？"><a href="#5-⼯⼚⽅法模式？" class="headerlink" title="5. ⼯⼚⽅法模式？"></a>5. ⼯⼚⽅法模式？</h3><p>和简单⼯⼚模式中⼯⼚负责⽣产所有产品相⽐，⼯⼚⽅法模式将⽣成具体 产品的任务分发给具体的产品⼯⼚。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04.png"></p><p>也就是定义⼀个抽象⼯⼚，其定义了产品的⽣产接⼝，但不负责具体的产 品，将⽣产任务交给不同的派⽣类⼯⼚。这样不⽤通过指定类型来创建对 象了。</p><h3 id="6-抽象⼯⼚模式"><a href="#6-抽象⼯⼚模式" class="headerlink" title="6. 抽象⼯⼚模式"></a>6. 抽象⼯⼚模式</h3><p>简单⼯⼚模式和⼯⼚⽅法模式不管⼯⼚怎么拆分抽象，都只是针对⼀类产 品，如果要⽣成另⼀种产品，就⽐较难办了！ </p><p>抽象⼯⼚模式通过在 AbstarctFactory 中增加创建产品的接⼝，并在具体⼦ ⼯⼚中实现新加产品的创建，当然前提是⼦⼯⼚⽀持⽣产该产品。否则继 承的这个接⼝可以什么也不⼲</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05.png"></p><h3 id="7-单例模式"><a href="#7-单例模式" class="headerlink" title="7. 单例模式"></a>7. 单例模式</h3><h4 id="什么是单例模式"><a href="#什么是单例模式" class="headerlink" title="什么是单例模式"></a>什么是单例模式</h4><p>单例模式属于创建型模式，⼀个单例类在任何情况下都只存在⼀个实例， 构造⽅法必须是私有的、由⾃⼰创建⼀个静态变量存储实例，对外提供⼀ 个静态公有⽅法获取实例。 </p><h4 id="单例模式的优点"><a href="#单例模式的优点" class="headerlink" title="单例模式的优点"></a>单例模式的优点</h4><p>优点是内存中只有⼀个实例，减少了开销，尤其是频繁创建和销毁实例的 情况下并且可以避免对资源的多重占⽤。缺点是没有抽象层，难以扩展， 与单⼀职责原则冲突。</p><h4 id="单例模式的常⻅写法"><a href="#单例模式的常⻅写法" class="headerlink" title="单例模式的常⻅写法"></a>单例模式的常⻅写法</h4><h5 id="饿汉式，线程安全"><a href="#饿汉式，线程安全" class="headerlink" title="饿汉式，线程安全"></a>饿汉式，线程安全</h5><p>饿汉式单例模式，顾名思义，类⼀加载就创建对象，这种⽅式⽐较常⽤， 但容易产⽣垃圾对象，浪费内存空间。 </p><p>优点：线程安全，没有加锁，执⾏效率较⾼<br>缺点：不是懒加载，类加载时就初始化，浪费内存空间</p><blockquote><p>懒加载 （lazy loading）：使⽤的时候再创建对象</p></blockquote><p>饿汉式单例是如何保证线程安全的呢？它是基于类加载机制避免了多线程 的同步问题，但是如果类被不同的类加载器加载就会创建不同的实例。</p><p><strong>代码实现，以及使⽤反射破坏单例：</strong></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-软件设计原则&quot;&gt;&lt;a href=&quot;#1-软件设计原则&quot; class=&quot;headerlink&quot; title=&quot;1. 软件设计原则&quot;&gt;&lt;/a&gt;1. 软件设计原则&lt;/h3&gt;&lt;p&gt;常⽤的⾯向对象设计原则包括7个，这些原则并不是孤⽴存在的，它们相互 依赖，相互补充。&lt;/</summary>
      
    
    
    
    
    <category term="设计模式" scheme="http://ailiaa.github.io/tags/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>Redis_02</title>
    <link href="http://ailiaa.github.io/2023/03/11/redis-02/"/>
    <id>http://ailiaa.github.io/2023/03/11/redis-02/</id>
    <published>2023-03-11T09:42:04.000Z</published>
    <updated>2023-03-11T10:06:50.115Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Redis事务"><a href="#1-Redis事务" class="headerlink" title="1. Redis事务"></a>1. Redis事务</h3><h4 id="Redis-事务支持原子性吗？"><a href="#Redis-事务支持原子性吗？" class="headerlink" title="Redis 事务支持原子性吗？"></a>Redis 事务支持原子性吗？</h4><p>Redis 的事务和我们平时理解的关系型数据库的事务不同。我们知道事务具有四大特性： <strong>1. 原子性</strong>，<strong>2. 隔离性</strong>，<strong>3. 持久性</strong>，<strong>4. 一致性</strong>。</p><ol><li> <strong>原子性（Atomicity）：</strong> 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li> <strong>隔离性（Isolation）：</strong> 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li> <strong>持久性（Durability）：</strong> 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li><li> <strong>一致性（Consistency）：</strong> 执行事务前后，数据保持一致，多个事务对同一个数据读取的结果是相同的；</li></ol><p>Redis 事务在运行错误的情况下，除了执行过程中出现错误的命令外，其他命令都能正常执行。并且，Redis 事务是不支持回滚（roll back）操作的。因此，Redis 事务其实是不满足原子性的（而且不满足持久性）。</p><p><strong>Redis 事务提供了一种将多个命令请求打包的功能。然后，再按顺序执行打包的所有命令，并且不会被中途打断。</strong></p><p>除了不满足原子性之外，事务中的每条命令都会与 Redis 服务器进行网络交互，这是比较浪费资源的行为。明明一次批量执行多个命令就可以了，这种操作实在是看不懂。</p><p>因此，Redis 事务是不建议在日常开发中使用的。</p><h4 id="如何解决-Redis-事务的缺陷？"><a href="#如何解决-Redis-事务的缺陷？" class="headerlink" title="如何解决 Redis 事务的缺陷？"></a>如何解决 Redis 事务的缺陷？</h4><p>Redis 从 2.6 版本开始支持执行 Lua 脚本，它的功能和事务非常类似。我们可以利用 Lua 脚本来批量执行多条 Redis 命令，这些 Redis 命令会被提交到 Redis 服务器一次性执行完成，大幅减小了网络开销。</p><p>一段 Lua 脚本可以视作一条命令执行，一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰。</p><p>不过，如果 Lua 脚本运行时出错并中途结束，出错之后的命令是不会被执行的。并且，出错之前执行的命令是无法被撤销的，无法实现类似关系型数据库执行失败可以回滚的那种原子性效果。因此， <strong>严格来说的话，通过 Lua 脚本来批量执行 Redis 命令实际也是不完全满足原子性的。</strong></p><p>如果想要让 Lua 脚本中的命令全部执行，必须保证语句语法和命令都是对的。</p><h3 id="2-Redis-性能优化"><a href="#2-Redis-性能优化" class="headerlink" title="2. Redis 性能优化"></a>2. Redis 性能优化</h3><h4 id="Redis-bigkey"><a href="#Redis-bigkey" class="headerlink" title="Redis bigkey"></a>Redis bigkey</h4><h5 id="什么是-bigkey？"><a href="#什么是-bigkey？" class="headerlink" title="什么是 bigkey？"></a>什么是 bigkey？</h5><p>简单来说，如果一个 key 对应的 value 所占用的内存比较大，那这个 key 就可以看作是 bigkey。具体多大才算大呢？有一个不是特别精确的参考标准：string 类型的 value 超过 10 kb，复合类型的 value 包含的元素超过 5000 个（对于复合类型的 value 来说，不一定包含的元素越多，占用的内存就越多）。</p><h5 id="bigkey-有什么危害？"><a href="#bigkey-有什么危害？" class="headerlink" title="bigkey 有什么危害？"></a>bigkey 有什么危害？</h5><p>除了会消耗更多的内存空间，bigkey 对性能也会有比较大的影响。</p><p>因此，我们应该尽量避免写入 bigkey！</p><h5 id="如何发现-bigkey？"><a href="#如何发现-bigkey？" class="headerlink" title="如何发现 bigkey？"></a>如何发现 bigkey？</h5><p><strong>1、使用 Redis 自带的 <code>--bigkeys</code> 参数来查找。</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># redis-cli -p 6379 --bigkeys</span><span class="token comment"># Scanning the entire keyspace to find biggest keys as well as</span><span class="token comment"># average sizes per key type.  You can use -i 0.1 to sleep 0.1 sec</span><span class="token comment"># per 100 SCAN commands (not usually needed).</span><span class="token punctuation">[</span>00.00%<span class="token punctuation">]</span> Biggest string found so far <span class="token string">'"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20"'</span> with <span class="token number">4437</span> bytes<span class="token punctuation">[</span>00.00%<span class="token punctuation">]</span> Biggest list   found so far <span class="token string">'"my-list"'</span> with <span class="token number">17</span> items-------- summary -------Sampled <span class="token number">5</span> keys <span class="token keyword">in</span> the keyspace<span class="token operator">!</span>Total key length <span class="token keyword">in</span> bytes is <span class="token number">264</span> <span class="token punctuation">(</span>avg len <span class="token number">52.80</span><span class="token punctuation">)</span>Biggest   list found <span class="token string">'"my-list"'</span> has <span class="token number">17</span> itemsBiggest string found <span class="token string">'"ballcat:oauth:refresh_auth:f6cdb384-9a9d-4f2f-af01-dc3f28057c20"'</span> has <span class="token number">4437</span> bytes<span class="token number">1</span> lists with <span class="token number">17</span> items <span class="token punctuation">(</span><span class="token number">20.00</span>% of keys, avg size <span class="token number">17.00</span><span class="token punctuation">)</span><span class="token number">0</span> hashs with <span class="token number">0</span> fields <span class="token punctuation">(</span>00.00% of keys, avg size <span class="token number">0.00</span><span class="token punctuation">)</span><span class="token number">4</span> strings with <span class="token number">4831</span> bytes <span class="token punctuation">(</span><span class="token number">80.00</span>% of keys, avg size <span class="token number">1207.75</span><span class="token punctuation">)</span><span class="token number">0</span> streams with <span class="token number">0</span> entries <span class="token punctuation">(</span>00.00% of keys, avg size <span class="token number">0.00</span><span class="token punctuation">)</span><span class="token number">0</span> sets with <span class="token number">0</span> members <span class="token punctuation">(</span>00.00% of keys, avg size <span class="token number">0.00</span><span class="token punctuation">)</span><span class="token number">0</span> zsets with <span class="token number">0</span> members <span class="token punctuation">(</span>00.00% of keys, avg size <span class="token number">0.00</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>从这个命令的运行结果，我们可以看出：这个命令会扫描(Scan) Redis 中的所有 key ，会对 Redis 的性能有一点影响。并且，这种方式只能找出每种数据结构 top 1 bigkey（占用内存最大的 string 数据类型，包含元素最多的复合数据类型）。</p><p><strong>2、分析 RDB 文件</strong></p><p>通过分析 RDB 文件来找出 big key。这种方案的前提是你的 Redis 采用的是 RDB 持久化。</p><p>网上有现成的代码/工具可以直接拿来使用：</p><ul><li>  redis-rdb-tools：Python 语言写的用来分析 Redis 的 RDB 快照文件用的工具</li><li>  rdb_bigkeys: Go 语言写的用来分析 Redis 的 RDB 快照文件用的工具，性能更好。</li></ul><h4 id="大量-key-集中过期问题"><a href="#大量-key-集中过期问题" class="headerlink" title="大量 key 集中过期问题"></a>大量 key 集中过期问题</h4><p>我在上面提到过：对于过期 key，Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 策略。</p><p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的。这就导致客户端请求没办法被及时处理，响应速度会比较慢。</p><p>如何解决呢？下面是两种常见的方法：</p><ol><li> 给 key 设置随机过期时间。</li><li> 开启 lazy-free（惰性删除/延迟释放） 。lazy-free 特性是 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li></ol><p>个人建议不管是否开启 lazy-free，我们都尽量给 key 设置随机过期时间。</p><h4 id="使用批量操作减少网络传输"><a href="#使用批量操作减少网络传输" class="headerlink" title="使用批量操作减少网络传输"></a>使用批量操作减少网络传输</h4><p>一个 Redis 命令的执行可以简化为以下 4 步：</p><ol><li> 发送命令</li><li> 命令排队</li><li> 命令执行</li><li> 返回结果</li></ol><p>其中，第 1 步和第 4 步耗费时间之和称为 <strong>Round Trip Time (RTT,往返时间)</strong> ，也就是数据在网络上传输的时间。</p><p><strong>使用批量操作可以减少网络传输次数，进而有效减小网络开销，大幅减少 RTT。</strong></p><h5 id="原生批量操作命令"><a href="#原生批量操作命令" class="headerlink" title="原生批量操作命令"></a>原生批量操作命令</h5><p>Redis 中有一些原生支持批量操作的命令，比如：</p><ul><li>  <code>mget</code>(获取一个或多个指定 key 的值)、<code>mset</code>(设置一个或多个指定 key 的值)、</li><li>  <code>hmget</code>(获取指定哈希表中一个或者多个指定字段的值)、<code>hmset</code>(同时将一个或多个 field-value 对设置到指定哈希表中)、</li><li>  <code>sadd</code>（向指定集合添加一个或多个元素）</li><li>  ……</li></ul><p>不过，在 Redis 官方提供的分片集群解决方案 Redis Cluster 下，使用这些原生批量操作命令可能会存在一些小问题需要解决。就比如说 <code>mget</code> 无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上，<code>mget</code>可能还是需要多次网络传输，原子操作也无法保证了。不过，相较于非批量操作，还是可以节省不少网络传输次数。</p><p>整个步骤的简化版如下（通常由 Redis 客户端实现，无需我们自己再手动实现）：</p><ol><li> 找到 key 对应的所有 hash slot；</li><li> 分别向对应的 Redis 节点发起 <code>mget</code> 请求获取数据；</li><li> 等待所有请求执行结束，重新组装结果数据，保持跟入参 key 的顺序一致，然后返回结果。</li></ol><p>如果想要解决这个多次网络传输的问题，比较常用的办法是自己维护 key 与 slot 的关系。不过这样不太灵活，虽然带来了性能提升，但同样让系统复杂性提升。</p><blockquote><p>Redis Cluster 并没有使用一致性哈希，采用的是 <strong>哈希槽分区</strong> ，每一个键值对都属于一个 <strong>hash slot</strong>（哈希槽） 。当客户端发送命令请求的时候，需要先根据 key 通过上面的计算公示找到的对应的哈希槽，然后再查询哈希槽和节点的映射关系，即可找到目标 Redis 节点。</p></blockquote><h5 id="pipeline"><a href="#pipeline" class="headerlink" title="pipeline"></a>pipeline</h5><p>对于不支持批量操作的命令，我们可以利用 <strong>pipeline（流水线)</strong> 将一批 Redis 命令封装成一组，这些 Redis 命令会被一次性提交到 Redis 服务器，只需要一次网络传输。不过，需要注意控制一次批量操作的 <strong>元素个数</strong>(例如 500 以内，实际也和元素字节数有关)，避免网络传输的数据量过大。</p><p>与<code>mget</code>、<code>mset</code>等原生批量操作命令一样，pipeline 同样在 Redis Cluster 上使用会存在一些小问题。原因类似，无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。如果想要使用的话，客户端需要自己维护 key 与 slot 的关系。</p><p>原生批量操作命令和 pipeline 的是有区别的，使用的时候需要注意：</p><ul><li>  原生批量操作命令是原子操作，pipeline 是非原子操作；</li><li>  pipeline 可以打包不同的命令，原生批量操作命令不可以；</li><li>  原生批量操作命令是 Redis 服务端支持实现的，而 pipeline 需要服务端和客户端的共同实现。</li></ul><p>另外，pipeline 不适用于执行顺序有依赖关系的一批命令。就比如说，你需要将前一个命令的结果给后续的命令使用，pipeline 就没办法满足你的需求了。对于这种需求，我们可以使用 <strong>Lua 脚本</strong> 。</p><h5 id="Lua-脚本"><a href="#Lua-脚本" class="headerlink" title="Lua 脚本"></a>Lua 脚本</h5><p>Lua 脚本同样支持批量操作多条命令。一段 Lua 脚本可以视作一条命令执行，可以看作是原子操作。一段 Lua 脚本执行过程中不会有其他脚本或 Redis 命令同时执行，保证了操作不会被其他指令插入或打扰，这是 pipeline 所不具备的。</p><p>并且，Lua 脚本中支持一些简单的逻辑处理比如使用命令读取值并在 Lua 脚本中进行处理，这同样是 pipeline 所不具备的。</p><p>不过， Redis Cluster 下 Lua 脚本的原子操作也无法保证了，原因同样是无法保证所有的 key 都在同一个 <strong>hash slot</strong>（哈希槽）上。</p><h3 id="3-Redis-生产问题"><a href="#3-Redis-生产问题" class="headerlink" title="3. Redis 生产问题"></a>3. Redis 生产问题</h3><h4 id="缓存穿透"><a href="#缓存穿透" class="headerlink" title="缓存穿透"></a>缓存穿透</h4><h5 id="什么是缓存穿透？"><a href="#什么是缓存穿透？" class="headerlink" title="什么是缓存穿透？"></a>什么是缓存穿透？</h5><p>缓存穿透说简单点就是大量请求的 key 是不合理的，<strong>根本不存在于缓存中，也不存在于数据库中</strong> 。这就导致这些请求直接到了数据库上，根本没有经过缓存这一层，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><img src="/images/image_redis/04.png"></p><p>举个例子：某个黑客故意制造一些非法的 key 发起大量请求，导致大量请求落到数据库，结果数据库上也没有查到对应的数据。也就是说这些请求最终都落到了数据库上，对数据库造成了巨大的压力。</p><h5 id="有哪些解决办法？"><a href="#有哪些解决办法？" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h5><p>最基本的就是首先做好参数校验，一些不合法的参数请求直接抛出异常信息返回给客户端。比如查询的数据库 id 不能小于 0、传入的邮箱格式不对的时候直接返回错误消息给客户端等等。</p><p><strong>1）缓存无效 key</strong></p><p>如果缓存和数据库都查不到某个 key 的数据就写一个到 Redis 中去并设置过期时间，具体命令如下： <code>SET key value EX 10086</code> 。这种方式可以解决请求的 key 变化不频繁的情况，如果黑客恶意攻击，每次构建不同的请求 key，会导致 Redis 中缓存大量无效的 key 。很明显，这种方案并不能从根本上解决此问题。如果非要用这种方式来解决穿透问题的话，尽量将无效的 key 的过期时间设置短一点比如 1 分钟。</p><p>如果用 Java 代码展示的话，差不多是下面这样的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getObjectInclNullById</span><span class="token punctuation">(</span><span class="token class-name">Integer</span> id<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 从缓存中获取数据</span>    <span class="token class-name">Object</span> cacheValue <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>id<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// 缓存为空</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>cacheValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// 从数据库中获取</span>        <span class="token class-name">Object</span> storageValue <span class="token operator">=</span> storage<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 缓存空对象</span>        cache<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> storageValue<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 如果存储数据为空，需要设置一个过期时间(300秒)</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>storageValue <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 必须设置过期时间，否则有被攻击的风险</span>            cache<span class="token punctuation">.</span><span class="token function">expire</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token number">60</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> storageValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> cacheValue<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>2）布隆过滤器</strong></p><p>布隆过滤器是一个非常神奇的数据结构，通过它我们可以非常方便地判断一个给定数据是否存在于海量数据中</p><p>具体是这样做的：把所有可能存在的请求的值都存放在布隆过滤器中，当用户请求过来，先判断用户发来的请求的值是否存在于布隆过滤器中。不存在的话，直接返回请求参数错误信息给客户端，存在的话才会走下面的流程。</p><p>加入布隆过滤器之后的缓存处理流程图如下。</p><p><img src="/images/image_redis/05.png"></p><p>但是，需要注意的是布隆过滤器可能会存在误判的情况。总结来说就是：&nbsp;<strong>布隆过滤器说某个元素存在，小概率会误判。布隆过滤器说某个元素不在，那么这个元素一定不在。</strong></p><h4 id="缓存击穿"><a href="#缓存击穿" class="headerlink" title="缓存击穿"></a>缓存击穿</h4><h5 id="什么是缓存击穿？"><a href="#什么是缓存击穿？" class="headerlink" title="什么是缓存击穿？"></a>什么是缓存击穿？</h5><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong> 。这就可能会导致瞬时大量的请求直接打到了数据库上，对数据库造成了巨大的压力，可能直接就被这么多请求弄宕机了。</p><p><img src="/images/image_redis/06.png"></p><p>举个例子 ：秒杀进行过程中，缓存中的某个秒杀商品的数据突然过期，这就导致瞬时大量对该商品的请求直接落到数据库上，对数据库造成了巨大的压力。</p><h5 id="有哪些解决办法？-1"><a href="#有哪些解决办法？-1" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h5><ul><li>  设置热点数据永不过期或者过期时间比较长。</li><li>  针对热点数据提前预热，将其存入缓存中并设置合理的过期时间比如秒杀场景下的数据在秒杀结束之前不过期。</li><li>  请求数据库写数据到缓存之前，先获取互斥锁，保证只有一个请求会落到数据库上，减少数据库的压力。</li></ul><h5 id="缓存穿透和缓存击穿的区别"><a href="#缓存穿透和缓存击穿的区别" class="headerlink" title="缓存穿透和缓存击穿的区别"></a>缓存穿透和缓存击穿的区别</h5><p>缓存穿透中，请求的 key 既不存在于缓存中，也不存在于数据库中。</p><p>缓存击穿中，请求的 key 对应的是 <strong>热点数据</strong> ，该数据 <strong>存在于数据库中，但不存在于缓存中（通常是因为缓存中的那份数据已经过期）</strong></p><h4 id="缓存雪崩"><a href="#缓存雪崩" class="headerlink" title="缓存雪崩"></a>缓存雪崩</h4><h5 id="什么是缓存雪崩？"><a href="#什么是缓存雪崩？" class="headerlink" title="什么是缓存雪崩？"></a>什么是缓存雪崩？</h5><p>缓存雪崩描述的是这样一个场景：<strong>缓存在同一时间大面积的失效，导致大量的请求都直接落到了数据库上，对数据库造成了巨大的压力。</strong> 这就好比雪崩一样，摧枯拉朽之势，数据库的压力可想而知，可能直接就被这么多请求弄宕机了。</p><p>另外，缓存服务宕机也会导致缓存雪崩现象，导致所有的请求都落到了数据库上。</p><p><img src="/images/image_redis/07.png"></p><p>举个例子 ：数据库中的大量数据在同一时间过期，这个时候突然有大量的请求需要访问这些过期的数据。这就导致大量的请求直接落到数据库上，对数据库造成了巨大的压力。</p><h5 id="有哪些解决办法？-2"><a href="#有哪些解决办法？-2" class="headerlink" title="有哪些解决办法？"></a>有哪些解决办法？</h5><p><strong>针对 Redis 服务不可用的情况：</strong></p><ol><li> 采用 Redis 集群，避免单机出现问题整个缓存服务都没办法使用。</li><li> 限流，避免同时处理大量的请求。</li></ol><p><strong>针对热点缓存失效的情况：</strong></p><ol><li> 设置不同的失效时间比如随机设置缓存的失效时间。</li><li> 缓存永不失效（不太推荐，实用性太差）。</li><li> 设置二级缓存。</li></ol><h5 id="缓存雪崩和缓存击穿的区别"><a href="#缓存雪崩和缓存击穿的区别" class="headerlink" title="缓存雪崩和缓存击穿的区别"></a>缓存雪崩和缓存击穿的区别</h5><p>缓存雪崩和缓存击穿比较像，但缓存雪崩导致的原因是缓存中的大量或者所有数据失效，缓存击穿导致的原因主要是某个热点数据不存在与缓存中（通常是因为缓存中的那份数据已经过期）。</p><h4 id="如何保证缓存和数据库数据的一致性？"><a href="#如何保证缓存和数据库数据的一致性？" class="headerlink" title="如何保证缓存和数据库数据的一致性？"></a>如何保证缓存和数据库数据的一致性？</h4><p><strong>Cache Aside Pattern（旁路缓存模式）</strong></p><p>Cache Aside Pattern 中遇到写请求是这样的：更新 DB，然后直接删除 cache 。</p><p>如果更新数据库成功，而删除缓存这一步失败的情况的话，简单说两个解决方案：</p><ol><li> <strong>缓存失效时间变短（不推荐，治标不治本）</strong> ：我们让缓存数据的过期时间变短，这样的话缓存就会从数据库中加载数据。另外，这种解决办法对于先操作缓存后操作数据库的场景不适用。</li><li> <strong>增加 cache 更新重试机制（常用）</strong>： 如果 cache 服务当前不可用导致缓存删除失败的话，我们就隔一段时间进行重试，重试次数可以自己定。如果多次重试还是失败的话，我们可以把当前更新失败的 key 存入队列中，等缓存服务可用之后，再将缓存中对应的 key 删除即可。</li></ol><h3 id="4-Redis-集群"><a href="#4-Redis-集群" class="headerlink" title="4. Redis 集群"></a>4. Redis 集群</h3><p><strong>Redis Sentinel</strong> ：</p><ol><li> 什么是 Sentinel？ 有什么用？</li><li> Sentinel 如何检测节点是否下线？主观下线与客观下线的区别?</li><li> Sentinel 是如何实现故障转移的？</li><li> 为什么建议部署多个 sentinel 节点（哨兵集群）？</li><li> Sentinel 如何选择出新的 master（选举机制）?</li><li> 如何从 Sentinel 集群中选择出 Leader ？</li><li> Sentinel 可以防止脑裂吗？</li></ol><p><strong>Redis Cluster</strong> ：</p><ol><li> 为什么需要 Redis Cluster？解决了什么问题？有什么优势？</li><li> Redis Cluster 是如何分片的？</li><li> 为什么 Redis Cluster 的哈希槽是 16384 个?</li><li> 如何确定给定 key 的应该分布到哪个哈希槽中？</li><li> Redis Cluster 支持重新分配哈希槽吗？</li><li> Redis Cluster 扩容缩容期间可以提供服务吗？</li><li> Redis Cluster 中的节点是怎么进行通信的？</li></ol><h3 id="5-Redis-使用规范"><a href="#5-Redis-使用规范" class="headerlink" title="5. Redis 使用规范"></a>5. Redis 使用规范</h3><p>实际使用 Redis 的过程中，我们尽量要准守一些常见的规范，比如：</p><ol><li> 使用连接池：避免频繁创建关闭客户端连接。</li><li> 尽量不使用 O(n)指令，使用 O(N)命令时要关注 N 的数量 ：例如 <code>hgetall</code>、<code>lrange</code>、<code>smembers</code>、<code>zrange</code>、<code>sinter</code> 、<code>sunion</code> 命令并非不能使用，但是需要明确 N 的值。有遍历的需求可以使用 <code>hscan</code>、<code>sscan</code>、<code>zscan</code> 代替。</li><li> 使用批量操作减少网络传输 ：原生批量操作命令（比如 <code>mget</code>、<code>mset</code>等等）、pipeline、Lua 脚本。</li><li> 尽量不适用 Redis 事务：Redis 事务实现的功能比较鸡肋，可以使用 Lua 脚本代替。</li><li> 禁止长时间开启 monitor：对性能影响比较大。</li><li> 控制 key 的生命周期：避免 Redis 中存放了太多不经常被访问的数据。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Redis事务&quot;&gt;&lt;a href=&quot;#1-Redis事务&quot; class=&quot;headerlink&quot; title=&quot;1. Redis事务&quot;&gt;&lt;/a&gt;1. Redis事务&lt;/h3&gt;&lt;h4 id=&quot;Redis-事务支持原子性吗？&quot;&gt;&lt;a href=&quot;#Redis-事务</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="NoSQL" scheme="http://ailiaa.github.io/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>Redis_01</title>
    <link href="http://ailiaa.github.io/2023/03/11/redis-01/"/>
    <id>http://ailiaa.github.io/2023/03/11/redis-01/</id>
    <published>2023-03-11T09:24:42.000Z</published>
    <updated>2023-03-11T09:58:30.952Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-Redis-基础"><a href="#1-Redis-基础" class="headerlink" title="1. Redis 基础"></a>1. Redis 基础</h3><h4 id="什么是-Redis？"><a href="#什么是-Redis？" class="headerlink" title="什么是 Redis？"></a>什么是 Redis？</h4><p>Redis 是一个基于 C 语言开发的开源数据库（BSD 许可），与传统数据库不同的是 Redis 的数据是存在内存中的（内存数据库），读写速度非常快，被广泛应用于缓存方向。并且，Redis 存储的是 KV 键值对数据。</p><p>为了满足不同的业务场景，Redis 内置了多种数据类型实现（比如 String、Hash、Sorted Set、Bitmap）。并且，Redis 还支持事务 、持久化、Lua 脚本、多种开箱即用的集群方案（Redis Sentinel、Redis Cluster）。</p><h4 id="Redis-为什么这么快？"><a href="#Redis-为什么这么快？" class="headerlink" title="Redis 为什么这么快？"></a>Redis 为什么这么快？</h4><p>Redis 内部做了非常多的性能优化，比较重要的主要有下面 3 点：</p><ul><li>  Redis 基于内存，内存的访问速度是磁盘的上千倍；</li><li>  Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型，主要是单线程事件循环和 IO 多路复用（Redis 线程模式后面会详细介绍到）；</li><li>  Redis 内置了多种优化过后的数据结构实现，性能非常高。</li></ul><h4 id="分布式缓存常见的技术选型方案"><a href="#分布式缓存常见的技术选型方案" class="headerlink" title="分布式缓存常见的技术选型方案"></a>分布式缓存常见的技术选型方案</h4><p>分布式缓存的话，比较老牌同时也是使用的比较多的还是 <strong>Memcached</strong> 和 <strong>Redis</strong>。不过，现在基本没有看过还有项目使用 <strong>Memcached</strong> 来做缓存，都是直接用 <strong>Redis</strong>。</p><p>另外，腾讯也开源了一款类似于 Redis 的分布式高性能 KV 存储数据库，名为 Tendis</p><h4 id="Redis-和-Memcached-的区别和共同点"><a href="#Redis-和-Memcached-的区别和共同点" class="headerlink" title="Redis 和 Memcached 的区别和共同点"></a>Redis 和 Memcached 的区别和共同点</h4><p><strong>共同点</strong> ：</p><ol><li> 都是基于内存的数据库，一般都用来当做缓存使用。</li><li> 都有过期策略。</li><li> 两者的性能都非常高。</li></ol><p><strong>区别</strong> ：</p><ol><li> <strong>Redis 支持更丰富的数据类型（支持更复杂的应用场景）</strong>。Redis 不仅仅支持简单的 k/v 类型的数据，同时还提供 list，set，zset，hash 等数据结构的存储。Memcached 只支持最简单的 k/v 数据类型。</li><li> <strong>Redis 支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而 Memcached 把数据全部存在内存之中。</strong></li><li> <strong>Redis 有灾难恢复机制。</strong> 因为可以把缓存中的数据持久化到磁盘上。</li><li> <strong>Redis 在服务器内存使用完之后，可以将不用的数据放到磁盘上。但是，Memcached 在服务器内存使用完之后，就会直接报异常。</strong></li><li> <strong>Memcached 没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 Redis 目前是原生支持 cluster 模式的。</strong></li><li> <strong>Memcached 是多线程，非阻塞 IO 复用的网络模型；Redis 使用单线程的多路 IO 复用模型。</strong> （Redis 6.0 引入了多线程 IO ）</li><li> <strong>Redis 支持发布订阅模型、Lua 脚本、事务等功能，而 Memcached 不支持。并且，Redis 支持更多的编程语言。</strong></li><li> <strong>Memcached 过期数据的删除策略只用了惰性删除，而 Redis 同时使用了惰性删除与定期删除。</strong></li></ol><h4 id="为什么要用-Redis-为什么要用缓存"><a href="#为什么要用-Redis-为什么要用缓存" class="headerlink" title="为什么要用 Redis/为什么要用缓存"></a>为什么要用 Redis/为什么要用缓存</h4><p>下面我们主要从“高性能”和“高并发”这两点来回答这个问题。</p><p><strong>高性能</strong></p><p>假如用户第一次访问数据库中的某些数据的话，这个过程是比较慢，毕竟是从硬盘中读取的。但是，如果说，用户访问的数据属于高频数据并且不会经常改变的话，那么我们就可以很放心地将该用户访问的数据存在缓存中。</p><p><strong>这样有什么好处呢？</strong> 那就是保证用户下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。</p><p><strong>高并发</strong></p><p>一般像 MySQL 这类的数据库的 QPS 大概都在 1w 左右（4 核 8g） ，但是使用 Redis 缓存之后很容易达到 10w+，甚至最高能达到 30w+（就单机 Redis 的情况，Redis 集群的话会更高）。</p><blockquote><p>QPS（Query Per Second）：服务器每秒可以执行的查询次数；</p></blockquote><p>由此可见，直接操作缓存能够承受的数据库请求数量是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。进而，我们也就提高了系统整体的并发。</p><h4 id="Redis-除了做缓存，还能做什么？"><a href="#Redis-除了做缓存，还能做什么？" class="headerlink" title="Redis 除了做缓存，还能做什么？"></a>Redis 除了做缓存，还能做什么？</h4><ul><li>  <strong>分布式锁</strong> ： 通过 Redis 来做分布式锁是一种比较常见的方式。通常情况下，我们都是基于 Redisson 来实现分布式锁。</li><li>  <strong>限流</strong> ：一般是通过 Redis + Lua 脚本的方式来实现限流。</li><li>  <strong>消息队列</strong> ：Redis 自带的 list 数据结构可以作为一个简单的队列使用。Redis 5.0 中增加的 Stream 类型的数据结构更加适合用来做消息队列。它比较类似于 Kafka，有主题和消费组的概念，支持消息持久化以及 ACK 机制。</li><li>  <strong>复杂业务场景</strong> ：通过 Redis 以及 Redis 扩展（比如 Redisson）提供的数据结构，我们可以很方便地完成很多复杂的业务场景比如通过 bitmap 统计活跃用户、通过 sorted set 维护排行榜。</li></ul><h4 id="Redis-可以做消息队列么？"><a href="#Redis-可以做消息队列么？" class="headerlink" title="Redis 可以做消息队列么？"></a>Redis 可以做消息队列么？</h4><p>Redis 5.0 新增加的一个数据结构 <code>Stream</code> 可以用来做消息队列，<code>Stream</code> 支持：</p><ul><li>  发布 / 订阅模式</li><li>  按照消费者组进行消费</li><li>  消息持久化（ RDB 和 AOF）</li></ul><p>不过，和专业的消息队列相比，还是有很多欠缺的地方比如消息丢失和堆积问题不好解决。因此，我们通常建议是不使用 Redis 来做消息队列的，你完全可以选择市面上比较成熟的一些消息队列比如 RocketMQ、Kafka。</p><h4 id="如何基于-Redis-实现分布式锁？"><a href="#如何基于-Redis-实现分布式锁？" class="headerlink" title="如何基于 Redis 实现分布式锁？"></a>如何基于 Redis 实现分布式锁？</h4><p>关于 Redis 实现分布式锁的详细介绍，可以看这篇文章：<a href="https://javaguide.cn/distributed-system/distributed-lock.html">分布式锁详解</a></p><h3 id="2-Redis-数据结构"><a href="#2-Redis-数据结构" class="headerlink" title="2. Redis 数据结构"></a>2. Redis 数据结构</h3><h4 id="Redis-常用的数据结构"><a href="#Redis-常用的数据结构" class="headerlink" title="Redis 常用的数据结构"></a>Redis 常用的数据结构</h4><ul><li>  <strong>5 种基础数据结构</strong> ：String（字符串）、List（列表）、Set（集合）、Hash（散列）、Zset（有序集合）。</li><li>  <strong>3 种特殊数据结构</strong> ：HyperLogLogs（基数统计）、Bitmap （位存储）、Geospatial (地理位置)。</li></ul><h4 id="String-的应用场景有哪些？"><a href="#String-的应用场景有哪些？" class="headerlink" title="String 的应用场景有哪些？"></a>String 的应用场景有哪些？</h4><ul><li>  常规数据（比如 session、token、、序列化后的对象）的缓存；</li><li>  计数比如用户单位时间的请求数（简单限流可以用到）、页面单位时间的访问数；</li><li>  分布式锁(利用 <code>SETNX key value</code> 命令可以实现一个最简易的分布式锁)；</li></ul><h4 id="String-还是-Hash-存储对象数据更好呢？"><a href="#String-还是-Hash-存储对象数据更好呢？" class="headerlink" title="String 还是 Hash 存储对象数据更好呢？"></a>String 还是 Hash 存储对象数据更好呢？</h4><ul><li>  String 存储的是序列化后的对象数据，存放的是整个对象。Hash 是对对象的每个字段单独存储，可以获取部分字段的信息，也可以修改或者添加部分字段，节省网络流量。如果对象中某些字段需要经常变动或者经常需要单独查询对象中的个别字段信息，Hash 就非常适合。</li><li>  String 存储相对来说更加节省内存，缓存相同数量的对象数据，String 消耗的内存约是 Hash 的一半。并且，存储具有多层嵌套的对象时也方便很多。如果系统对性能和资源消耗非常敏感的话，String 就非常适合。</li></ul><p>在绝大部分情况，我们建议使用 String 来存储对象数据即可！</p><h4 id="String-的底层实现"><a href="#String-的底层实现" class="headerlink" title="String 的底层实现"></a>String 的底层实现</h4><p>Redis 是基于 C 语言编写的，但 Redis 的 String 类型的底层实现并不是 C 语言中的字符串（即以空字符 <code>\0</code> 结尾的字符数组），而是自己编写了 SDS（Simple Dynamic String，简单动态字符串） 来作为底层实现。</p><p>SDS 最早是 Redis 作者为日常 C 语言开发而设计的 C 字符串，后来被应用到了 Redis 上，并经过了大量的修改完善以适合高性能操作。</p><p>Redis7.0 的 SDS 的部分源码如下（<a href="https://github.com/redis/redis/blob/7.0/src/sds.h%EF%BC%89%EF%BC%9A">https://github.com/redis/redis/blob/7.0/src/sds.h）：</a></p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token comment">/* Note: sdshdr5 is never used, we just access the flags byte directly. * However is here to document the layout of type 5 SDS strings. */</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr5</span> <span class="token punctuation">{</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, and 5 msb of string length */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr8</span> <span class="token punctuation">{</span>    <span class="token class-name">uint8_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>    <span class="token class-name">uint8_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr16</span> <span class="token punctuation">{</span>    <span class="token class-name">uint16_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>    <span class="token class-name">uint16_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr32</span> <span class="token punctuation">{</span>    <span class="token class-name">uint32_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>    <span class="token class-name">uint32_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token keyword">struct</span> <span class="token keyword">__attribute__</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>__packed__<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token class-name">sdshdr64</span> <span class="token punctuation">{</span>    <span class="token class-name">uint64_t</span> len<span class="token punctuation">;</span> <span class="token comment">/* used */</span>    <span class="token class-name">uint64_t</span> alloc<span class="token punctuation">;</span> <span class="token comment">/* excluding the header and null terminator */</span>    <span class="token keyword">unsigned</span> <span class="token keyword">char</span> flags<span class="token punctuation">;</span> <span class="token comment">/* 3 lsb of type, 5 unused bits */</span>    <span class="token keyword">char</span> buf<span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>通过源码可以看出，SDS 共有五种实现方式 SDS_TYPE_5（并未用到）、SDS_TYPE_8、SDS_TYPE_16、SDS_TYPE_32、SDS_TYPE_64，其中只有后四种实际用到。Redis 会根据初始化的长度决定使用哪种类型，从而减少内存的使用。</p><p>对于后四种实现都包含了下面这 4 个属性：</p><ul><li>  <code>len</code> ：字符串的长度也就是已经使用的字节数</li><li>  <code>alloc</code>：总共可用的字符空间大小，alloc-len 就是 SDS 剩余的空间大小</li><li>  <code>buf[]</code> ：实际存储字符串的数组</li><li>  <code>flags</code> ：低三位保存类型标志</li></ul><p>SDS 相比于 C 语言中的字符串有如下提升：</p><ol><li> <strong>可以避免缓冲区溢出</strong> ：C 语言中的字符串被修改（比如拼接）时，一旦没有分配足够长度的内存空间，就会造成缓冲区溢出。SDS 被修改时，会先根据 len 属性检查空间大小是否满足要求，如果不满足，则先扩展至所需大小再进行修改操作。</li><li> <strong>获取字符串长度的复杂度较低</strong> ： C 语言中的字符串的长度通常是经过遍历计数来实现的，时间复杂度为 O(n)。SDS 的长度获取直接读取 len 属性即可，时间复杂度为 O(1)。</li><li> <strong>减少内存分配次数</strong> ： 为了避免修改（增加/减少）字符串时，每次都需要重新分配内存（C 语言的字符串是这样的），SDS 实现了空间预分配和惰性空间释放两种优化策略。当 SDS 需要增加字符串时，Redis 会为 SDS 分配好内存，并且根据特定的算法分配多余的内存，这样可以减少连续执行字符串增长操作所需的内存重分配次数。当 SDS 需要减少字符串时，这部分内存不会立即被回收，会被记录下来，等待后续使用（支持手动释放，有对应的 API）。</li><li> <strong>二进制安全</strong> ：C 语言中的字符串以空字符 <code>\0</code> 作为字符串结束的标识，这存在一些问题，像一些二进制文件（比如图片、视频、音频）就可能包括空字符，C 字符串无法正确保存。SDS 使用 len 属性判断字符串是否结束，不存在这个问题。</li></ol><h4 id="购物车信息用-String-还是-Hash-存储更好"><a href="#购物车信息用-String-还是-Hash-存储更好" class="headerlink" title="购物车信息用 String 还是 Hash 存储更好"></a>购物车信息用 String 还是 Hash 存储更好</h4><p>由于购物车中的商品频繁修改和变动，购物车信息建议使用 Hash 存储：</p><ul><li>  用户 id 为 key</li><li>  商品 id 为 field，商品数量为 value<br><img src="/images/image_redis/01.png"></li></ul><p>用户购物车信息的维护具体操作</p><ul><li>  用户添加商品就是往 Hash 里面增加新的 field 与 value；</li><li>  查询购物车信息就是遍历对应的 Hash；</li><li>  更改商品数量直接修改对应的 value 值（直接 set 或者做运算皆可）；</li><li>  删除商品就是删除 Hash 中对应的 field；</li><li>  清空购物车直接删除对应的 key 即可。</li></ul><p>这里只是以业务比较简单的购物车场景举例，实际电商场景下，field 只保存一个商品 id 是没办法满足需求的。</p><h4 id="使用-Redis-实现一个排行榜"><a href="#使用-Redis-实现一个排行榜" class="headerlink" title="使用 Redis 实现一个排行榜"></a>使用 Redis 实现一个排行榜</h4><p>Redis 中有一个叫做 <code>sorted set</code> 的数据结构经常被用在各种排行榜的场景，比如直播间送礼物的排行榜、朋友圈的微信步数排行榜、王者荣耀中的段位排行榜、话题热度排行榜等等。</p><p>相关的一些 Redis 命令: <code>ZRANGE</code> (从小到大排序) 、 <code>ZREVRANGE</code> （从大到小排序）、<code>ZREVRANK</code> (指定元素排名)。</p><h4 id="使用-Set-实现抽奖系统用到的命令"><a href="#使用-Set-实现抽奖系统用到的命令" class="headerlink" title="使用 Set 实现抽奖系统用到的命令"></a>使用 Set 实现抽奖系统用到的命令</h4><ul><li>  <code>SPOP key count</code> ： 随机移除并获取指定集合中一个或多个元素，适合不允许重复中奖的场景。</li><li>  <code>SRANDMEMBER key count</code> : 随机获取指定集合中指定数量的元素，适合允许重复中奖的场景。</li></ul><h4 id="使用-Bitmap-统计活跃用户怎"><a href="#使用-Bitmap-统计活跃用户怎" class="headerlink" title="使用 Bitmap 统计活跃用户怎"></a>使用 Bitmap 统计活跃用户怎</h4><p>使用日期（精确到天）作为 key，然后用户 ID 为 offset，如果当日活跃过就设置为 1。</p><p>初始化数据：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> SETBIT <span class="token number">20210308</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token operator">&gt;</span> SETBIT <span class="token number">20210308</span> <span class="token number">2</span> <span class="token number">1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span class="token operator">&gt;</span> SETBIT <span class="token number">20210309</span> <span class="token number">1</span> <span class="token number">1</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>统计 20210308~20210309 总活跃用户数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> BITOP and desk1 <span class="token number">20210308</span> <span class="token number">20210309</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">&gt;</span> BITCOUNT desk1<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>统计 20210308~20210309 在线活跃用户数:</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> BITOP or desk2 <span class="token number">20210308</span> <span class="token number">20210309</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">&gt;</span> BITCOUNT desk2<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="3-Redis-线程模型"><a href="#3-Redis-线程模型" class="headerlink" title="3. Redis 线程模型"></a>3. Redis 线程模型</h3><p>对于读写命令来说，Redis 一直是单线程模型。不过，在 Redis 4.0 版本之后引入了多线程来执行一些大键值对的异步删除操作， Redis 6.0 版本之后引入了多线程来处理网络请求（提高网络 IO 读写性能）。</p><h4 id="Redis-单线程模型"><a href="#Redis-单线程模型" class="headerlink" title="Redis 单线程模型"></a>Redis 单线程模型</h4><p><strong>Redis 基于 Reactor 模式设计开发了一套高效的事件处理模型</strong> （Netty 的线程模型也基于 Reactor 模式，Reactor 模式不愧是高性能 IO 的基石），这套事件处理模型对应的是 Redis 中的文件事件处理器（file event handler）。由于文件事件处理器（file event handler）是单线程方式运行的，所以我们一般都说 Redis 是单线程模型。</p><blockquote><p>Redis 基于 Reactor 模式开发了自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）。</p><ul><li>  文件事件处理器使用 I/O 多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事件处理器。</li><li>  当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关 闭（close）等操作时，与操作相对应的文件事件就会产生，这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件。</li></ul><p><strong>虽然文件事件处理器以单线程方式运行，但通过使用 I/O 多路复用程序来监听多个套接字</strong>，文件事件处理器既实现了高性能的网络通信模型，又可以很好地与 Redis 服务器中其他同样以单线程方式运行的模块进行对接，这保持了 Redis 内部单线程设计的简单性。</p></blockquote><p><strong>既然是单线程，那怎么监听大量的客户端连接？</strong></p><p>Redis 通过 <strong>IO 多路复用程序</strong> 来监听来自客户端的大量连接（或者说是监听多个 socket），它会将感兴趣的事件及类型（读、写）注册到内核中并监听每个事件是否发生。</p><p>这样的好处非常明显： <strong>I/O 多路复用技术的使用让 Redis 不需要额外创建多余的线程来监听客户端的大量连接，降低了资源的消耗</strong>（和 NIO 中的 <code>Selector</code> 组件很像）。</p><p>文件事件处理器（file event handler）主要是包含 4 个部分：</p><ul><li>  多个 socket（客户端连接）</li><li>  IO 多路复用程序（支持多个客户端连接的关键）</li><li>  文件事件分派器（将 socket 关联到相应的事件处理器）</li><li>  事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）</li></ul><p><img src="/images/image_redis/02.png"></p><h4 id="Redis6-0-之前为什么不使用多线程？"><a href="#Redis6-0-之前为什么不使用多线程？" class="headerlink" title="Redis6.0 之前为什么不使用多线程？"></a>Redis6.0 之前为什么不使用多线程？</h4><p>虽然说 Redis 是单线程模型，但是，实际上，<strong>Redis 在 4.0 之后的版本中就已经加入了对多线程的支持。</strong></p><p>不过，Redis 4.0 增加的多线程主要是针对一些大键值对的删除操作的命令，使用这些命令就会使用主线程之外的其他线程来“异步处理”。</p><p>为此，Redis 4.0 之后新增了<code>UNLINK</code>（可以看作是 <code>DEL</code> 的异步版本）、<code>FLUSHALL ASYNC</code>（清空所有数据库的所有 key，不仅仅是当前 <code>SELECT</code> 的数据库）、<code>FLUSHDB ASYNC</code>（清空当前 <code>SELECT</code> 数据库中的所有 key）等异步命令。</p><p>大体上来说，Redis 6.0 之前主要还是单线程处理。</p><p><strong>那 Redis6.0 之前为什么不使用多线程？</strong> 我觉得主要原因有 3 点：</p><ul><li>  单线程编程容易并且更容易维护；</li><li>  Redis 的性能瓶颈不在 CPU ，主要在内存和网络；</li><li>  多线程就会存在死锁、线程上下文切换等问题，甚至会影响性能。</li></ul><h4 id="Redis6-0-之后为何引入了多线程？"><a href="#Redis6-0-之后为何引入了多线程？" class="headerlink" title="Redis6.0 之后为何引入了多线程？"></a>Redis6.0 之后为何引入了多线程？</h4><p><strong>Redis6.0 引入多线程主要是为了提高网络 IO 读写性能</strong>，因为这个算是 Redis 中的一个性能瓶颈（Redis 的瓶颈主要受限于内存和网络）。</p><p>虽然，Redis6.0 引入了多线程，但是 Redis 的多线程只是在网络数据的读写这类耗时操作上使用了，执行命令仍然是单线程顺序执行。因此，你也不需要担心线程安全问题。</p><h3 id="4-Redis-内存管理"><a href="#4-Redis-内存管理" class="headerlink" title="4. Redis 内存管理"></a>4. Redis 内存管理</h3><h4 id="Redis-给缓存数据设置过期时间"><a href="#Redis-给缓存数据设置过期时间" class="headerlink" title="Redis 给缓存数据设置过期时间"></a>Redis 给缓存数据设置过期时间</h4><p>一般情况下，我们设置保存的缓存数据的时候都会设置一个过期时间。为什么呢？</p><p>因为内存是有限的，如果缓存中的所有数据都是一直保存的话，分分钟直接 Out of memory。</p><p>Redis 自带了给缓存数据设置过期时间的功能，比如：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> expire key <span class="token number">60</span> <span class="token comment"># 数据在 60s 后过期</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> setex key <span class="token number">60</span> value <span class="token comment"># 数据在 60s 后过期 (setex:[set] + [ex]pire)</span>OK<span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> ttl key <span class="token comment"># 查看数据还有多久过期</span><span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">56</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注意：<strong>Redis 中除了字符串类型有自己独有设置过期时间的命令 <code>setex</code> 外，其他方法都需要依靠 <code>expire</code> 命令来设置过期时间 。另外， <code>persist</code> 命令可以移除一个键的过期时间。</strong></p><p><strong>过期时间除了有助于缓解内存的消耗，还有什么其他用么？</strong></p><p>很多时候，我们的业务场景就是需要某个数据只在某一时间段内存在，比如我们的短信验证码可能只在 1 分钟内有效，用户登录的 token 可能只在 1 天内有效。</p><p>如果使用传统的数据库来处理的话，一般都是自己判断过期，这样更麻烦并且性能要差很多。</p><h4 id="Redis-是如何判断数据是否过期"><a href="#Redis-是如何判断数据是否过期" class="headerlink" title="Redis 是如何判断数据是否过期"></a>Redis 是如何判断数据是否过期</h4><p>Redis 通过一个叫做过期字典（可以看作是 hash 表）来保存数据过期的时间。过期字典的键指向 Redis 数据库中的某个 key(键)，过期字典的值是一个 long long 类型的整数，这个整数保存了 key 所指向的数据库键的过期时间（毫秒精度的 UNIX 时间戳）。</p><p>过期字典是存储在 redisDb 这个结构里的：</p><pre class="line-numbers language-c" data-language="c"><code class="language-c"><span class="token keyword">typedef</span> <span class="token keyword">struct</span> <span class="token class-name">redisDb</span> <span class="token punctuation">{</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>    dict <span class="token operator">*</span>dict<span class="token punctuation">;</span>     <span class="token comment">//数据库键空间,保存着数据库中所有键值对</span>    dict <span class="token operator">*</span>expires   <span class="token comment">// 过期字典,保存着键的过期时间</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span> redisDb<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="过期的数据的删除策略"><a href="#过期的数据的删除策略" class="headerlink" title="过期的数据的删除策略"></a>过期的数据的删除策略</h4><p>如果假设你设置了一批 key 只能存活 1 分钟，那么 1 分钟后，Redis 是怎么对这批 key 进行删除的呢？</p><p>常用的过期数据的删除策略就两个（重要！自己造缓存轮子的时候需要格外考虑的东西）：</p><ol><li> <strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li> <strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性/懒汉式删除</strong> 。</p><p>但是，仅仅通过给 key 设置过期时间还是有问题的。因为还是可能存在定期删除和惰性删除漏掉了很多过期 key 的情况。这样就导致大量过期 key 堆积在内存里，然后就 Out of memory 了。</p><p>怎么解决这个问题呢？答案就是：<strong>Redis 内存淘汰机制。</strong></p><h4 id="Redis-内存淘汰机制"><a href="#Redis-内存淘汰机制" class="headerlink" title="Redis 内存淘汰机制"></a>Redis 内存淘汰机制</h4><blockquote><p>相关问题：MySQL 里有 2000w 数据，Redis 中只存 20w 的数据，如何保证 Redis 中的数据都是热点数据?</p></blockquote><p>Redis 提供 6 种数据淘汰策略：</p><ol><li> <strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li> <strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li> <strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li> <strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（这个是最常用的）</li><li> <strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li> <strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0 版本后增加以下两种：</p><ol start="7"><li> <strong>volatile-lfu（least frequently used）</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最不经常使用的数据淘汰</li><li> <strong>allkeys-lfu（least frequently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的 key</li></ol><h3 id="5-Redis-持久化机制"><a href="#5-Redis-持久化机制" class="headerlink" title="5. Redis 持久化机制"></a>5. Redis 持久化机制</h3><h4 id="怎么保证-Redis-挂掉之后再重启数据可以进行恢复"><a href="#怎么保证-Redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="怎么保证 Redis 挂掉之后再重启数据可以进行恢复"></a>怎么保证 Redis 挂掉之后再重启数据可以进行恢复</h4><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p><p>Redis 不同于 Memcached 的很重要一点就是，Redis 支持持久化，而且支持两种不同的持久化操作。<strong>Redis 的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file, AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p><h4 id="RDB-持久化"><a href="#RDB-持久化" class="headerlink" title="RDB 持久化"></a>RDB 持久化</h4><p>Redis 可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis 主从结构，主要用来提高 Redis 性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>快照持久化是 Redis 默认采用的持久化方式，在 <code>redis.conf</code> 配置文件中默认有此下配置：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">save <span class="token number">900</span> <span class="token number">1</span>           <span class="token comment">#在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发bgsave命令创建快照。</span>save <span class="token number">300</span> <span class="token number">10</span>          <span class="token comment">#在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发bgsave命令创建快照。</span>save <span class="token number">60</span> <span class="token number">10000</span>        <span class="token comment">#在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发bgsave命令创建快照。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="RDB-创建快照时会阻塞主线程吗？"><a href="#RDB-创建快照时会阻塞主线程吗？" class="headerlink" title="RDB 创建快照时会阻塞主线程吗？"></a>RDB 创建快照时会阻塞主线程吗？</h4><p>Redis 提供了两个命令来生成 RDB 快照文件：</p><ul><li>  <code>save</code> : 主线程执行，会阻塞主线程；</li><li>  <code>bgsave</code> : 子线程执行，不会阻塞主线程，默认选项。</li></ul><h4 id="AOF-持久化"><a href="#AOF-持久化" class="headerlink" title="AOF 持久化"></a>AOF 持久化</h4><p>与快照持久化相比，AOF 持久化的实时性更好，因此已成为主流的持久化方案。默认情况下 Redis 没有开启 AOF（append only file）方式的持久化，可以通过 appendonly 参数开启：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">appendonly <span class="token function">yes</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开启 AOF 持久化后每执行一条会更改 Redis 中的数据的命令，Redis 就会将该命令写入到内存缓存 <code>server.aof_buf</code> 中，然后再根据 <code>appendfsync</code> 配置来决定何时将其同步到硬盘中的 AOF 文件。</p><p>AOF 文件的保存位置和 RDB 文件的位置相同，都是通过 dir 参数设置的，默认的文件名是 <code>appendonly.aof</code>。</p><p>在 Redis 的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">appendfsync always    <span class="token comment">#每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span>appendfsync everysec  <span class="token comment">#每秒钟同步一次，显式地将多个写命令同步到硬盘</span>appendfsync no        <span class="token comment">#让操作系统决定何时进行同步</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>为了兼顾数据和写入性能，用户可以考虑 <code>appendfsync everysec</code> 选项 ，让 Redis 每秒同步一次 AOF 文件，Redis 性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis 还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><h4 id="AOF-日志实现"><a href="#AOF-日志实现" class="headerlink" title="AOF 日志实现"></a>AOF 日志实现</h4><p>关系型数据库（如 MySQL）通常都是执行命令之前记录日志（方便故障恢复），而 Redis AOF 持久化机制是在执行完命令之后再记录日志。</p><p><img src="/images/image_redis/03.png"></p><p><strong>为什么是在执行完命令之后记录日志呢？</strong></p><ul><li>  避免额外的检查开销，AOF 记录日志不会对命令进行语法检查；</li><li>  在命令执行完之后再记录，不会阻塞当前的命令执行。</li></ul><p>这样也带来了风险（我在前面介绍 AOF 持久化的时候也提到过）：</p><ul><li>  如果刚执行完命令 Redis 就宕机会导致对应的修改丢失；</li><li>  可能会阻塞后续其他命令的执行（AOF 记录日志是在 Redis 主线程中进行的）。</li></ul><h4 id="AOF-重写"><a href="#AOF-重写" class="headerlink" title="AOF 重写"></a>AOF 重写</h4><p>当 AOF 变得太大时，Redis 能够在后台自动重写 AOF 产生一个新的 AOF 文件，这个新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。</p><p>AOF 重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有 AOF 文件进行任何读入、分析或者写入操作。</p><p>在执行 <code>BGREWRITEAOF</code> 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新 AOF 文件期间，记录服务器执行的所有写命令。当子进程完成创建新 AOF 文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新 AOF 文件的末尾，使得新的 AOF 文件保存的数据库状态与现有的数据库状态一致。最后，服务器用新的 AOF 文件替换旧的 AOF 文件，以此来完成 AOF 文件重写操作。</p><p>Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</p><h4 id="如何选择-RDB-和-AOF"><a href="#如何选择-RDB-和-AOF" class="headerlink" title="如何选择 RDB 和 AOF"></a>如何选择 RDB 和 AOF</h4><p><strong>RDB 比 AOF 优秀的地方</strong> ：</p><ul><li>  RDB 文件存储的内容是经过压缩的二进制数据， 保存着某个时间点的数据集，文件很小，适合做数据的备份，灾难恢复。AOF 文件存储的是每一次写命令，类似于 MySQL 的 binlog 日志，通常会必 RDB 文件大很多。当 AOF 变得太大时，Redis 能够在后台自动重写 AOF。新的 AOF 文件和原有的 AOF 文件所保存的数据库状态一样，但体积更小。不过， Redis 7.0 版本之前，如果在重写期间有写入命令，AOF 可能会使用大量内存，重写期间到达的所有写入命令都会写入磁盘两次。</li><li>  使用 RDB 文件恢复数据，直接解析还原数据即可，不需要一条一条地执行命令，速度非常快。而 AOF 则需要依次执行每个写命令，速度非常慢。也就是说，与 AOF 相比，恢复大数据集的时候，RDB 速度更快。</li></ul><p><strong>AOF 比 RDB 优秀的地方</strong> ：</p><ul><li>  RDB 的数据安全性不如 AOF，没有办法实时或者秒级持久化数据。生成 RDB 文件的过程是比较繁重的， 虽然 BGSAVE 子进程写入 RDB 文件的工作不会阻塞主线程，但会对机器的 CPU 资源和内存资源产生影响，严重的情况下甚至会直接把 Redis 服务干宕机。AOF 支持秒级数据丢失（取决 fsync 策略，如果是 everysec，最多丢失 1 秒的数据），仅仅是追加命令到 AOF 文件，操作轻量。</li><li>  RDB 文件是以特定的二进制格式保存的，并且在 Redis 版本演进中有多个版本的 RDB，所以存在老版本的 Redis 服务不兼容新版本的 RDB 格式的问题。</li><li>  AOF 以一种易于理解和解析的格式包含所有操作的日志。你可以轻松地导出 AOF 文件进行分析，你也可以直接操作 AOF 文件来解决一些问题。比如，如果执行<code>FLUSHALL</code>命令意外地刷新了所有内容后，只要 AOF 文件没有被重写，删除最新命令并重启即可恢复之前的状态。</li></ul><h4 id="Redis-4-0-对于持久化机制做了什么优化"><a href="#Redis-4-0-对于持久化机制做了什么优化" class="headerlink" title="Redis 4.0 对于持久化机制做了什么优化"></a>Redis 4.0 对于持久化机制做了什么优化</h4><p>由于 RDB 和 AOF 各有优势，于是，Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-Redis-基础&quot;&gt;&lt;a href=&quot;#1-Redis-基础&quot; class=&quot;headerlink&quot; title=&quot;1. Redis 基础&quot;&gt;&lt;/a&gt;1. Redis 基础&lt;/h3&gt;&lt;h4 id=&quot;什么是-Redis？&quot;&gt;&lt;a href=&quot;#什么是-Redis</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="NoSQL" scheme="http://ailiaa.github.io/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL高性能优化</title>
    <link href="http://ailiaa.github.io/2023/03/11/mysql-gao-xing-neng-you-hua/"/>
    <id>http://ailiaa.github.io/2023/03/11/mysql-gao-xing-neng-you-hua/</id>
    <published>2023-03-11T07:51:24.000Z</published>
    <updated>2023-03-11T08:00:39.588Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-数据库命名规范"><a href="#1-数据库命名规范" class="headerlink" title="1. 数据库命名规范"></a>1. 数据库命名规范</h3><ul><li>  所有数据库对象名称必须使用小写字母并用下划线分割</li><li>  所有数据库对象名称禁止使用 MySQL 保留关键字（如果表名中包含关键字查询时，需要将其用单引号括起来）</li><li>  数据库对象的命名要能做到见名识意，并且最后不要超过 32 个字符</li><li>  临时库表必须以 <code>tmp_</code> 为前缀并以日期为后缀，备份表必须以 <code>bak_</code> 为前缀并以日期 (时间戳) 为后缀</li><li>  所有存储相同数据的列名和列类型必须一致（一般作为关联列，如果查询时关联列类型不一致会自动进行数据类型隐式转换，会造成列上的索引失效，导致查询效率降低）</li></ul><h3 id="2-数据库基本设计规范"><a href="#2-数据库基本设计规范" class="headerlink" title="2. 数据库基本设计规范"></a>2. 数据库基本设计规范</h3><h4 id="所有表必须使用-InnoDB-存储引擎"><a href="#所有表必须使用-InnoDB-存储引擎" class="headerlink" title="所有表必须使用 InnoDB 存储引擎"></a>所有表必须使用 InnoDB 存储引擎</h4><p>没有特殊要求（即 InnoDB 无法满足的功能如：列存储，存储空间数据等）的情况下，所有表必须使用 InnoDB 存储引擎（MySQL5.5 之前默认使用 Myisam，5.6 以后默认的为 InnoDB）。</p><p>InnoDB 支持事务，支持行级锁，更好的恢复性，高并发下性能更好。</p><h4 id="数据库和表的字符集统一使用-UTF8"><a href="#数据库和表的字符集统一使用-UTF8" class="headerlink" title="数据库和表的字符集统一使用 UTF8"></a>数据库和表的字符集统一使用 UTF8</h4><p>兼容性更好，统一字符集可以避免由于字符集转换产生的乱码，不同的字符集进行比较前需要进行转换会造成索引失效，如果数据库中有存储 emoji 表情的需要，字符集需要采用 utf8mb4 字符集。</p><h4 id="所有表和字段都需要添加注释"><a href="#所有表和字段都需要添加注释" class="headerlink" title="所有表和字段都需要添加注释"></a>所有表和字段都需要添加注释</h4><p>使用 comment 从句添加表和列的备注，从一开始就进行数据字典的维护</p><h4 id="尽量控制单表数据量的大小，建议控制在-500-万以内"><a href="#尽量控制单表数据量的大小，建议控制在-500-万以内" class="headerlink" title="尽量控制单表数据量的大小，建议控制在 500 万以内"></a>尽量控制单表数据量的大小，建议控制在 500 万以内</h4><p>500 万并不是 MySQL 数据库的限制，过大会造成修改表结构，备份，恢复都会有很大的问题。</p><p>可以用历史数据归档（应用于日志数据），分库分表（应用于业务数据）等手段来控制数据量大小</p><h4 id="谨慎使用-MySQL-分区表"><a href="#谨慎使用-MySQL-分区表" class="headerlink" title="谨慎使用 MySQL 分区表"></a>谨慎使用 MySQL 分区表</h4><p>分区表在物理上表现为多个文件，在逻辑上表现为一个表；</p><p>谨慎选择分区键，跨分区查询效率可能更低；</p><p>建议采用物理分表的方式管理大数据。</p><h4 id="经常一起使用的列放到一个表中"><a href="#经常一起使用的列放到一个表中" class="headerlink" title="经常一起使用的列放到一个表中"></a>经常一起使用的列放到一个表中</h4><p>避免更多的关联操作。</p><h4 id="禁止在表中建立预留字段"><a href="#禁止在表中建立预留字段" class="headerlink" title="禁止在表中建立预留字段"></a>禁止在表中建立预留字段</h4><ul><li>  预留字段的命名很难做到见名识义。</li><li>  预留字段无法确认存储的数据类型，所以无法选择合适的类型。</li><li>  对预留字段类型的修改，会对表进行锁定。</li></ul><h4 id="禁止在数据库中存储文件（比如图片）这类大的二进制数据"><a href="#禁止在数据库中存储文件（比如图片）这类大的二进制数据" class="headerlink" title="禁止在数据库中存储文件（比如图片）这类大的二进制数据"></a>禁止在数据库中存储文件（比如图片）这类大的二进制数据</h4><p>在数据库中存储文件会严重影响数据库性能，消耗过多存储空间。</p><p>文件（比如图片）这类大的二进制数据通常存储于文件服务器，数据库只存储文件地址信息。</p><h4 id="不要被数据库范式所束缚"><a href="#不要被数据库范式所束缚" class="headerlink" title="不要被数据库范式所束缚"></a>不要被数据库范式所束缚</h4><p>一般来说，设计关系数据库时需要满足第三范式，但为了满足第三范式，我们可能会拆分出多张表。而在进行查询时需要对多张表进行关联查询，有时为了提高查询效率，会降低范式的要求，在表中保存一定的冗余信息，也叫做反范式。但要注意反范式一定要适度。</p><h4 id="禁止在线上做数据库压力测试"><a href="#禁止在线上做数据库压力测试" class="headerlink" title="禁止在线上做数据库压力测试"></a>禁止在线上做数据库压力测试</h4><h4 id="禁止从开发环境-测试环境直接连接生产环境数据库"><a href="#禁止从开发环境-测试环境直接连接生产环境数据库" class="headerlink" title="禁止从开发环境,测试环境直接连接生产环境数据库"></a>禁止从开发环境,测试环境直接连接生产环境数据库</h4><p>安全隐患极大，要对生产环境抱有敬畏之心！</p><h3 id="3-数据库字段设计规范"><a href="#3-数据库字段设计规范" class="headerlink" title="3. 数据库字段设计规范"></a>3. 数据库字段设计规范</h3><h4 id="优先选择符合存储需要的最小的数据类型"><a href="#优先选择符合存储需要的最小的数据类型" class="headerlink" title="优先选择符合存储需要的最小的数据类型"></a>优先选择符合存储需要的最小的数据类型</h4><p>存储字节越小，占用也就空间越小，性能也越好。</p><p><strong>a.某些字符串可以转换成数字类型存储比如可以将 IP 地址转换成整型数据。</strong></p><p>数字是连续的，性能更好，占用空间也更小。</p><p>MySQL 提供了两个方法来处理 ip 地址</p><ul><li>  <code>INET_ATON()</code> ： 把 ip 转为无符号整型 (4-8 位)</li><li>  <code>INET_NTOA()</code> :把整型的 ip 转为地址</li></ul><p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p><p><strong>b.对于非负型的数据 (如自增 ID,整型 IP，年龄) 来说,要优先使用无符号整型来存储。</strong></p><p>无符号相对于有符号可以多出一倍的存储空间</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">SIGNED <span class="token keyword">INT</span> <span class="token operator">-</span><span class="token number">2147483648</span><span class="token operator">~</span><span class="token number">2147483647</span><span class="token keyword">UNSIGNED</span> <span class="token keyword">INT</span> <span class="token number">0</span><span class="token operator">~</span><span class="token number">4294967295</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>c.小数值类型（比如年龄、状态表示如 0/1）优先使用 TINYINT 类型。</strong></p><h4 id="避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据"><a href="#避免使用-TEXT-BLOB-数据类型，最常见的-TEXT-类型可以存储-64k-的数据" class="headerlink" title="避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据"></a>避免使用 TEXT,BLOB 数据类型，最常见的 TEXT 类型可以存储 64k 的数据</h4><p><strong>a. 建议把 BLOB 或是 TEXT 列分离到单独的扩展表中。</strong></p><p>MySQL 内存临时表不支持 TEXT、BLOB 这样的大数据类型，如果查询中包含这样的数据，在排序等操作时，就不能使用内存临时表，必须使用磁盘临时表进行。而且对于这种数据，MySQL 还是要进行二次查询，会使 sql 性能变得很差，但是不是说一定不能使用这样的数据类型。</p><p>如果一定要使用，建议把 BLOB 或是 TEXT 列分离到单独的扩展表中，查询时一定不要使用 <code>select *</code>而只需要取出必要的列，不需要 TEXT 列的数据时不要对该列进行查询。</p><p><strong>2、TEXT 或 BLOB 类型只能使用前缀索引</strong></p><p>因为 MySQL 对索引字段长度是有限制的，所以 TEXT 类型只能使用前缀索引，并且 TEXT 列上是不能有默认值的</p><h4 id="避免使用-ENUM-类型"><a href="#避免使用-ENUM-类型" class="headerlink" title="避免使用 ENUM 类型"></a>避免使用 ENUM 类型</h4><ul><li>  修改 ENUM 值需要使用 ALTER 语句；</li><li>  ENUM 类型的 ORDER BY 操作效率低，需要额外操作；</li><li>  ENUM 数据类型存在一些限制比如建议不要使用数值作为 ENUM 的枚举值。</li></ul><h4 id="尽可能把所有列定义为-NOT-NULL"><a href="#尽可能把所有列定义为-NOT-NULL" class="headerlink" title="尽可能把所有列定义为 NOT NULL"></a>尽可能把所有列定义为 NOT NULL</h4><p>除非有特别的原因使用 NULL 值，应该总是让字段保持 NOT NULL。</p><ul><li>  索引 NULL 列需要额外的空间来保存，所以要占用更多的空间；</li><li>  进行比较和计算时要对 NULL 值做特别的处理。</li></ul><h4 id="使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间"><a href="#使用-TIMESTAMP-4-个字节-或-DATETIME-类型-8-个字节-存储时间" class="headerlink" title="使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间"></a>使用 TIMESTAMP(4 个字节) 或 DATETIME 类型 (8 个字节) 存储时间</h4><p>TIMESTAMP 存储的时间范围 1970-01-01 00:00:01 ~ 2038-01-19-03:14:07</p><p>TIMESTAMP 占用 4 字节和 INT 相同，但比 INT 可读性高</p><p>超出 TIMESTAMP 取值范围的使用 DATETIME 类型存储</p><p><strong>经常会有人用字符串存储日期型的数据（不正确的做法）</strong></p><ul><li>  缺点 1：无法用日期函数进行计算和比较</li><li>  缺点 2：用字符串存储日期要占用更多的空间</li></ul><h4 id="同财务相关的金额类数据必须使用-decimal-类型"><a href="#同财务相关的金额类数据必须使用-decimal-类型" class="headerlink" title="同财务相关的金额类数据必须使用 decimal 类型"></a>同财务相关的金额类数据必须使用 decimal 类型</h4><ul><li>  <strong>非精准浮点</strong> ：float,double</li><li>  <strong>精准浮点</strong> ：decimal</li></ul><p>decimal 类型为精准浮点数，在计算时不会丢失精度。占用空间由定义的宽度决定，每 4 个字节可以存储 9 位数字，并且小数点要占用一个字节。并且，decimal 可用于存储比 bigint 更大的整型数据</p><p>不过， 由于 decimal 需要额外的空间和计算开销，应该尽量只在需要对数据进行精确计算时才使用 decimal 。</p><h4 id="单表不要包含过多字段"><a href="#单表不要包含过多字段" class="headerlink" title="单表不要包含过多字段"></a>单表不要包含过多字段</h4><p>如果一个表包含过多字段的话，可以考虑将其分解成多个表，必要时增加中间表进行关联。</p><h3 id="4-索引设计规范"><a href="#4-索引设计规范" class="headerlink" title="4. 索引设计规范"></a>4. 索引设计规范</h3><h4 id="限制每张表上的索引数量-建议单张表索引不超过-5-个"><a href="#限制每张表上的索引数量-建议单张表索引不超过-5-个" class="headerlink" title="限制每张表上的索引数量,建议单张表索引不超过 5 个"></a>限制每张表上的索引数量,建议单张表索引不超过 5 个</h4><p>索引并不是越多越好！索引可以提高效率同样可以降低效率。</p><p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p><p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p><h4 id="禁止使用全文索引"><a href="#禁止使用全文索引" class="headerlink" title="禁止使用全文索引"></a>禁止使用全文索引</h4><p>全文索引不适用于 OLTP 场景。</p><h4 id="禁止给表中的每一列都建立单独的索引"><a href="#禁止给表中的每一列都建立单独的索引" class="headerlink" title="禁止给表中的每一列都建立单独的索引"></a>禁止给表中的每一列都建立单独的索引</h4><p>5.6 版本之前，一个 sql 只能使用到一个表中的一个索引，5.6 以后，虽然有了合并索引的优化方式，但是还是远远没有使用一个联合索引的查询方式好。</p><h4 id="每个-InnoDB-表必须有个主键"><a href="#每个-InnoDB-表必须有个主键" class="headerlink" title="每个 InnoDB 表必须有个主键"></a>每个 InnoDB 表必须有个主键</h4><p>InnoDB 是一种索引组织表：数据的存储的逻辑顺序和索引的顺序是相同的。每个表都可以有多个索引，但是表的存储顺序只能有一种。</p><p>InnoDB 是按照主键索引的顺序来组织表的</p><ul><li>  不要使用更新频繁的列作为主键，不适用多列主键（相当于联合索引）</li><li>  不要使用 UUID,MD5,HASH,字符串列作为主键（无法保证数据的顺序增长）</li><li>  主键建议使用自增 ID 值</li></ul><h4 id="常见索引列建议"><a href="#常见索引列建议" class="headerlink" title="常见索引列建议"></a>常见索引列建议</h4><ul><li>  出现在 SELECT、UPDATE、DELETE 语句的 WHERE 从句中的列</li><li>  包含在 ORDER BY、GROUP BY、DISTINCT 中的字段</li><li>  并不要将符合 1 和 2 中的字段的列都建立一个索引， 通常将 1、2 中的字段建立联合索引效果更好</li><li>  多表 join 的关联列</li></ul><h4 id="如何选择索引列的顺序"><a href="#如何选择索引列的顺序" class="headerlink" title="如何选择索引列的顺序"></a>如何选择索引列的顺序</h4><p>建立索引的目的是：希望通过索引进行数据查找，减少随机 IO，增加查询性能 ，索引能过滤出越少的数据，则从磁盘中读入的数据也就越少。</p><ul><li>  区分度最高的放在联合索引的最左侧（区分度=列中不同值的数量/列的总行数）</li><li>  尽量把字段长度小的列放在联合索引的最左侧（因为字段长度越小，一页能存储的数据量越大，IO 性能也就越好）</li><li>  使用最频繁的列放到联合索引的左侧（这样可以比较少的建立一些索引）</li></ul><h4 id="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"><a href="#避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）" class="headerlink" title="避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）"></a>避免建立冗余索引和重复索引（增加了查询优化器生成执行计划的时间）</h4><ul><li>  重复索引示例：primary key(id)、index(id)、unique index(id)</li><li>  冗余索引示例：index(a,b,c)、index(a,b)、index(a)</li></ul><h4 id="对于频繁的查询优先考虑使用覆盖索引"><a href="#对于频繁的查询优先考虑使用覆盖索引" class="headerlink" title="对于频繁的查询优先考虑使用覆盖索引"></a>对于频繁的查询优先考虑使用覆盖索引</h4><blockquote><p>覆盖索引：就是包含了所有查询字段 (where,select,order by,group by 包含的字段) 的索引</p></blockquote><p><strong>覆盖索引的好处：</strong></p><ul><li>  <strong>避免 InnoDB 表进行索引的二次查询:</strong> InnoDB 是以聚集索引的顺序来存储的，对于 InnoDB 来说，二级索引在叶子节点中所保存的是行的主键信息，如果是用二级索引查询数据的话，在查找到相应的键值后，还要通过主键进行二次查询才能获取我们真实所需要的数据。而在覆盖索引中，二级索引的键值中可以获取所有的数据，避免了对主键的二次查询 ，减少了 IO 操作，提升了查询效率。</li><li>  <strong>可以把随机 IO 变成顺序 IO 加快查询效率:</strong> 由于覆盖索引是按键值的顺序存储的，对于 IO 密集型的范围查找来说，对比随机从磁盘读取每一行的数据 IO 要少的多，因此利用覆盖索引在访问时也可以把磁盘的随机读取的 IO 转变成索引查找的顺序 IO。</li></ul><h4 id="索引-SET-规范"><a href="#索引-SET-规范" class="headerlink" title="索引 SET 规范"></a>索引 SET 规范</h4><p><strong>尽量避免使用外键约束</strong></p><ul><li>  不建议使用外键约束（foreign key），但一定要在表与表之间的关联键上建立索引</li><li>  外键可用于保证数据的参照完整性，但建议在业务端实现</li><li>  外键会影响父表和子表的写操作从而降低性能</li></ul><h3 id="5-数据库-SQL-开发规范"><a href="#5-数据库-SQL-开发规范" class="headerlink" title="5. 数据库 SQL 开发规范"></a>5. 数据库 SQL 开发规范</h3><h4 id="优化对性能影响较大的-SQL-语句"><a href="#优化对性能影响较大的-SQL-语句" class="headerlink" title="优化对性能影响较大的 SQL 语句"></a>优化对性能影响较大的 SQL 语句</h4><p>要找到最需要优化的 SQL 语句。要么是使用最频繁的语句，要么是优化后提高最明显的语句，可以通过查询 MySQL 的慢查询日志来发现需要进行优化的 SQL 语句；</p><h4 id="充分利用表上已经存在的索引"><a href="#充分利用表上已经存在的索引" class="headerlink" title="充分利用表上已经存在的索引"></a>充分利用表上已经存在的索引</h4><p>避免使用双%号的查询条件。如：<code>a like '%123%'</code>，（如果无前置%,只有后置%，是可以用到列上的索引的）</p><p>一个 SQL 只能利用到复合索引中的一列进行范围查询。如：有 a,b,c 列的联合索引，在查询条件中有 a 列的范围查询，则在 b,c 列上的索引将不会被用到。</p><p>在定义联合索引时，如果 a 列要用到范围查找的话，就要把 a 列放到联合索引的右侧，使用 left join 或 not exists 来优化 not in 操作，因为 not in 也通常会使用索引失效。</p><h4 id="禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询"><a href="#禁止使用-SELECT-必须使用-SELECT-lt-字段列表-gt-查询" class="headerlink" title="禁止使用 SELECT * 必须使用 SELECT <字段列表> 查询"></a>禁止使用 SELECT * 必须使用 SELECT &lt;字段列表&gt; 查询</h4><ul><li>  <code>SELECT *</code> 消耗更多的 CPU 和 IO 以网络带宽资源</li><li>  <code>SELECT *</code> 无法使用覆盖索引</li><li>  <code>SELECT &lt;字段列表&gt;</code> 可减少表结构变更带来的影响</li></ul><h4 id="禁止使用不含字段列表的-INSERT-语句"><a href="#禁止使用不含字段列表的-INSERT-语句" class="headerlink" title="禁止使用不含字段列表的 INSERT 语句"></a>禁止使用不含字段列表的 INSERT 语句</h4><p>如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> t <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应使用：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">insert</span> <span class="token keyword">into</span> t<span class="token punctuation">(</span>c1<span class="token punctuation">,</span>c2<span class="token punctuation">,</span>c3<span class="token punctuation">)</span> <span class="token keyword">values</span> <span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="建议使用预编译语句进行数据库操作"><a href="#建议使用预编译语句进行数据库操作" class="headerlink" title="建议使用预编译语句进行数据库操作"></a>建议使用预编译语句进行数据库操作</h4><ul><li>  预编译语句可以重复使用这些计划，减少 SQL 编译所需要的时间，还可以解决动态 SQL 所带来的 SQL 注入的问题。</li><li>  只传参数，比传递 SQL 语句更高效。</li><li>  相同语句可以一次解析，多次使用，提高处理效率。</li></ul><h4 id="避免数据类型的隐式转换"><a href="#避免数据类型的隐式转换" class="headerlink" title="避免数据类型的隐式转换"></a>避免数据类型的隐式转换</h4><p>隐式转换会导致索引失效如:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> name<span class="token punctuation">,</span>phone <span class="token keyword">from</span> customer <span class="token keyword">where</span> id <span class="token operator">=</span> <span class="token string">'111'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="避免使用子查询，可以把子查询优化为-join-操作"><a href="#避免使用子查询，可以把子查询优化为-join-操作" class="headerlink" title="避免使用子查询，可以把子查询优化为 join 操作"></a>避免使用子查询，可以把子查询优化为 join 操作</h4><p>通常子查询在 in 子句中，且子查询中为简单 SQL(不包含 union、group by、order by、limit 从句) 时,才可以把子查询转化为关联查询进行优化。</p><p><strong>子查询性能差的原因：</strong> 子查询的结果集无法使用索引，通常子查询的结果集会被存储到临时表中，不论是内存临时表还是磁盘临时表都不会存在索引，所以查询性能会受到一定的影响。特别是对于返回结果集比较大的子查询，其对查询性能的影响也就越大。由于子查询会产生大量的临时表也没有索引，所以会消耗过多的 CPU 和 IO 资源，产生大量的慢查询。</p><h4 id="避免使用-JOIN-关联太多的表"><a href="#避免使用-JOIN-关联太多的表" class="headerlink" title="避免使用 JOIN 关联太多的表"></a>避免使用 JOIN 关联太多的表</h4><p>对于 MySQL 来说，是存在关联缓存的，缓存的大小可以由 join_buffer_size 参数进行设置。</p><p>在 MySQL 中，对于同一个 SQL 多关联（join）一个表，就会多分配一个关联缓存，如果在一个 SQL 中关联的表越多，所占用的内存也就越大。</p><p>如果程序中大量的使用了多表关联的操作，同时 join_buffer_size 设置的也不合理的情况下，就容易造成服务器内存溢出的情况，就会影响到服务器数据库性能的稳定性。</p><p>同时对于关联操作来说，会产生临时表操作，影响查询效率，MySQL 最多允许关联 61 个表，建议不超过 5 个。</p><h4 id="减少同数据库的交互次数"><a href="#减少同数据库的交互次数" class="headerlink" title="减少同数据库的交互次数"></a>减少同数据库的交互次数</h4><p>数据库更适合处理批量操作，合并多个相同的操作到一起，可以提高处理效率。</p><h4 id="对应同一列进行-or-判断时，使用-in-代替-or"><a href="#对应同一列进行-or-判断时，使用-in-代替-or" class="headerlink" title="对应同一列进行 or 判断时，使用 in 代替 or"></a>对应同一列进行 or 判断时，使用 in 代替 or</h4><p>in 的值不要超过 500 个，in 操作可以更有效的利用索引，or 大多数情况下很少能利用到索引。</p><h4 id="禁止使用-order-by-rand-进行随机排序"><a href="#禁止使用-order-by-rand-进行随机排序" class="headerlink" title="禁止使用 order by rand() 进行随机排序"></a>禁止使用 order by rand() 进行随机排序</h4><p>order by rand() 会把表中所有符合条件的数据装载到内存中，然后在内存中对所有数据根据随机生成的值进行排序，并且可能会对每一行都生成一个随机值，如果满足条件的数据集非常大，就会消耗大量的 CPU 和 IO 及内存资源。</p><p>推荐在程序中获取一个随机值，然后从数据库中获取数据的方式。</p><h4 id="WHERE-从句中禁止对列进行函数转换和计算"><a href="#WHERE-从句中禁止对列进行函数转换和计算" class="headerlink" title="WHERE 从句中禁止对列进行函数转换和计算"></a>WHERE 从句中禁止对列进行函数转换和计算</h4><p>对列进行函数转换或计算时会导致无法使用索引</p><p><strong>不推荐：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">where</span> <span class="token keyword">date</span><span class="token punctuation">(</span>create_time<span class="token punctuation">)</span><span class="token operator">=</span><span class="token string">'20190101'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>推荐：</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">where</span> create_time <span class="token operator">&gt;=</span> <span class="token string">'20190101'</span> <span class="token operator">and</span> create_time <span class="token operator">&lt;</span> <span class="token string">'20190102'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="在明显不会有重复值时使用-UNION-ALL-而不是-UNION"><a href="#在明显不会有重复值时使用-UNION-ALL-而不是-UNION" class="headerlink" title="在明显不会有重复值时使用 UNION ALL 而不是 UNION"></a>在明显不会有重复值时使用 UNION ALL 而不是 UNION</h4><ul><li>  UNION 会把两个结果集的所有数据放到临时表中后再进行去重操作</li><li>  UNION ALL 不会再对结果集进行去重操作</li></ul><h4 id="拆分复杂的大-SQL-为多个小-SQL"><a href="#拆分复杂的大-SQL-为多个小-SQL" class="headerlink" title="拆分复杂的大 SQL 为多个小 SQL"></a>拆分复杂的大 SQL 为多个小 SQL</h4><ul><li>  大 SQL 逻辑上比较复杂，需要占用大量 CPU 进行计算的 SQL</li><li>  MySQL 中，一个 SQL 只能使用一个 CPU 进行计算</li><li>  SQL 拆分后可以通过并行执行来提高处理效率</li></ul><h4 id="程序连接不同的数据库使用不同的账号，禁止跨库查询"><a href="#程序连接不同的数据库使用不同的账号，禁止跨库查询" class="headerlink" title="程序连接不同的数据库使用不同的账号，禁止跨库查询"></a>程序连接不同的数据库使用不同的账号，禁止跨库查询</h4><ul><li>  为数据库迁移和分库分表留出余地</li><li>  降低业务耦合度</li><li>  避免权限过大而产生的安全风险</li></ul><h3 id="6-数据库操作行为规范"><a href="#6-数据库操作行为规范" class="headerlink" title="6. 数据库操作行为规范"></a>6. 数据库操作行为规范</h3><h4 id="超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作"><a href="#超-100-万行的批量写-UPDATE-DELETE-INSERT-操作-要分批多次进行操作" class="headerlink" title="超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作"></a>超 100 万行的批量写 (UPDATE,DELETE,INSERT) 操作,要分批多次进行操作</h4><p><strong>大批量操作可能会造成严重的主从延迟</strong></p><p>主从环境中,大批量操作可能会造成严重的主从延迟，大批量的写操作一般都需要执行一定长的时间，而只有当主库上执行完成后，才会在其他从库上执行，所以会造成主库与从库长时间的延迟情况</p><p><strong>binlog 日志为 row 格式时会产生大量的日志</strong></p><p>大批量写操作会产生大量日志，特别是对于 row 格式二进制数据而言，由于在 row 格式中会记录每一行数据的修改，我们一次修改的数据越多，产生的日志量也就会越多，日志的传输和恢复所需要的时间也就越长，这也是造成主从延迟的一个原因</p><p><strong>避免产生大事务操作</strong></p><p>大批量修改数据，一定是在一个事务中进行的，这就会造成表中大批量数据进行锁定，从而导致大量的阻塞，阻塞会对 MySQL 的性能产生非常大的影响。</p><p>特别是长时间的阻塞会占满所有数据库的可用连接，这会使生产环境中的其他应用无法连接到数据库，因此一定要注意大批量写操作要进行分批</p><h4 id="对于大表使用-pt-online-schema-change-修改表结构"><a href="#对于大表使用-pt-online-schema-change-修改表结构" class="headerlink" title="对于大表使用 pt-online-schema-change 修改表结构"></a>对于大表使用 pt-online-schema-change 修改表结构</h4><ul><li>  避免大表修改产生的主从延迟</li><li>  避免在对表字段进行修改时进行锁表</li></ul><p>对大表数据结构的修改一定要谨慎，会造成严重的锁表操作，尤其是生产环境，是不能容忍的。</p><p>pt-online-schema-change 它会首先建立一个与原表结构相同的新表，并且在新表上进行表结构的修改，然后再把原表中的数据复制到新表中，并在原表中增加一些触发器。把原表中新增的数据也复制到新表中，在行所有数据复制完成之后，把新表命名成原表，并把原来的表删除掉。把原来一个 DDL 操作，分解成多个小的批次进行。</p><h4 id="禁止为程序使用的账号赋予-super-权限"><a href="#禁止为程序使用的账号赋予-super-权限" class="headerlink" title="禁止为程序使用的账号赋予 super 权限"></a>禁止为程序使用的账号赋予 super 权限</h4><ul><li>  当达到最大连接数限制时，还运行 1 个有 super 权限的用户连接</li><li>  super 权限只能留给 DBA 处理问题的账号使用</li></ul><h4 id="对于程序连接数据库账号-遵循权限最小原则"><a href="#对于程序连接数据库账号-遵循权限最小原则" class="headerlink" title="对于程序连接数据库账号,遵循权限最小原则"></a>对于程序连接数据库账号,遵循权限最小原则</h4><ul><li>  程序使用数据库账号只能在一个 DB 下使用，不准跨库</li><li>  程序使用的账号原则上不准有 drop 权限</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-数据库命名规范&quot;&gt;&lt;a href=&quot;#1-数据库命名规范&quot; class=&quot;headerlink&quot; title=&quot;1. 数据库命名规范&quot;&gt;&lt;/a&gt;1. 数据库命名规范&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;  所有数据库对象名称必须使用小写字母并用下划线分割&lt;/li&gt;
&lt;l</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://ailiaa.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>SQL优化常用方法</title>
    <link href="http://ailiaa.github.io/2023/03/11/sql-you-hua-chang-yong-fang-fa/"/>
    <id>http://ailiaa.github.io/2023/03/11/sql-you-hua-chang-yong-fang-fa/</id>
    <published>2023-03-11T07:44:39.000Z</published>
    <updated>2023-03-11T07:50:23.507Z</updated>
    
    <content type="html"><![CDATA[<p>1、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>2、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>3、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num <span class="token operator">is</span> <span class="token boolean">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以在num列设置默认值0，然后通过=等号查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">10</span> <span class="token operator">or</span> num<span class="token operator">=</span><span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此查询可优化为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">10</span>    <span class="token keyword">union</span> <span class="token keyword">all</span>    <span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>5、下面的查询也将导致全表扫描：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'%abc%'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若要提高效率，可以考虑全文检索。</p><p>6、in 和 not in 也要慎用，否则会导致全表扫描，如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num <span class="token operator">in</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若查询的数值为连续值，则可以优化为between来查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num <span class="token operator">between</span> <span class="token number">1</span> <span class="token operator">and</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>7、如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问，计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token variable">@num</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以改为强制查询使用索引：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">index</span><span class="token punctuation">(</span>索引名<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token variable">@num</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">/</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应改为:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">elect id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">100</span><span class="token operator">*</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>9、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> substring<span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token string">'abc'</span><span class="token comment">--name以abc开头的id</span><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> datediff<span class="token punctuation">(</span><span class="token keyword">day</span><span class="token punctuation">,</span>createdate<span class="token punctuation">,</span><span class="token string">'2005-11-30'</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token comment">--'2005-11-30'生成的id</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>应改为:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'abc%'</span><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> createdate<span class="token operator">&gt;=</span><span class="token string">'2005-11-30'</span> <span class="token operator">and</span> createdate<span class="token operator">&lt;</span><span class="token string">'2005-12-1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>10、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><p> 11、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><p>12、不要写一些没有意义的查询，如需要生成一个空表结构：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> col1<span class="token punctuation">,</span>col2 <span class="token keyword">into</span> <span class="token comment">#t from t where 1=0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token comment">#t(...)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>13、很多时候用 exists 代替 in 是一个好的选择：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> num <span class="token keyword">from</span> a <span class="token keyword">where</span> num <span class="token operator">in</span><span class="token punctuation">(</span><span class="token keyword">select</span> num <span class="token keyword">from</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用下面的语句替换：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> num <span class="token keyword">from</span> a <span class="token keyword">where</span> <span class="token keyword">exists</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">from</span> b <span class="token keyword">where</span> num<span class="token operator">=</span>a<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>14、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p><p>15、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><p>16、应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><p>17、应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><p>18、尽可能的使用varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>19、任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p><p>20、尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><p>21、避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。&lt;/p&gt;
&lt;p&gt;2、应尽量避免在 where 子句中使用!=或&amp;lt;&amp;gt;操作符，否则将引擎放弃使用索引而进行全表扫描。&lt;/p&gt;
&lt;p&gt;3、应尽量避免在 wher</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://ailiaa.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL索引</title>
    <link href="http://ailiaa.github.io/2023/03/11/mysql-suo-yin/"/>
    <id>http://ailiaa.github.io/2023/03/11/mysql-suo-yin/</id>
    <published>2023-03-11T07:27:04.000Z</published>
    <updated>2023-03-11T08:41:14.013Z</updated>
    
    <content type="html"><![CDATA[<h3 id="索引介绍"><a href="#索引介绍" class="headerlink" title="索引介绍"></a>索引介绍</h3><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p><p>索引的作用就相当于书的目录。</p><p>索引底层数据结构存在很多种类型，常见的索引结构有: B 树， B+树 和 Hash、红黑树。在 MySQL 中，无论是 Innodb 还是 MyIsam，都使用了 B+树作为索引结构。</p><h3 id="索引的优缺点"><a href="#索引的优缺点" class="headerlink" title="索引的优缺点"></a>索引的优缺点</h3><p><strong>优点</strong> ：</p><ul><li>  使用索引可以大大加快 数据的检索速度（大大减少检索的数据量）, 这也是创建索引的最主要的原因。</li><li>  通过创建唯一性索引，可以保证数据库表中每一行数据的唯一性。</li></ul><p><strong>缺点</strong> ：</p><ul><li>  创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>  索引需要使用物理文件存储，也会耗费一定空间。</li></ul><p>但是，<strong>使用索引一定能提高查询性能吗?</strong></p><p>大多数情况下，索引查询都是比全表扫描要快的。但是如果数据库的数据量不大，那么使用索引也不一定能够带来很大提升。</p><h3 id="索引的底层数据结构"><a href="#索引的底层数据结构" class="headerlink" title="索引的底层数据结构"></a>索引的底层数据结构</h3><h4 id="Hash-表"><a href="#Hash-表" class="headerlink" title="Hash 表"></a>Hash 表</h4><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p><p>哈希算法有个&nbsp;<strong>Hash 冲突</strong>&nbsp;问题，也就是说多个不同的 key 最后得到的 index 相同。为了减少 Hash 冲突的发生，一个好的哈希函数应该“均匀地”将数据分布在整个可能的哈希值集合中。</p><p><strong>为什么 MySQL 没有使用其作为索引的数据结构呢？</strong> Hash 索引不支持顺序和范围查询。</p><h4 id="B-树-amp-B-树"><a href="#B-树-amp-B-树" class="headerlink" title="B 树&amp; B+树"></a>B 树&amp; B+树</h4><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。B 树和 B+树中的 B 是 <code>Balanced</code> （平衡）的意思。</p><p>目前大部分数据库系统及文件系统都采用 B-Tree 或其变种 B+Tree 作为索引结构。</p><p><strong>B 树&amp; B+树两者有何异同呢？</strong></p><ul><li>  B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>  B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>  B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是，两者的实现方式不太一样。（下面的内容整理自《Java 工程师修炼之道》）</p><blockquote><p>MyISAM 引擎中，B+Tree 叶节点的 data 域存放的是数据记录的地址。在索引检索的时候，首先按照 B+Tree 搜索算法搜索索引，如果指定的 Key 存在，则取出其 data 域的值，然后以 data 域的值为地址读取相应的数据记录。这被称为“<strong>非聚簇索引（非聚集索引）</strong>”。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。这个索引的 key 是数据表的主键，因此 InnoDB 表数据文件本身就是主索引。这被称为“<strong>聚簇索引（聚集索引）</strong>”，而其余的索引都作为 <strong>辅助索引</strong> ，辅助索引的 data 域存储相应记录主键的值而不是地址，这也是和 MyISAM 不同的地方。在根据主索引搜索时，直接找到 key 所在的节点即可取出数据；在根据辅助索引查找时，则需要先取出主键的值，再走一遍主索引。 因此，在设计表的时候，不建议使用过长的字段作为主键，也不建议使用非单调的字段作为主键，这样会造成主索引频繁分裂。</p></blockquote><h4 id="为什么Mysql用B-树做索引而不用B-树"><a href="#为什么Mysql用B-树做索引而不用B-树" class="headerlink" title="为什么Mysql用B+树做索引而不用B-树"></a>为什么Mysql用B+树做索引而不用B-树</h4><p><strong>B+树索引节点没有有Data域，索引范围大</strong>：B+树只有叶节点存放数据，其余节点用来索引，而B-树是每个索引节点都会有Data域。所以从Mysql（Innodb）的角度来看，B+树是用来充当索引的，一般来说索引非常大，尤其是关系性数据库这种数据量大的索引能达到亿级别，所以为了减少内存的占用，索引也会被存储在磁盘上。</p><p><strong>B+树节点小，磁盘IO次数少</strong>：**&nbsp;B-树/B+树 的特点就是每层节点数目非常多，层数很少，目的就是减少磁盘IO次数，但是B-树的每个节点都有data域（指针），这无疑增大了节点大小，说白了增加了磁盘IO次数（磁盘IO一次读出的数据量大小是固定的，单个数据变大，每次读出的就少，IO次数增多，一次IO多耗时），而B+树除了叶子节点其它节点并不存储数据，节点小，磁盘IO次数就少。  </p><p><strong>叶子节点用指针串连，进行区间访问</strong>：B+树所有的Data域在叶子节点，一般来说都会进行一个优化，就是将所有的叶子节点用指针串起来。这遍历叶子节点就能获得全部数据，这样就能进行区间访问啦。在数据库中基于范围的查询是非常频繁的，而B树不支持这样的遍历操作。</p><h4 id="为什么Mysql用B-树做索引而不用红黑树或者AVL树"><a href="#为什么Mysql用B-树做索引而不用红黑树或者AVL树" class="headerlink" title="为什么Mysql用B+树做索引而不用红黑树或者AVL树"></a>为什么Mysql用B+树做索引而不用红黑树或者AVL树</h4><p><strong>红黑树和AVL树的高度太大</strong>：<strong>AVL 树和红黑树基本都是存储在内存中才会使用的数据结构</strong>。在大规模数据存储的时候，红黑树往往出现由于<strong>树的深度过大</strong>而造成磁盘IO读写过于频繁，进而导致效率低下的情况。为什么会出现这样的情况，我们知道要获取磁盘上数据，必须先通过磁盘移动臂移动到数据所在的柱面，然后找到指定盘面，接着旋转盘面找到数据所在的磁道，最后对数据进行读写。磁盘IO代价主要花费在查找所需的柱面上，树的深度过大会造成磁盘IO频繁读写。根据<strong>磁盘查找存取的次数往往由树的高度所决定</strong>，所以，只要我们通过某种较好的树结构减少树的结构尽量减少树的高度，B树可以有多个子女，从几十到上千，可以降低树的高度。</p><p><strong>B树一个node只需一次I/O</strong>：<strong>数据库系统的设计者巧妙利用了磁盘预读原理</strong>，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。为了达到这个目的，在实际实现B-Tree还需要使用如下技巧：每次新建节点时，直接申请一个页的空间，这样就保证<strong>一个节点物理上也存储在一个页里</strong>，加之计算机存储分配都是按页对齐的，就实现了一个node只需一次I/O。</p><h3 id="索引类型总结"><a href="#索引类型总结" class="headerlink" title="索引类型总结"></a>索引类型总结</h3><h4 id="按照数据结构维度划分"><a href="#按照数据结构维度划分" class="headerlink" title="按照数据结构维度划分"></a>按照数据结构维度划分</h4><ul><li>  BTree 索引：MySQL 里默认和最常用的索引类型。只有叶子节点存储 value，非叶子节点只有指针和 key。存储引擎 MyISAM 和 InnoDB 实现 BTree 索引都是使用 B+Tree，但二者实现方式不一样（前面已经介绍了）。</li><li>  哈希索引：类似键值对的形式，一次即可定位。</li><li>  RTree 索引：一般不会使用，仅支持 geometry 数据类型，优势在于范围查找，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li><li>  全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><h4 id="按照底层存储方式角度划分"><a href="#按照底层存储方式角度划分" class="headerlink" title="按照底层存储方式角度划分"></a>按照底层存储方式角度划分</h4><ul><li>  聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li><li>  非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li></ul><h4 id="按照应用维度划分"><a href="#按照应用维度划分" class="headerlink" title="按照应用维度划分"></a>按照应用维度划分</h4><ul><li>  主键索引：加速查询 + 列值唯一（不可以有 NULL）+ 表中只有一个。</li><li>  普通索引：仅加速查询。</li><li>  唯一索引：加速查询 + 列值唯一（可以有 NULL）。</li><li>  覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</li><li>  联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</li><li>  全文索引：对文本的内容进行分词，进行搜索。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</li></ul><h4 id="MySQL-8-x-中实现的索引新特性"><a href="#MySQL-8-x-中实现的索引新特性" class="headerlink" title="MySQL 8.x 中实现的索引新特性"></a>MySQL 8.x 中实现的索引新特性</h4><ul><li>  隐藏索引：也称为不可见索引，不会被优化器使用，但是仍然需要维护，通常会软删除和灰度发布的场景中使用。主键不能设置为隐藏（包括显式设置或隐式设置）。</li><li>  降序索引：之前的版本就支持通过 desc 来指定索引为降序，但实际上创建的仍然是常规的升序索引。直到 MySQL 8.x 版本才开始真正支持降序索引。另外，在 MySQL 8.x 版本中，不再对 GROUP BY 语句进行隐式排序。</li><li>  函数索引：从 MySQL 8.0.13 版本开始支持在索引中使用函数或者表达式的值，也就是在索引中可以包含函数或者表达式。</li></ul><h3 id="主键索引-Primary-Key"><a href="#主键索引-Primary-Key" class="headerlink" title="主键索引(Primary Key)"></a>主键索引(Primary Key)</h3><p>数据表的主键列使用的就是主键索引。</p><p>一张数据表有只能有一个主键，并且主键不能为 null，不能重复。</p><p>在 MySQL 的 InnoDB 的表中，当没有显示的指定表的主键时，InnoDB 会自动先检查表中是否有唯一索引且不允许存在 null 值的字段，如果有，则选择该字段为默认的主键，否则 InnoDB 将会自动创建一个 6Byte 的自增主键。</p><p><img src="/images/image_MySQL%E7%B4%A2%E5%BC%95/01.png"></p><h3 id="二级索引-辅助索引"><a href="#二级索引-辅助索引" class="headerlink" title="二级索引(辅助索引)"></a>二级索引(辅助索引)</h3><p><strong>二级索引又称为辅助索引，是因为二级索引的叶子节点存储的数据是主键。也就是说，通过二级索引，可以定位主键的位置。</strong></p><p>唯一索引，普通索引，前缀索引等索引属于二级索引。</p><p>PS: 不懂的同学可以暂存疑，慢慢往下看，后面会有答案的，也可以自行搜索。</p><ol><li> <strong>唯一索引(Unique Key)</strong> ：唯一索引也是一种约束。<strong>唯一索引的属性列不能出现重复的数据，但是允许数据为 NULL，一张表允许创建多个唯一索引。</strong> 建立唯一索引的目的大部分时候都是为了该属性列的数据的唯一性，而不是为了查询效率。</li><li> <strong>普通索引(Index)</strong> ：<strong>普通索引的唯一作用就是为了快速查询数据，一张表允许创建多个普通索引，并允许数据重复和 NULL。</strong></li><li> <strong>前缀索引(Prefix)</strong> ：前缀索引只适用于字符串类型的数据。前缀索引是对文本的前几个字符创建索引，相比普通索引建立的数据更小， 因为只取前几个字符。</li></ol><p>二级索引:<br><img src="/images/image_MySQL%E7%B4%A2%E5%BC%95/02.png"></p><h3 id="聚簇索引与非聚簇索引"><a href="#聚簇索引与非聚簇索引" class="headerlink" title="聚簇索引与非聚簇索引"></a>聚簇索引与非聚簇索引</h3><h4 id="聚簇索引（聚集索引）"><a href="#聚簇索引（聚集索引）" class="headerlink" title="聚簇索引（聚集索引）"></a>聚簇索引（聚集索引）</h4><h5 id="聚簇索引介绍"><a href="#聚簇索引介绍" class="headerlink" title="聚簇索引介绍"></a>聚簇索引介绍</h5><p><strong>聚簇索引即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。</strong></p><p>在 MySQL 中，InnoDB 引擎的表的 <code>.ibd</code>文件就包含了该表的索引和数据，对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p><h5 id="聚簇索引的优缺点"><a href="#聚簇索引的优缺点" class="headerlink" title="聚簇索引的优缺点"></a>聚簇索引的优缺点</h5><p><strong>优点</strong> ：</p><ul><li>  <strong>查询速度非常快</strong> ：聚簇索引的查询速度非常的快，因为整个 B+树本身就是一颗多叉平衡树，叶子节点也都是有序的，定位到索引的节点，就相当于定位到了数据。相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li><li>  <strong>对排序查找和范围查找优化</strong> ：聚簇索引对于主键的排序查找和范围查找速度非常快。</li></ul><p><strong>缺点</strong> ：</p><ul><li>  <strong>依赖于有序的数据</strong> ：因为 B+树是多路平衡树，如果索引的数据不是有序的，那么就需要在插入时排序，如果数据是整型还好，否则类似于字符串或 UUID 这种又长又难比较的数据，插入或查找的速度肯定比较慢。</li><li>  <strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改，而且聚簇索引的叶子节点还存放着数据，修改代价肯定是较大的，所以对于主键索引来说，主键一般都是不可被修改的。</li></ul><h4 id="非聚簇索引（非聚集索引）"><a href="#非聚簇索引（非聚集索引）" class="headerlink" title="非聚簇索引（非聚集索引）"></a>非聚簇索引（非聚集索引）</h4><h5 id="非聚簇索引介绍"><a href="#非聚簇索引介绍" class="headerlink" title="非聚簇索引介绍"></a>非聚簇索引介绍</h5><p><strong>非聚簇索引即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</strong></p><p>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</p><h5 id="非聚簇索引的优缺点"><a href="#非聚簇索引的优缺点" class="headerlink" title="非聚簇索引的优缺点"></a>非聚簇索引的优缺点</h5><p><strong>优点</strong> ：</p><p>更新代价比聚簇索引要小 。非聚簇索引的更新代价就没有聚簇索引那么大了，非聚簇索引的叶子节点是不存放数据的</p><p><strong>缺点</strong> ：</p><ul><li>  <strong>依赖于有序的数据</strong> ：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li><li>  <strong>可能会二次查询(回表)</strong> ：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ul><p>这是 MySQL 的表的文件截图:</p><p><img src="/images/image_MySQL%E7%B4%A2%E5%BC%95/03.png"></p><p>聚簇索引和非聚簇索引:</p><p><img src="/images/image_MySQL%E7%B4%A2%E5%BC%95/04.png"></p><h4 id="非聚簇索引一定回表查询吗-覆盖索引"><a href="#非聚簇索引一定回表查询吗-覆盖索引" class="headerlink" title="非聚簇索引一定回表查询吗(覆盖索引)?"></a>非聚簇索引一定回表查询吗(覆盖索引)?</h4><p><strong>非聚簇索引不一定回表查询。</strong></p><p>试想一种情况，用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> name <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">'guang19'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p><p>即使是 MYISAM 也是这样，虽然 MYISAM 的主键索引确实需要回表，因为它的主键索引的叶子节点存放的是指针。但是！<strong>如果 SQL 查的就是主键呢?</strong></p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> id <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> id<span class="token operator">=</span><span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>主键索引本身的 key 就是主键，查到返回就行了。这种情况就称之为覆盖索引了。</p><h3 id="覆盖索引和联合索引"><a href="#覆盖索引和联合索引" class="headerlink" title="覆盖索引和联合索引"></a>覆盖索引和联合索引</h3><h4 id="覆盖索引"><a href="#覆盖索引" class="headerlink" title="覆盖索引"></a>覆盖索引</h4><p>如果一个索引包含（或者说覆盖）所有需要查询的字段的值，我们就称之为“覆盖索引”。我们知道在 InnoDB 存储引擎中，如果不是主键索引，叶子节点存储的是主键+列值。最终还是要“回表”，也就是要通过主键再查找一次。这样就会比较慢覆盖索引就是把要查询出的列和索引是对应的，不做回表操作！</p><p><strong>覆盖索引即需要查询的字段正好是索引的字段，那么直接根据该索引，就可以查到数据了，而无需回表查询。</strong></p><blockquote><p>如主键索引，如果一条 SQL 需要查询主键，那么正好根据主键索引就可以查到主键。</p><p>再如普通索引，如果一条 SQL 需要查询 name，name 字段正好有索引， 那么直接根据这个索引就可以查到数据，也无需回表。</p></blockquote><p><img src="/images/image_MySQL%E7%B4%A2%E5%BC%95/05.png"></p><h4 id="联合索引"><a href="#联合索引" class="headerlink" title="联合索引"></a>联合索引</h4><p>使用表中的多个字段创建索引，就是 <strong>联合索引</strong>，也叫 <strong>组合索引</strong> 或 <strong>复合索引</strong>。</p><h4 id="最左前缀匹配原则"><a href="#最左前缀匹配原则" class="headerlink" title="最左前缀匹配原则"></a>最左前缀匹配原则</h4><p>最左前缀匹配原则指的是，在使用联合索引时，<strong>MySQL</strong> 会根据联合索引中的字段顺序，从左到右依次到查询条件中去匹配，如果查询条件中存在与联合索引中最左侧字段相匹配的字段，则就会使用该字段过滤一批数据，直至联合索引中全部字段匹配完成，或者在执行过程中遇到范围查询（如 **<code>&gt;</code><strong>、</strong><code>&lt;</code>**）才会停止匹配。对于 <strong><code>&gt;=</code><strong>、</strong><code>&lt;=</code><strong>、</strong><code>BETWEEN</code><strong>、</strong><code>like</code></strong> 前缀匹配的范围查询，并不会停止匹配。所以，我们在使用联合索引时，可以将区分度高的字段放在最左边，这也可以过滤更多数据。</p><h3 id="索引下推"><a href="#索引下推" class="headerlink" title="索引下推"></a>索引下推</h3><p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数</p><h3 id="正确使用索引的一些建议"><a href="#正确使用索引的一些建议" class="headerlink" title="正确使用索引的一些建议"></a>正确使用索引的一些建议</h3><h4 id="选择合适的字段创建索引"><a href="#选择合适的字段创建索引" class="headerlink" title="选择合适的字段创建索引"></a>选择合适的字段创建索引</h4><ul><li>  <strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。如果字段频繁被查询，但又避免不了为 NULL，建议使用 0,1,true,false 这样语义较为清晰的短值或短字符作为替代。</li><li>  <strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li><li>  <strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li><li>  <strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li><li>  <strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。</li></ul><h4 id="被频繁更新的字段应该慎重建立索引"><a href="#被频繁更新的字段应该慎重建立索引" class="headerlink" title="被频繁更新的字段应该慎重建立索引"></a>被频繁更新的字段应该慎重建立索引</h4><p>虽然索引能带来查询上的效率，但是维护索引的成本也是不小的。 如果一个字段不被经常查询，反而被经常修改，那么就更不应该在这种字段上建立索引了。</p><h4 id="限制每张表上的索引数量"><a href="#限制每张表上的索引数量" class="headerlink" title="限制每张表上的索引数量"></a>限制每张表上的索引数量</h4><p>索引并不是越多越好，建议单张表索引不超过 5 个！索引可以提高效率同样可以降低效率。</p><p>索引可以增加查询效率，但同样也会降低插入和更新的效率，甚至有些情况下会降低查询效率。</p><p>因为 MySQL 优化器在选择如何优化查询时，会根据统一信息，对每一个可以用到的索引来进行评估，以生成出一个最好的执行计划，如果同时有很多个索引都可以用于查询，就会增加 MySQL 优化器生成执行计划的时间，同样会降低查询性能。</p><h4 id="尽可能的考虑建立联合索引而不是单列索引"><a href="#尽可能的考虑建立联合索引而不是单列索引" class="headerlink" title="尽可能的考虑建立联合索引而不是单列索引"></a>尽可能的考虑建立联合索引而不是单列索引</h4><p>因为索引是需要占用磁盘空间的，可以简单理解为每个索引都对应着一颗 B+树。如果一个表的字段过多，索引过多，那么当这个表的数据达到一个体量后，索引占用的空间也是很多的，且修改索引时，耗费的时间也是较多的。如果是联合索引，多个字段在一个索引上，那么将会节约很大磁盘空间，且修改数据的操作效率也会提升。</p><h4 id="注意避免冗余索引"><a href="#注意避免冗余索引" class="headerlink" title="注意避免冗余索引"></a>注意避免冗余索引</h4><p>冗余索引指的是索引的功能相同，能够命中索引(a, b)就肯定能命中索引(a) ，那么索引(a)就是冗余索引。如（name,city ）和（name ）这两个索引就是冗余索引，能够命中前者的查询肯定是能够命中后者的 在大多数情况下，都应该尽量扩展已有的索引而不是创建新索引。</p><h4 id="字符串类型的字段使用前缀索引代替普通索引"><a href="#字符串类型的字段使用前缀索引代替普通索引" class="headerlink" title="字符串类型的字段使用前缀索引代替普通索引"></a>字符串类型的字段使用前缀索引代替普通索引</h4><p>前缀索引仅限于字符串类型，较普通索引会占用更小的空间，所以可以考虑使用前缀索引带替普通索引。</p><h4 id="避免索引失效"><a href="#避免索引失效" class="headerlink" title="避免索引失效"></a>避免索引失效</h4><p>索引失效也是慢查询的主要原因之一，常见的导致索引失效的情况有下面这些：</p><ul><li>  使用 <code>SELECT *</code> 进行查询;</li><li>  创建了组合索引，但查询条件未遵守最左匹配原则;</li><li>  在索引列上进行计算、函数、类型转换等操作;</li><li>  以 <code>%</code> 开头的 LIKE 查询比如 <code>like '%abc'</code>;</li><li>  查询条件中使用 or，且 or 的前后条件中有一个列没有索引，涉及的索引都不会被使用到;</li><li>  发生隐式转换;</li></ul><h4 id="知道如何分析语句是否走索引查询"><a href="#知道如何分析语句是否走索引查询" class="headerlink" title="知道如何分析语句是否走索引查询"></a>知道如何分析语句是否走索引查询</h4><p>我们可以使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> ，这样就知道语句是否命中索引了。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p><p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><p><code>EXPLAIN</code> 的输出格式如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token identifier"><span class="token punctuation">`</span>score<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>cus_order<span class="token punctuation">`</span></span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token identifier"><span class="token punctuation">`</span>score<span class="token punctuation">`</span></span> <span class="token keyword">DESC</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span>     <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span>   <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra          <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> cus_order <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">997572</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> filesort <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>各个字段的含义如下：</p><p><img src="/images/image_MySQL%E7%B4%A2%E5%BC%95/06.png"></p><h3 id="MySQL隐式转换造成索引失效"><a href="#MySQL隐式转换造成索引失效" class="headerlink" title="MySQL隐式转换造成索引失效"></a>MySQL隐式转换造成索引失效</h3><h4 id="数据准备"><a href="#数据准备" class="headerlink" title="数据准备"></a>数据准备</h4><p>首先使用存储过程生成 1000 万条测试数据， 测试表一共建立了 7 个字段（包括主键），<code>num1</code>和<code>num2</code>保存的是和<code>ID</code>一样的顺序数字，其中<code>num2</code>是字符串类型。 <code>type1</code>和<code>type2</code>保存的都是主键对 5 的取模，目的是模拟实际应用中常用类似 type 类型的数据，但是<code>type2</code>是没有建立索引的。 <code>str1</code>和<code>str2</code>都是保存了一个 20 位长度的随机字符串，<code>str1</code>不能为<code>NULL</code>，<code>str2</code>允许为<code>NULL</code>，相应的生成测试数据的时候我也会在<code>str2</code>字段生产少量<code>NULL</code>值（每 100 条数据产生一个<code>NULL</code>值）。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment">-- 创建测试数据表</span><span class="token keyword">DROP</span> <span class="token keyword">TABLE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> test1<span class="token punctuation">;</span><span class="token keyword">CREATE</span> <span class="token keyword">TABLE</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span>    <span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token identifier"><span class="token punctuation">`</span>num1<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span><span class="token punctuation">,</span>    <span class="token identifier"><span class="token punctuation">`</span>num2<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">,</span>    <span class="token identifier"><span class="token punctuation">`</span>type1<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span><span class="token punctuation">,</span>    <span class="token identifier"><span class="token punctuation">`</span>type2<span class="token punctuation">`</span></span> <span class="token keyword">int</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">'0'</span><span class="token punctuation">,</span>    <span class="token identifier"><span class="token punctuation">`</span>str1<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">NOT</span> <span class="token boolean">NULL</span> <span class="token keyword">DEFAULT</span> <span class="token string">''</span><span class="token punctuation">,</span>    <span class="token identifier"><span class="token punctuation">`</span>str2<span class="token punctuation">`</span></span> <span class="token keyword">varchar</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token keyword">DEFAULT</span> <span class="token boolean">NULL</span><span class="token punctuation">,</span>    <span class="token keyword">PRIMARY</span> <span class="token keyword">KEY</span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>num1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>num1<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>num2<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>num2<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>type1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>type1<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>str1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>str1<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">,</span>    <span class="token keyword">KEY</span> <span class="token identifier"><span class="token punctuation">`</span>str2<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>str2<span class="token punctuation">`</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">ENGINE</span><span class="token operator">=</span><span class="token keyword">InnoDB</span> <span class="token keyword">DEFAULT</span> <span class="token keyword">CHARSET</span><span class="token operator">=</span>utf8<span class="token punctuation">;</span><span class="token comment">-- 创建存储过程</span><span class="token keyword">DROP</span> <span class="token keyword">PROCEDURE</span> <span class="token keyword">IF</span> <span class="token keyword">EXISTS</span> pre_test1<span class="token punctuation">;</span><span class="token keyword">DELIMITER</span> <span class="token comment">//</span><span class="token keyword">CREATE</span> <span class="token keyword">PROCEDURE</span> <span class="token identifier"><span class="token punctuation">`</span>pre_test1<span class="token punctuation">`</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">BEGIN</span>    <span class="token keyword">DECLARE</span> i <span class="token keyword">INT</span> <span class="token keyword">DEFAULT</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">SET</span> autocommit <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">WHILE</span> i <span class="token operator">&lt;</span> <span class="token number">10000000</span> <span class="token keyword">DO</span>        <span class="token keyword">SET</span> i <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">SET</span> <span class="token variable">@str1</span> <span class="token operator">=</span> SUBSTRING<span class="token punctuation">(</span>MD5<span class="token punctuation">(</span>RAND<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">-- 每100条数据str2产生一个null值</span>        <span class="token keyword">IF</span> i <span class="token operator">%</span> <span class="token number">100</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">THEN</span>            <span class="token keyword">SET</span> <span class="token variable">@str2</span> <span class="token operator">=</span> <span class="token boolean">NULL</span><span class="token punctuation">;</span>        <span class="token keyword">ELSE</span>            <span class="token keyword">SET</span> <span class="token variable">@str2</span> <span class="token operator">=</span> <span class="token variable">@str1</span><span class="token punctuation">;</span>        <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>        <span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> test1 <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>num1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>num2<span class="token punctuation">`</span></span><span class="token punctuation">,</span>        <span class="token identifier"><span class="token punctuation">`</span>type1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>type2<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>str1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>str2<span class="token punctuation">`</span></span><span class="token punctuation">)</span>        <span class="token keyword">VALUES</span> <span class="token punctuation">(</span>CONCAT<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> CONCAT<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span>        CONCAT<span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">,</span> i<span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">,</span> i<span class="token operator">%</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token variable">@str1</span><span class="token punctuation">,</span> <span class="token variable">@str2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">-- 事务优化，每一万条数据提交一次事务</span>        <span class="token keyword">IF</span> i <span class="token operator">%</span> <span class="token number">10000</span> <span class="token operator">=</span> <span class="token number">0</span> <span class="token keyword">THEN</span>            <span class="token keyword">COMMIT</span><span class="token punctuation">;</span>        <span class="token keyword">END</span> <span class="token keyword">IF</span><span class="token punctuation">;</span>    <span class="token keyword">END</span> <span class="token keyword">WHILE</span><span class="token punctuation">;</span><span class="token keyword">END</span><span class="token punctuation">;</span><span class="token comment">// DELIMITER ;</span><span class="token comment">-- 执行存储过程</span><span class="token keyword">CALL</span> pre_test1<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>数据量比较大，还涉及使用<code>MD5</code>生成随机字符串，所以速度有点慢，稍安勿躁，耐心等待即可。</p><p>1000 万条数据，我用了 33 分钟才跑完（实际时间跟你电脑硬件配置有关）。这里贴几条生成的数据，大致长这样。</p><p><img src="/images/image_MySQL%E7%B4%A2%E5%BC%95/07.png"></p><h4 id="SQL-测试"><a href="#SQL-测试" class="headerlink" title="SQL 测试"></a>SQL 测试</h4><p>先来看这组 SQL，一共四条，我们的测试数据表<code>num1</code>是<code>int</code>类型，<code>num2</code>是<code>varchar</code>类型，但是存储的数据都是跟主键<code>id</code>一样的顺序数字，两个字段都建立有索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1</span>: <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> num1 <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span><span class="token number">2</span>: <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> num1 <span class="token operator">=</span> <span class="token string">'10000'</span><span class="token punctuation">;</span><span class="token number">3</span>: <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> num2 <span class="token operator">=</span> <span class="token number">10000</span><span class="token punctuation">;</span><span class="token number">4</span>: <span class="token keyword">SELECT</span> <span class="token operator">*</span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token keyword">WHERE</span> num2 <span class="token operator">=</span> <span class="token string">'10000'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这四条 SQL 都是有针对性写的，12 查询的字段是 int 类型，34 查询的字段是<code>varchar</code>类型。12 或 34 查询的字段虽然都相同，但是一个条件是数字，一个条件是用引号引起来的字符串。这样做有什么区别呢？先不看下边的测试结果你能猜出这四条 SQL 的效率顺序吗？</p><p>经测试这四条 SQL 最后的执行结果却相差很大，其中 124 三条 SQL 基本都是瞬间出结果，大概在 0.001<del>0.005 秒，在千万级的数据量下这样的结果可以判定这三条 SQL 性能基本没差别了。但是第三条 SQL，多次测试耗时基本在 4.5</del>4.8 秒之间。</p><p>为什么 34 两条 SQL 效率相差那么大，但是同样做对比的 12 两条 SQL 却没什么差别呢？查看一下执行计划，下边分别 1234 条 SQL 的执行计划数据：</p><p><img src="/images/image_MySQL%E7%B4%A2%E5%BC%95/08.png"></p><p>可以看到，124 三条 SQL 都能使用到索引，连接类型都为<code>ref</code>，扫描行数都为 1，所以效率非常高。再看看第三条 SQL，没有用上索引，所以为全表扫描，<code>rows</code>直接到达 1000 万了，所以性能差别才那么大。</p><p>仔细观察你会发现，34 两条 SQL 查询的字段<code>num2</code>是<code>varchar</code>类型的，查询条件等号右边加引号的第 4 条 SQL 是用到索引的，那么是查询的数据类型和字段数据类型不一致造成的吗？如果是这样那 12 两条 SQL 查询的字段<code>num1</code>是<code>int</code>类型，但是第 2 条 SQL 查询条件右边加了引号为什么还能用上索引呢。</p><p>查阅 MySQL 相关文档发现是隐式转换造成的，看一下官方的描述：</p><blockquote><p>当操作符与不同类型的操作数一起使用时，会发生类型转换以使操作数兼容。某些转换是隐式发生的。例如，MySQL 会根据需要自动将字符串转换为数字，反之亦然。以下规则描述了比较操作的转换方式：</p><ol><li> 两个参数至少有一个是<code>NULL</code>时，比较的结果也是<code>NULL</code>，特殊的情况是使用<code>&lt;=&gt;</code>对两个<code>NULL</code>做比较时会返回<code>1</code>，这两种情况都不需要做类型转换</li><li> 两个参数都是字符串，会按照字符串来比较，不做类型转换</li><li> 两个参数都是整数，按照整数来比较，不做类型转换</li><li> 十六进制的值和非数字做比较时，会被当做二进制串</li><li> 有一个参数是<code>TIMESTAMP</code>或<code>DATETIME</code>，并且另外一个参数是常量，常量会被转换为<code>timestamp</code></li><li> 有一个参数是<code>decimal</code>类型，如果另外一个参数是<code>decimal</code>或者整数，会将整数转换为<code>decimal</code>后进行比较，如果另外一个参数是浮点数，则会把<code>decimal</code>转换为浮点数进行比较</li><li> <strong>所有其他情况下，两个参数都会被转换为浮点数再进行比较</strong></li></ol></blockquote><p>根据官方文档的描述，我们的第 23 两条 SQL 都发生了隐式转换，第 2 条 SQL 的查询条件<code>num1 = '10000'</code>，左边是<code>int</code>类型右边是字符串，第 3 条 SQL 相反，那么根据官方转换规则第 7 条，左右两边都会转换为浮点数再进行比较。</p><p>先看第 2 条 SQL：<code>SELECT * FROM</code>test1<code>WHERE num1 = '10000';</code> <strong>左边为 int 类型</strong><code>10000</code>，转换为浮点数还是<code>10000</code>，右边字符串类型<code>'10000'</code>，转换为浮点数也是<code>10000</code>。两边的转换结果都是唯一确定的，所以不影响使用索引。</p><p>第 3 条 SQL：<code>SELECT * FROM</code>test1<code>WHERE num2 = 10000;</code> <strong>左边是字符串类型</strong><code>'10000'</code>，转浮点数为 10000 是唯一的，右边<code>int</code>类型<code>10000</code>转换结果也是唯一的。但是，因为左边是检索条件，<code>'10000'</code>转到<code>10000</code>虽然是唯一，但是其他字符串也可以转换为<code>10000</code>，比如<code>'10000a'</code>，<code>'010000'</code>，<code>'10000'</code>等等都能转为浮点数<code>10000</code>，这样的情况下，是不能用到索引的。</p><p>关于这个<strong>隐式转换</strong>我们可以通过查询测试验证一下，先插入几条数据，其中<code>num2='10000a'</code>、<code>'010000'</code>和<code>'10000'</code>：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>num1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>num2<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>type1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>type2<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>str1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>str2<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'10000001'</span><span class="token punctuation">,</span> <span class="token string">'10000'</span><span class="token punctuation">,</span> <span class="token string">'10000a'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'2df3d9465ty2e4hd523'</span><span class="token punctuation">,</span> <span class="token string">'2df3d9465ty2e4hd523'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>num1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>num2<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>type1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>type2<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>str1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>str2<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'10000002'</span><span class="token punctuation">,</span> <span class="token string">'10000'</span><span class="token punctuation">,</span> <span class="token string">'010000'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'2df3d9465ty2e4hd523'</span><span class="token punctuation">,</span> <span class="token string">'2df3d9465ty2e4hd523'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">INSERT</span> <span class="token keyword">INTO</span> <span class="token identifier"><span class="token punctuation">`</span>test1<span class="token punctuation">`</span></span> <span class="token punctuation">(</span><span class="token identifier"><span class="token punctuation">`</span>id<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>num1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>num2<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>type1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>type2<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>str1<span class="token punctuation">`</span></span><span class="token punctuation">,</span> <span class="token identifier"><span class="token punctuation">`</span>str2<span class="token punctuation">`</span></span><span class="token punctuation">)</span> <span class="token keyword">VALUES</span> <span class="token punctuation">(</span><span class="token string">'10000003'</span><span class="token punctuation">,</span> <span class="token string">'10000'</span><span class="token punctuation">,</span> <span class="token string">' 10000'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'0'</span><span class="token punctuation">,</span> <span class="token string">'2df3d9465ty2e4hd523'</span><span class="token punctuation">,</span> <span class="token string">'2df3d9465ty2e4hd523'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>然后使用第三条 SQL 语句<code>SELECT * FROM</code>test1<code>WHERE num2 = 10000;</code>进行查询：<br><img src="/images/image_MySQL%E7%B4%A2%E5%BC%95/09.png"></p><p>从结果可以看到，后面插入的三条数据也都匹配上了。那么这个字符串隐式转换的规则是什么呢？为什么<code>num2='10000a'</code>、<code>'010000'</code>和<code>'10000'</code>这三种情形都能匹配上呢？查阅相关资料发现规则如下：</p><ol><li> <strong>不以数字开头</strong>的字符串都将转换为<code>0</code>。如<code>'abc'</code>、<code>'a123bc'</code>、<code>'abc123'</code>都会转化为<code>0</code>；</li><li> <strong>以数字开头的</strong>字符串转换时会进行截取，从第一个字符截取到第一个非数字内容为止。比如<code>'123abc'</code>会转换为<code>123</code>，<code>'012abc'</code>会转换为<code>012</code>也就是<code>12</code>，<code>'5.3a66b78c'</code>会转换为<code>5.3</code>，其他同理。</li></ol><p>现对以上规则做如下测试验证：</p><p><img src="/images/image_MySQL%E7%B4%A2%E5%BC%95/10.png"></p><p>如此也就印证了之前的查询结果了。</p><p>再次写一条 SQL 查询 str1 字段：<code>SELECT * FROM</code>test1<code>WHERE str1 = 1234;</code><br><img src="/images/image_MySQL%E7%B4%A2%E5%BC%95/11.png"></p><h4 id="分析和总结"><a href="#分析和总结" class="headerlink" title="分析和总结"></a>分析和总结</h4><p>通过上面的测试我们发现 MySQL 使用操作符的一些特性：</p><ol><li> 当操作符<strong>左右两边的数据类型不一致</strong>时，会发生<strong>隐式转换</strong>。</li><li> 当 where 查询操作符<strong>左边为数值类型</strong>时发生了隐式转换，那么对效率影响不大，但还是不推荐这么做。</li><li> 当 where 查询操作符<strong>左边为字符类型</strong>时发生了隐式转换，那么会导致索引失效，造成全表扫描效率极低。</li><li> 字符串转换为数值类型时，非数字开头的字符串会转化为<code>0</code>，以数字开头的字符串会截取从第一个字符到第一个非数字内容为止的值为转化结果。</li></ol><p>所以，我们在写 SQL 时一定要养成良好的习惯，查询的字段是什么类型，等号右边的条件就写成对应的类型。特别当查询的字段是字符串时，等号右边的条件一定要用引号引起来标明这是一个字符串，否则会造成索引失效触发全表扫描。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;索引介绍&quot;&gt;&lt;a href=&quot;#索引介绍&quot; class=&quot;headerlink&quot; title=&quot;索引介绍&quot;&gt;&lt;/a&gt;索引介绍&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。&lt;/strong&gt;&lt;/p&gt;</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://ailiaa.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>MySQL</title>
    <link href="http://ailiaa.github.io/2023/03/10/mysql/"/>
    <id>http://ailiaa.github.io/2023/03/10/mysql/</id>
    <published>2023-03-10T09:08:45.000Z</published>
    <updated>2023-03-11T07:41:05.241Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-MySQL-基础"><a href="#1-MySQL-基础" class="headerlink" title="1. MySQL 基础"></a>1. MySQL 基础</h3><h4 id="什么是关系型数据库？"><a href="#什么是关系型数据库？" class="headerlink" title="什么是关系型数据库？"></a>什么是关系型数据库？</h4><p>顾名思义，关系型数据库（RDBMS，Relational Database Management System）就是一种建立在关系模型的基础上的数据库。关系模型表明了数据库中所存储的数据之间的联系（一对一、一对多、多对多）。</p><p>关系型数据库中，我们的数据都被存放在了各种表中（比如用户表），表中的每一行就存放着一条数据（比如一个用户的信息）。</p><p>大部分关系型数据库都使用 SQL 来操作数据库中的数据。并且，大部分关系型数据库都支持事务的四大特性(ACID)。</p><p><strong>有哪些常见的关系型数据库呢？</strong></p><p>MySQL、PostgreSQL、Oracle、SQL Server、SQLite（微信本地的聊天记录的存储就是用的 SQLite） ……</p><h4 id="什么是-SQL？"><a href="#什么是-SQL？" class="headerlink" title="什么是 SQL？"></a>什么是 SQL？</h4><p>SQL 是一种结构化查询语言(Structured Query Language)，专门用来与数据库打交道，目的是提供一种从数据库中读写数据的简单有效的方法。</p><p>几乎所有的主流关系数据库都支持 SQL ，适用性非常强。并且，一些非关系型数据库也兼容 SQL 或者使用的是类似于 SQL 的查询语言。</p><p>SQL 可以帮助我们：</p><ul><li>  新建数据库、数据表、字段；</li><li>  在数据库中增加，删除，修改，查询数据；</li><li>  新建视图、函数、存储过程；</li><li>  对数据库中的数据进行简单的数据分析；</li><li>  搭配 Hive，Spark SQL 做大数据；</li><li>  搭配 SQLFlow 做机器学习；</li></ul><h4 id="什么是-MySQL？"><a href="#什么是-MySQL？" class="headerlink" title="什么是 MySQL？"></a>什么是 MySQL？</h4><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p><p>由于 MySQL 是开源免费并且比较成熟的数据库，因此，MySQL 被大量使用在各种系统中。MySQL 的默认端口号是<strong>3306</strong>。</p><h4 id="MySQL-的优点"><a href="#MySQL-的优点" class="headerlink" title="MySQL 的优点"></a>MySQL 的优点</h4><p>这个问题本质上是在问 MySQL 如此流行的原因。</p><p>MySQL 主要具有下面这些优点：</p><ol><li> 成熟稳定，功能完善。</li><li> 开源免费。</li><li> 文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li><li> 开箱即用，操作简单，维护成本低。</li><li> 兼容性好，支持常见的操作系统，支持多种开发语言。</li><li> 社区活跃，生态完善。</li><li> 事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li><li> 支持分库分表、读写分离、高可用。</li></ol><h3 id="2-MySQL-基础架构"><a href="#2-MySQL-基础架构" class="headerlink" title="2. MySQL 基础架构"></a>2. MySQL 基础架构</h3><p>下图是 MySQL 的一个简要架构图，从下图你可以很清晰的看到客户端的一条 SQL 语句在 MySQL 内部是如何执行的。<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/08.png"><br>从上图可以看出， MySQL 主要由下面几部分构成：</p><ul><li>  <strong>连接器：</strong> 身份认证和权限相关(登录 MySQL 的时候)。</li><li>  <strong>查询缓存：</strong> 执行查询语句的时候，会先查询缓存（MySQL 8.0 版本后移除，因为这个功能不太实用）。</li><li>  <strong>分析器：</strong> 没有命中缓存的话，SQL 语句就会经过分析器，分析器说白了就是要先看你的 SQL 语句要干嘛，再检查你的 SQL 语句语法是否正确。</li><li>  <strong>优化器：</strong> 按照 MySQL 认为最优的方案去执行。</li><li>  <strong>执行器：</strong> 执行语句，然后从存储引擎返回数据。 执行语句之前会先判断是否有权限，如果没有权限的话，就会报错。</li><li>  <strong>插件式存储引擎</strong> ： 主要负责数据的存储和读取，采用的是插件式架构，支持 InnoDB、MyISAM、Memory 等多种存储引擎。</li></ul><h3 id="3-MySQL-存储引擎"><a href="#3-MySQL-存储引擎" class="headerlink" title="3. MySQL 存储引擎"></a>3. MySQL 存储引擎</h3><p>MySQL 核心在于存储引擎</p><h4 id="MySQL-支持的存储引擎，默认使用哪个"><a href="#MySQL-支持的存储引擎，默认使用哪个" class="headerlink" title="MySQL 支持的存储引擎，默认使用哪个"></a>MySQL 支持的存储引擎，默认使用哪个</h4><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/09.png"></p><p>MySQL 5.5.5 之前，MyISAM 是 MySQL 的默认存储引擎。5.5.5 版本之后，InnoDB 是 MySQL 的默认存储引擎。</p><h4 id="MySQL-存储引擎架构"><a href="#MySQL-存储引擎架构" class="headerlink" title="MySQL 存储引擎架构"></a>MySQL 存储引擎架构</h4><p>MySQL 存储引擎采用的是 <strong>插件式架构</strong> ，支持多种存储引擎，我们甚至可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><p>并且，还可以根据 MySQL 定义的存储引擎实现标准接口来编写一个属于自己的存储引擎。这些非官方提供的存储引擎可以称为第三方存储引擎，区别于官方存储引擎。</p><h4 id="MyISAM-和-InnoDB-的区别"><a href="#MyISAM-和-InnoDB-的区别" class="headerlink" title="MyISAM 和 InnoDB 的区别"></a>MyISAM 和 InnoDB 的区别</h4><p><strong>1.是否支持行级锁</strong></p><p>MyISAM 只有表级锁(table-level locking)，而 InnoDB 支持行级锁(row-level locking)和表级锁,默认为行级锁。</p><p>也就说，MyISAM 一锁就是锁住了整张表，这在并发写的情况下性能很差。</p><p><strong>2.是否支持事务</strong></p><p>MyISAM 不提供事务支持。</p><p>InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别，具有提交(commit)和回滚(rollback)事务的能力。并且，InnoDB 默认使用的 REPEATABLE-READ（可重读）隔离级别是可以解决幻读问题发生的（基于 MVCC 和 Next-Key Lock）。</p><p><strong>3.是否支持外键</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>外键对于维护数据一致性非常有帮助，但是对性能有一定的损耗。因此，通常情况下，不建议在实际生产项目中使用外键，在业务代码中进行约束即可</p><p><strong>4.是否支持数据库异常崩溃后的安全恢复</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>使用 InnoDB 的数据库在异常崩溃后，数据库重新启动的时候会保证数据库恢复到崩溃前的状态。这个恢复的过程依赖于 <code>redo log</code> 。</p><p><strong>5.是否支持 MVCC</strong></p><p>MyISAM 不支持，而 InnoDB 支持。</p><p>MyISAM 连行级锁都不支持。MVCC 可以看作是行级锁的一个升级，可以有效减少加锁操作，提高性能。</p><p><strong>6.索引实现不一样。</strong></p><p>虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</p><p>InnoDB 引擎中，其数据文件本身就是索引文件。相比 MyISAM，索引文件和数据文件是分离的，其表数据文件本身就是按 B+Tree 组织的一个索引结构，树的叶节点 data 域保存了完整的数据记录。</p><p><strong>7.性能有差别。</strong></p><p>InnoDB 的性能比 MyISAM 更强大，不管是在读写混合模式下还是只读模式下，随着 CPU 核数的增加，InnoDB 的读写能力呈线性增长。MyISAM 因为读写不能并发，它的处理能力跟核数没关系。</p><p><strong>总结</strong> ：</p><ul><li>  InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li><li>  MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li><li>  MyISAM 不支持外键，而 InnoDB 支持。</li><li>  MyISAM 不支持 MVCC，而 InnoDB 支持。</li><li>  虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。</li><li>  MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li><li>  InnoDB 的性能比 MyISAM 更强大。</li></ul><h3 id="4-MySQL-事务"><a href="#4-MySQL-事务" class="headerlink" title="4. MySQL 事务"></a>4. MySQL 事务</h3><h4 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h4><p>我们设想一个场景，这个场景中我们需要插入多条相关联的数据到数据库，不幸的是，这个过程可能会遇到下面这些问题：</p><ul><li>  数据库中途突然因为某些原因挂掉了。</li><li>  客户端突然因为网络原因连接不上数据库了。</li><li>  并发访问数据库时，多个线程同时写入数据库，覆盖了彼此的更改。</li></ul><p>上面的任何一个问题都可能会导致数据的不一致性。为了保证数据的一致性，系统必须能够处理这些问题。事务就是我们抽象出来简化这些问题的首选机制。事务的概念起源于数据库，目前，已经成为一个比较广泛的概念。</p><p><strong>何为事务？</strong> 一言蔽之，<strong>事务是逻辑上的一组操作，要么都执行，要么都不执行。</strong></p><p>事务最经典也经常被拿出来说例子就是转账了。假如小明要给小红转账 1000 元，这个转账会涉及到两个关键操作，这两个操作必须都成功或者都失败。</p><ol><li> 将小明的余额减少 1000 元</li><li> 将小红的余额增加 1000 元。</li></ol><p>事务会把这两个操作就可以看成逻辑上的一个整体，这个整体包含的操作要么都成功，要么都要失败。这样就不会出现小明余额减少而小红的余额却并没有增加的情况。</p><h4 id="数据库事务"><a href="#数据库事务" class="headerlink" title="数据库事务"></a>数据库事务</h4><p>大多数情况下，我们在谈论事务的时候，如果没有特指<strong>分布式事务</strong>，往往指的就是<strong>数据库事务</strong>。</p><p>数据库事务在我们日常开发中接触的最多了。如果你的项目属于单体架构的话，你接触到的往往就是数据库事务了。</p><p><strong>那数据库事务有什么作用呢？</strong></p><p>简单来说，数据库事务可以保证多个对数据库的操作（也就是 SQL 语句）构成一个逻辑上的整体。构成这个逻辑上的整体的这些数据库操作遵循：<strong>要么全部执行成功,要么全部不执行</strong> 。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/10.png"></p><p>另外，关系型数据库（例如：<code>MySQL</code>、<code>SQL Server</code>、<code>Oracle</code>&nbsp;等）事务都有&nbsp;<strong>ACID</strong>&nbsp;特性：</p><ul><li>  <strong>原子性</strong>（<code>Atomicity</code>） ： 事务是最小的执行单位，不允许分割。事务的原子性确保动作要么全部完成，要么完全不起作用；</li><li>  <strong>一致性</strong>（<code>Consistency</code>）： 执行事务前后，数据保持一致，例如转账业务中，无论事务是否成功，转账者和收款人的总额应该是不变的；</li><li>  <strong>隔离性</strong>（<code>Isolation</code>）： 并发访问数据库时，一个用户的事务不被其他事务所干扰，各并发事务之间数据库是独立的；</li><li>  <strong>持久性</strong>（<code>Durability</code>）： 一个事务被提交之后。它对数据库中数据的改变是持久的，即使数据库发生故障也不应该对其有任何影响。</li></ul><p><strong>只有保证了事务的持久性、原子性、隔离性之后，一致性才能得到保障。也就是说 A、I、D 是手段，C 是目的</strong></p><h4 id="并发事务带来了的问题"><a href="#并发事务带来了的问题" class="headerlink" title="并发事务带来了的问题"></a>并发事务带来了的问题</h4><p>在典型的应用程序中，多个事务并发运行，经常会操作相同的数据来完成各自的任务（多个用户对同一数据进行操作）。并发虽然是必须的，但可能会导致以下的问题。</p><h5 id="脏读（Dirty-read）"><a href="#脏读（Dirty-read）" class="headerlink" title="脏读（Dirty read）"></a>脏读（Dirty read）</h5><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据，这也就是脏读的由来。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 1 修改 A=A-1，事务 2 读取到 A = 19,事务 1 回滚导致对 A 的修改并为提交到数据库， A 的值还是 20。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/11.png"></p><h5 id="丢失修改（Lost-to-modify）"><a href="#丢失修改（Lost-to-modify）" class="headerlink" title="丢失修改（Lost to modify）"></a>丢失修改（Lost to modify）</h5><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 先修改 A=A-1，事务 2 后来也修改 A=A-1，最终结果 A=19，事务 1 的修改被丢失。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/12.png"></p><h5 id="不可重复读（Unrepeatable-read）"><a href="#不可重复读（Unrepeatable-read）" class="headerlink" title="不可重复读（Unrepeatable read）"></a>不可重复读（Unrepeatable read）</h5><p>指在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。这就发生了在一个事务内两次读到的数据是不一样的情况，因此称为不可重复读。</p><p>例如：事务 1 读取某表中的数据 A=20，事务 2 也读取 A=20，事务 1 修改 A=A-1，事务 2 再次读取 A =19，此时读取的结果和第一次读取的结果不同。<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/13.png"></p><h5 id="幻读（Phantom-read）"><a href="#幻读（Phantom-read）" class="headerlink" title="幻读（Phantom read）"></a>幻读（Phantom read）</h5><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><p>例如：事务 2 读取某个范围的数据，事务 1 在这个范围插入了新的数据，事务 2 再次读取这个范围的数据发现相比于第一次读取的结果多了新的数据。<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/14.png"></p><h4 id="不可重复读和幻读的区别"><a href="#不可重复读和幻读的区别" class="headerlink" title="不可重复读和幻读的区别"></a>不可重复读和幻读的区别</h4><ul><li>  不可重复读的重点是内容修改或者记录减少比如多次读取一条记录发现其中某些记录的值被修改；</li><li>  幻读的重点在于记录新增比如多次执行同一条查询语句（DQL）时，发现查到的记录增加了。</li></ul><p>幻读其实可以看作是不可重复读的一种特殊情况，单独把区分幻读的原因主要是解决幻读和不可重复读的方案不一样。</p><p>举个例子：执行 <code>delete</code> 和 <code>update</code> 操作的时候，可以直接对记录加锁，保证事务安全。而执行 <code>insert</code> 操作的时候，由于记录锁（Record Lock）只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁（Gap Lock）。也就是说执行 <code>insert</code> 操作的时候需要依赖 Next-Key Lock（Record Lock+Gap Lock） 进行加锁来保证不出现幻读。</p><h4 id="并发事务的控制方式"><a href="#并发事务的控制方式" class="headerlink" title="并发事务的控制方式"></a>并发事务的控制方式</h4><p>MySQL 中并发事务的控制方式无非就两种：<strong>锁</strong> 和 <strong>MVCC</strong>。锁可以看作是悲观控制的模式，多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式。</p><p><strong>锁</strong> 控制方式下会通过锁来显示控制共享资源而不是通过调度手段，MySQL 中主要是通过 <strong>读写锁</strong> 来实现并发控制。</p><ul><li>  <strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li>  <strong>排他锁（X 锁）</strong> ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条记录加任何类型的锁（锁不兼容）。</li></ul><p>读写锁可以做到读读并行，但是无法做到写读、写写并行。另外，根据根据锁粒度的不同，又被分为 <strong>表级锁(table-level locking)</strong> 和 <strong>行级锁(row-level locking)</strong> 。InnoDB 不光支持表级锁，还支持行级锁，默认为行级锁。行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类。</p><p><strong>MVCC</strong> 是多版本并发控制方法，即对一份数据会存储多个版本，通过事务的可见性来保证事务能看到自己应该看到的版本。通常会有一个全局的版本分配器来为每一行数据设置版本号，版本号是唯一的。</p><p>MVCC 在 MySQL 中实现所依赖的手段主要是: <strong>隐藏字段、read view、undo log</strong>。</p><ul><li>  undo log : undo log 用于记录某行数据的多个版本的数据。</li><li>  read view 和 隐藏字段 : 用来判断当前版本数据的可见性。</li></ul><h4 id="SQL-标准定义的事务隔离级别"><a href="#SQL-标准定义的事务隔离级别" class="headerlink" title="SQL 标准定义的事务隔离级别"></a>SQL 标准定义的事务隔离级别</h4><p>SQL 标准定义了四个隔离级别：</p><ul><li>  <strong>READ-UNCOMMITTED(读取未提交)</strong> ： 最低的隔离级别，允许读取尚未提交的数据变更，可能会导致脏读、幻读或不可重复读。</li><li>  <strong>READ-COMMITTED(读取已提交)</strong> ： 允许读取并发事务已经提交的数据，可以阻止脏读，但是幻读或不可重复读仍有可能发生。</li><li>  <strong>REPEATABLE-READ(可重复读)</strong> ： 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，可以阻止脏读和不可重复读，但幻读仍有可能发生。</li><li>  <strong>SERIALIZABLE(可串行化)</strong> ： 最高的隔离级别，完全服从 ACID 的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，该级别可以防止脏读、不可重复读以及幻读。<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/15.png"></li></ul><p>MySQL InnoDB 存储引擎的默认支持的隔离级别是&nbsp;<strong>REPEATABLE-READ（可重读）</strong>。</p><h4 id="MySQL-的隔离级别是基于锁实现的吗？"><a href="#MySQL-的隔离级别是基于锁实现的吗？" class="headerlink" title="MySQL 的隔离级别是基于锁实现的吗？"></a>MySQL 的隔离级别是基于锁实现的吗？</h4><p>MySQL 的隔离级别基于锁和 MVCC 机制共同实现的。</p><p>SERIALIZABLE 隔离级别是通过锁来实现的，READ-COMMITTED 和 REPEATABLE-READ 隔离级别是基于 MVCC 实现的。不过， SERIALIZABLE 之外的其他隔离级别可能也需要用到锁机制，就比如 REPEATABLE-READ 在当前读情况下需要使用加锁读来保证不会出现幻读。</p><h3 id="5-MySQL-锁"><a href="#5-MySQL-锁" class="headerlink" title="5. MySQL 锁"></a>5. MySQL 锁</h3><p>锁是一种常见的并发事务的控制方式。</p><h4 id="表级锁和行级锁，有什么区别"><a href="#表级锁和行级锁，有什么区别" class="headerlink" title="表级锁和行级锁，有什么区别"></a>表级锁和行级锁，有什么区别</h4><p>MyISAM 仅仅支持表级锁(table-level locking)，一锁就锁整张表，这在并发写的情况下性非常差。InnoDB 不光支持表级锁(table-level locking)，还支持行级锁(row-level locking)，默认为行级锁。</p><p>行级锁的粒度更小，仅对相关的记录上锁即可（对一行或者多行记录加锁），所以对于并发写入操作来说， InnoDB 的性能更高。</p><p><strong>表级锁和行级锁对比</strong> ：</p><ul><li>  <strong>表级锁：</strong> MySQL 中锁定粒度最大的一种锁（全局锁除外），是针对非索引字段加的锁，对当前操作的整张表加锁，实现简单，资源消耗也比较少，加锁快，不会出现死锁。不过，触发锁冲突的概率最高，高并发下效率极低。表级锁和存储引擎无关，MyISAM 和 InnoDB 引擎都支持表级锁。</li><li>  <strong>行级锁：</strong> MySQL 中锁定粒度最小的一种锁，是 <strong>针对索引字段加的锁</strong> ，只针对当前操作的行记录进行加锁。 行级锁能大大减少数据库操作的冲突。其加锁粒度最小，并发度高，但加锁的开销也最大，加锁慢，会出现死锁。行级锁和存储引擎有关，是在存储引擎层面实现的。</li></ul><h4 id="行级锁的使用注意事项"><a href="#行级锁的使用注意事项" class="headerlink" title="行级锁的使用注意事项"></a>行级锁的使用注意事项</h4><p>InnoDB 的行锁是针对索引字段加的锁，表级锁是针对非索引字段加的锁。当我们执行 <code>UPDATE</code>、<code>DELETE</code> 语句时，如果 <code>WHERE</code>条件中字段没有命中唯一索引或者索引失效的话，就会导致扫描全表对表中的所有行记录进行加锁。这个在我们日常工作开发中经常会遇到，一定要多多注意！</p><p>不过，很多时候即使用了索引也有可能会走全表扫描，这是因为 MySQL 优化器的原因。</p><h4 id="InnoDB-行锁"><a href="#InnoDB-行锁" class="headerlink" title="InnoDB 行锁"></a>InnoDB 行锁</h4><p>InnoDB 行锁是通过对索引数据页上的记录加锁实现的，MySQL InnoDB 支持三种行锁定方式：</p><ul><li>  <strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</li><li>  <strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li><li>  <strong>临键锁（Next-Key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要目的是为了解决幻读问题（MySQL 事务部分提到过）。记录锁只能锁住已经存在的记录，为了避免插入新记录，需要依赖间隙锁。</li></ul><p><strong>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock。但是，如果操作的索引是唯一索引或主键，InnoDB 会对 Next-Key Lock 进行优化，将其降级为 Record Lock，即仅锁住索引本身，而不是范围。</strong></p><h4 id="共享锁和排他锁"><a href="#共享锁和排他锁" class="headerlink" title="共享锁和排他锁"></a>共享锁和排他锁</h4><p>不论是表级锁还是行级锁，都存在共享锁（Share Lock，S 锁）和排他锁（Exclusive Lock，X 锁）这两类：</p><ul><li>  <strong>共享锁（S 锁）</strong> ：又称读锁，事务在读取记录的时候获取共享锁，允许多个事务同时获取（锁兼容）。</li><li>  <strong>排他锁（X 锁）</strong> ：又称写锁/独占锁，事务在修改记录的时候获取排他锁，不允许多个事务同时获取。如果一个记录已经被加了排他锁，那其他事务不能再对这条事务加任何类型的锁（锁不兼容）。</li></ul><p>排他锁与任何的锁都不兼容，共享锁仅和共享锁兼容。</p><p>由于 MVCC 的存在，对于一般的&nbsp;<code>SELECT</code>&nbsp;语句，InnoDB 不会加任何锁。不过， 你可以通过以下语句显式加共享锁或排他锁。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 共享锁</span><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token punctuation">;</span><span class="token comment"># 排他锁</span><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="意向锁有的作用"><a href="#意向锁有的作用" class="headerlink" title="意向锁有的作用"></a>意向锁有的作用</h4><p>如果需要用到表锁的话，如何判断表中的记录没有行锁呢，一行一行遍历肯定是不行，性能太差。我们需要用到一个叫做意向锁的东西来快速判断是否可以对某个表使用表锁。</p><p>意向锁是表级锁，共有两种：</p><ul><li>  <strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</li><li>  <strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</li></ul><p><strong>意向锁是有数据引擎自己维护的，用户无法手动操作意向锁，在为数据行加共享/排他锁之前，InooDB 会先获取该数据行所在在数据表的对应意向锁。</strong></p><p>意向锁之间是互相兼容的。</p><p>意向锁和共享锁和排它锁互斥（这里指的是表级别的共享锁和排他锁，意向锁不会与行级的共享锁和排他锁互斥）。</p><h4 id="当前读和快照读的区别"><a href="#当前读和快照读的区别" class="headerlink" title="当前读和快照读的区别"></a>当前读和快照读的区别</h4><p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句，但不包括下面这两类 <code>SELECT</code> 语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>快照即记录的历史版本，每行记录可能存在多个历史版本（多版本技术）。</p><p>快照读的情况下，如果读取的记录正在执行 UPDATE/DELETE 操作，读取操作不会因此去等待记录上 X 锁的释放，而是会去读取行的一个快照。</p><p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li>  在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li><li>  在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li></ul><p>快照读比较适合对于数据一致性要求不是特别高且追求极致性能的业务场景。</p><p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p><p>当前读的一些常见 SQL 语句类型如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 对读的记录加一个X锁</span><span class="token keyword">SELECT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token comment"># 对读的记录加一个S锁</span><span class="token keyword">SELECT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token comment"># 对修改的记录加一个X锁</span><span class="token keyword">INSERT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">UPDATE</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">DELETE</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="6-能用-MySQL-直接存储文件（比如图片）吗？"><a href="#6-能用-MySQL-直接存储文件（比如图片）吗？" class="headerlink" title="6. 能用 MySQL 直接存储文件（比如图片）吗？"></a>6. 能用 MySQL 直接存储文件（比如图片）吗？</h3><p>可以是可以，直接存储文件对应的二进制数据即可。不过，还是建议不要在数据库中存储文件，会严重影响数据库性能，消耗过多存储空间。</p><p>可以选择使用云服务厂商提供的开箱即用的文件存储服务，成熟稳定，价格也比较低。</p><p>也可以选择自建文件存储服务，实现起来也不难，基于 FastDFS、MinIO（推荐） 等开源项目就可以实现分布式文件服务。</p><p><strong>数据库只存储文件地址信息，文件由文件存储服务负责存储。</strong></p><h3 id="7-MySQL-存储-IP-地址"><a href="#7-MySQL-存储-IP-地址" class="headerlink" title="7. MySQL 存储 IP 地址"></a>7. MySQL 存储 IP 地址</h3><p>可以将 IP 地址转换成整形数据存储，性能更好，占用空间也更小。</p><p>MySQL 提供了两个方法来处理 ip 地址</p><ul><li>  <code>INET_ATON()</code> ： 把 ip 转为无符号整型 (4-8 位)</li><li>  <code>INET_NTOA()</code> :把整型的 ip 转为地址</li></ul><p>插入数据前，先用 <code>INET_ATON()</code> 把 ip 地址转为整型，显示数据时，使用 <code>INET_NTOA()</code> 把整型的 ip 地址转为地址显示即可。</p><h3 id="8-MySQL时间类型数据存储建议"><a href="#8-MySQL时间类型数据存储建议" class="headerlink" title="8. MySQL时间类型数据存储建议"></a>8. MySQL时间类型数据存储建议</h3><h4 id="不要用字符串存储日期"><a href="#不要用字符串存储日期" class="headerlink" title="不要用字符串存储日期"></a>不要用字符串存储日期</h4><p>这种存储日期的方式的优点还是有的，就是简单直白，容易上手。</p><p>但是，这是不正确的做法，主要会有下面两个问题：</p><ol><li> 字符串占用的空间更大！</li><li> 字符串存储的日期效率比较低（逐个字符进行比对），无法用日期相关的 API 进行计算和比较。</li></ol><h4 id="Datetime-和-Timestamp-之间抉择"><a href="#Datetime-和-Timestamp-之间抉择" class="headerlink" title="Datetime 和 Timestamp 之间抉择"></a>Datetime 和 Timestamp 之间抉择</h4><p>Datetime 和 Timestamp 是 MySQL 提供的两种比较相似的保存时间的数据类型。他们两者究竟该如何选择呢？</p><p><strong>通常我们都会首选 Timestamp。</strong> 下面说一下为什么这样做!</p><h4 id="DateTime-类型没有时区信息"><a href="#DateTime-类型没有时区信息" class="headerlink" title="DateTime 类型没有时区信息"></a>DateTime 类型没有时区信息</h4><p><strong>DateTime 类型是没有时区信息的（时区无关）</strong> ，DateTime 类型保存的时间都是当前会话所设置的时区对应的时间。这样就会有什么问题呢？当你的时区更换之后，比如你的服务器更换地址或者更换客户端连接时区设置的话，就会导致你从数据库中读出的时间错误。不要小看这个问题，很多系统就是因为这个问题闹出了很多笑话。</p><p><strong>Timestamp 和时区有关</strong>。Timestamp 类型字段的值会随着服务器时区的变化而变化，自动换算成相应的时间，说简单点就是在不同时区，查询到同一个条记录此字段的值会不一样。</p><h4 id="DateTime-类型耗费空间更大"><a href="#DateTime-类型耗费空间更大" class="headerlink" title="DateTime 类型耗费空间更大"></a>DateTime 类型耗费空间更大</h4><p>Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间。但是，这样同样造成了一个问题，Timestamp 表示的时间范围更小。</p><h4 id="数值型时间戳是更好的选择吗？"><a href="#数值型时间戳是更好的选择吗？" class="headerlink" title="数值型时间戳是更好的选择吗？"></a>数值型时间戳是更好的选择吗？</h4><p>很多时候，我们也会使用 int 或者 bigint 类型的数值也就是时间戳来表示时间。</p><p>这种存储方式的具有 Timestamp 类型的所具有一些优点，并且使用它的进行日期排序以及对比等操作的效率会更高，跨系统也很方便，毕竟只是存放的数值。缺点也很明显，就是数据的可读性太差了，你无法直观的看到具体时间。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/22.jpg"></p><h3 id="9-分析-SQL-的性能"><a href="#9-分析-SQL-的性能" class="headerlink" title="9. 分析 SQL 的性能"></a>9. 分析 SQL 的性能</h3><p>我们可以使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> 。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p><p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><p><code>EXPLAIN</code> 适用于 <code>SELECT</code>, <code>DELETE</code>, <code>INSERT</code>, <code>REPLACE</code>, 和 <code>UPDATE</code>语句，我们一般分析 <code>SELECT</code> 查询较多。</p><p><code>EXPLAIN</code> 的输出格式如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token identifier"><span class="token punctuation">`</span>score<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>cus_order<span class="token punctuation">`</span></span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token identifier"><span class="token punctuation">`</span>score<span class="token punctuation">`</span></span> <span class="token keyword">DESC</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span>     <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span>   <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra          <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> cus_order <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">997572</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> filesort <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_MySQL%E7%B4%A2%E5%BC%95/06.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-MySQL-基础&quot;&gt;&lt;a href=&quot;#1-MySQL-基础&quot; class=&quot;headerlink&quot; title=&quot;1. MySQL 基础&quot;&gt;&lt;/a&gt;1. MySQL 基础&lt;/h3&gt;&lt;h4 id=&quot;什么是关系型数据库？&quot;&gt;&lt;a href=&quot;#什么是关系型数据库</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://ailiaa.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>NoSQL</title>
    <link href="http://ailiaa.github.io/2023/03/10/nosql/"/>
    <id>http://ailiaa.github.io/2023/03/10/nosql/</id>
    <published>2023-03-10T08:54:55.000Z</published>
    <updated>2023-03-11T07:31:40.799Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-NoSQL-是什么？"><a href="#1-NoSQL-是什么？" class="headerlink" title="1. NoSQL 是什么？"></a>1. NoSQL 是什么？</h3><p>NoSQL（Not Only SQL 的缩写）泛指非关系型的数据库，主要针对的是键值、文档以及图形类型数据存储。并且，NoSQL 数据库天生支持分布式，数据冗余和数据分片等特性，旨在提供可扩展的高可用高性能数据存储解决方案。</p><p>一个常见的误解是 NoSQL 数据库或非关系型数据库不能很好地存储关系型数据。NoSQL 数据库可以存储关系型数据—它们与关系型数据库的存储方式不同。</p><p>NoSQL 数据库代表：HBase 、Cassandra、MongoDB、Redis。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/05.png"></p><h3 id="2-SQL-和-NoSQL-的区别"><a href="#2-SQL-和-NoSQL-的区别" class="headerlink" title="2. SQL 和 NoSQL 的区别"></a>2. SQL 和 NoSQL 的区别</h3><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/06.png"></p><h3 id="3-NoSQL-数据库的优势"><a href="#3-NoSQL-数据库的优势" class="headerlink" title="3. NoSQL 数据库的优势"></a>3. NoSQL 数据库的优势</h3><p>NoSQL 数据库非常适合许多现代应用程序，例如移动、Web 和游戏等应用程序，它们需要灵活、可扩展、高性能和功能强大的数据库以提供卓越的用户体验。</p><ul><li>  <strong>灵活性：</strong> NoSQL 数据库通常提供灵活的架构，以实现更快速、更多的迭代开发。灵活的数据模型使 NoSQL 数据库成为半结构化和非结构化数据的理想之选。</li><li>  <strong>可扩展性：</strong> NoSQL 数据库通常被设计为通过使用分布式硬件集群来横向扩展，而不是通过添加昂贵和强大的服务器来纵向扩展。</li><li>  <strong>高性能：</strong> NoSQL 数据库针对特定的数据模型和访问模式进行了优化，这与尝试使用关系数据库完成类似功能相比可实现更高的性能。</li><li>  <strong>强大的功能：</strong> NoSQL 数据库提供功能强大的 API 和数据类型，专门针对其各自的数据模型而构建。</li></ul><h3 id="4-NoSQL-数据库有哪些类型？"><a href="#4-NoSQL-数据库有哪些类型？" class="headerlink" title="4. NoSQL 数据库有哪些类型？"></a>4. NoSQL 数据库有哪些类型？</h3><p>NoSQL 数据库主要可以分为下面四种类型：</p><ul><li>  <strong>键值</strong> ：键值数据库是一种较简单的数据库，其中每个项目都包含键和值。这是极为灵活的 NoSQL 数据库类型，因为应用可以完全控制 value 字段中存储的内容，没有任何限制。Redis 和 DynanoDB 是两款非常流行的键值数据库。</li><li>  <strong>文档</strong> ：文档数据库中的数据被存储在类似于 JSON（JavaScript 对象表示法）对象的文档中，非常清晰直观。每个文档包含成对的字段和值。这些值通常可以是各种类型，包括字符串、数字、布尔值、数组或对象等，并且它们的结构通常与开发者在代码中使用的对象保持一致。MongoDB 就是一款非常流行的文档数据库。</li><li>  <strong>图形</strong> ：图形数据库旨在轻松构建和运行与高度连接的数据集一起使用的应用程序。图形数据库的典型使用案例包括社交网络、推荐引擎、欺诈检测和知识图形。Neo4j 和 Giraph 是两款非常流行的图形数据库。</li><li>  <strong>宽列</strong> ：宽列存储数据库非常适合需要存储大量的数据。Cassandra 和 HBase 是两款非常流行的宽列存储数据库。</li></ul><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/07.png"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-NoSQL-是什么？&quot;&gt;&lt;a href=&quot;#1-NoSQL-是什么？&quot; class=&quot;headerlink&quot; title=&quot;1. NoSQL 是什么？&quot;&gt;&lt;/a&gt;1. NoSQL 是什么？&lt;/h3&gt;&lt;p&gt;NoSQL（Not Only SQL 的缩写）泛指非关系</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="NoSQL" scheme="http://ailiaa.github.io/tags/NoSQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库基础</title>
    <link href="http://ailiaa.github.io/2023/03/10/shu-ju-ku-ji-chu/"/>
    <id>http://ailiaa.github.io/2023/03/10/shu-ju-ku-ji-chu/</id>
    <published>2023-03-10T08:17:08.000Z</published>
    <updated>2023-03-10T08:50:15.356Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#1-什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="1. 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?"></a>1. 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h3><ul><li>  <strong>数据库</strong> : 数据库(DataBase 简称 DB)就是信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li><li>  <strong>数据库管理系统</strong> : 数据库管理系统(Database Management System 简称 DBMS)是一种操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li><li>  <strong>数据库系统</strong> : 数据库系统(Data Base System，简称 DBS)通常由软件、数据库和数据管理员(DBA)组成。</li><li>  <strong>数据库管理员</strong> : 数据库管理员(Database Administrator, 简称 DBA)负责全面管理和控制数据库系统。</li></ul><h3 id="2-什么是元组-码-候选码-主码-外码-主属性-非主属性？"><a href="#2-什么是元组-码-候选码-主码-外码-主属性-非主属性？" class="headerlink" title="2. 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？"></a>2. 什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h3><ul><li>  <strong>元组</strong> ： 元组（tuple）是关系数据库中的基本概念，关系是一张表，表中的每行（即数据库中的每条记录）就是一个元组，每列就是一个属性。 在二维表里，元组也称为行。</li><li>  <strong>码</strong> ：码就是能唯一标识实体的属性，对应表中的列。</li><li>  <strong>候选码</strong> ： 若关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。例如：在学生实体中，“学号”是能唯一的区分学生实体的，同时又假设“姓名”、“班级”的属性组合足以区分学生实体，那么{学号}和{姓名，班级}都是候选码。</li><li>  <strong>主码</strong> : 主码也叫主键。主码是从候选码中选出来的。 一个实体集中只能有一个主码，但可以有多个候选码。</li><li>  <strong>外码</strong> : 外码也叫外键。如果一个关系中的一个属性是另外一个关系中的主码则这个属性为外码。</li><li>  <strong>主属性</strong> ： 候选码中出现过的属性称为主属性。比如关系 工人（工号，身份证号，姓名，性别，部门）. 显然工号和身份证号都能够唯一标示这个关系，所以都是候选码。工号、身份证号这两个属性就是主属性。如果主码是一个属性组，那么属性组中的属性都是主属性。</li><li>  <strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。比如在关系——学生（学号，姓名，年龄，性别，班级）中，主码是“学号”，那么其他的“姓名”、“年龄”、“性别”、“班级”就都可以称为非主属性。</li></ul><h3 id="3-ER-图"><a href="#3-ER-图" class="headerlink" title="3. ER 图"></a>3. ER 图</h3><p><strong>ER 图</strong> 全称是 Entity Relationship Diagram（实体联系图），提供了表示实体类型、属性和联系的方法。</p><p>ER 图由下面 3 个要素组成：</p><ul><li>  <strong>实体</strong> ：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。比如对于一个校园管理系统，会涉及学生、教师、课程、班级等等实体。在 ER 图中，实体使用矩形框表示。</li><li>  <strong>属性</strong> ：即某个实体拥有的属性，属性用来描述组成实体的要素，对于产品设计来说可以理解为字段。在 ER 图中，属性使用椭圆形表示。</li><li>  <strong>联系</strong> ：即实体与实体之间的关系，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。例如，一个班级会有多个学生就是一种实体间的联系。</li></ul><p>下图是一个学生选课的 ER 图，每个学生可以选若干门课程，同一门课程也可以被若干人选择，所以它们之间的关系是多对多（M: N）。另外，还有其他两种实体之间的关系是：1 对 1（1:1）、1 对多（1: N）。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/01.png"></p><h3 id="4-数据库范式"><a href="#4-数据库范式" class="headerlink" title="4. 数据库范式"></a>4. 数据库范式</h3><ul><li>  1NF(第一范式)：属性不可再分。</li><li>  2NF(第二范式)：1NF 的基础之上，每一个非主属性完全函数依赖于任何一个候选码，消除了非主属性对于码的部分函数依赖。</li><li>  3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</li><li> BC范式 BCFN：关系模式R&lt;U,F&gt;中，若每一个决定因素都包含码，则R&lt;U,F&gt;属于BCFN。</li></ul><h4 id="1NF-第一范式"><a href="#1NF-第一范式" class="headerlink" title="1NF(第一范式)"></a>1NF(第一范式)</h4><p>属性（对应于表中的字段）不能再被分割，也就是这个字段只能是一个值，不能再分为多个其他的字段了。<strong>1NF 是所有关系型数据库的最基本要求</strong> ，也就是说关系型数据库中创建的表一定满足第一范式。</p><p>不符合第一范式：<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/03.png"></p><h4 id="2NF-第二范式"><a href="#2NF-第二范式" class="headerlink" title="2NF(第二范式)"></a>2NF(第二范式)</h4><p>2NF 在 1NF 的基础之上，消除了非主属性对于码的部分函数依赖。</p><p>有关系模式S-L-C(Sno, Sdept, Sloc, Cno, Grade)，其中Sno, Sdept, Sloc, Cno, Grade依次表示学生的学号、所在的系、住处、课程号、班级，并且每个系的学生住在同一个地方。可知S-L-C的码为（Sno, Cno），则存在以下函数依赖：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/04.jpg"></p><p>非主属性Sloc、Sdept并不完全函数依赖于码，因此关系模式S-L-C(Sno, Sdept, Sloc, Cno, Grade)不符合第二范式。</p><p>一些重要的概念：</p><ul><li>  <strong>函数依赖（functional dependency）</strong> ：若在一张表中，在属性（或属性组）X 的值确定的情况下，必定能确定属性 Y 的值，那么就可以说 Y 函数依赖于 X，写作 X → Y。</li><li>  <strong>部分函数依赖（partial functional dependency）</strong> ：如果 X→Y，并且存在 X 的一个真子集 X0，使得 X0→Y，则称 Y 对 X 部分函数依赖。比如学生基本信息表 R 中（学号，身份证号，姓名）当然学号属性取值是唯一的，在 R 关系中，（学号，身份证号）-&gt;（姓名），（学号）-&gt;（姓名），（身份证号）-&gt;（姓名）；所以姓名部分函数依赖与（学号，身份证号）；</li><li>  <strong>完全函数依赖(Full functional dependency)</strong> ：在一个关系中，若某个非主属性数据项依赖于全部关键字称之为完全函数依赖。比如学生基本信息表 R（学号，班级，姓名）假设不同的班级学号有相同的，班级内学号不能相同，在 R 关系中，（学号，班级）-&gt;（姓名），但是（学号）-&gt;(姓名)不成立，（班级）-&gt;(姓名)不成立，所以姓名完全函数依赖与（学号，班级）；</li><li>  <strong>传递函数依赖</strong> ： 在关系模式 R(U)中，设 X，Y，Z 是 U 的不同的属性子集，如果 X 确定 Y、Y 确定 Z，且有 X 不包含 Y，Y 不确定 X，（X∪Y）∩Z=空集合，则称 Z 传递函数依赖(transitive functional dependency) 于 X。传递函数依赖会导致数据冗余和异常。传递函数依赖的 Y 和 Z 子集往往同属于某一个事物，因此可将其合并放到一个表中。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖。。</li></ul><h4 id="3NF-第三范式"><a href="#3NF-第三范式" class="headerlink" title="3NF(第三范式)"></a>3NF(第三范式)</h4><p>3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。符合 3NF 要求的数据库设计，<strong>基本</strong>上解决了数据冗余过大，插入异常，修改异常，删除异常的问题。比如在关系 R(学号 , 姓名, 系名，系主任)中，学号 → 系名，系名 → 系主任，所以存在非主属性系主任对于学号的传递函数依赖，所以该表的设计，不符合 3NF 的要求。</p><h4 id="BC范式-BCFN"><a href="#BC范式-BCFN" class="headerlink" title="BC范式 BCFN"></a>BC范式 BCFN</h4><p>定义： 关系模式R&lt;U,F&gt;中，若每一个决定因素都包含码，则R&lt;U,F&gt;属于BCFN。</p><p>理解： 根据定义我们可以得到结论，一个满足BC范式的关系模式有：</p><p>所有非主属性对每一个码都是完全函数依赖；<br>所有主属性对每一个不包含它的码也是完全函数依赖；<br>没有任何属性完全函数依赖于非码的任何一组属性。</p><p>例如有关系模式C(Cno, Cname, Pcno)，Cno, Cname, Pcno依次表示课程号、课程名、先修课。可知关系C只有一个码Cno，且没有任何属性对Cno部分函数依赖或传递函数依赖，所以关系C属于第三范式，同时Cno是C中的唯一决定因素，所以C也属于BC范式。</p><h3 id="主键和外键的区别"><a href="#主键和外键的区别" class="headerlink" title="主键和外键的区别"></a>主键和外键的区别</h3><ul><li>  <strong>主键(主码)</strong> ：主键用于唯一标识一个元组，不能有重复，不允许为空。一个表只能有一个主键。</li><li>  <strong>外键(外码)</strong> ：外键用来和其他表建立联系用，外键是另一表的主键，外键是可以有重复的，可以是空值。一个表可以有多个外键。</li></ul><h3 id="5-为什么不推荐使用外键与级联？"><a href="#5-为什么不推荐使用外键与级联？" class="headerlink" title="5. 为什么不推荐使用外键与级联？"></a>5. 为什么不推荐使用外键与级联？</h3><p>对于外键和级联，阿里巴巴开发手册这样说到：</p><blockquote><p>【强制】不得使用外键与级联，一切外键概念必须在应用层解决。</p><p>说明: 以学生和成绩的关系为例，学生表中的 student_id 是主键，那么成绩表中的 student_id 则为外键。如果更新学生表中的 student_id，同时触发成绩表中的 student_id 更新，即为级联更新。外键与级联更新适用于单机低并发，不适合分布式、高并发集群; 级联更新是强阻塞，存在数据库更新风暴的风 险; 外键影响数据库的插入速度</p></blockquote><p>为什么不要用外键呢？大部分人可能会这样回答：</p><ol><li> <strong>增加了复杂性：</strong> a. 每次做 DELETE 或者 UPDATE 都必须考虑外键约束，会导致开发的时候很痛苦, 测试数据极为不方便; b. 外键的主从关系是定的，假如那天需求有变化，数据库中的这个字段根本不需要和其他表有关联的话就会增加很多麻烦。</li><li> <strong>增加了额外工作</strong>： 数据库需要增加维护外键的工作，比如当我们做一些涉及外键字段的增，删，更新操作之后，需要触发相关操作去检查，保证数据的的一致性和正确性，这样会不得不消耗资源；（个人觉得这个不是不用外键的原因，因为即使你不使用外键，你在应用层面也还是要保证的。所以，我觉得这个影响可以忽略不计。）</li><li> <strong>对分库分表不友好</strong> ：因为分库分表下外键是无法生效的。</li></ol><p>实际上，外键也是有很多好处的，比如：</p><ol><li> 保证了数据库数据的一致性和完整性；</li><li> 级联操作方便，减轻了程序代码量；</li></ol><p>如果系统不涉及分库分表，并发量不是很高的情况还是可以考虑使用外键的。</p><h3 id="5-什么是存储过程"><a href="#5-什么是存储过程" class="headerlink" title="5. 什么是存储过程?"></a>5. 什么是存储过程?</h3><p>我们可以把存储过程看成是一些 SQL 语句的集合，中间加了点逻辑控制语句。存储过程在业务比较复杂的时候是非常实用的，比如很多时候我们完成一个操作可能需要写一大串 SQL 语句，这时候我们就可以写有一个存储过程，这样也方便了我们下一次的调用。存储过程一旦调试完成通过后就能稳定运行，另外，使用存储过程比单纯 SQL 语句执行要快，因为存储过程是预编译过的。</p><p>存储过程在互联网公司应用不多，因为存储过程难以调试和扩展，而且没有移植性，还会消耗数据库资源。</p><p>阿里巴巴 Java 开发手册里要求禁止使用存储过程</p><h3 id="6-drop、delete-与-truncate-区别？"><a href="#6-drop、delete-与-truncate-区别？" class="headerlink" title="6. drop、delete 与 truncate 区别？"></a>6. drop、delete 与 truncate 区别？</h3><h4 id="用法不同"><a href="#用法不同" class="headerlink" title="用法不同"></a>用法不同</h4><ul><li>  <code>drop</code>(丢弃数据): <code>drop table 表名</code> ，直接将表都删除掉，在删除表的时候使用。</li><li>  <code>truncate</code> (清空数据) : <code>truncate table 表名</code> ，只删除表中的数据，再插入数据的时候自增长 id 又从 1 开始，在清空表中数据的时候使用。</li><li>  <code>delete</code>（删除数据） : <code>delete from 表名 where 列名=值</code>，删除某一行的数据，如果不加 <code>where</code> 子句和<code>truncate table 表名</code>作用类似。</li></ul><p><code>truncate</code> 和不带 where``子句的 <code>delete</code>、以及 <code>drop</code> 都会删除表内的数据，但是 <strong><code>truncate</code> 和 <code>delete</code> 只删除数据不删除表的结构(定义)，执行 <code>drop</code> 语句，此表的结构也会删除，也就是执行 <code>drop</code> 之后对应的表不复存在。</strong></p><h4 id="属于不同的数据库语言"><a href="#属于不同的数据库语言" class="headerlink" title="属于不同的数据库语言"></a>属于不同的数据库语言</h4><p><code>truncate</code> 和 <code>drop</code> 属于 DDL(数据定义语言)语句，操作立即生效，原数据不放到 rollback segment 中，不能回滚，操作不触发 trigger。而 <code>delete</code> 语句是 DML (数据库操作语言)语句，这个操作会放到 rollback segement 中，事务提交之后才生效。</p><p><strong>DML 语句和 DDL 语句区别：</strong></p><ul><li>  DML 是数据库操作语言（Data Manipulation Language）的缩写，是指对数据库中表记录的操作，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li><li>  DDL （Data Definition Language）是数据定义语言的缩写，简单来说，就是对数据库内部的对象进行创建、删除、修改的操作语言。它和 DML 语言的最大区别是 DML 只是对表内部数据的操作，而不涉及到表的定义、结构的修改，更不会涉及到其他对象。DDL 语句更多的被数据库管理员（DBA）所使用，一般的开发人员很少使用。</li></ul><p>另外，由于<code>select</code>不会对表进行破坏，所以有的地方也会把<code>select</code>单独区分开叫做数据库查询语言 DQL（Data Query Language）。</p><h4 id="执行速度不同"><a href="#执行速度不同" class="headerlink" title="执行速度不同"></a>执行速度不同</h4><p>一般来说：<code>drop</code> &gt; <code>truncate</code> &gt; <code>delete</code> 。</p><ul><li>  <code>delete</code>命令执行的时候会产生数据库的<code>binlog</code>日志，而日志记录是需要消耗时间的，但是也有个好处方便数据回滚恢复。</li><li>  <code>truncate</code>命令执行的时候不会产生数据库日志，因此比<code>delete</code>要快。除此之外，还会把表的自增值重置和索引恢复到初始大小等。</li><li>  <code>drop</code>命令会把表占用的空间全部释放掉。</li></ul><h3 id="7-数据库设计通常分为哪几步"><a href="#7-数据库设计通常分为哪几步" class="headerlink" title="7. 数据库设计通常分为哪几步?"></a>7. 数据库设计通常分为哪几步?</h3><ol><li> <strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li><li> <strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li><li> <strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li><li> <strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li> <strong>数据库实施</strong> : 包括编程、测试和试运行</li><li> <strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-什么是数据库-数据库管理系统-数据库系统-数据库管理员&quot;&gt;&lt;a href=&quot;#1-什么是数据库-数据库管理系统-数据库系统-数据库管理员&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>MySQL日志</title>
    <link href="http://ailiaa.github.io/2023/03/10/mysql-du-xie-fen-chi-fen-ku-fen-biao/"/>
    <id>http://ailiaa.github.io/2023/03/10/mysql-du-xie-fen-chi-fen-ku-fen-biao/</id>
    <published>2023-03-10T07:57:42.000Z</published>
    <updated>2023-03-11T07:33:48.810Z</updated>
    
    <content type="html"><![CDATA[<h3 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h3><p><strong>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。</strong>&nbsp;这样的话，就能够小幅提升写性能，大幅提升读性能。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/16.png"></p><p>一般情况下，我们都会选择一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。这样的架构实现起来比较简单，并且也符合系统的写少读多的特点。</p><h4 id="实现读写分离的方法"><a href="#实现读写分离的方法" class="headerlink" title="实现读写分离的方法"></a>实现读写分离的方法</h4><p>不论是使用哪一种读写分离具体的实现方案，想要实现读写分离一般包含如下几步：</p><ol><li> 部署多台数据库，选择其中的一台作为主数据库，其他的一台或者多台作为从数据库。</li><li> 保证主数据库和从数据库之间的数据是实时同步的，这个过程也就是我们常说的<strong>主从复制</strong>。</li><li> 系统将写请求交给主数据库处理，读请求交给从数据库处理。</li></ol><p>落实到项目本身的话，常用的方式有两种：</p><p><strong>1.代理方式</strong></p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/17.png"></p><p>我们可以在应用和数据中间加了一个代理层。应用程序所有的数据请求都交给代理层处理，代理层负责分离读写请求，将它们路由到对应的数据库中。</p><p>提供类似功能的中间件有 <strong>MySQL Router</strong>（官方）、<strong>Atlas</strong>（基于 MySQL Proxy）、<strong>Maxscale</strong>、<strong>MyCat</strong>。</p><p><strong>2.组件方式</strong></p><p>在这种方式中，我们可以通过引入第三方组件来帮助我们读写请求。</p><p>这也是比较推荐的一种方式。这种方式目前在各种互联网公司中用的最多的，相关的实际的案例也非常多。如果你要采用这种方式的话，推荐使用 <code>sharding-jdbc</code> ，直接引入 jar 包即可使用，非常方便。同时，也节省了很多运维的成本。</p><h4 id="读写分离会带来的问题，解决方法"><a href="#读写分离会带来的问题，解决方法" class="headerlink" title="读写分离会带来的问题，解决方法"></a>读写分离会带来的问题，解决方法</h4><p>主库和从库的数据存在延迟，比如写完主库之后，主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 <strong>主从同步延迟</strong> 。</p><p>参考的解决办法：</p><p><strong>1.强制将读请求路由到主库处理。</strong></p><p>既然你从库的数据过期了，那我就直接从主库读取嘛！这种方案虽然会增加主库的压力，但是，实现起来比较简单，也是我了解到的使用最多的一种方式。</p><p>比如 <code>Sharding-JDBC</code> 就是采用的这种方案。通过使用 Sharding-JDBC 的 <code>HintManager</code> 分片键值管理器，我们可以强制使用主库。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">HintManager</span> hintManager <span class="token operator">=</span> <span class="token class-name">HintManager</span><span class="token punctuation">.</span><span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>hintManager<span class="token punctuation">.</span><span class="token function">setMasterRouteOnly</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 继续JDBC操作</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>对于这种方案，你可以将那些必须获取最新数据的读请求都交给主库处理。</p><p><strong>2.延迟读取。</strong></p><p>比如主从同步延迟 0.5s，那就1s 之后再读取数据。这样多方便啊！方便是方便，但是性能差。</p><p>不过，如果你是这样设计业务流程就会好很多：对于一些对数据比较敏感的场景，你可以在完成写请求之后，避免立即进行请求操作。比如你支付成功之后，跳转到一个支付成功的页面，当你点击返回之后才返回自己的账户。</p><h4 id="主从复制原理"><a href="#主从复制原理" class="headerlink" title="主从复制原理"></a>主从复制原理</h4><p>MySQL binlog(binary log 即二进制日志文件) 主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/18.png"></p><ol><li> 主库将数据库中数据的变化写入到 binlog</li><li> 从库连接主库</li><li> 从库会创建一个 I/O 线程向主库请求更新的 binlog</li><li> 主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收</li><li> 从库的 I/O 线程将接收的 binlog 写入到 relay log 中。</li><li> 从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。</li></ol><p>当然，除了主从复制之外，binlog 还能帮助我们实现数据恢复。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><ul><li>  读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。 这样的话，就能够小幅提升写性能，大幅提升读性能。</li><li>  读写分离基于主从复制，MySQL 主从复制是依赖于 binlog 。</li></ul><h3 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h3><p><strong>如果 MySQL 一张表的数据量过大怎么办?</strong></p><p>换言之，<strong>我们该如何解决 MySQL 的存储压力呢？</strong></p><p>答案之一就是 <strong>分库分表</strong>。</p><h4 id="什么是分库"><a href="#什么是分库" class="headerlink" title="什么是分库"></a>什么是分库</h4><p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。</p><p><strong>垂直分库</strong> 就是把单一数据库按照业务进行划分，不同的业务使用不同的数据库，进而将一个数据库的压力分担到多个数据库。</p><p>举个例子：将数据库中的用户表、订单表和商品表分别单独拆分为用户数据库、订单数据库和商品数据库。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/19.png"></p><p><strong>水平分库</strong>&nbsp;是把同一个表按一定规则拆分到不同的数据库中，每个库可以位于不同的服务器上，这样就实现了水平扩展，解决了单表的存储和性能瓶颈的问题。</p><p>举个例子：订单表数据量太大，你对订单表进行了水平切分（水平分表），然后将切分后的 2 张订单表分别放在两个不同的数据库。<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/20.png"></p><h4 id="什么是分表"><a href="#什么是分表" class="headerlink" title="什么是分表"></a>什么是分表</h4><p><strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p><p><strong>垂直分表</strong> 是对数据表列的拆分，把一张列比较多的表拆分为多张表。</p><p>举个例子：我们可以将用户信息表中的一些列单独抽出来作为一个表。</p><p><strong>水平分表</strong> 是对数据表行的拆分，把一张行比较多的表拆分为多张表，可以解决单一表数据量过大的问题。</p><p>举个例子：我们可以将用户信息表拆分成多个用户信息表，这样就可以避免单一表数据量过大对性能造成影响。</p><p>水平拆分只能解决单表数据量大的问题，为了提升性能，我们通常会选择将拆分后的多张表放在不同的数据库中。也就是说，水平分表通常和水平分库同时出现。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/21.png"></p><h4 id="什么情况下需要分库分表"><a href="#什么情况下需要分库分表" class="headerlink" title="什么情况下需要分库分表"></a>什么情况下需要分库分表</h4><p>遇到下面几种场景可以考虑分库分表：</p><ul><li>  单表的数据达到千万级别以上，数据库读写速度比较缓慢。</li><li>  数据库中的数据占用的空间越来越大，备份时间越来越长。</li><li>  应用的并发量太大。</li></ul><h4 id="常见的分片算法"><a href="#常见的分片算法" class="headerlink" title="常见的分片算法"></a>常见的分片算法</h4><p>分片算法主要解决了数据被水平分片之后，数据究竟该存放在哪个表的问题。</p><ul><li>  <strong>哈希分片</strong> ：求指定 key（比如 id） 的哈希，然后根据哈希值确定数据应被放置在哪个表中。哈希分片比较适合随机读写的场景，不太适合经常需要范围查询的场景。</li><li>  <strong>范围分片</strong> ：按照特性的范围区间（比如时间区间、ID区间）来分配数据，比如 将 <code>id</code> 为 <code>1~299999</code> 的记录分到第一个库， <code>300000~599999</code> 的分到第二个库。范围分片适合需要经常进行范围查找的场景，不太适合随机读写的场景（数据未被分散，容易出现热点数据的问题）。</li><li>  <strong>地理位置分片</strong> ：很多 NewSQL 数据库都支持地理位置分片算法，也就是根据地理位置（如城市、地域）来分配数据。</li><li>  <strong>融合算法</strong> ：灵活组合多种分片算法，比如将哈希分片和范围分片组合。</li></ul><h4 id="分库分表会带的问题"><a href="#分库分表会带的问题" class="headerlink" title="分库分表会带的问题"></a>分库分表会带的问题</h4><ul><li>  <strong>join 操作</strong> ： 同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装，比如你在一个数据库中查询到一个数据之后，再根据这个数据去另外一个数据库中找对应的数据。</li><li>  <strong>事务问题</strong> ：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。</li><li>  <strong>分布式 id</strong> ：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。我们如何为不同的数据节点生成全局唯一主键呢？这个时候，我们就需要为我们的系统引入分布式 id 了。</li></ul><p>另外，引入分库分表之后，一般需要 DBA 的参与，同时还需要更多的数据库服务器，这些都属于成本。</p><h4 id="分库分表后，数据怎么迁移"><a href="#分库分表后，数据怎么迁移" class="headerlink" title="分库分表后，数据怎么迁移"></a>分库分表后，数据怎么迁移</h4><p>分库分表之后，我们如何将老库（单库单表）的数据迁移到新库（分库分表后的数据库系统）呢？</p><p>比较简单同时也是非常常用的方案就是<strong>停机迁移</strong>，写个脚本老库的数据写到新库中。比如你在凌晨 2 点，系统使用的人数非常少的时候，挂一个公告说系统要维护升级预计 1 小时。然后，你写一个脚本将老库的数据都同步到新库中。</p><p>如果你不想停机迁移数据的话，也可以考虑<strong>双写方案</strong>。双写方案是针对那种不能停机迁移的场景，实现起来要稍微麻烦一些。具体原理是这样的：</p><ul><li>  我们对老库的更新操作（增删改），同时也要写入新库（双写）。如果操作的数据不存在于新库的话，需要插入到新库中。 这样就能保证，咱们新库里的数据是最新的。</li><li>  在迁移过程，双写只会让被更新操作过的老库中的数据同步到新库，我们还需要自己写脚本将老库中的数据和新库的数据做比对。如果新库中没有，那咱们就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）。</li><li>  重复上一步的操作，直到老库和新库的数据一致为止。</li></ul><p>想要在项目中实施双写还是比较麻烦的，很容易会出现问题。我们可以借助上面提到的数据库同步工具 Canal 做增量数据迁移（还是依赖 binlog，开发和维护成本较低）。</p><h4 id="分库分表比较推荐的方案"><a href="#分库分表比较推荐的方案" class="headerlink" title="分库分表比较推荐的方案"></a>分库分表比较推荐的方案</h4><p>ShardingSphere 项目</p><p>ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。</p><p>另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</p><h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><ul><li>  <strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上。<strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</li><li>  引入分库分表之后，需要系统解决事务、分布式 id、无法 join 操作问题。</li><li>  ShardingSphere 绝对可以说是当前分库分表的首选！ShardingSphere 的功能完善，除了支持读写分离和分库分表，还提供分布式事务、数据库治理等功能。另外，ShardingSphere 的生态体系完善，社区活跃，文档完善，更新和发布比较频繁。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;读写分离&quot;&gt;&lt;a href=&quot;#读写分离&quot; class=&quot;headerlink&quot; title=&quot;读写分离&quot;&gt;&lt;/a&gt;读写分离&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。&lt;/strong&gt;&amp;nbsp;这样的话，就能</summary>
      
    
    
    
    
    <category term="数据库" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
    <category term="MySQL" scheme="http://ailiaa.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>排序算法</title>
    <link href="http://ailiaa.github.io/2023/03/10/pai-xu-suan-fa/"/>
    <id>http://ailiaa.github.io/2023/03/10/pai-xu-suan-fa/</id>
    <published>2023-03-10T07:04:05.000Z</published>
    <updated>2023-03-10T07:52:27.660Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-分类"><a href="#1-分类" class="headerlink" title="1. 分类"></a>1. 分类</h3><ul><li>  <strong>内部排序</strong> ：数据记录在内存中进行排序。</li><li>  <strong>外部排序</strong>：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</li></ul><p>常见的内部排序算法有：<strong>插入排序</strong>、<strong>希尔排序</strong>、<strong>选择排序</strong>、<strong>冒泡排序</strong>、<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>堆排序</strong>、<strong>基数排序</strong>等，本文只讲解内部排序算法。用一张图概括：</p><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01.png"><br><strong>图片名词解释：</strong></p><ul><li>  <strong>n</strong>：数据规模</li><li>  <strong>k</strong>：“桶” 的个数</li><li>  <strong>In-place</strong>：占用常数内存，不占用额外内存</li><li>  <strong>Out-place</strong>：占用额外内存</li></ul><p><strong>术语说明</strong></p><ul><li>  <strong>稳定</strong>：如果 A 原本在 B 前面，而 A=B，排序之后 A 仍然在 B 的前面。</li><li>  <strong>不稳定</strong>：如果 A 原本在 B 的前面，而 A=B，排序之后 A 可能会出现在 B 的后面。</li><li>  <strong>内排序</strong>：所有排序操作都在内存中完成。</li><li>  <strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li><li>  <strong>时间复杂度</strong>： 定性描述一个算法执行所耗费的时间。</li><li>  <strong>空间复杂度</strong>：定性描述一个算法执行所需内存的大小<br><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/02.png"></li></ul><p>常见的<strong>快速排序</strong>、<strong>归并排序</strong>、<strong>堆排序</strong>以及<strong>冒泡排序</strong>等都属于<strong>比较类排序算法</strong>。比较类排序是通过比较来决定元素间的相对次序，由于其时间复杂度不能突破 <code>O(nlogn)</code>，因此也称为非线性时间比较类排序。在冒泡排序之类的排序中，问题规模为 <code>n</code>，又因为需要比较 <code>n</code> 次，所以平均时间复杂度为 <code>O(n²)</code>。在<strong>归并排序</strong>、<strong>快速排序</strong>之类的排序中，问题规模通过<strong>分治法</strong>消减为 <code>logn</code> 次，所以时间复杂度平均 <code>O(nlogn)</code>。</p><p>比较类排序的优势是，适用于各种规模的数据，也不在乎数据的分布，都能进行排序。可以说，比较排序适用于一切需要排序的情况。</p><p>而<strong>计数排序</strong>、<strong>基数排序</strong>、<strong>桶排序</strong>则属于<strong>非比较类排序算法</strong>。非比较排序不通过比较来决定元素间的相对次序，而是通过确定每个元素之前，应该有多少个元素来排序。由于它可以突破基于比较排序的时间下界，以线性时间运行，因此称为线性时间非比较类排序。 非比较排序只要确定每个元素之前的已有的元素个数即可，所有一次遍历即可解决。算法时间复杂度 <code>O(n)</code>。</p><p>非比较排序时间复杂度底，但由于非比较排序需要占用空间来确定唯一位置。所以对数据规模和数据分布有一定的要求。</p><h3 id="2-冒泡排序-Bubble-Sort"><a href="#2-冒泡排序-Bubble-Sort" class="headerlink" title="2. 冒泡排序 (Bubble Sort)"></a>2. 冒泡排序 (Bubble Sort)</h3><p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的序列，依次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历序列的工作是重复地进行直到没有再需要交换为止，此时说明该序列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li> 比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li> 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li> 针对所有的元素重复以上的步骤，除了最后一个；</li><li> 重复步骤 1~3，直到排序完成。</li></ol><h4 id="图解算法"><a href="#图解算法" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/03.gif"></p><h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 冒泡排序 * @param arr * @return arr */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// Set a flag, if true, that means the loop has not been swapped,</span>        <span class="token comment">// that is, the sequence has been ordered, the sorting has been completed.</span>        <span class="token keyword">boolean</span> flag <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> i<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>    <span class="token comment">// Change flag</span>                flag <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>flag<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">break</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>此处对代码做了一个小优化，加入了 <code>is_sorted</code> Flag，目的是将算法的最佳时间复杂度优化为 <code>O(n)</code>，即当原输入序列就是排序好的情况下，该算法的时间复杂度就是 <code>O(n)</code>。</strong></p><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong>：稳定</li><li>  <strong>时间复杂度</strong>&nbsp;：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li><li>  <strong>空间复杂度</strong>&nbsp;：O(1)</li><li>  <strong>排序方式</strong>&nbsp;：In-place</li></ul><h3 id="3-选择排序-Selection-Sort"><a href="#3-选择排序-Selection-Sort" class="headerlink" title="3. 选择排序 (Selection Sort)"></a>3. 选择排序 (Selection Sort)</h3><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 <code>O(n²)</code> 的时间复杂度。所以用到它的时候，数据规模越小越好。唯一的好处可能就是不占用额外的内存空间了吧。它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li> 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li> 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li> 重复第 2 步，直到所有元素均排序完毕。</li></ol><h4 id="图解算法-1"><a href="#图解算法-1" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/04.gif"></p><h4 id="代码实现-1"><a href="#代码实现-1" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 选择排序 * @param arr * @return arr */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">selectionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> minIndex <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                minIndex <span class="token operator">=</span> j<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minIndex <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>            arr<span class="token punctuation">[</span>minIndex<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong>：不稳定</li><li>  <strong>时间复杂度</strong> ：最佳：O(n2) ，最差：O(n2)， 平均：O(n2)</li><li>  <strong>空间复杂度</strong> ：O(1)</li><li>  <strong>排序方式</strong> ：In-place</li></ul><h3 id="4-插入排序-Insertion-Sort"><a href="#4-插入排序-Insertion-Sort" class="headerlink" title="4. 插入排序 (Insertion Sort)"></a>4. 插入排序 (Insertion Sort)</h3><p>插入排序是一种简单直观的排序算法。它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。插入排序在实现上，通常采用 in-place 排序（即只需用到 <code>O(1)</code> 的额外空间的排序），因而在从后向前扫描过程中，需要反复把已排序元素逐步向后挪位，为最新元素提供插入空间。</p><p>插入排序的代码实现虽然没有冒泡排序和选择排序那么简单粗暴，但它的原理应该是最容易理解的了，因为只要打过扑克牌的人都应该能够秒懂。插入排序是一种最简单直观的排序算法，它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。</p><p>插入排序和冒泡排序一样，也有一种优化算法，叫做拆半插入。</p><h4 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li> 从第一个元素开始，该元素可以认为已经被排序；</li><li> 取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li> 如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li> 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li> 将新元素插入到该位置后；</li><li> 重复步骤 2~5。</li></ol><h4 id="图解算法-2"><a href="#图解算法-2" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/05.gif"></p><h4 id="代码实现-2"><a href="#代码实现-2" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 插入排序 * @param arr * @return arr */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">insertionSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> preIndex <span class="token operator">=</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> current <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>preIndex <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> current <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            arr<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>            preIndex <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        arr<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong>：稳定</li><li>  <strong>时间复杂度</strong> ：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li><li>  <strong>空间复杂度</strong> ：O(1)</li><li>  <strong>排序方式</strong> ：In-place</li></ul><h3 id="5-希尔排序-Shell-Sort"><a href="#5-希尔排序-Shell-Sort" class="headerlink" title="5. 希尔排序 (Shell Sort)"></a>5. 希尔排序 (Shell Sort)</h3><p>希尔排序是希尔 (Donald Shell) 于 1959 年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为递减增量排序算法，同时该算法是冲破 <code>O(n²)</code> 的第一批算法之一。</p><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。</p><h4 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量 <code>gap=length/2</code>，缩小增量继续以 <code>gap = gap/2</code> 的方式，这种增量选择我们可以用一个序列来表示，<code>{n/2, (n/2)/2, ..., 1}</code>，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>  选择一个增量序列 <code>{t1, t2, …, tk}</code>，其中 <code>(ti&gt;tj, i&lt;j, tk=1)</code>；</li><li>  按增量序列个数 k，对序列进行 k 趟排序；</li><li>  每趟排序，根据对应的增量 <code>t</code>，将待排序列分割成若干长度为 <code>m</code> 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="图解算法-3"><a href="#图解算法-3" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/06.png"></p><h4 id="代码实现-3"><a href="#代码实现-3" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 希尔排序 * * @param arr * @return arr */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">shellSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token keyword">int</span> gap <span class="token operator">=</span> n <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>gap <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> gap<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> current <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            <span class="token keyword">int</span> preIndex <span class="token operator">=</span> i <span class="token operator">-</span> gap<span class="token punctuation">;</span>            <span class="token comment">// Insertion sort</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>preIndex <span class="token operator">&gt;=</span> <span class="token number">0</span> <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span> <span class="token operator">&gt;</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>preIndex<span class="token punctuation">]</span><span class="token punctuation">;</span>                preIndex <span class="token operator">-=</span> gap<span class="token punctuation">;</span>            <span class="token punctuation">}</span>            arr<span class="token punctuation">[</span>preIndex <span class="token operator">+</span> gap<span class="token punctuation">]</span> <span class="token operator">=</span> current<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        gap <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong>：稳定</li><li>  <strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(n2) 平均：O(nlogn)</li><li>  <strong>空间复杂度</strong> ：<code>O(1)</code></li></ul><h3 id="6-归并排序-Merge-Sort"><a href="#6-归并排序-Merge-Sort" class="headerlink" title="6. 归并排序 (Merge Sort)"></a>6. 归并排序 (Merge Sort)</h3><p>归并排序是建立在归并操作上的一种有效的排序算法。该算法是采用分治法 (Divide and Conquer) 的一个非常典型的应用。归并排序是一种稳定的排序方法。将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2 - 路归并。</p><p>和选择排序一样，归并排序的性能不受输入数据的影响，但表现比选择排序好的多，因为始终都是 <code>O(nlogn)</code> 的时间复杂度。代价是需要额外的内存空间。</p><h4 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>归并排序算法是一个递归过程，边界条件为当输入序列仅有一个元素时，直接返回，具体过程如下：</p><ol><li> 如果输入内只有一个元素，则直接返回，否则将长度为 <code>n</code> 的输入序列分成两个长度为 <code>n/2</code> 的子序列；</li><li> 分别对这两个子序列进行归并排序，使子序列变为有序状态；</li><li> 设定两个指针，分别指向两个已经排序子序列的起始位置；</li><li> 比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置；</li><li> 重复步骤 3 ~4 直到某一指针达到序列尾；</li><li> 将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><h4 id="图解算法-4"><a href="#图解算法-4" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/07.gif"></p><h4 id="代码实现-4"><a href="#代码实现-4" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 归并排序 * * @param arr * @return arr */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> middle <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr_1 <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> middle<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr_2 <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOfRange</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> middle<span class="token punctuation">,</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token function">mergeSort</span><span class="token punctuation">(</span>arr_1<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">mergeSort</span><span class="token punctuation">(</span>arr_2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * Merge two sorted arrays * * @param arr_1 * @param arr_2 * @return sorted_arr */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr_1<span class="token punctuation">,</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr_2<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> sorted_arr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>arr_1<span class="token punctuation">.</span>length <span class="token operator">+</span> arr_2<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> idx_1 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> idx_2 <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>idx_1 <span class="token operator">&lt;</span> arr_1<span class="token punctuation">.</span>length <span class="token operator">&amp;&amp;</span> idx_2 <span class="token operator">&lt;</span> arr_2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr_1<span class="token punctuation">[</span>idx_1<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr_2<span class="token punctuation">[</span>idx_2<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            sorted_arr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> arr_1<span class="token punctuation">[</span>idx_1<span class="token punctuation">]</span><span class="token punctuation">;</span>            idx_1 <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            sorted_arr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> arr_2<span class="token punctuation">[</span>idx_2<span class="token punctuation">]</span><span class="token punctuation">;</span>            idx_2 <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        idx <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>idx_1 <span class="token operator">&lt;</span> arr_1<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>idx_1 <span class="token operator">&lt;</span> arr_1<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sorted_arr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> arr_1<span class="token punctuation">[</span>idx_1<span class="token punctuation">]</span><span class="token punctuation">;</span>            idx_1 <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>            idx <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>idx_2 <span class="token operator">&lt;</span> arr_2<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            sorted_arr<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> arr_2<span class="token punctuation">[</span>idx_2<span class="token punctuation">]</span><span class="token punctuation">;</span>            idx_2 <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>            idx <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> sorted_arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong>：稳定</li><li>  <strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li><li>  <strong>空间复杂度</strong> ：O(n)</li></ul><h3 id="7-快速排序-Quick-Sort"><a href="#7-快速排序-Quick-Sort" class="headerlink" title="7. 快速排序 (Quick Sort)"></a>7. 快速排序 (Quick Sort)</h3><p>快速排序用到了分治思想，同样的还有归并排序。乍看起来快速排序和归并排序非常相似，都是将问题变小，先排序子串，最后合并。不同的是快速排序在划分子问题的时候经过多一步处理，将划分的两组数据划分为一大一小，这样在最后合并的时候就不必像归并排序那样再进行比较。但也正因为如此，划分的不定性使得快速排序的时间复杂度并不稳定。</p><p>快速排序的基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</p><h4 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>快速排序使用分治法（Divide and conquer）策略来把一个序列分为较小和较大的 2 个子序列，然后递回地排序两个子序列。具体算法描述如下：</p><ol><li> 从序列中<strong>随机</strong>挑出一个元素，做为 “基准”(<code>pivot</code>)；</li><li> 重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li> 递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。</li></ol><h4 id="图解算法-5"><a href="#图解算法-5" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/08.gif"></p><h4 id="代码实现-5"><a href="#代码实现-5" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">partition</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> pivot <span class="token operator">=</span> array<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> pointer <span class="token operator">=</span> low<span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> low<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> high<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> pivot<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span><span class="token punctuation">;</span>            array<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>            pointer<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span>array<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> temp <span class="token operator">=</span> array<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span><span class="token punctuation">;</span>    array<span class="token punctuation">[</span>pointer<span class="token punctuation">]</span> <span class="token operator">=</span> array<span class="token punctuation">[</span>high<span class="token punctuation">]</span><span class="token punctuation">;</span>    array<span class="token punctuation">[</span>high<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>    <span class="token keyword">return</span> pointer<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">quickSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> array<span class="token punctuation">,</span> <span class="token keyword">int</span> low<span class="token punctuation">,</span> <span class="token keyword">int</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>low <span class="token operator">&lt;</span> high<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> position <span class="token operator">=</span> <span class="token function">partition</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> low<span class="token punctuation">,</span> position <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">quickSort</span><span class="token punctuation">(</span>array<span class="token punctuation">,</span> position <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> high<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong> ：不稳定</li><li>  <strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)，平均：O(nlogn)</li><li>  <strong>空间复杂度</strong> ：O(nlogn)</li></ul><h3 id="8-堆排序-Heap-Sort"><a href="#8-堆排序-Heap-Sort" class="headerlink" title="8. 堆排序 (Heap Sort)"></a>8. 堆排序 (Heap Sort)</h3><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足<strong>堆的性质</strong>：即<strong>子结点的值总是小于（或者大于）它的父节点</strong>。</p><h4 id="算法步骤-6"><a href="#算法步骤-6" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li> 将初始待排序列 <code>(R1, R2, ……, Rn)</code> 构建成大顶堆，此堆为初始的无序区；</li><li> 将堆顶元素 <code>R[1]</code> 与最后一个元素 <code>R[n]</code> 交换，此时得到新的无序区 <code>(R1, R2, ……, Rn-1)</code> 和新的有序区 (Rn), 且满足 <code>R[1, 2, ……, n-1]&lt;=R[n]</code>；</li><li> 由于交换后新的堆顶 <code>R[1]</code> 可能违反堆的性质，因此需要对当前无序区 <code>(R1, R2, ……, Rn-1)</code> 调整为新堆，然后再次将 R [1] 与无序区最后一个元素交换，得到新的无序区 <code>(R1, R2, ……, Rn-2)</code> 和新的有序区 <code>(Rn-1, Rn)</code>。不断重复此过程直到有序区的元素个数为 <code>n-1</code>，则整个排序过程完成。</li></ol><h4 id="图解算法-6"><a href="#图解算法-6" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/09.gif"></p><h4 id="代码实现-6"><a href="#代码实现-6" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// Global variable that records the length of an array;</span><span class="token keyword">static</span> <span class="token keyword">int</span> heapLen<span class="token punctuation">;</span><span class="token comment">/** * Swap the two elements of an array * @param arr * @param i * @param j */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>    arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * Build Max Heap * @param arr */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * Adjust it to the maximum heap * @param arr * @param i */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapify</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> left <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> right <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> i <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> largest <span class="token operator">=</span> i<span class="token punctuation">;</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>right <span class="token operator">&lt;</span> heapLen <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>right<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        largest <span class="token operator">=</span> right<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>left <span class="token operator">&lt;</span> heapLen <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>left<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>largest<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        largest <span class="token operator">=</span> left<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>largest <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> largest<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token comment">/** * Heap Sort * @param arr * @return */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">heapSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// index at the end of the heap</span>    heapLen <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">// build MaxHeap</span>    <span class="token function">buildMaxHeap</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// Move the top of the heap to the tail of the heap in turn</span>        <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>        heapLen <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token function">heapify</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong> ：不稳定</li><li>  <strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li><li>  <strong>空间复杂度</strong> ：O(1)</li></ul><h3 id="9-计数排序-Counting-Sort"><a href="#9-计数排序-Counting-Sort" class="headerlink" title="9. 计数排序 (Counting Sort)"></a>9. 计数排序 (Counting Sort)</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，<strong>计数排序要求输入的数据必须是有确定范围的整数</strong>。</p><p>计数排序 (Counting sort) 是一种稳定的排序算法。计数排序使用一个额外的数组 <code>C</code>，其中第 <code>i</code> 个元素是待排序数组 <code>A</code> 中值等于 <code>i</code> 的元素的个数。然后根据数组 <code>C</code> 来将 <code>A</code> 中的元素排到正确的位置。<strong>它只能对整数进行排序</strong>。</p><h4 id="算法步骤-7"><a href="#算法步骤-7" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li> 找出数组中的最大值 <code>max</code>、最小值 <code>min</code>；</li><li> 创建一个新数组 <code>C</code>，其长度是 <code>max-min+1</code>，其元素默认值都为 0；</li><li> 遍历原数组 <code>A</code> 中的元素 <code>A[i]</code>，以 <code>A[i]-min</code> 作为 <code>C</code> 数组的索引，以 <code>A[i]</code> 的值在 <code>A</code> 中元素出现次数作为 <code>C[A[i]-min]</code> 的值；</li><li> 对 <code>C</code> 数组变形，<strong>新元素的值是该元素与前一个元素值的和</strong>，即当 <code>i&gt;1</code> 时 <code>C[i] = C[i] + C[i-1]</code>；</li><li> 创建结果数组 <code>R</code>，长度和原始数组一样。</li><li> <strong>从后向前</strong>遍历原始数组 <code>A</code> 中的元素 <code>A[i]</code>，使用 <code>A[i]</code> 减去最小值 <code>min</code> 作为索引，在计数数组 <code>C</code> 中找到对应的值 <code>C[A[i]-min]</code>，<code>C[A[i]-min]-1</code> 就是 <code>A[i]</code> 在结果数组 <code>R</code> 中的位置，做完上述这些操作，将 <code>count[A[i]-min]</code> 减小 1。</li></ol><h4 id="图解算法-7"><a href="#图解算法-7" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/10.gif"></p><h4 id="代码实现-7"><a href="#代码实现-7" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Gets the maximum and minimum values in the array * * @param arr * @return */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getMinAndMax</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> maxValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> minValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&gt;</span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxValue <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> minValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            minValue <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> minValue<span class="token punctuation">,</span> maxValue <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * Counting Sort * * @param arr * @return */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">countingSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> extremum <span class="token operator">=</span> <span class="token function">getMinAndMax</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> minValue <span class="token operator">=</span> extremum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> maxValue <span class="token operator">=</span> extremum<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> countArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>maxValue <span class="token operator">-</span> minValue <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        countArr<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minValue<span class="token punctuation">]</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> countArr<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        countArr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">+=</span> countArr<span class="token punctuation">[</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> countArr<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minValue<span class="token punctuation">]</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        result<span class="token punctuation">[</span>idx<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>        countArr<span class="token punctuation">[</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">-</span> minValue<span class="token punctuation">]</span> <span class="token operator">-=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h4><p>当输入的元素是 <code>n</code> 个 <code>0</code> 到 <code>k</code> 之间的整数时，它的运行时间是 <code>O(n+k)</code>。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 <code>C</code> 的长度取决于待排序数组中数据的范围（等于待排序数组的<strong>最大值与最小值的差加上 1</strong>），这使得计数排序对于数据范围很大的数组，需要大量额外内存空间。</p><ul><li>  <strong>稳定性</strong> ：稳定</li><li>  <strong>时间复杂度</strong> ：最佳：<code>O(n+k)</code> 最差：<code>O(n+k)</code> 平均：<code>O(n+k)</code></li><li>  <strong>空间复杂度</strong> ：<code>O(k)</code></li></ul><h3 id="10-桶排序-Bucket-Sort"><a href="#10-桶排序-Bucket-Sort" class="headerlink" title="10. 桶排序 (Bucket Sort)"></a>10. 桶排序 (Bucket Sort)</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li> 在额外空间充足的情况下，尽量增大桶的数量</li><li> 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行。</p><h4 id="算法步骤-8"><a href="#算法步骤-8" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li> 设置一个 BucketSize，作为每个桶所能放置多少个不同数值；</li><li> 遍历输入数据，并且把数据依次映射到对应的桶里去；</li><li> 对每个非空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li> 从非空桶里把排好序的数据拼接起来。</li></ol><h4 id="图解算法-8"><a href="#图解算法-8" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/11.gif"></p><h4 id="代码实现-8"><a href="#代码实现-8" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Gets the maximum and minimum values in the array * @param arr * @return */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">getMinAndMax</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">int</span> maxValue <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> minValue <span class="token operator">=</span> arr<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&gt;</span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxValue <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> minValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            minValue <span class="token operator">=</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">{</span> minValue<span class="token punctuation">,</span> maxValue <span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">/** * Bucket Sort * @param arr * @return */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token function">bucketSort</span><span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> bucket_size<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">2</span> <span class="token operator">||</span> bucket_size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> extremum <span class="token operator">=</span> <span class="token function">getMinAndMax</span><span class="token punctuation">(</span>arr<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> minValue <span class="token operator">=</span> extremum<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> maxValue <span class="token operator">=</span> extremum<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> bucket_cnt <span class="token operator">=</span> <span class="token punctuation">(</span>maxValue <span class="token operator">-</span> minValue<span class="token punctuation">)</span> <span class="token operator">/</span> bucket_size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> buckets <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> bucket_cnt<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        buckets<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> element <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token punctuation">(</span>element <span class="token operator">-</span> minValue<span class="token punctuation">)</span> <span class="token operator">/</span> bucket_size<span class="token punctuation">;</span>        buckets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> buckets<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>buckets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            buckets<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> <span class="token function">sort</span><span class="token punctuation">(</span>buckets<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">,</span> bucket_size <span class="token operator">/</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> result <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> bucket <span class="token operator">:</span> buckets<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> element <span class="token operator">:</span> bucket<span class="token punctuation">)</span> <span class="token punctuation">{</span>            result<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> result<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong> ：稳定</li><li>  <strong>时间复杂度</strong> ：最佳：<code>O(n+k)</code> 最差：<code>O(n²)</code> 平均：<code>O(n+k)</code></li><li>  <strong>空间复杂度</strong> ：<code>O(k)</code></li></ul><h3 id="11-基数排序-Radix-Sort"><a href="#11-基数排序-Radix-Sort" class="headerlink" title="11. 基数排序 (Radix Sort)"></a>11. 基数排序 (Radix Sort)</h3><p>基数排序也是非比较的排序算法，对元素中的每一位数字进行排序，从最低位开始排序，复杂度为 <code>O(n×k)</code>，<code>n</code> 为数组长度，<code>k</code> 为数组中元素的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序。最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。</p><h4 id="算法步骤-9"><a href="#算法步骤-9" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li> 取得数组中的最大数，并取得位数，即为迭代次数 <code>N</code>（例如：数组中最大数值为 1000，则 <code>N=4</code>）；</li><li> <code>A</code> 为原始数组，从最低位开始取每个位组成 <code>radix</code> 数组；</li><li> 对 <code>radix</code> 进行计数排序（利用计数排序适用于小范围数的特点）；</li><li> 将 <code>radix</code> 依次赋值给原数组；</li><li> 重复 2~4 步骤 <code>N</code> 次</li></ol><h4 id="图解算法-9"><a href="#图解算法-9" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/12.gif"></p><h4 id="代码实现-9"><a href="#代码实现-9" class="headerlink" title="代码实现"></a>代码实现</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * Radix Sort * * @param arr * @return */</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">radixSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> arr<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">int</span> <span class="token class-name">N</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token keyword">int</span> maxValue <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> element <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>element <span class="token operator">&gt;</span> maxValue<span class="token punctuation">)</span> <span class="token punctuation">{</span>            maxValue <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>maxValue <span class="token operator">/</span> <span class="token number">10</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        maxValue <span class="token operator">=</span> maxValue <span class="token operator">/</span> <span class="token number">10</span><span class="token punctuation">;</span>        <span class="token class-name">N</span> <span class="token operator">+=</span> <span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token class-name">N</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">List</span><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> radix <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> k<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            radix<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> element <span class="token operator">:</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token punctuation">(</span>element <span class="token operator">/</span> <span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">)</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">pow</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">%</span> <span class="token number">10</span><span class="token punctuation">;</span>            radix<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>idx<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> l <span class="token operator">:</span> radix<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> n <span class="token operator">:</span> l<span class="token punctuation">)</span> <span class="token punctuation">{</span>                arr<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> n<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> arr<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="算法分析-9"><a href="#算法分析-9" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong> ：稳定</li><li>  <strong>时间复杂度</strong> ：最佳：<code>O(n×k)</code> 最差：<code>O(n×k)</code> 平均：<code>O(n×k)</code></li><li>  <strong>空间复杂度</strong> ：<code>O(n+k)</code></li></ul><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>  基数排序：根据键值的每位数字来分配桶</li><li>  计数排序：每个桶只存储单一键值</li><li>  桶排序：每个桶存储一定范围的数值</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-分类&quot;&gt;&lt;a href=&quot;#1-分类&quot; class=&quot;headerlink&quot; title=&quot;1. 分类&quot;&gt;&lt;/a&gt;1. 分类&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;  &lt;strong&gt;内部排序&lt;/strong&gt; ：数据记录在内存中进行排序。&lt;/li&gt;
&lt;li&gt;  &lt;str</summary>
      
    
    
    
    
    <category term="算法" scheme="http://ailiaa.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>堆</title>
    <link href="http://ailiaa.github.io/2023/03/10/dui/"/>
    <id>http://ailiaa.github.io/2023/03/10/dui/</id>
    <published>2023-03-10T06:47:35.000Z</published>
    <updated>2023-03-10T07:01:11.361Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1-什么是堆"><a href="#1-什么是堆" class="headerlink" title="1. 什么是堆"></a>1. 什么是堆</h3><p>堆是一种满足以下条件的树：</p><p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p><h3 id="2-堆的用途"><a href="#2-堆的用途" class="headerlink" title="2. 堆的用途"></a>2. 堆的用途</h3><p>当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。</p><p>可能会想到用有序数组，初始化一个有序数组时间复杂度是 <code>O(nlog(n))</code>，查找最大值或者最小值时间复杂度都是 <code>O(1)</code>，但是，涉及到更新（插入或删除）数据时，时间复杂度为 <code>O(n)</code>，即使是使用复杂度为 <code>O(log(n))</code> 的二分法找到要插入或者删除的数据，在移动数据时也需要 <code>O(n)</code> 的时间复杂度。</p><p><strong>相对于有序数组而言，堆的主要优势在于更新数据效率较高。</strong> 堆的初始化时间复杂度为 <code>O(nlog(n))</code>，堆可以做到<code>O(1)</code>时间复杂度取出最大值或者最小值，<code>O(log(n))</code>时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。</p><h3 id="3-堆的分类"><a href="#3-堆的分类" class="headerlink" title="3. 堆的分类"></a>3. 堆的分类</h3><p>堆分为 <strong>最大堆</strong> 和 <strong>最小堆</strong>。二者的区别在于节点的排序方式。</p><ul><li>  <strong>最大堆</strong> ：堆中的每一个节点的值都大于等于子树中所有节点的值</li><li>  <strong>最小堆</strong> ：堆中的每一个节点的值都小于等于子树中所有节点的值</li></ul><p>如下图所示，图1是最大堆，图2是最小堆</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/01.png"></p><h3 id="4-堆的存储"><a href="#4-堆的存储" class="headerlink" title="4. 堆的存储"></a>4. 堆的存储</h3><p>由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为1，那么对于树中任意节点i，其左子节点序号为 <code>2*i</code>，右子节点序号为 <code>2*i+1</code>）。</p><p>为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/02.png"></p><h3 id="5-堆的操作"><a href="#5-堆的操作" class="headerlink" title="5. 堆的操作"></a>5. 堆的操作</h3><p>堆的更新操作主要包括两种 : <strong>插入元素</strong> 和 <strong>删除堆顶元素</strong>。</p><h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p><strong>1.将要插入的元素放到最后</strong></p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/03.png"></p><p><strong>2.从底向上，如果父结点比该元素小，则该节点和父结点交换，直到无法交换</strong></p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/04.png"></p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/05.png"></p><h4 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h4><p>根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。</p><p>删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为”<strong>堆化</strong>“，堆化的方法分为两种：</p><ul><li>  一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。</li><li>  另一种是自顶向下堆化，元素由最顶部向下移动。</li></ul><h5 id="自底向上堆化"><a href="#自底向上堆化" class="headerlink" title="自底向上堆化"></a>自底向上堆化</h5><p>首先删除堆顶元素，使得数组中下标为1的位置空出。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/06.png"></p><p>比较根结点的左子节点和右子节点，也就是下标为2,3的数组元素，将较大的元素填充到根结点(下标为1)的位置<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/07.png"></p><p>一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/08.png"></p><p>这个时候已经完成了自底向上的堆化，没有元素可以填补空缺了，但是，我们可以看到数组中出现了“气泡”，这会导致存储空间的浪费。接下来我们试试自顶向下堆化。</p><h5 id="自顶向下堆化"><a href="#自顶向下堆化" class="headerlink" title="自顶向下堆化"></a>自顶向下堆化</h5><p>自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/09.png"></p><p>然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/10.png"></p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/11.png"></p><h4 id="堆的操作总结"><a href="#堆的操作总结" class="headerlink" title="堆的操作总结"></a>堆的操作总结</h4><ul><li>  <strong>插入元素</strong> ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</li><li>  <strong>删除堆顶元素</strong> ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。</li></ul><h3 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h3><p>堆排序的过程分为两步：</p><ul><li>  第一步是建堆，将一个无序的数组建立为一个堆</li><li>  第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。</li></ul><h4 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h4><p>如果你已经足够了解堆化的过程，那么建堆的过程掌握起来就比较容易了。建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。</p><p>首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为n，那么我们需要对n/2到1的节点进行自顶向下（沉底）堆化。</p><p>具体过程如下图：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/12.png"></p><p>将初始的无序数组抽象为一棵树，图中的节点个数为6，所以4,5,6节点为叶节点，1,2,3节点为非叶节点，所以要对1-3号节点进行自顶向下（沉底）堆化，注意，顺序是从后往前堆化，从3号节点开始，一直到1号节点。 3号节点堆化结果：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/13.png"></p><p>2号节点堆化结果：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/14.png"></p><p>1号节点堆化结果：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/15.png"></p><p>至此，数组所对应的树已经成为了一个最大堆</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。</p><p>我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。</p><p>这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。</p><p>取出第一个元素并堆化：<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/16.png"><br>取出第二个元素并堆化：<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/17.png"><br>取出第三个元素并堆化：<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/18.png"><br>取出第四个元素并堆化：<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/19.png"></p><p>取出第五个元素并堆化：<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/20.png"><br>取出第六个元素并堆化：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/21.png"></p><p>堆排序完成</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;1-什么是堆&quot;&gt;&lt;a href=&quot;#1-什么是堆&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是堆&quot;&gt;&lt;/a&gt;1. 什么是堆&lt;/h3&gt;&lt;p&gt;堆是一种满足以下条件的树：&lt;/p&gt;
&lt;p&gt;堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。</summary>
      
    
    
    
    
    <category term="数据结构" scheme="http://ailiaa.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
</feed>
