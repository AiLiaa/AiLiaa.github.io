<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>k8s</title>
      <link href="/2023/06/28/k8s/"/>
      <url>/2023/06/28/k8s/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是k8s"><a href="#什么是k8s" class="headerlink" title="什么是k8s"></a>什么是k8s</h3><p>K8s是指Kubernetes，是一个用于自动化部署、扩展和管理容器化应用程序的开源平台。</p><p>简单来说，k8s就是一个<strong>编排容器的系统</strong></p><p>Kubernetes提供了一个可移植、可扩展的平台，可以自动化部署、扩展和管理应用程序。</p><p>Kubernetes基于容器技术，实现自动化的容器编排和管理，可以自动调度容器到集群中的节点上，并根据应用的需求进行水平扩展和负载均衡。</p><h3 id="k8s的核心组件有哪些"><a href="#k8s的核心组件有哪些" class="headerlink" title="k8s的核心组件有哪些"></a>k8s的核心组件有哪些</h3><ol><li><p>etcd：一个可靠的分布式键值存储，用于存储 Kubernetes 集群的状态信息。</p></li><li><p>kube-apiserver：提供了一个Kubernetes API，其他组件都可以通过该API与集群进行交互操作。（集群管理，数据交互）</p></li><li><p>kube-controller-manager：负责控制器的管理，运行各种控制器来确保系统的自愈能力，比如Replication Controller、Endpoint Controller等。</p></li><li><p>kube-scheduler：根据调度算法为新创建的Pod选择一个合适的Node，并将其绑定到该节点上。</p></li><li><p>kubelet：运行在每个Node上，负责启动Pod并确保Pod内的容器处于正常运行状态。</p></li><li><p>kube-proxy：负责为Service 提供 Cluster 内部的服务发现和负载均衡功能。</p></li><li><p>container-runtime：容器运行时环境，即运行容器所需要的一系列程序（docker）</p></li></ol><p>k8s主要由master节点和node节点构成。</p><p>master节点负责管理集群，node节点是容器应用真正运行的地方。 </p><ul><li>master节点包含的组件有：kube-api-server、kube-controller-manager、kube-scheduler、etcd。 </li><li>node节点包含的组件有：kubelet、kube-proxy、container-runtime</li></ul><h3 id="kube-api-server的端口是多少？各个pod是如何访问kube-api-server的"><a href="#kube-api-server的端口是多少？各个pod是如何访问kube-api-server的" class="headerlink" title="kube-api-server的端口是多少？各个pod是如何访问kube-api-server的"></a>kube-api-server的端口是多少？各个pod是如何访问kube-api-server的</h3><p>kube-api-server的端口是8080和6443，前者是http的端口，后者是https的端口</p><p>Pod可以通过以下两种方式访问kube-apiserver：</p><ol><li>使用环境变量：Kubernetes在每个Pod中注入了一些环境变量，其中包括了kube-apiserver的服务地址和端口信息。</li><li>使用Kubernetes集群内部DNS：在Kubernetes集群中，每个Service都会分配一个唯一的DNS名称。kube-apiserver作为一个Service，也有一个DNS名称。Pod可以使用这个DNS名称来解析出kube-apiserver的IP地址。Pod可以通过该IP地址和kube-apiserver的暴露端口进行通信。</li></ol><h3 id="k8s中命名空间的作用是什么"><a href="#k8s中命名空间的作用是什么" class="headerlink" title="k8s中命名空间的作用是什么"></a>k8s中命名空间的作用是什么</h3><p>Kubernetes中的命名空间（Namespace）是一种用于<strong>隔离</strong>不同资源和对象的机制。它可以将一个Kubernetes集群划分为多个虚拟集群，每个命名空间提供了一个独立的工作空间，用于组织和管理应用程序、服务和其他资源。</p><p>通过它可以实现资源隔离、资源管理、访问控制、共享资源和管理视图等多种功能，帮助用户更好地组织和管理集群中的资源和工作负载。</p><h3 id="pod是什么"><a href="#pod是什么" class="headerlink" title="pod是什么"></a>pod是什么</h3><p>Pod是Kubernetes中<strong>最小的可部署和可管理单元</strong>。它是一组关联的容器集合，共享同一个网络命名空间、存储卷以及其他资源。</p><p>Pod是Kubernetes中最基本的部署单元，它提供了一种逻辑上独立和可扩展的环境，使得多个容器可以在同一个Pod中协同工作，方便k8s对容器的调度和管理</p><h3 id="pod有什么特点"><a href="#pod有什么特点" class="headerlink" title="pod有什么特点"></a>pod有什么特点</h3><ol><li>共享网络：Pod内的所有容器共享同一个网络命名空间。</li><li>共享存储：Pod内的容器可以访问共享的存储卷。这样可以实现数据的持久化和共享。</li><li>生命周期绑定：Pod中的容器具有相同的生命周期，它们一起启动、调度和停止。当Pod被删除时，Pod中的所有容器也将被删除。</li><li>紧密关联：Pod中的容器经常需要相互配合工作。它们可以通过本地环回网络进行通信，无需通过网络暴露端口。</li><li>每个pod就像一个<strong>独立</strong>的逻辑机器，k8s会为每个pod分配一个集群内部唯一的IP地址，每个pod都拥有自己的IP地址、主机名、进程等；</li></ol><h3 id="pause容器是什么"><a href="#pause容器是什么" class="headerlink" title="pause容器是什么"></a>pause容器是什么</h3><p>Pause容器是一个轻量级容器，它的主要作用是<strong>协调Pod中其他容器的网络和存储功能</strong>。</p><p>当Pod中有多个容器时，Kubernetes使用pause容器来共享网络命名空间、IPC命名空间和volume存储卷等资源，并确保其他容器可以使用这些资源。</p><ul><li><strong>网络共享</strong>：当pod被创建时，pod首先会创建pause容器，从而把其他业务容器加入pause容器，从而让所有业务容器都在同一个命名空间中，实现网络共享。</li><li><strong>共享存储</strong>：在pod级别引入数据卷volume，业务容器都可以挂载这个数据卷从而实现持久化存储。</li></ul><h3 id="pod的重启策略有哪些"><a href="#pod的重启策略有哪些" class="headerlink" title="pod的重启策略有哪些"></a>pod的重启策略有哪些</h3><p>pod重启容器策略是指针对pod内<strong>所有容器</strong>的重启策略，不是重启pod</p><p>可以通过<code>restartPolicy</code>字段配置pod重启容器的策略</p><ul><li><code>Always</code>: 当容器终止退出后，总是重启容器，默认策略就是<code>Always</code>。</li><li><code>OnFailure</code>: 当容器异常退出，退出状态码非0时，才重启容器。</li><li><code>Never</code>: 当容器终止退出，不管退出状态码是什么，从不重启容器。</li></ul><h3 id="pod的镜像拉取策略有哪几种"><a href="#pod的镜像拉取策略有哪几种" class="headerlink" title="pod的镜像拉取策略有哪几种"></a>pod的镜像拉取策略有哪几种</h3><p>pod镜像拉取策略可以通过<code>imagePullPolicy</code>字段配置镜像拉取策略</p><ul><li><code>IfNotPresent</code>: 默认值，镜像在node节点宿主机上不存在时才拉取。</li><li><code>Always</code>: 总是重新拉取，即每次创建pod都会重新从镜像仓库拉取一次镜像。</li><li><code>Never</code>: 永远不会主动拉取镜像，仅使用本地镜像，需要手动拉取镜像到node节点，如果node节点不存在镜像则pod启动失败。</li></ul><h3 id="pod的存活探针有哪几种"><a href="#pod的存活探针有哪几种" class="headerlink" title="pod的存活探针有哪几种"></a>pod的存活探针有哪几种</h3><p>kubernetes可以通过存活探针检查容器是否还在运行，可以为pod中的每个容器单独定义存活探针，kubernetes将定期执行探针，如果探测失败，将杀死容器，并根据<code>restartPolicy</code>策略来决定是否重启容器</p><p>kubernetes提供了3种探测容器的存活探针</p><ul><li><code>httpGet</code>：通过容器的IP、端口、路径发送http 请求，返回200-400范围内的状态码表示成功。</li><li><code>exec</code>：在容器内执行shell命令，根据命令退出状态码是否为0进行判断，0表示健康，非0表示不健康。</li><li><code>TCPSocket</code>：与容器的端口建立TCP Socket链接。</li></ul><h3 id="存活探针的属性参数有哪几个"><a href="#存活探针的属性参数有哪几个" class="headerlink" title="存活探针的属性参数有哪几个"></a>存活探针的属性参数有哪几个</h3><ul><li><code>initialDelaySeconds</code>：表示在容器启动后延时多久秒才开始探测；</li><li><code>periodSeconds</code>：表示执行探测的频率，即间隔多少秒探测一次，默认间隔周期是10秒，最小1秒；</li><li><code>timeoutSeconds</code>：表示探测超时时间，默认1秒，最小1秒，表示容器必须在超时时间范围内做出响应，否则视为本次探测失败；</li><li><code>successThreshold</code>：表示最少连续探测成功多少次才被认定为成功，默认是1</li><li><code>failureThreshold</code>：表示连续探测失败多少次才被认定为失败，默认是3，连续3次失败，k8s 将根据pod重启策略对容器做出决定；</li></ul><h3 id="pod的就绪探针有哪几种"><a href="#pod的就绪探针有哪几种" class="headerlink" title="pod的就绪探针有哪几种"></a>pod的就绪探针有哪几种</h3><p>当一个pod启动后，就会立即加入service的endpoint ip列表中，并开始接收到客户端的链接请求，假若此时pod中的容器的业务进程还没有初始化完毕，那么这些客户端链接请求就会失败，为了解决这个问题，kubernetes提供了就绪探针来解决这个问题的。</p><p>在pod中的容器定义一个就绪探针，就绪探针周期性检查容器，如果就绪探针检查失败了，说明该pod还未准备就绪，不能接受客户端链接，则该pod将从endpoint列表中移除</p><p>k8s提供了3种就绪探针</p><ul><li><code>exec</code>：在容器中执行命令并检查命令退出的状态码，如果状态码为0，则说明容器已经准备就绪；</li><li><code>httpGet</code>：向容器发送http get请求，通过响应的http状态码判断容器是否准备就绪；</li><li><code>tcpSocket</code>：打开一个tcp连接到容器的指定端口，如果连接已建立，则认为容器已经准备就绪。</li></ul><h3 id="就绪探针的属性参数有哪些"><a href="#就绪探针的属性参数有哪些" class="headerlink" title="就绪探针的属性参数有哪些"></a>就绪探针的属性参数有哪些</h3><ul><li><code>initialDelaySeconds</code>：延时秒数，即容器启动多少秒后才开始探测，不写默认容器启动就探测；</li><li><code>periodSeconds</code>&nbsp;：执行探测的频率（秒），默认为10秒，最低值为1；</li><li><code>timeoutSeconds</code>&nbsp;：超时时间，表示探测时在超时时间内必须得到响应，负责视为本次探测失败，默认为1秒，最小值为1；</li><li><code>failureThreshold</code>&nbsp;：连续探测失败的次数，视为本次探测失败，默认为3次，最小值为1次；</li><li><code>successThreshold</code>&nbsp;：连续探测成功的次数，视为本次探测成功，默认为1次，最小值为1次；</li></ul><h3 id="就绪探针与存活探针区别是什么"><a href="#就绪探针与存活探针区别是什么" class="headerlink" title="就绪探针与存活探针区别是什么"></a>就绪探针与存活探针区别是什么</h3><p>作用上的区别：</p><p>存活探针：当存活探针检查失败，是将检查失败的容器杀死，创建新的启动容器来保持pod正常工作；</p><p>就绪探针：当就绪探针检查失败，并不重启容器，而是将pod移出endpoint，就绪探针确保了service中的pod都是可用的，确保客户端只与正常的pod交互</p><h3 id="简单讲一下-pod创建过程"><a href="#简单讲一下-pod创建过程" class="headerlink" title="简单讲一下 pod创建过程"></a>简单讲一下 pod创建过程</h3><p><img src="/images/image_%E5%88%86%E5%B8%83%E5%BC%8F/2.png"></p><p>首先，需要编写一个包含Pod配置信息的描述文件，通常使用YAML或JSON格式。在描述文件中，定义Pod的名称、命名空间、容器、网络设置、存储卷等相关配置。</p><ol><li>用户通过kubectl向api-server发起创建pod请求。</li><li>apiserver通过对应的kubeconfig进行认证，认证通过后将yaml中的po信息存到etcd。</li><li>Controller-Manager通过apiserver的watch接口发现了pod信息的更新，整合对应的信息交给apiserver，apiserver写到etcd，此时pod已经可以被调度。</li><li>Scheduler同样通过apiserver的watch接口更新到pod可以被调度，通过算法给pod分配节点，并将pod和对应节点绑定的信息交给apiserver，apiserver写到etcd，然后将pod交给kubelet。</li><li>kubelet收到pod后，调用CNI接口给pod创建pod网络，调用CRI接口去启动容器，调用CSI进行存储卷的挂载。</li><li>网络，容器，存储创建完成后pod创建完成，等业务进程启动后，pod运行成功。</li></ol><h3 id="说说pod的终止过程"><a href="#说说pod的终止过程" class="headerlink" title="说说pod的终止过程"></a>说说pod的终止过程</h3><ol><li>用户向apiserver发送删除pod对象的命令</li><li>apiserver中的pod对象信息会随着时间的推移而更新，在宽限期内（默认30s），pod被视为dead</li><li>将pod标记为terminating状态</li><li>kubectl在监控到pod对象为状态了就会启动pod关闭过程</li><li>endpoint控制器监控到pod对象的关闭行为时将其从所有匹配到此endpoint的server资源endpoint列表中删除</li><li>如果当前pod对象定义了preStop钩子处理器，则在其被标记为terminating后会意同步的方式启动执行</li><li>pod对象中的容器进程收到停止信息</li><li>宽限期结束后，若pod中还存在运行的进程，那么pod对象会收到立即终止的信息</li><li>kubelet请求apiserver将此pod资源的宽限期设置为0从而完成删除操作，此时pod对用户已不可见</li></ol><h3 id="pod的生命周期有哪几种（也称5种相位）"><a href="#pod的生命周期有哪几种（也称5种相位）" class="headerlink" title="pod的生命周期有哪几种（也称5种相位）"></a>pod的生命周期有哪几种（也称5种相位）</h3><p>pod生命周期有的5种状态</p><ul><li><strong>Pending</strong>（挂起）：API server已经创建pod，但是该pod还有一个或多个容器的镜像没有创建，包括正在下载镜像的过程；</li><li><strong>Running</strong>（运行中）：Pod内所有的容器已经创建，且至少有一个容器处于运行状态、正在启动或者正在重启状态；</li><li><strong>Succeed</strong>（成功）：Pod内所有容器均已退出，且不会再重启；</li><li><strong>Failed</strong>（失败）：Pod内所有容器均已退出，且至少有一个容器为退出失败状态</li><li><strong>Unknown</strong>（未知）：某于某种原因apiserver无法获取该pod的状态，可能由于网络通行问题导致；</li></ul><h3 id="pod的初始化容器是干什么的"><a href="#pod的初始化容器是干什么的" class="headerlink" title="pod的初始化容器是干什么的"></a>pod的初始化容器是干什么的</h3><p>init container，初始化容器用于在启动应用容器之前完成应用容器所需要的前置条件</p><p>1、初始化容器必须运行完成直至结束，若某初始化容器运行失败，那么kubernetes需要重启它直到成功完成；</p><p>2、初始化容器必须按照定义的顺序执行，当且仅当前一个初始化容器成功之后，后面的一个初始化容器才能运行；</p><h3 id="service是什么"><a href="#service是什么" class="headerlink" title="service是什么"></a>service是什么</h3><p>Service是一种定义了一组Pod的网络访问方式的资源对象。它为一组具有相同功能的Pod提供了一个统一的入口，并将它们封装在一个虚拟的服务IP地址后面。</p><p>Service可以通过一个稳定的IP地址和端口提供对应用程序的访问，无论这些应用程序运行在Kubernetes集群内的哪个节点上。它为应用程序提供了一种抽象层，使得后端Pod的变动对外界用户来说是透明的。</p><p>主要特性：</p><ol><li>服务发现和负载均衡：Service通过为一组Pod分配唯一的虚拟IP地址和端口，实现了服务发现功能。它会自动将请求均匀地分发到后端Pod中，从而实现负载均衡。</li><li>稳定的网络标识：每个Service都有一个稳定的虚拟IP地址和端口，这个地址和端口可以长期保持不变。</li><li>内部和外部访问：内部Service仅在集群内部可用，用于集群内部的服务通信。外部Service则通过负载均衡器、节点端口或外部IP地址等方式，将流量从集群外部引导到Service中。</li></ol><h3 id="endpoint是什么"><a href="#endpoint是什么" class="headerlink" title="endpoint是什么"></a>endpoint是什么</h3><p>Endpoint是一种资源对象，用于表示一个Service所关联的后端Pod的网络终点。它存储着Service要连接到的实际后端Pod的IP地址和端口信息。</p><p>Endpoint对象主要有两个作用：</p><ol><li>服务发现：Endpoints对象记录了与Service关联的所有后端Pod的网络地址信息。</li><li>负载均衡：Endpoints对象中可以包含多个后端Pod的IP地址和端口。当请求到达Service时，Kubernetes会将请求按照负载均衡算法分发到不同的后端Pod上，从而平衡流量负载。</li></ol><h3 id="kube-proxy是什么"><a href="#kube-proxy是什么" class="headerlink" title="kube-proxy是什么"></a>kube-proxy是什么</h3><p>kube-proxy是Kubernetes集群中的一个组件，它负责实现Service的网络代理和负载均衡功能。</p><p>kube-proxy运行在每个节点上，并监听Kubernetes API服务器上的Service和Endpoint对象的变化。它会根据这些变化动态地更新节点上的网络规则，以确保流量能够正确地路由到后端Pod上。</p><p>主要功能包括：</p><ol><li>Service代理：kube-proxy会监视Kubernetes API中的Service对象，并为每个Service创建一个虚拟IP地址和端口。当请求到达该虚拟地址时，kube-proxy会将请求转发到后端Pod上，从而实现服务发现和代理功能。</li><li>负载均衡：当请求到达Service的虚拟地址时，kube-proxy会根据预定义的负载均衡算法选择其中一个后端Pod，然后将请求转发给该Pod。</li><li>Endpoint监视：k当Endpoint发生变化时（例如，Pod的添加、删除或IP地址的更改），kube-proxy会相应地更新负载均衡器的配置，以确保流量能够正确地路由到新的后端Pod上。</li></ol><h3 id="deployment是什么"><a href="#deployment是什么" class="headerlink" title="deployment是什么"></a>deployment是什么</h3><p>Deployment是一种资源对象，用于定义和管理Pod副本集。它是Kubernetes中最常用的控制器之一，用于实现应用程序的无缝部署、更新和回滚。</p><p>Deployment对象提供了一种声明式的方式来描述应用程序的期望状态，并由Kubernetes系统负责维护实际状态与期望状态的一致性。</p><p>通过Deployment，可以轻松地进行以下操作：</p><ol><li>创建和管理Pod副本：Deployment根据定义的副本数量和Pod模板创建和管理一组Pod副本。Pod模板定义了每个副本的容器镜像、资源需求、环境变量等信息。</li><li>应用程序的无缝部署：通过修改Deployment对象的配置，可以实现应用程序的无缝部署。例如，可以通过增加副本数量来扩展应用程序，Kubernetes会自动创建新的Pod副本；反之，减少副本数量则会进行缩容。</li><li>应用程序的更新和回滚：通过修改Deployment的Pod模板或更新策略，可以实现应用程序的更新。Kubernetes会逐步替换旧版本的Pod副本，从而实现滚动更新。如果更新过程中出现问题，可以通过回滚操作将应用程序恢复到之前的版本。</li><li>健康检查和自愈能力：Deployment可以配置健康检查来监测Pod副本的运行状态，如果某个副本失败或不可用，Kubernetes会自动替换它，以确保应用程序的稳定性和可用性。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> k8s </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker</title>
      <link href="/2023/06/22/docker/"/>
      <url>/2023/06/22/docker/</url>
      
        <content type="html"><![CDATA[<h3 id="介绍一下-Docker"><a href="#介绍一下-Docker" class="headerlink" title="介绍一下 Docker"></a>介绍一下 Docker</h3><p>Docker是一种开源的容器化平台，用于构建、发布和运行应用程序。</p><p>Docker使用容器化技术，将应用程序及其依赖项打包成一个独立的、可执行的容器，包括应用程序代码、运行时环境、系统工具和依赖库。容器可以在任何支持Docker的环境中运行，而无需担心环境差异或依赖问题。</p><p>通过使用Docker，开发人员和运维团队可以更轻松地构建、交付和管理应用程序，提高开发效率、部署速度和系统可靠性。同时，Docker也为分布式系统、微服务架构和持续集成/持续交付（CI/CD）提供了强大的支持。</p><h3 id="一个完整的Docker由哪些部分组成"><a href="#一个完整的Docker由哪些部分组成" class="headerlink" title="一个完整的Docker由哪些部分组成"></a>一个完整的Docker由哪些部分组成</h3><ol><li>Docker引擎（Docker Engine）：核心组件，负责处理容器的生命周期管理、镜像构建和运行等功能。包括三个主要组件：Docker守护进程（Docker daemon）、REST API以及用于与守护进程进行交互的命令行工具（例如docker命令）。</li><li>Docker镜像（Docker Images）：镜像是Docker的基本构建块，它是一个只读的模板，包含了运行应用程序所需的文件系统、应用程序代码、依赖项和配置信息等。</li><li>Docker容器（Docker Containers）：容器是从镜像创建的运行实例。</li><li>Docker仓库（Docker Registry）：仓库是存储和分发Docker镜像的地方。Docker Hub是最常用的公共仓库，包含大量的官方和社区维护的镜像。</li><li>Docker网络（Docker Networking）：Docker网络允许容器之间进行通信，并与外部网络进行连接。</li><li>Docker数据卷（Docker Volumes）：数据卷是用于持久化和共享数据的机制，可以在容器之间共享文件和目录。数据卷可以附加到容器中，并在容器重新创建时保留数据。</li></ol><h3 id="什么是-Docker镜像"><a href="#什么是-Docker镜像" class="headerlink" title="什么是 Docker镜像"></a>什么是 Docker镜像</h3><p>Docker镜像是Docker容器的基础构建模块，是一个只读的模板，包含了运行应用程序所需的<strong>文件系统、应用程序代码、依赖项和配置信息</strong>等</p><p>镜像可以通过在Dockerfile中定义构建步骤来创建，也可以从Docker Hub等公共或私有仓库中获取现有的镜像。在容器创建时，Docker引擎会使用指定的镜像作为模板，并在只读层的基础上创建一个可写层，从而生成一个运行实例，即容器。</p><p>通过使用镜像，可以实现应用程序的快速部署、可重复性和便携性。每个镜像都是独立和隔离的，可以在各种环境中使用</p><h3 id="什么是-Docker-容器"><a href="#什么是-Docker-容器" class="headerlink" title="什么是 Docker 容器"></a>什么是 Docker 容器</h3><p>Docker容器是一种轻量级的虚拟化技术，用于将应用程序及其依赖项打包在一个可移植的、自包含的环境中。它可以在不同的计算机上运行，而无需担心环境差异、依赖问题或系统冲突。</p><p>通过使用Docker容器，开发人员可以轻松构建、交付和运行应用程序。容器化的应用程序可以在开发、测试和生产环境中保持一致，避免了”在我的机器上可以运行”的问题。</p><p><strong>特点</strong>：</p><ol><li><strong>轻量级</strong>：相比传统虚拟机，它们消耗更少的系统资源和存储空间。可以快速启动、停止和迁移</li><li><strong>可移植性</strong>：Docker容器包含了应用程序及其所有依赖项，可以在任何支持Docker的环境中运行。</li><li><strong>隔离性</strong>：每个Docker容器都是相互隔离的运行时环境，它们共享主机操作系统的内核，但彼此之间相互隔离。</li><li><strong>可扩展性</strong>：通过容器编排工具（Kubernetes），可以自动化地管理和调度多个容器实例，实现高可用性和负载均衡。</li><li><strong>快速部署和回滚</strong>：容器可以在几秒钟内启动，并且支持快速回滚到之前的版本。</li></ol><h3 id="Docker-和虚拟机有什么不同"><a href="#Docker-和虚拟机有什么不同" class="headerlink" title="Docker 和虚拟机有什么不同"></a>Docker 和虚拟机有什么不同</h3><ol><li><strong>架构差异</strong>：传统虚拟机是通过在物理主机上运行一个完整的操作系统来创建虚拟化环境，每个虚拟机都有自己的内核、操作系统和应用程序。而Docker容器共享宿主机的操作系统内核，容器内只运行应用程序及其依赖项，不需要额外的操作系统。</li><li><strong>资源利用</strong>：传统虚拟机需要分配独立的资源（CPU、内存、磁盘空间等）给每个虚拟机，这会导致资源的浪费。Docker容器共享主机操作系统的资源，可以更高效地利用和管理资源，多个容器可以在同一个宿主机上运行，共享内存和硬件。</li><li><strong>启动时间</strong>：传统虚拟机的启动时间通常较长，需要启动完整的操作系统和相关服务。而Docker容器的启动时间非常快速，通常只需几秒钟，因为容器只需要加载应用程序及其依赖项即可运行。</li><li><strong>部署和迁移</strong>：传统虚拟机的部署和迁移相对复杂，需要复制整个虚拟机镜像和配置文件。而Docker容器可以通过镜像来快速部署和迁移，镜像包含了应用程序的代码、依赖项和配置信息，可以在不同的Docker主机上快速复制和运行。</li></ol><h3 id="什么是-DockerFile"><a href="#什么是-DockerFile" class="headerlink" title="什么是 DockerFile"></a>什么是 DockerFile</h3><p>Dockerfile是一种文本文件，用于定义Docker镜像的构建过程。它包含一系列指令和参数，通过这些指令来描述应用程序的组件和依赖关系，以及如何将它们打包成一个可执行的Docker容器。</p><p>在Dockerfile中，以下是一些常用的指令：</p><ol><li>FROM：指定基础镜像，即构建新镜像所基于的现有镜像。</li><li>RUN：在容器中运行命令或脚本，用于安装软件包、配置环境和进行其他系统操作。</li><li>COPY 和 ADD：将文件从主机复制到容器中，可以将应用程序代码、配置文件和其他资源添加到镜像中。</li><li>WORKDIR：设置工作目录，即在容器中执行后续指令时的默认目录。</li><li>ENV：设置环境变量，供容器中的应用程序使用。</li><li>EXPOSE：声明容器应用程序监听的端口，方便在运行容器时进行映射。</li><li>CMD 和 ENTRYPOINT：用于定义容器启动后要运行的命令或脚本。</li></ol><p>通过编写和构建Dockerfile，可以自动化地构建Docker镜像，确保镜像的一致性和可重复性。可以使用<strong>docker build</strong>命令根据Dockerfile构建镜像，并将其保存在本地或推送到远程镜像仓库以供他人使用。</p><p><img src="/images/image_%E5%88%86%E5%B8%83%E5%BC%8F/1.png"></p><h3 id="Docker-Compose-是什么"><a href="#Docker-Compose-是什么" class="headerlink" title="Docker Compose 是什么"></a>Docker Compose 是什么</h3><p>Docker Compose是一个用于定义和管理多个Docker容器的工具，它通过一个单独的YAML文件来描述应用程序的组件、服务之间的关系以及它们的配置。</p><p>使用Docker Compose，可以轻松地在一个命令行界面中定义、启动和停止由多个容器组成的复杂应用程序。可以将复杂的应用程序拆分为多个独立的容器，并使用一个统一的配置文件进行管理。</p><p>主要功能：</p><ol><li><strong>定义多个容器</strong>：通过编写服务的配置，可以定义应用程序所需的多个容器。每个服务定义了一个镜像、容器的依赖关系和其他配置选项。</li><li><strong>管理容器的关系</strong>：自动处理容器之间的网络连接和依赖关系，确保它们正确地启动和通信。</li><li><strong>统一的环境变量和网络设置</strong>：在一个配置文件中指定容器的环境变量、端口映射、网络设置等</li><li><strong>一键启动和停止</strong>：使用docker-compose命令，可以一键启动、停止和重启整个应用程序，而不需要手动操作每个容器。</li></ol><h3 id="使用Docker-Compose时如何保证容器A先于容器B运行"><a href="#使用Docker-Compose时如何保证容器A先于容器B运行" class="headerlink" title="使用Docker Compose时如何保证容器A先于容器B运行"></a>使用Docker Compose时如何保证容器A先于容器B运行</h3><p>Docker Compose 在继续下一个容器之前不会等待容器准备就绪。为了控制我们的执行顺序，我们可以使用“<strong>取决于</strong>”条件，<code>depends_on</code>&nbsp;。</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">version</span><span class="token punctuation">:</span> <span class="token string">"2.4"</span><span class="token key atrule">services</span><span class="token punctuation">:</span> <span class="token key atrule">backend</span><span class="token punctuation">:</span>   <span class="token key atrule">build</span><span class="token punctuation">:</span> .    <span class="token comment"># 构建自定义镜像</span>   <span class="token key atrule">depends_on</span><span class="token punctuation">:</span>     <span class="token punctuation">-</span> db <span class="token key atrule">db</span><span class="token punctuation">:</span>   <span class="token key atrule">image</span><span class="token punctuation">:</span> mysql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>用&nbsp;<code>docker-compose up</code>&nbsp;命令将按照我们指定的依赖顺序启动和运行服务。<br><code>docker-compose down</code>关闭服务</p><h3 id="docker-常用命令有哪些"><a href="#docker-常用命令有哪些" class="headerlink" title="docker 常用命令有哪些"></a>docker 常用命令有哪些</h3><ol><li><p>镜像相关命令：</p><ul><li><code>docker images</code>：列出本地所有的Docker镜像。</li><li><code>docker pull &lt;镜像名&gt;</code>：从仓库下载指定的Docker镜像。</li><li><code>docker push &lt;镜像名&gt;</code>：将本地的Docker镜像推送到仓库中。</li><li><code>docker build -t &lt;镜像名&gt; &lt;Dockerfile路径&gt;</code>：基于Dockerfile构建一个新的Docker镜像。</li><li><code>docker rmi &lt;镜像名&gt;</code>：删除指定的Docker镜像。</li></ul></li><li><p>容器相关命令：</p><ul><li><code>docker ps</code>：列出正在运行的容器。</li><li><code>docker ps -a</code>：列出所有的容器，包括正在运行和已停止的。</li><li><code>docker run &lt;镜像名&gt;</code>：创建并启动一个新的容器。</li><li><code>docker start &lt;容器ID或名称&gt;</code>：启动已停止的容器。</li><li><code>docker stop &lt;容器ID或名称&gt;</code>：停止正在运行的容器。</li><li><code>docker restart &lt;容器ID或名称&gt;</code>：重启容器。</li><li><code>docker rm &lt;容器ID或名称&gt;</code>：删除指定的容器。</li><li><code>docker exec -it &lt;容器ID或名称&gt; &lt;命令&gt;</code>：在正在运行的容器中执行命令。</li></ul></li><li><p>仓库和网络相关命令：</p><ul><li><code>docker login</code>：登录到Docker仓库。</li><li><code>docker logout</code>：登出Docker仓库。</li><li><code>docker search &lt;关键词&gt;</code>：在Docker仓库中搜索镜像。</li><li><code>docker network ls</code>：列出所有的网络。</li><li><code>docker network create &lt;网络名称&gt;</code>：创建一个新的网络。</li></ul></li></ol><h3 id="说说-Docker容器的生命周期"><a href="#说说-Docker容器的生命周期" class="headerlink" title="说说 Docker容器的生命周期"></a>说说 Docker容器的生命周期</h3><p>Docker容器的生命周期包括创建、启动、运行、停止和删除几个主要阶段</p><ol><li>创建阶段：通过使用<code>docker run</code>命令或类似的方式，基于Docker镜像创建一个新的容器。Docker引擎会根据镜像的定义，在镜像的只读层上创建一个可写层，并为容器分配资源。</li><li>启动阶段：通过<code>docker start</code>命令，启动一个已创建但处于停止状态的容器。</li><li>运行阶段：一旦容器启动，它就处于运行状态。可以使用<code>docker exec</code>命令在运行中的容器中执行额外的命令。</li><li>停止阶段：通过<code>docker stop</code>命令，停止一个正在运行的容器。如果应用程序无法正常停止，可以使用<code>docker kill</code>命令来强制停止容器。</li><li>删除阶段：通过<code>docker rm</code>命令，删除一个已停止的容器。</li></ol><p>容器本身是临时的，当容器停止或删除后，它的状态和数据都会丢失。</p><p>为了持久化数据，可以使用数据卷（Volume）或绑定挂载（Bind Mount）等方式将容器内部的数据映射到宿主机上的存储位置。</p><h3 id="docker容器之间怎么隔离"><a href="#docker容器之间怎么隔离" class="headerlink" title="docker容器之间怎么隔离"></a>docker容器之间怎么隔离</h3><p>Docker容器之间通过使用<strong>Linux内核级别的隔离技术</strong>来实现隔离。</p><ol><li>命名空间（Namespaces）：Docker使用了多种命名空间，包括PID（进程ID）、UTS（主机名和域名）、IPC（进程间通信）、网络、挂载点和用户等。每个容器在这些命名空间中具有独立的视图，使得它们在容器内部看到的系统资源是有限的，无法直接访问其他容器的资源。</li><li>控制组（Control Groups，简称cgroups）：cgroups允许对容器中的资源进行限制和分配，例如CPU、内存、磁盘IO等。通过cgroups，可以为每个容器设置资源限制，防止一个容器占用过多的资源对其他容器产生影响。</li><li>文件系统隔离：每个容器都有自己的文件系统空间，容器中的文件系统在本质上是宿主机上的一个目录或文件的快照。</li><li>网络隔离：Docker为每个容器提供了独立的网络命名空间和网络栈，使得容器可以有自己的IP地址、网络接口和路由表。</li></ol><h3 id="Docker-Swarm是什么"><a href="#Docker-Swarm是什么" class="headerlink" title="Docker Swarm是什么"></a>Docker Swarm是什么</h3><p>Docker Swarm 是 Docker 容器的集群管理工具，它允许将多个 Docker 主机组成一个分布式的容器集群。</p><p>通过 Docker Swarm，用户可以使用简单的命令或者 Docker Compose 文件来创建、部署和管理容器集群。Swarm Manager 负责集群的管理和调度，自动将服务在集群中分配和扩展。</p><p>关键概念和功能：</p><ol><li>节点（Nodes）: 每个节点可以是物理机器或虚拟机。其中有一个节点被选为 Swarm Manager（管理节点），其他节点为 Worker（工作节点）。</li><li>服务（Services）: 基本单位，表示要部署和运行的容器应用。</li><li>副本（Replicas）: 服务可以指定多个副本（replica），Swarm 会自动将这些副本调度到不同的节点上运行，以实现负载均衡和高可用性。</li><li>任务（Tasks）: 每个服务都会被划分为多个任务（task），每个任务代表一个要运行的容器实例。</li><li>网络（Networks）: 不同节点上的容器可以直接通过内部网络通信，而无需暴露主机端口。</li><li>栈（Stacks）: 相关的服务的集合。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>分布式</title>
      <link href="/2023/06/16/fen-bu-shi-xi-tong/"/>
      <url>/2023/06/16/fen-bu-shi-xi-tong/</url>
      
        <content type="html"><![CDATA[<h3 id="谈谈你对分布式系统的理解"><a href="#谈谈你对分布式系统的理解" class="headerlink" title="谈谈你对分布式系统的理解"></a>谈谈你对分布式系统的理解</h3><p>为了解决传统单体服务架构带来的各种问题，代码数量庞大，迭代测试维护困难，可能因为一处改动测试不到位造成整个服务瘫痪等问题。</p><p>分布式系统就是将一个大的服务拆分成几十个甚至上百个微小的服务。，代码不在一个项目里，方便大家分工开发，也不会冲突，便于项目维护</p><p>比如阿里的 Dubbo，还有 Spring 全家桶里的 Spring Cloud，都是解决分布式微服务架构的优秀框架。</p><h3 id="分布式系统环境下各自有什么优缺点"><a href="#分布式系统环境下各自有什么优缺点" class="headerlink" title="分布式系统环境下各自有什么优缺点"></a>分布式系统环境下各自有什么优缺点</h3><p>优点：</p><ul><li><p><strong>系统可用性提升</strong>：分布式下的服务体系，单台机器有故障，不致于造成整个服务不可用。</p></li><li><p><strong>系统并发能力提升</strong>：请求通过 Nginx 负载均衡被分发到不同的服务器上，运行同样代码的服务器可以有 1 台或 N 台，通常情况下会根据实际用户访问量随时增加机器</p></li><li><p><strong>系统容错能力提升</strong>：同一组服务分别部署在北京上海杭州，杭州的机房突发断电或者火灾，杭州机房的流量会被自动分发到北京和上海的机房，不影响用户使用。</p></li><li><p><strong>低延迟</strong> ：北京的用户请求自动分发到北京，上海的用户请求被分发到上海，服务器会根据用户的 IP 选择距离自己最近的机房，降低网络延迟。</p></li></ul><p>缺点：</p><p><strong>分布式服务依赖网络</strong>：服务器间通讯依赖网络，不可靠网络包括网络延时，丢包、中断、异步，一个完整的服务请求依赖一连串服务调用，任意一个服务节点网络出现问题，都可能造成本次请求失败。</p><p><strong>维护成本高</strong>：分布式服务系统被拆分成若干个小服务，服务从 1 变为几十个上百个服务后，增加运维成本。</p><p><strong>一致性，可用性，分区容错性无法同时满足</strong>：这三种特性最多只能满足两种，无法同时满足，需要根据实际情况去调整牺牲掉其中哪个。</p><h3 id="CAP-理论是什么"><a href="#CAP-理论是什么" class="headerlink" title="CAP 理论是什么"></a>CAP 理论是什么</h3><p><strong>CAP</strong>&nbsp;也就是&nbsp;<strong>Consistency（一致性）</strong>、<strong>Availability（可用性）</strong>、<strong>Partition Tolerance（分区容错性）</strong>&nbsp;这三个单词首字母组合。</p><p>CAP 定理（CAP theorem）指出对于一个分布式系统来说，当设计读写操作时，只能同时满足以下三点中的两个：</p><ul><li><strong>一致性</strong> : 所有节点访问同一份最新的数据副本</li><li><strong>可用性</strong>: 非故障的节点在合理的时间内返回合理的响应（不是错误或者超时的响应）。</li><li><strong>分区容错性</strong> : 分布式系统出现网络分区的时候，仍然能够对外提供服务。</li></ul><p>网络分区：分布式系统中，多个节点之间的网络本来是连通的，但是因为某些故障（比如部分节点网络出了问题）某些节点之间不连通了，整个网络就分成了几块区域。</p><p>CAP 理论中分区容错性 P 是一定要满足的，在此基础上，只能满足可用性 A 或者一致性 C。</p><h3 id="为什么不可能选择-CA-架构呢"><a href="#为什么不可能选择-CA-架构呢" class="headerlink" title="为什么不可能选择 CA 架构呢"></a>为什么不可能选择 CA 架构呢</h3><p>举个例子：若系统出现“分区”，系统中的某个节点在进行写操作。为了保证 C， 必须要禁止其他节点的读写操作，这就和 A 发生冲突了。如果为了保证 A，其他节点的读写操作正常的话，那就和 C 发生冲突了</p><p><strong>如果网络分区正常的话（系统在绝大部分时候所处的状态），也就说不需要保证 P 的时候，C 和 A 能够同时保证。</strong></p><p><strong>如果系统发生“分区”，我们要考虑选择 CP 还是 AP。如果系统没有发生“分区”的话，我们要思考如何保证 CA 。</strong></p><h3 id="BASE-理论是什么"><a href="#BASE-理论是什么" class="headerlink" title="BASE 理论是什么"></a>BASE 理论是什么</h3><p><strong>BASE</strong> 是 <strong>Basically Available（基本可用）</strong>、<strong>Soft-state（软状态）</strong> 和 <strong>Eventually Consistent（最终一致性）</strong> 三个短语的缩写。</p><p>BASE 理论是对 CAP 中一致性 C 和可用性 A 权衡的结果，其来源于对大规模互联网系统分布式实践的总结，是基于 CAP 定理逐步演化而来的，它大大降低了我们对系统的要求。</p><p><strong>基本可用</strong>：基本可用是指分布式系统在出现不可预知故障的时候，允许损失部分可用性。但是，这绝不等价于系统不可用。</p><ul><li><strong>响应时间上的损失</strong>: 正常情况下，处理用户请求需要 0.5s 返回结果，但是由于系统出现故障，处理用户请求的时间变为 3 s。</li><li><strong>系统功能上的损失</strong>：正常情况下，用户可以使用系统的全部功能，但是由于系统访问量突然剧增，系统的部分非核心功能无法使用。</li></ul><p><strong>软状态</strong>：允许系统中的数据存在中间状态（<strong>CAP 理论中的数据不一致</strong>），并认为该中间状态的存在不会影响系统的整体可用性，即允许系统在不同节点的数据副本之间进行数据同步的过程<strong>存在延时</strong>。</p><p><strong>最终一致性</strong>：强调的是系统中所有的数据副本，在经过一段时间的同步后，最终能够达到一个一致的状态。</p><ul><li>分布式一致性的 3 种级别：</li></ul><ol><li><strong>强一致性</strong>：系统写入了什么，读出来的就是什么。</li><li><strong>弱一致性</strong>：不一定可以读取到最新写入的值，也不保证多少时间之后读取到的数据是最新的，只是会尽量保证某个时刻达到数据一致的状态。</li><li><strong>最终一致性</strong>：弱一致性的升级版，系统会保证在一定时间内达到数据一致的状态。</li></ol><h3 id="BASE-理论的核心思想"><a href="#BASE-理论的核心思想" class="headerlink" title="BASE 理论的核心思想"></a>BASE 理论的核心思想</h3><p>即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</p><blockquote><p>也就是牺牲数据的一致性来满足系统的高可用性，系统中一部分数据不可用或者不一致时，仍需要保持系统整体“主要可用”。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于kubernetes部署云原生微服务应用Online Boutique</title>
      <link href="/2023/06/09/ji-yu-kubernetes-bu-shu-yun-yuan-sheng-wei-fu-wu-ying-yong-online-boutique/"/>
      <url>/2023/06/09/ji-yu-kubernetes-bu-shu-yun-yuan-sheng-wei-fu-wu-ying-yong-online-boutique/</url>
      
        <content type="html"><![CDATA[<h3 id="配置kubernetes集群环境"><a href="#配置kubernetes集群环境" class="headerlink" title="配置kubernetes集群环境"></a>配置kubernetes集群环境</h3><p>创建三台华为云服务器，一台做k8s-master服务器，另外两台做node节点服务器。</p><p><em><strong>对这三台服务器</strong></em>，执行以下相同命令</p><p><strong>关闭swap:</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">swapoff <span class="token parameter variable">-a</span><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/.*swap.*/#&amp;/'</span> /etc/fstab<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>关闭防火墙：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl stop ufwsystemctl disable ufwsystemctl stop firewalldsystemctl disable firewalld<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>修改软件源：</strong></p><p>编辑/etc/apt/sources.list</p><p>修改镜像源(阿里云/华为/清华园)</p><p>例如：</p><pre class="line-numbers language-none"><code class="language-none">deb https://mirrors.aliyun.com/kubernetes/apt kubernetes-xenial main<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> update<span class="token function">apt-get</span> upgrade<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>安装docker：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> <span class="token function">install</span> docker.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>开机自启动</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> <span class="token function">docker</span>systemctl daemon-reloadsystemctl restart <span class="token function">docker</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><em><strong>对于master节点</strong></em></p><p><strong>配置master节点：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">hostname</span> k8s-master<span class="token function">wget</span> https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpgapt-key <span class="token function">add</span> apt-key.gpg<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>安装kubernetes：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> apt-transport-https <span class="token function">curl</span><span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token assign-left variable">kubelet</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 <span class="token assign-left variable">kubeadm</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 <span class="token assign-left variable">kubectl</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 --allow-unauthenticated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm config images list<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/1.png"></p><p><strong>配置镜像：</strong></p><p>换国内源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.17<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.17 k8s.gcr.io/kube-apiserver:v1.17.17<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/kube-apiserver:v1.17.17<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-controller-manager:v1.17.17<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/kube-controller-manager:v1.17.17 k8s.gcr.io/kube-controller-manager:v1.17.17<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/kube-controller-manager:v1.17.17<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-scheduler:v1.17.17<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/kube-scheduler:v1.17.17 k8s.gcr.io/kube-scheduler:v1.17.17<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/kube-scheduler:v1.17.17<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/kube-proxy:v1.17.17<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/kube-proxy:v1.17.17 k8s.gcr.io/kube-proxy:v1.17.17<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/kube-proxy:v1.17.17<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/pause:3.1<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/pause:3.1 k8s.gcr.io/pause:3.1<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/pause:3.1<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/etcd:3.4.3-0<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/etcd:3.4.3-0 k8s.gcr.io/etcd:3.4.3-0<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/etcd:3.4.3-0<span class="token function">docker</span> pull registry.aliyuncs.com/google_containers/coredns:1.6.5<span class="token function">docker</span> tag  registry.aliyuncs.com/google_containers/coredns:1.6.5 k8s.gcr.io/coredns:1.6.5<span class="token function">docker</span> rmi  registry.aliyuncs.com/google_containers/coredns:1.6.5<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/2.png"></p><p><strong>初始化master节点：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm init --pod-network-cidr<span class="token operator">=</span><span class="token number">10.244</span>.0.0/16<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/3.png"></p><p>保存图中node节点加入master集群的指令：</p><p>kubeadm&nbsp;join……</p><p>切换为普通用户</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> <span class="token environment constant">$HOME</span>/.kube<span class="token function">sudo</span> <span class="token function">cp</span> <span class="token parameter variable">-i</span> /etc/kubernetes/admin.conf <span class="token environment constant">$HOME</span>/.kube/config<span class="token function">sudo</span> <span class="token function">chown</span> <span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> <span class="token parameter variable">-u</span><span class="token variable">)</span></span><span class="token builtin class-name">:</span><span class="token variable"><span class="token variable">$(</span><span class="token function">id</span> <span class="token parameter variable">-g</span><span class="token variable">)</span></span> <span class="token environment constant">$HOME</span>/.kube/configkubectl get pods --all-namespaces<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/4.png"></p><p>如果coredns 处于pending状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get nodes<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现master处于NotReady状态</p><p>需要部署pod network插件文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /usr/local/src/kube-flannel.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">node</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/5.png"></p><p><strong>配置node节点：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">hostname</span> node1<span class="token punctuation">(</span>node2<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>同上操作</p><p><strong>安装****kubernetes</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">wget</span> https://mirrors.aliyun.com/kubernetes/apt/doc/apt-key.gpgapt-key <span class="token function">add</span> apt-key.gpg<span class="token function">apt-get</span> update <span class="token operator">&amp;&amp;</span> <span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> apt-transport-https <span class="token function">curl</span><span class="token function">apt-get</span> <span class="token function">install</span> <span class="token parameter variable">-y</span> <span class="token assign-left variable">kubelet</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 <span class="token assign-left variable">kubeadm</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 <span class="token assign-left variable">kubectl</span><span class="token operator">=</span><span class="token number">1.17</span>.2-00 --allow-unauthenticated<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>docker镜像换源</strong><br>……</p><p><strong>加入集群：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubeadm <span class="token function">join</span> <span class="token number">192.168</span>.0.202:6443 <span class="token parameter variable">--token</span> 09hdi2.ogp6wujqwvhmrisk <span class="token punctuation">\</span> --discovery-token-ca-cert-hash sha256:1cffed7c52b078773c1f128ef3b7ecfd00efda14cf2c408a324cc492bf94f523<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>可能出现的问题</strong></p><p>&lt;1&gt;如果出现coredns网络异常，则可能需要部署网络插件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /usr/local/src/kube-flannel.yml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>&lt;2&gt;如果出现</p><pre class="line-numbers language-none"><code class="language-none">Error in configuration:* unable to read client-cert /var/lib/kubelet/pki/kubelet-client-current.pem for default-auth due to open /var/lib/kubelet/pki/kubelet-client-current.pem: no such file or directory* unable to read client-key /var/lib/kubelet/pki/kubelet-client-current.pem for default-auth due to open /var/lib/kubelet/pki/kubelet-client-current.pem: no such file or directory<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>则表示token过期，需要重新create及join</p><p>&lt;3&gt;如果出现</p><pre class="line-numbers language-none"><code class="language-none">error execution phase preflight: couldn't validate the identity of the API Server: Get "https://192.168.xxx.xx:6443/api/v1/namespaces/kube-public/configmaps/cluster-info?timeout=10s": net/http: request canceled while waiting for connection (Client.Timeout exceeded while awaiting headers)To see the stack trace of this error execute with --v=5 or higher<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>则可能是防火墙问题</p><p>&lt;4&gt;如果</p><pre class="line-numbers language-none"><code class="language-none">W0706 10:27:55.181115 &nbsp;&nbsp;22817 loader.go:221] Config not found: /etc/kubernetes/admin.confThe connection to the server localhost:8080 was refused - did you specify the right host or port?<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>发现 Node 节点只有 kubelet.conf 配置项，而没有admin.conf</p><p>切换为普通用户</p><pre class="line-numbers language-none"><code class="language-none">mkdir -p $HOME/.kubesudo cp -i /etc/kubernetes/kubelet.conf $HOME/.kube/configsudo chown $(id -u):$(id -g) $HOME/.kube/config<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Node节点配置完成，在master节点上执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">node</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/6.png"></p><p>如果k8s-master的状态是NotReady,可能是hostname k8s-master错误，和主机命名不一致</p><h3 id="部署dashboard"><a href="#部署dashboard" class="headerlink" title="部署dashboard"></a>部署dashboard</h3><p>将配置文件create-admin.yaml和kubernetes-dashboard-v2.0.3.yml上传到master节点，执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> create-admin.yamlkubectl apply <span class="token parameter variable">-f</span> kubernetes-dashboard-v2.0.3.yml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get pod <span class="token parameter variable">-o</span> wide --all-namespaces<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/7.png"></p><p>登录dashboard面板</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/8.png"></p><p>获取token登录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl <span class="token parameter variable">-n</span> kubernetes-dashboard describe secret <span class="token variable"><span class="token variable">$(</span>kubectl <span class="token parameter variable">-n</span> kubernetes-dashboard get secret <span class="token operator">|</span> <span class="token function">grep</span> admin-user <span class="token operator">|</span> <span class="token function">awk</span> <span class="token string">'{print $1}'</span><span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/9.png"></p><h3 id="安装并部署Istio"><a href="#安装并部署Istio" class="headerlink" title="安装并部署Istio"></a>安装并部署Istio</h3><p>去<a href="https://github.com/istio/istio/releases">https://github.com/istio/istio/releases</a>下载安装包,下载安装包之后解压</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> xf istio-1.8.5-linux-amd64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>或者</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">curl</span> <span class="token parameter variable">-L</span> https://istio.io/downloadIstio <span class="token operator">|</span> <span class="token assign-left variable">ISTIO_VERSION</span><span class="token operator">=</span><span class="token number">1.8</span>.5 <span class="token assign-left variable">TARGET_ARCH</span><span class="token operator">=</span>x86_64 <span class="token function">sh</span> -<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加到 path</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加以下内容</p><pre class="line-numbers language-none"><code class="language-none">export ISTIOCTL_HOME="/home/istio-1.8.5"export PATH="$ISTIOCTL_HOME/bin:$PATH"<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行生效</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证安装成功</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">istioctl version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/10.png"></p><p>部署 Istio Operator</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">istioctl operator init<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/11.png"></p><p>init 命令创建了 istio-operator 命名空间，并部署了 CRD、Operator Deployment 以及 operator 工作所需的其他资源。</p><p>要安装 Istio，必须先创建 IstioOperator 资源，并指定要使用的配置文件。</p><p>创建目录istioyaml，用来专门存放yaml文件</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> istioyaml<span class="token builtin class-name">cd</span> istioyaml/<span class="token function">vim</span> istio-demo-profile.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>填入以下内容：</p><pre class="line-numbers language-none"><code class="language-none">apiVersion: v1kind: Namespacemetadata:&nbsp;&nbsp;name: istio-system---apiVersion: install.istio.io/v1alpha1kind: IstioOperatormetadata:&nbsp;&nbsp;namespace: istio-system&nbsp;&nbsp;name: demo-istio-installspec:&nbsp;&nbsp;profile: demo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> istio-demo-profile.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看istio-system命名空间下的所有资源</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get all <span class="token parameter variable">-o</span> wide <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/12.png"></p><p>为了检查安装的状态，查看 istio-system&nbsp;命名空间中的 Pod 的状态。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get pod <span class="token parameter variable">-o</span> wide <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/13.png"></p><p>Istio安装完成后，创建一个命名空间online-boutique，新的项目就部署在online-boutique命名空间下，给命名空间online-boutique设置上 istio-injection=enabled 标签，启用sidecar 自动注入。</p><p>创建命名空间online-boutique</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl create ns online-boutique<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>切换命名空间</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl config set-context <span class="token parameter variable">--current</span> <span class="token parameter variable">--namespace</span><span class="token operator">=</span>online-boutique<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>让命名空间online-boutique启用sidecar 自动注入</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl label ns online-boutique istio-injection<span class="token operator">=</span>enabledkubectl get ns <span class="token parameter variable">-l</span> istio-injection --show-labels<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/14.png"></p><h3 id="部署-Online-Boutique-应用"><a href="#部署-Online-Boutique-应用" class="headerlink" title="部署 Online Boutique 应用"></a>部署 Online Boutique 应用</h3><p><strong>拉取项目</strong></p><p>创建online-boutique目录，项目放在该目录</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> online-boutique<span class="token builtin class-name">cd</span> online-boutique/<span class="token function">git</span> clone https://github.com/GoogleCloudPlatform/microservices-demo.git<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>配置镜像</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> microservices-demo/<span class="token builtin class-name">cd</span> release/<span class="token comment"># 查看需要下载的镜像</span><span class="token function">grep</span> image kubernetes-manifests.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/15.png"></p><p>镜像换源，换为国内</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/gcr.io/gcr.lank8s.cn/'</span> kubernetes-manifests.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>创建 Kubernetes 资源</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /home/online-boutique/microservices-demo/release/kubernetes-manifests.yaml <span class="token parameter variable">-n</span> online-boutique<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/16.png"></p><p>检查所有 Pod 都在运行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get pod <span class="token parameter variable">-o</span> wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/17.png"></p><p><strong>创建 Istio 资源</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> ./istio-manifests<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>获取访问地址</strong></p><p>部署了一切后，就可以得到入口网关的 IP 地址并打开前端服务：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">INGRESS_HOST</span><span class="token operator">=</span><span class="token string">"<span class="token variable"><span class="token variable">$(</span>kubectl <span class="token parameter variable">-n</span> istio-system get <span class="token function">service</span> istio-ingressgateway <span class="token parameter variable">-o</span> <span class="token assign-left variable">jsonpath</span><span class="token operator">=</span><span class="token string">'{.status.loadBalancer.ingress[0].ip}'</span><span class="token variable">)</span></span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"<span class="token variable">$INGRESS_HOST</span>"</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">service</span> <span class="token parameter variable">-n</span> istio-system istio-ingressgateway <span class="token parameter variable">-o</span> wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>发现 EXTERNAL-IP 为 pending</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl edit  <span class="token function">service</span> istio-ingressgateway <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加外部IP</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/18.png"></p><p>访问项目地址</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/19.png"></p><h3 id="Istio插件配置"><a href="#Istio插件配置" class="headerlink" title="Istio插件配置"></a>Istio插件配置</h3><h4 id="Prometheus"><a href="#Prometheus" class="headerlink" title="Prometheus"></a>Prometheus</h4><p>Prometheus 是一个开源的监控系统和时间序列数据库。Istio 使用 Prometheus 来记录指标，跟踪 Istio 和网格中的应用程序的健康状况。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/istio-1.8.5/samples/addons/<span class="token function">grep</span> image prometheus.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>安装prometheus需要用到两个镜像：</p><p>jimmidyson/configmap-reload:v0.4.0 和 prom/prometheus:v2.21.0</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/20.png"></p><p>在k8s的node节点拉取所需镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull jimmidyson/configmap-reload:v0.4.0<span class="token function">docker</span> pull prom/prometheus:v2.21.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/21.png"></p><p>安装prometheus</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /home/istio-1.8.5/samples/addons/prometheus.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/22.png"></p><p>查看部署状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get deploy <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/23.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">service</span> <span class="token parameter variable">-n</span> istio-system <span class="token parameter variable">-o</span> wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/24.png"></p><p>prometheus的service的类型为ClusterIP，外部环境访问不了</p><p>修改prometheus这个service的类型为NodePort，这样外部环境就可以访问prometheus了</p><p>把type: ClusterIP 修改为 type: NodePort即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl edit <span class="token function">service</span> prometheus <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/25.png"></p><p>之后可以根据ip加端口号访问该服务</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/26.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/27.png"></p><h4 id="Grafana"><a href="#Grafana" class="headerlink" title="Grafana"></a>Grafana</h4><p>Grafana 是一个用于分析和监控的开放平台。Grafana 可以连接到各种数据源，并使用图形、表格、热图等将数据可视化。通过强大的查询语言，你可以定制现有的仪表盘并创建更高级的可视化。</p><p>通过 Grafana，我们可以监控 Istio 安装和服务网格中运行的应用程序的健康状况。</p><p>我们可以使用 grafana.yaml 来部署带有预配置仪表盘的 Grafana 示例安装。该 YAML 文件在 Istio 安装包的 /samples/addons 下。</p><p>确保在部署 Grafana 之前部署 Promeheus 插件，因为 Grafana 使用 Prometheus 作为其数据源。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/istio-1.8.5/samples/addons<span class="token function">grep</span> image grafana.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/28.png"></p><p>在k8s的node节点拉取所需镜像</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull grafana/grafana:7.2.1<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/29.png"></p><p>安装grafana</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl apply <span class="token parameter variable">-f</span> /home/istio-1.8.5/samples/addons/grafana.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/30.png"></p><p>查看部署状态</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get pod <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/31.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">service</span> <span class="token parameter variable">-n</span> istio-system <span class="token parameter variable">-o</span> wide<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/32.png"></p><p>同上</p><p>可以看到grafana这个service的类型为ClusterIP，外部环境访问不了</p><p>修改grafana这个service的类型为NodePort，这样外部环境就可以访问grafana了</p><p>把type: ClusterIP 修改为 type: NodePort即可</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl edit <span class="token function">service</span> grafana <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>之后可以根据ip加端口号访问该服务</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/33.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/34.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/35.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/36.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/37.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/38.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/39.png"></p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/40.png"></p><h4 id="Kiali"><a href="#Kiali" class="headerlink" title="Kiali"></a>Kiali</h4><p>在kubernetes中为Istio配置Kiali，实现Istio服务网格的可视化，为Online Boutique项目提供服务拓扑图、全链路跟踪、指标遥测、配置校验、健康检查等功能。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/istio-1.8.5/samples/addons/kubectl apply <span class="token parameter variable">-f</span> kiali.yamlkubectl get pod <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/41.png"></p><p>同样需要把type: ClusterIP 修改为 type: NodePort</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/42.png"></p><h4 id="Jaeger"><a href="#Jaeger" class="headerlink" title="Jaeger"></a>Jaeger</h4><p>Jaeger 是Uber推出的一款开源分布式追踪系统，兼容OpenTracing API。分布式追踪系统用于记录请求范围内的信息，包括一次调用的服务链路以及每个服务的延时，能够帮助我们很好的分析微服务间链路调用的错误及瓶颈。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/istio-1.8.5/samples/addons/kubectl apply <span class="token parameter variable">-f</span> jaeger.yaml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/43.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">kubectl get <span class="token function">service</span> <span class="token parameter variable">-n</span> istio-system<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/44.png"></p><p>同样需要把type: ClusterIP 修改为 type: NodePort</p><p>之后可以根据ip加端口号访问该服务</p><p><img src="/images/image_k8s%E9%83%A8%E7%BD%B2%E5%BE%AE%E6%9C%8D%E5%8A%A1%E5%BA%94%E7%94%A8/45.png"></p><h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><p>[1]&nbsp;<a href="https://www.cnblogs.com/boshen-hzb/p/10679863.html">https://www.cnblogs.com/boshen-hzb/p/10679863.html</a>&nbsp;&nbsp;istio实现对外暴露服务</p><p>[2]&nbsp;<a href="https://www.cnblogs.com/fenjyang/p/14417494.html">https://www.cnblogs.com/fenjyang/p/14417494.html</a>&nbsp;K8S线上集群排查，实测排查Node节点NotReady异常状态</p><p>[3]&nbsp;<a href="https://www.cnblogs.com/renshengdezheli/p/16841875.html#32-kubernetes%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83">https://www.cnblogs.com/renshengdezheli/p/16841875.html#32-kubernetes%E9%9B%86%E7%BE%A4%E7%8E%AF%E5%A2%83</a>&nbsp;Istio项目实际案例——Online Boutique</p>]]></content>
      
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> kubernetes </tag>
            
            <tag> Istio </tag>
            
            <tag> 微服务 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为云大数据集群搭建</title>
      <link href="/2023/05/17/hua-wei-yun-da-shu-ju-ji-qun-da-jian/"/>
      <url>/2023/05/17/hua-wei-yun-da-shu-ju-ji-qun-da-jian/</url>
      
        <content type="html"><![CDATA[<h3 id="华为云环境搭建"><a href="#华为云环境搭建" class="headerlink" title="华为云环境搭建"></a>华为云环境搭建</h3><h4 id="华为云ECS"><a href="#华为云ECS" class="headerlink" title="华为云ECS"></a>华为云ECS</h4><p>ECS购买需遵循以下规格：</p><ul><li>计费模式：按需计费</li><li>可用区：可用区一</li><li>CPU架构：x86</li><li>规格： 2vcpus|8GB</li><li>系统：CentOS7.6</li><li>系统盘：超高IO、100GB。</li><li>网络：按流量计费</li><li>其他配置：默认</li></ul><p>完成基础配置，网络配置，高级配置。购买4台ECS</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%871.png">&nbsp;</p><h4 id="对象存储服务OBS"><a href="#对象存储服务OBS" class="headerlink" title="对象存储服务OBS"></a>对象存储服务OBS</h4><p>区域选择与ECS相同。其他配置默认</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%872.png"></p><h4 id="创建并行文件系统"><a href="#创建并行文件系统" class="headerlink" title="创建并行文件系统"></a>创建并行文件系统</h4><p>配置默认</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%873.png"></p><p>进入创建的OBS桶，记录参数endpoint</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%874.png"></p><h4 id="获取AK-SK"><a href="#获取AK-SK" class="headerlink" title="获取AK/SK"></a>获取AK/SK</h4><p>华为云页面右上角“用户名”，下拉选择“我的凭证”，点击“访问秘钥”。新增访问秘钥，根据提示进行操作，得到文件“credentials.csv”，打开即可得到AK/SK</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%875.png"></p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%876.png"></p><h3 id="Hadoop集群搭建"><a href="#Hadoop集群搭建" class="headerlink" title="Hadoop集群搭建"></a>Hadoop集群搭建</h3><p>通过搭建开源Hadoop集群，掌握Hadoop搭建方法。并且使开源Hadoop与华为云OBS服务互联，使Hadoop集群可读取OBS数据。</p><h4 id="配置ECS"><a href="#配置ECS" class="headerlink" title="配置ECS"></a>配置ECS</h4><p>登录三个节点服务器<br>下载hadoop安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">wget</span> https://bigdata-tools-hw.obs.cn-north-1.myhuaweicloud.com/hadoop-2.8.3.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>下载OBSFileSystem相关jar包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">wget</span> https://bigdata-tools-hw.obs.cn-north-1.myhuaweicloud.com/hadoop-huaweicloud-2.8.3-hw-39.jar<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%877.png"></p><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><p>下载并拷贝jdk8至/usr/local/java，并解压缩</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/<span class="token function">mkdir</span> <span class="token function">java</span><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> jdk-8u351-linux-x64.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置环境变量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按“i”进入编辑模式，使用hjkl键或方向键移动光标，在文件最后添加以下代码：</p><pre class="line-numbers language-none"><code class="language-none">JAVA_HOME=/usr/local/java/jdk1.8******export PATH=$PATH:$JAVA_HOME/binexport JAVA_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>按“Esc”退出编辑模式，输入“:wq”并按回车，保存退出。</p><p>执行以下命令，使新增配置生效。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，验证jdk安装并配置成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> –version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%878.png"></p><h4 id="配置hosts文件"><a href="#配置hosts文件" class="headerlink" title="配置hosts文件"></a>配置hosts文件</h4><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/hosts<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加</p><pre class="line-numbers language-none"><code class="language-none">192.168.0.46&nbsp;node-0001192.168.0.123&nbsp;node-0002192.168.0.148&nbsp;node-0003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="配置节点互信"><a href="#配置节点互信" class="headerlink" title="配置节点互信"></a>配置节点互信</h4><p>各节点执行以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">ssh-keygen <span class="token parameter variable">-t</span> rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%879.png"></p><p>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> /root/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8710.png"></p><p>复制该命令在各节点的输出内容。</p><p>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /root/.ssh/authorized_keys<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入各节点的复制内容，保存退出。</p><p>各节点执行：ssh node-0001~node-0003，选择yes后，确保能够无密码跳转到目标节点</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8711.png"></p><h4 id="搭建Hadoop集群"><a href="#搭建Hadoop集群" class="headerlink" title="搭建Hadoop集群"></a>搭建Hadoop集群</h4><p>创建目录<br>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /home/modules/data/buf<span class="token function">mkdir</span> <span class="token parameter variable">-p</span> /home/nm/localdir<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>登录node-0001节点，解压hadoop安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">cp</span> hadoop-2.8.3.tar.gz /home/modules/<span class="token builtin class-name">cd</span> /home/modules/<span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> hadoop-2.8.3.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>配置hadoop core-site.xml配置文件<br>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/core-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数配置：</p><pre class="line-numbers language-none"><code class="language-none">&lt;configuration&gt;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.readahead.inputstream.enabled&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;true&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.buffer.max.range&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;6291456&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.buffer.part.size&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;2097152&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.threads.read.core&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;500&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.threads.read.max&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;1000&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.write.buffer.size&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;8192&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.read.buffer.size&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;8192&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.connection.maximum&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;1000&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.defaultFS&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;hdfs://node-0001:8020&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;hadoop.tmp.dir&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;/home/modules/hadoop-2.8.3/tmp&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.access.key&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;FOR20CBUDGPBNEZDADQE&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.secret.key&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;5TZnFhulDt04EG1lfMzgdYCi8OMg6HwasWEcGBkO&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.endpoint&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;obs.cn-north-4.myhuaweicloud.com:5080&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.buffer.dir&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;/home/modules/data/buf&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.impl&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;org.apache.hadoop.fs.obs.OBSFileSystem&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.connection.ssl.enabled&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;false&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.fast.upload&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;true&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.socket.send.buffer&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;65536&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.socket.recv.buffer&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;65536&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.max.total.tasks&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;20&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;fs.obs.threads.max&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;20&lt;/value&gt;&nbsp;&lt;/property&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：fs.obs.access.key、fs.obs.secret.key、fs.obs.endpoint、fs.defaultFS需根据实际情况修改</p><p>配置hdfs-site.xml</p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/hdfs-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数配置如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;configuration&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.replication&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;3&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.namenode.secondary.http-address&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;node-0001:50090&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.namenode.secondary.https-address&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;node-0001:50091&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&nbsp;&lt;property&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.namenode.name.dir&lt;/name&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;file:/home/modules/hadoop-2.8.3/data/namenode&lt;/value&gt;  &nbsp;&lt;/property&gt;  &nbsp;&lt;property&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;dfs.datanode.data.dir&lt;/name&gt;  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;file:/home/modules/hadoop-2.8.3/data/datanode&lt;/value&gt;  &nbsp;&lt;/property&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：主机名node-0001需要根据实际替换。</p><p><strong>配置yarn-site.xml</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/yarn-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>参数配置如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;configuration&gt;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.local-dirs&lt;/name&gt;&lt;value&gt;/home/nm/localdir&lt;/value&gt;&lt;/property&gt;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.resource.memory-mb&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;28672&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.scheduler.minimum-allocation-mb&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;3072&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.scheduler.maximum-allocation-mb&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;28672&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.resource.cpu-vcores&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;38&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.scheduler.maximum-allocation-vcores&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;38&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.aux-services&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;mapreduce_shuffle&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.resourcemanager.hostname&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;node-0001&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.log-aggregation-enable&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;true&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&lt;name&gt;yarn.log-aggregation.retain-seconds&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;106800&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.vmem-check-enabled&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;false&lt;/value&gt;&nbsp;&nbsp;&nbsp;&lt;description&gt;Whether virtual memory limits will be enforced for containers&lt;/description&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.nodemanager.vmem-pmem-ratio&lt;/name&gt;&nbsp;&nbsp;&nbsp;&lt;value&gt;4&lt;/value&gt;&nbsp;&nbsp;&nbsp;&lt;description&gt;Ratio between virtual memory to physical memory when setting memory limits for containers&lt;/description&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.resourcemanager.scheduler.class&lt;/name&gt;&nbsp;&nbsp;&lt;value&gt;org.apache.hadoop.yarn.server.resourcemanager.scheduler.fair.FairScheduler&lt;/value&gt;&nbsp;&nbsp;&lt;/property&gt;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;yarn.log.server.url&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;http://node-0001:19888/jobhistory/logs&lt;/value&gt;&lt;/property&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：主机名node-0001需要根据实际情况修改。</p><p><strong>配置mapred-site.xml</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/modules/hadoop-2.8.3/etc/hadoop/<span class="token function">mv</span> mapred-site.xml.template mapred-site.xml<span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/mapred-site.xml<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>参数配置如下：</p><pre class="line-numbers language-none"><code class="language-none">&lt;configuration&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;mapreduce.framework.name&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;yarn&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;mapreduce.jobhistory.address&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;node-0001:10020&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;mapreduce.jobhistory.webapp.address&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;node-0001:19888&lt;/value&gt;&nbsp;&lt;/property&gt;&nbsp;&lt;property&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;name&gt;mapred.task.timeout&lt;/name&gt;&nbsp;&nbsp;&nbsp;&nbsp;&lt;value&gt;1800000&lt;/value&gt;&nbsp;&lt;/property&gt;&lt;/configuration&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>注：主机名node-0001需要根据实际情况修改。</p><p><strong>配置slaves</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/slaves<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>删除原有内容，添加内容如下：</p><pre class="line-numbers language-none"><code class="language-none">node-0002node-0003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>配置hadoop环境变量</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /home/modules/hadoop-2.8.3/etc/hadoop/hadoop-env.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加如下内容：</p><pre class="line-numbers language-none"><code class="language-none">export JAVA_HOME=/usr/local/java/jdk1.8.0_351<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>配置jar包</strong></p><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">cp</span> hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/hadoop-2.8.3/share/hadoop/common/lib/<span class="token function">cp</span> hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/hadoop-2.8.3/share/hadoop/tools/lib<span class="token function">cp</span> hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/hadoop-2.8.3/share/hadoop/httpfs/tomcat/webapps/webhdfs/WEB-INF/lib/<span class="token function">cp</span> hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/hadoop-2.8.3/share/hadoop/hdfs/lib/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>分发hadoop包到各节点</strong></p><p>node-0001下执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 分发hadoop包到node2</span><span class="token function">scp</span> <span class="token parameter variable">-r</span> /home/modules/hadoop-2.8.3/ root@node-0002:/home/modules/<span class="token comment"># 分发hadoop包到node3</span><span class="token function">scp</span> <span class="token parameter variable">-r</span> /home/modules/hadoop-2.8.3/ root@node-0003:/home/modules/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>配置环境变量</strong></p><p>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在文件尾部添加如下内容：</p><pre class="line-numbers language-none"><code class="language-none">export HADOOP_HOME=/home/modules/hadoop-2.8.3export PATH=$HADOOP_HOME/bin:$HADOOP_HOME/sbin:$PATHexport HADOOP_CLASSPATH=/home/modules/hadoop-2.8.3/share/hadoop/tools/lib/*:$HADOOP_CLASSPATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>namenode初始化</strong><br>node-0001节点执行namenode初始化<br>执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hdfs namenode <span class="token parameter variable">-format</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化成功后，启动hdfs。<br>node-0001节点执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">start-all.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行hdfs命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hdfs dfs <span class="token parameter variable">-mkdir</span> /bigdata<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看集群部署报告</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hdfs dfsadmin <span class="token parameter variable">-report</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8712.png"></p><p>主要原因是 每台机器的/etc/hosts 错误</p><pre class="line-numbers language-none"><code class="language-none">127.0.0.1 localhost127.0.1.1 node-000*192.168.x.x node-0001192.168.x.x node-0002192.168.x.x node-0003<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>把127.0.1.1 node-000*这一行删掉</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8713.png"></p><p>停止HDFS<br>node-0001节点执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">stop-all.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>测试Hadoop与OBS互联</strong></p><p>进入OBS桶，选择“对象”上传文件</p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8714.png"></p><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8715.png"></p><p>执行hdfs命令查看OBS文件 hadoop-bigdata&nbsp;是obs的命名</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hdfs dfs <span class="token parameter variable">-ls</span> obs://hadoop-dataserver/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8716.png"></p><p>测试能否跑任务</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">hadoop jar /home/modules/hadoop-2.8.3/share/hadoop/mapreduce/hadoop-mapreduce-examples-2.8.3.jar pi <span class="token number">100</span> <span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8717.png"></p><p>Hadooop集群搭建成功，hadooop成功与OBS互联，并且能跑通任务</p><h3 id="搭建Spark集群"><a href="#搭建Spark集群" class="headerlink" title="搭建Spark集群"></a>搭建Spark集群</h3><p>安装Spark集群，并使Spark能够读取OBS数据，使Spark集群能够实现存算分离，提高计算性能。</p><h4 id="搭建Spark集群-1"><a href="#搭建Spark集群-1" class="headerlink" title="搭建Spark集群"></a>搭建Spark集群</h4><p>获取spark安装包<br>node-0001节点下载Spark安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /root<span class="token function">wget</span> https://bigdata-tools-hw.obs.cn-north-1.myhuaweicloud.com/spark-2.3.0-bin-without-hadoop.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="解压spark安装包"><a href="#解压spark安装包" class="headerlink" title="解压spark安装包"></a>解压spark安装包</h4><p>node-0001节点执行下列命令：</p><p>复制安装包到/home/modules目录下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> /root/spark-2.3.0-bin-without-hadoop.tgz /home/modules<span class="token builtin class-name">cd</span> /home/modules<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>解压安装包</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> spark-2.3.0-bin-without-hadoop.tgz<span class="token function">mv</span> spark-2.3.0-bin-without-hadoop spark-2.3.0<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="配置spark-jar包"><a href="#配置spark-jar包" class="headerlink" title="配置spark jar包"></a>配置spark jar包</h4><p>在node-0001节点，复制jar包到spark/jar下</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cp</span> /root/hadoop-huaweicloud-2.8.3-hw-39.jar /home/modules/spark-2.3.0/jars/<span class="token function">cp</span> /home/modules/hadoop-2.8.3/share/hadoop/common/lib/snappy-java-1.0.4.1.jar /home/modules/spark-2.3.0/jars/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="配置spark配置文件"><a href="#配置spark配置文件" class="headerlink" title="配置spark配置文件"></a>配置spark配置文件</h4><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /home/modules/spark-2.3.0/conf/<span class="token function">mv</span> spark-env.sh.template spark-env.sh<span class="token function">vim</span> spark-env.sh<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>文件末尾添加如下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/usr/local/java/jdk1.8.0_351<span class="token builtin class-name">export</span> <span class="token assign-left variable">SCALA_HOME</span><span class="token operator">=</span>/home/modules/spark-2.3.0/examples/src/main/scala<span class="token builtin class-name">export</span> <span class="token assign-left variable">HADOOP_HOME</span><span class="token operator">=</span>/home/modules/hadoop-2.8.3<span class="token builtin class-name">export</span> <span class="token assign-left variable">HADOOP_CONF_DIR</span><span class="token operator">=</span>/home/modules/hadoop-2.8.3/etc/hadoop<span class="token builtin class-name">export</span> <span class="token assign-left variable">SPARK_HOME</span><span class="token operator">=</span>/home/modules/spark-2.3.0<span class="token builtin class-name">export</span> <span class="token assign-left variable">SPARK_DIST_CLASSPATH</span><span class="token operator">=</span><span class="token variable"><span class="token variable">$(</span>/home/modules/hadoop-2.8.3/bin/hadoop classpath<span class="token variable">)</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分发Spark"><a href="#分发Spark" class="headerlink" title="分发Spark"></a>分发Spark</h4><p>node-0001节点执行下列命令：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">scp</span> <span class="token parameter variable">-r</span> /home/modules/spark-2.3.0/ root@node-0002:/home/modules/<span class="token function">scp</span> <span class="token parameter variable">-r</span> /home/modules/spark-2.3.0/ root@node-0003:/home/modules/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>各节点执行：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>添加如下内容：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">export</span> <span class="token assign-left variable">SPARK_HOME</span><span class="token operator">=</span>/home/modules/spark-2.3.0<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token variable">${SPARK_HOME}</span>/bin:<span class="token variable">${SPARK_HOME}</span>/sbin:<span class="token environment constant">$PATH</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>各节点执行如下命令，使环境变量生效：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="验证存算分离"><a href="#验证存算分离" class="headerlink" title="验证存算分离"></a>验证存算分离</h4><p>查看要计算的文件</p><p>本次实验验证Spark与OBS实现存算分离，使用上传的playerinfo.txt文件。</p><p>数据如下：</p><pre class="line-numbers language-none"><code class="language-none">Alex James Lax GenuKerry Mary Olivia WilliamHale Edith Vera RobertMary Olivia James LaxEdith Vera Robertm Genu<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>计算上述数据的wordcount<br>启动yarn</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">start-yarn.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注：前面如果使用的是start-all.sh，此命令可以省略</p><p>启动pyspark</p><p>在node-0001节点下执行以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">pyspark<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8718.png"></p><pre class="line-numbers language-python" data-language="python"><code class="language-python">lines <span class="token operator">=</span> spark<span class="token punctuation">.</span>read<span class="token punctuation">.</span>text<span class="token punctuation">(</span><span class="token string">"obs://hadoop-bigdata/playerinfo.txt"</span><span class="token punctuation">)</span><span class="token punctuation">.</span>rdd<span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> r<span class="token punctuation">:</span> r<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>counts <span class="token operator">=</span> lines<span class="token punctuation">.</span>flatMap<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> x<span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token string">' '</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token builtin">map</span><span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">:</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>reduceByKey<span class="token punctuation">(</span><span class="token keyword">lambda</span> x<span class="token punctuation">,</span> y<span class="token punctuation">:</span> x <span class="token operator">+</span> y<span class="token punctuation">)</span>output <span class="token operator">=</span> counts<span class="token punctuation">.</span>collect<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token keyword">for</span> <span class="token punctuation">(</span>word<span class="token punctuation">,</span> count<span class="token punctuation">)</span> <span class="token keyword">in</span> output<span class="token punctuation">:</span><span class="token keyword">print</span><span class="token punctuation">(</span><span class="token string">"%s: %i"</span> <span class="token operator">%</span> <span class="token punctuation">(</span>word<span class="token punctuation">,</span> count<span class="token punctuation">)</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>或者使用以下命令</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token variable">$SPARK_HOME</span>/bin/run-example org.apache.spark.examples.JavaWordCount obs://hadoop-dataserver/playerinfo.txt<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%A4%A7%E6%95%B0%E6%8D%AE%E9%9B%86%E7%BE%A4%E6%90%AD%E5%BB%BA/%E5%9B%BE%E7%89%8719.png"></p><p>成功安装Spark集群，并使Spark能够读取OBS数据，使Spark集群能够实现存算分离，提高计算性能。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
            <tag> hadoop </tag>
            
            <tag> spark </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为云平台应用高可用部署</title>
      <link href="/2023/04/25/hua-wei-yun-ping-tai-ying-yong-gao-ke-yong-bu-shu/"/>
      <url>/2023/04/25/hua-wei-yun-ping-tai-ying-yong-gao-ke-yong-bu-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>通过使用华为云弹性负载均衡ELB和弹性伸缩AS服务，实现华为云平台OA系统应用的高可用部署。</p></blockquote><h3 id="配置应用开机启动"><a href="#配置应用开机启动" class="headerlink" title="配置应用开机启动"></a>配置应用开机启动</h3><p><strong>获取启动脚本</strong></p><p>执行以下命令，下载启动脚本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># cd /home/</span><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># wget https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/autostart.sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行以下命令，打开脚本文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># vim autostart.sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，修改脚本代码。</p><p>修改JAVA_HOME为当前操作系统Java虚拟机的目录。</p><pre class="line-numbers language-none"><code class="language-none">/usr/lib/jvm/java-1.8.0-openjdk-1.8.0.242.b08-1.h5.oe1.aarch64/<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改app为当前OA系统jar包地址。</p><pre class="line-numbers language-none"><code class="language-none">/home/oasys_mysql/target/oasys.jar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，为脚本添加可执行权限。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># chmod +x autostart.sh</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><strong>自定义开机启动命令</strong></p><p>执行以下命令，进入系统目录，下载服务脚本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># cd /etc/systemd/system/</span><span class="token punctuation">[</span>root@ecs-oa system<span class="token punctuation">]</span><span class="token comment"># wget [https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/oa-service.service](https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/oa-service.service)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>执行以下命令，为脚本添加可执行权限。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa system<span class="token punctuation">]</span><span class="token comment"># chmod +x oa-service.service</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，添加开机启动服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl <span class="token builtin class-name">enable</span> oa-service.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8736.png"></p><p><strong>验证开机启动</strong></p><p>重启名为ecs-oa的云服务器。等待1-2分钟，通过ecs-oa弹性公网IP地址加8088端口访问OA系统登录页，如<a href="http://123.60.210.240:8088/%E3%80%82%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E5%90%8D%E2%80%9Csoli%E2%80%9D%E5%92%8C%E5%AF%86%E7%A0%81%E2%80%9C123456%E2%80%9D%E7%99%BB%E5%BD%95%E8%BF%9B%E5%85%A5OA%E7%B3%BB%E7%BB%9F%E4%B8%BB%E7%95%8C%E9%9D%A2%E3%80%82">http://123.60.210.240:8088/。使用用户名“soli”和密码“123456”登录进入OA系统主界面。</a></p><p>配置自启动后，根据弹性伸缩策略分发服务器的时候才能访问到项目（之后会构建这个oa服务器的镜像，供弹性负载均衡服务器运行）</p><h3 id="配置弹性负载均衡"><a href="#配置弹性负载均衡" class="headerlink" title="配置弹性负载均衡"></a>配置弹性负载均衡</h3><h4 id="购买华为云ELB弹性负载均衡"><a href="#购买华为云ELB弹性负载均衡" class="headerlink" title="购买华为云ELB弹性负载均衡"></a>购买华为云ELB弹性负载均衡</h4><p>进入华为云控制台操作页面。选择区域“北京四”，单击“服务列表”，选择“网络 弹性负载均衡ELB”，进入弹性负载均衡列表页面。页面右上角的“购买弹性负载均衡”。</p><p>选择与ecs-oa相同的“所属VPC”和“网络”，选择“按流量计费”，输入名称“elb-oa”，点击右下角“立即购买”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8737.png"></p><h4 id="配置监听器"><a href="#配置监听器" class="headerlink" title="配置监听器"></a>配置监听器</h4><p>在负载均衡器列表中，点击“点我开始配置”。在“监听器”标签中，点击“添加监听器”。默认配置，点击“下一步”。修改名称为“server_group-kunpeng”，点击“完成”。点击“现在添加”。在“后端服务器组”标签中，点击“添加”。选择名为“ecs-oa”的云服务器，点击“下一步”。添加端口输入“8088”，点击“完成”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8738.png"></p><p>等待约30秒之后，点击“刷新”按钮，ecs-oa健康检查结果显示“正常”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8739.png"></p><p>返回负载均衡器列表，记录“elb-oa”的弹性公网IP，使用该IP地址直接访问OA系统登录页，如<a href="http://http//http://123.249.75.243/%E3%80%82%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E5%90%8D%E2%80%9Csoli%E2%80%9D%E5%92%8C%E5%AF%86%E7%A0%81%E2%80%9C123456%E2%80%9D%E7%99%BB%E5%BD%95%E8%BF%9B%E5%85%A5OA%E7%B3%BB%E7%BB%9F%E4%B8%BB%E7%95%8C%E9%9D%A2%E3%80%82">http://http://http://123.249.75.243/。使用用户名“soli”和密码“123456”登录进入OA系统主界面。</a></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8740.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8741.png"></p><h3 id="配置弹性伸缩"><a href="#配置弹性伸缩" class="headerlink" title="配置弹性伸缩"></a>配置弹性伸缩</h3><h4 id="创建华为云云服务器镜像"><a href="#创建华为云云服务器镜像" class="headerlink" title="创建华为云云服务器镜像"></a>创建华为云云服务器镜像</h4><p>返回弹性云服务器列表，点击“更多 -&gt; 镜像/磁盘 -&gt; 创建镜像”。选择名为“ecs-oa”的云服务器，操作系统centos。名称“img-oa-kunpeng”，点击“立即创建”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8742.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8743.png"></p><h4 id="购买华为云AS弹性伸缩服务"><a href="#购买华为云AS弹性伸缩服务" class="headerlink" title="购买华为云AS弹性伸缩服务"></a>购买华为云AS弹性伸缩服务</h4><p>进入华为云控制台操作页面。选择区域“北京四”，单击“服务列表”，选择“弹性伸缩AS”，进入弹性伸缩列表页面。页面右上方，点击“创建弹性伸缩组”。输入名称“as-group-oa-kunpeng”，最大、期望、最小实例数分别为3、2和1台。点击加号按钮，增加伸缩配置。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8744.png"></p><h4 id="创建伸缩配置"><a href="#创建伸缩配置" class="headerlink" title="创建伸缩配置"></a>创建伸缩配置</h4><p>点击“创建伸缩配置”。输入名称为“as-config-oa-kunpeng”。选择配置为CPU架构“X86计算”，规格“华为云计算，华为云通用计算增强型，kc1.large.2 2vCPUs | 4GB”。</p><p>在“私有镜像”标签内，选择名为“img-oa-kunpeng”的私有镜像，安全组选择“sg-FullAccess”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8745.png"></p><p>返回伸缩配置列表，显示名为“as-config-oa-kunpeng”的伸缩配置</p><p>确认使用和ecs-oa同样的虚拟私有云和子网，负载均衡选择“使用弹性负载均衡”，负载均衡器选择“elb-oa”，后端服务器组选择“server_group-kunpeng”，后端端口填写“8088”，点击“立即创建”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8746.png"></p><h4 id="添加弹性策略"><a href="#添加弹性策略" class="headerlink" title="添加弹性策略"></a>添加弹性策略</h4><p>点击“添加伸缩策略”，在伸缩策略页面，点击“添加伸缩策略”。将伸缩策略命名为“as-policy-oa-kunpeng”，使用“告警策略”，设置触发条件为“CPU使用率最大值&gt;50%”，连续出现次数填写“3”，点击“确定”。</p><p>点击“概览”标签，显示当前实例数为2台，即设置的“期望实例数”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8747.png"></p><p>返回弹性云服务器列表，点击刷新按钮，显示通过AS创建的华为云实例。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8748.png"></p><p>进入弹性负载均衡器“elb-oa”的后端服务器组”标签，显示这两台华为云实例已加入。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8749.png"></p><p>返回伸缩实例as-group-oa-kunpeng的“伸缩策略”页面，点击“立即执行”，在对话框中点击“是”。在“概览”页面、云服务器列表和弹性负载均衡后端服务器组中都可显示新创建的华为云实例。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8750.png"></p><p>返回负载均衡器列表，记录“elb-oa”的弹性公网IP，使用该IP地址直接访问OA系统登录页，如<a href="http://123.249.75.243/%E3%80%82%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E5%90%8D%E2%80%9Csoli%E2%80%9D%E5%92%8C%E5%AF%86%E7%A0%81%E2%80%9C123456%E2%80%9D%E7%99%BB%E5%BD%95%E8%BF%9B%E5%85%A5OA%E7%B3%BB%E7%BB%9F%E4%B8%BB%E7%95%8C%E9%9D%A2%E3%80%82">http://123.249.75.243/。使用用户名“soli”和密码“123456”登录进入OA系统主界面。</a></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8751.png"></p><p>成功使用华为云弹性负载均衡ELB和弹性伸缩AS服务，实现华为云平台OA系统应用的高可用部署。</p><p>使用弹性负载均衡ELB公网IP访问项目的时候，可能会出现登录页面嵌套问题。</p><p>因为该OA项目的单体项目，不是分布式项目，在不同服务器中无法共享session。所以当刷新页面的时候，会把请求分发到不同服务器，这个服务器没有保存之前的信息，属于项目接口的非法访问，就跳转到登录页面。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 分布式 </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为云平台数据库迁移与部署</title>
      <link href="/2023/04/25/hua-wei-yun-ping-tai-shu-ju-ku-qian-yi-yu-bu-shu/"/>
      <url>/2023/04/25/hua-wei-yun-ping-tai-shu-ju-ku-qian-yi-yu-bu-shu/</url>
      
        <content type="html"><![CDATA[<blockquote><p>通过配置华为云平台OA系统的数据库配置文件、将数据从华为云ECS自建数据库迁移至GaussDB(for MySQL)数据库，实现可供华为云平台OA系统接入的GaussDB(for MySQL)数据库部署。</p></blockquote><h3 id="部署云数据库GaussDB"><a href="#部署云数据库GaussDB" class="headerlink" title="部署云数据库GaussDB"></a>部署云数据库GaussDB</h3><p><strong>购买云数据库GaussDB</strong></p><p>进入控制台操作页面。选择区域“北京四”，单击“服务列表”，选择“数据库 &gt; 云数据库GaussDB”，进入服务列表页面。页面右上角的“购买数据库实例”。</p><p>进入云数据库GaussDB基础配置页面，选择配置如下所示，点击“立即购买”。计费模式：按需计费；区域：华北-北京四；实例名称：gauss-oa；性能规格：16核 | 64 GB；虚拟私有云：vpc-default；子网：subnet-default；内网安全组：sg-FullAccess；管理员密码&amp;确认密码。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8725.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8726.png"></p><p>查看云数据库信息，记录gauss-oa的内网地址</p><h3 id="数据迁移"><a href="#数据迁移" class="headerlink" title="数据迁移"></a>数据迁移</h3><h4 id="导出ecs-mysql数据"><a href="#导出ecs-mysql数据" class="headerlink" title="导出ecs-mysql数据"></a>导出ecs-mysql数据</h4><p>使用登录ecs-mysql的PuTTY，或者重新使用PuTTY登录ecs-mysql。执行以下命令，导出数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-mysql ~<span class="token punctuation">]</span><span class="token comment"># mysqldump -uroot -p oasys &gt; oasys-dump.sql</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8727.png"></p><p>因为我们的mysql是在docker中运行的，需要进入docker下的mysql</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysqlserver <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>然后再执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqldump <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span> oasys <span class="token operator">&gt;</span> oasys-dump.sql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导出的oasys-dump.sql文件在共享文件夹/opt/docker_mysql/data/中</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">Enter password:<span class="token punctuation">[</span>root@ecs-mysql ~<span class="token punctuation">]</span><span class="token comment"># ls</span>oasys-dump.sql<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8728.png"></p><h4 id="导入数据到gauss-oa"><a href="#导入数据到gauss-oa" class="headerlink" title="导入数据到gauss-oa"></a>导入数据到gauss-oa</h4><p>通过MySQL客户端登录gauss-oa，其中192.168.0.XXX修改为gauss-oa相应的内网地址。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-mysql ~<span class="token punctuation">]</span><span class="token comment"># mysql -h 192.168.0.xxx -P 3306 -u root -p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8729.png"></p><p>这里也需要先执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysqlserver <span class="token function">bash</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>导入oasys-dump.sql到gauss-oa</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> create database oasys<span class="token punctuation">;</span>Query OK, <span class="token number">1</span> row affected <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span>mysql<span class="token operator">&gt;</span> use oasys<span class="token punctuation">;</span>Database changedmysql<span class="token operator">&gt;</span> <span class="token builtin class-name">source</span> /var/lib/mysql/oasys-dump.sql<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>（/opt/docker_mysql/data/oasys-dump.sql路径是主机下docker中的mysql共享文件夹,这里在docker下执行,路径是/var/lib/mysql/oasys-dump.sql，安装mysql的时候设置的data目录）</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8730.png"></p><p>查看数据库表并退出。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> show tables<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8731.png"></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">exit</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="修改配置文件"><a href="#修改配置文件" class="headerlink" title="修改配置文件"></a>修改配置文件</h4><p>在使用putty登录ecs-oa，执行以下命令，打开并修改数据库连接信息。其中IP地址为gauss-oa的内网地址，密码为gauss-oa的root登录密码。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa ~<span class="token punctuation">]</span><span class="token comment"># cd /home/oasys_mysql/src/main/resources/</span><span class="token punctuation">[</span>root@ecs-oa resources<span class="token punctuation">]</span><span class="token comment"># vim application.properties</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8732.png"></p><h4 id="编译安装系统"><a href="#编译安装系统" class="headerlink" title="编译安装系统"></a>编译安装系统</h4><p>安装Maven。执行以下命令，进入项目目录，使用Maven本地安装。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa resources<span class="token punctuation">]</span><span class="token comment"># cd /home/oasys_mysql/</span><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># mvn install</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>执行以下命令，启动应用。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># java -jar target/oasys.jar</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8733.png"></p><p>通过ecs-oa的弹性公网IP地址加8088端口访问OA系统登录页，使用用户名“soli”和密码“123456”登录OA系统主界面。</p><p>成功将数据从华为云ECS自建数据库迁移至GaussDB(for MySQL)数据库，实现可供华为云平台OA系统接入的GaussDB(for MySQL)数据库部署。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8734.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8735.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>华为云平台部署OA系统</title>
      <link href="/2023/04/25/hua-wei-yun-ping-tai-bu-shu-oa-xi-tong/"/>
      <url>/2023/04/25/hua-wei-yun-ping-tai-bu-shu-oa-xi-tong/</url>
      
        <content type="html"><![CDATA[<blockquote><p>通过一个开源的OA(自动化办公 Office Automation)系统实例<br>实现OA系统在华为云服务器上的部署</p></blockquote><h3 id="数据库部署"><a href="#数据库部署" class="headerlink" title="数据库部署"></a>数据库部署</h3><h4 id="ECS云服务器搭建"><a href="#ECS云服务器搭建" class="headerlink" title="ECS云服务器搭建"></a>ECS云服务器搭建</h4><p>访问<a href="https://www.huaweicloud.com/?locale=zh-cn">华为云官网</a>，注册登录账号，然后进入控制台。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%871.png"></p><p>在页面左上角，选择区域“北京四”，单击“服务列表”，选择“计算 -&gt; 弹性云服务器ECS”，进入弹性云服务器列表页面。购买弹性云服务器。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%872.png"></p><p>购买后，进入弹性云服务器的基础配置页面，选择基础配置（按需计费，华为云计算，X86架构，通用计算增强型，1核2G内存，CentOS/Ubuntu），单击“下一步：网络配置”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%873.png"></p><p>进入弹性云服务器的网络配置页面，其中网络选择“vpc-default –&gt; subnet-default -&gt; 自动分配地址”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%874.png"></p><p>新建安全组，检查安全组中是否有“Sys-FullAccess”，若没有则点击“创建安全组”。选择模板为“开放全部端口”，输入名称“sg-FullAccess”，点击“确定”。</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%875.png"></p><p>点击安全组刷新按钮，选择“sg-FullAccess”，公网带宽选择“按流量计费”和“5”Mbit/s带宽大小，单击“下一步：高级配置”</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%876.png"></p><p>进入弹性云服务器的高级配置页面，高级配置如下图所示：</p><p>云服务器名称：ecs-mysql</p><p>输入自定义密码，密码需大于8位并带有特殊字符，再次确认密码</p><p>单击“下一步：确认配置</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%877.png"></p><p>进入弹性云服务器的确认配置页面，核对信息无误后，勾选下方的“我已经阅读并同意《华为镜像免责声明》”，如果有企业项目使用下拉框选择企业项目，单击“立即购买”，完成用于部署MySQL的云服务器购买。</p><p>返回弹性云服务器列表页面，查看刚刚购买的弹性云服务器ecs-mysql，等待其状态变为“运行中”， 记录其弹性IP地址。</p><h4 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h4><p>安装必要的docker 工具</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> <span class="token parameter variable">-y</span> yum-utils<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>yum-config-manager，这个命令可以设置docker仓库源，命令如下：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum-config-manager <span class="token punctuation">\</span>    --add-repo <span class="token punctuation">\</span>    https://download.docker.com/linux/centos/docker-ce.repo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>设置阿里云镜像加速：登录阿里云，找到镜像加速服务，粘贴代码，运行即可，目的是为了加速镜像的获取</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%878.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%879.png"></p><p>查看docker可安装版本</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum list docker-ce <span class="token parameter variable">--showduplicates</span> <span class="token operator">|</span> <span class="token function">sort</span> <span class="token parameter variable">-r</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>指定版本安装：yum -y install docker-ce-&lt; VERSION STRING &gt;<br>或者直接</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> <span class="token parameter variable">-y</span> docker-ce docker-ce-cli http://containerd.io<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看docker版本、启动，停止以及自启动<br>查看： docker -v(或version) ；<br>启动： service docker start/systemctl start docker ;<br>停止：systemctl stop docker ;<br>自启动： systemctl enable docker .<br>查看镜像： docker images ；<br>删除镜像： docker rmi 镜像id ；<br>查看所有容器： docker ps -a ;<br>查看运行中的容器： docker ps ；<br>删除容器: docker rm &nbsp;容器id &nbsp;</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8710.png"></p><p>docker安装MySQL<br>查看可安装的MySQL：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> search mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装mysql：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> pull mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8711.png"></p><p>启动mysql：</p><p>在opt目录下创建docker_mysql文件夹：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span>  /opt/ <span class="token punctuation">;</span><span class="token function">mkdir</span>  docker_mysql <span class="token punctuation">;</span><span class="token builtin class-name">cd</span> docker_mysql ；<span class="token builtin class-name">echo</span> <span class="token environment constant">$PWD</span> <span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>启动mysql容器，在var/lib/docker/containers/下查看容器</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> run <span class="token parameter variable">--name</span> mysqlserver <span class="token punctuation">\</span><span class="token parameter variable">-v</span> <span class="token environment constant">$PWD</span>/conf:/etc/mysql/conf.d <span class="token punctuation">\</span><span class="token parameter variable">-v</span> <span class="token environment constant">$PWD</span>/logs:/logs <span class="token punctuation">\</span><span class="token parameter variable">-v</span> <span class="token environment constant">$PWD</span>/data:/var/lib/mysql <span class="token punctuation">\</span><span class="token parameter variable">-e</span> <span class="token assign-left variable">MYSQL_ROOT_PASSWORD</span><span class="token operator">=</span><span class="token number">123456</span> <span class="token parameter variable">-d</span> <span class="token parameter variable">-i</span> <span class="token parameter variable">-p</span> <span class="token number">3306</span>:3306 mysql:latest<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>查看mysql进程：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token function">ps</span> <span class="token parameter variable">-a</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8712.png"></p><p>进入mysql容器，并登陆mysql</p><p>进入MySQL： </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">docker</span> <span class="token builtin class-name">exec</span> <span class="token parameter variable">-it</span> mysqlserver <span class="token function">bash</span><span class="token comment"># 或 docker attach 容器ID</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>登录mysql </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-uroot</span> -p；<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>退出MySQL容器： exit 或者 Ctrl+P+Q</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8713.png"></p><p><strong>导入数据：</strong></p><p>下载原始sql文件到/home目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">exit</span><span class="token punctuation">[</span>root@ecs-mysql run<span class="token punctuation">]</span><span class="token comment"># cd /home/</span><span class="token punctuation">[</span>root@ecs-mysql home<span class="token punctuation">]</span><span class="token comment"># wget [https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/oasys_mysql.sql](https://obs-oa-zyl.obs.cn-north-4.myhuaweicloud.com/oasys_mysql.sql)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>登录mysql，下述命令中的“mypassword”需要根据实际修改成要配置的密码。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-mysql home<span class="token punctuation">]</span><span class="token comment"># mysql -uroot -pmypassword</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>创建名为“oasys”的数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> create database oasys<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>使用“oasys”数据库，执行原始sql文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> use oasys<span class="token punctuation">;</span>mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">source</span> /home/oasys_mysql.sql<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>找不到/home/oasys_mysql.sql，因为MySQL在docker下运行，需要把oasys_mysql.sql文件放在/data:/var/lib/mysql。放在data目录下。</p><p>执行</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql<span class="token operator">&gt;</span> <span class="token builtin class-name">source</span> /var/lib/mysql/oasys_mysql.sql<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8714.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8715.png"></p><h3 id="OA应用部署"><a href="#OA应用部署" class="headerlink" title="OA应用部署"></a>OA应用部署</h3><h4 id="ECS云服务器搭建-1"><a href="#ECS云服务器搭建-1" class="headerlink" title="ECS云服务器搭建"></a>ECS云服务器搭建</h4><p>同上操作</p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8716.png"></p><h4 id="安装JDK"><a href="#安装JDK" class="headerlink" title="安装JDK"></a>安装JDK</h4><p>下载并拷贝jdk8至/usr/local/java，并解压缩</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">cd</span> /usr/local/<span class="token function">mkdir</span> <span class="token function">java</span><span class="token function">tar</span> <span class="token parameter variable">-zxvf</span> jdk-8-linux-i586<span class="token punctuation">(</span>x86<span class="token punctuation">)</span>.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>设置环境变量</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">vim</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按“i”进入编辑模式，使用hjkl键或方向键移动光标，在文件最后添加以下代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">JAVA_HOME</span><span class="token operator">=</span>/usr/local/java/jdk1.8******<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$JAVA_HOME</span>/bin<span class="token builtin class-name">export</span> JAVA_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>按“Esc”退出编辑模式，输入“:wq”并按回车，保存退出。<br>执行以下命令，使新增配置生效。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">source</span> /etc/profile<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，验证jdk安装并配置成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">java</span> –version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8717.png"><br>解决方法：<br>执行命令 </p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sudo</span> yum <span class="token function">install</span> glibc.i686<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8718.png"></p><h4 id="安装Maven"><a href="#安装Maven" class="headerlink" title="安装Maven"></a>安装Maven</h4><p>执行以下命令，创建Maven安装目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa ~<span class="token punctuation">]</span><span class="token comment"># mkdir /usr/local/maven</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，切换到Maven安装目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa ~<span class="token punctuation">]</span><span class="token comment"># cd /usr/local/maven</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，获取Maven二进制包。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># wget [http://mirrors.huaweicloud.com/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz](http://mirrors.huaweicloud.com/apache/maven/maven-3/3.6.3/binaries/apache-maven-3.6.3-bin.tar.gz)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，解压Maven二进制包。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># tar -xvzf apache-maven-3.6.3-bin.tar.gz</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>步骤 5执行以下命令，打开环境变量配置文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># vim /etc/profile</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>按“i”进入编辑模式，使用hjkl键或方向键移动光标，在文件最后添加以下代码：</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">MAVEN_HOME</span><span class="token operator">=</span>/usr/local/maven/apache-maven-3.6.3<span class="token builtin class-name">export</span> <span class="token assign-left variable"><span class="token environment constant">PATH</span></span><span class="token operator">=</span><span class="token environment constant">$PATH</span><span class="token builtin class-name">:</span><span class="token variable">$MAVEN_HOME</span>/bin<span class="token builtin class-name">export</span> MAVEN_HOME<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>按“Esc”退出编辑模式，输入“:wq”并按回车，保存退出。<br>执行以下命令，使新增配置生效。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># source /etc/profile</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，验证Maven安装。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># mvn -v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8719.png"></p><h4 id="Maven换源"><a href="#Maven换源" class="headerlink" title="Maven换源"></a>Maven换源</h4><p>执行以下命令，进入Maven配置文件目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa maven<span class="token punctuation">]</span><span class="token comment"># cd /usr/local/maven/apache-maven-3.6.3/conf/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，打开配置文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa conf<span class="token punctuation">]</span><span class="token comment"># vim settings.xml</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>输入”:158”后按回车键，在<mirrors>和</mirrors>中间，插入以下代码。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&lt;</span>mirror<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>id<span class="token operator">&gt;</span>mirror<span class="token operator">&lt;</span>/id<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>mirrorOf<span class="token operator">&gt;</span>*<span class="token operator">&lt;</span>/mirrorOf<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>name<span class="token operator">&gt;</span>cmc-cd-mirror<span class="token operator">&lt;</span>/name<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span>url<span class="token operator">&gt;</span>https://mirrors.huaweicloud.com/repository/maven/<span class="token operator">&lt;</span>/url<span class="token operator">&gt;</span><span class="token operator">&lt;</span>/mirror<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="克隆项目"><a href="#克隆项目" class="headerlink" title="克隆项目"></a>克隆项目</h4><p>执行以下命令，安装Git。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa conf<span class="token punctuation">]</span><span class="token comment"># yum install -y git</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，验证Git版本。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa conf<span class="token punctuation">]</span><span class="token comment"># git version</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8720.png"></p><p>执行以下命令，Clone源码到本地。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa conf<span class="token punctuation">]</span><span class="token comment"># cd /home</span><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># git clone -b mysql-8 https://gitee.com/github-5407963/oasys_mysql.git</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="配置MySQL连接"><a href="#配置MySQL连接" class="headerlink" title="配置MySQL连接"></a>配置MySQL连接</h4><p>执行以下命令，进入OA系统数据库配置文件目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa home<span class="token punctuation">]</span><span class="token comment"># cd /home/oasys_mysql/src/main/resources/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，编辑应用配置文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa resources<span class="token punctuation">]</span><span class="token comment"># vim application.properties</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改url、username和password为ecs-mysql的内网地址、mysql的登录用户名和密码，保存文件，退出。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token assign-left variable">server.port</span><span class="token operator">=</span><span class="token number">8088</span>spring.datasource.driver-class-name<span class="token operator">=</span>com.mysql.cj.jdbc.Driver<span class="token assign-left variable">spring.datasource.url</span><span class="token operator">=</span>jdbc:mysql://192.168.0.25:3306/oasys?autoReconnect<span class="token operator">=</span>true<span class="token operator">&amp;</span><span class="token assign-left variable">useSSL</span><span class="token operator">=</span>false<span class="token operator">&amp;</span><span class="token assign-left variable">characterEncoding</span><span class="token operator">=</span>utf-8<span class="token operator">&amp;</span><span class="token assign-left variable">serverTimezone</span><span class="token operator">=</span>Hongkong<span class="token operator">&amp;</span><span class="token assign-left variable">rewriteBatchedStatements</span><span class="token operator">=</span>true<span class="token operator">&amp;</span><span class="token assign-left variable">allowPublicKeyRetrieval</span><span class="token operator">=</span>true<span class="token assign-left variable">spring.datasource.username</span><span class="token operator">=</span>root<span class="token assign-left variable">spring.datasource.password</span><span class="token operator">=</span>mypassword<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以下命令，进入OA系统目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa resources<span class="token punctuation">]</span><span class="token comment"># cd /home/oasys_mysql/</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行以下命令，重新Maven本地编译安装。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># mvn install</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8721.png"></p><p>执行以下命令，启动项目应用。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token punctuation">[</span>root@ecs-oa oasys_mysql<span class="token punctuation">]</span><span class="token comment"># java -jar target/oasys.jar</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8722.png"></p><p>通过ecs-oa弹性公网IP地址加8088端口访问OA系统登录页，如<a href="http://123.60.210.240:8088/%E3%80%82%E4%BD%BF%E7%94%A8%E7%94%A8%E6%88%B7%E5%90%8D%E2%80%9Csoli%E2%80%9D%E5%92%8C%E5%AF%86%E7%A0%81%E2%80%9C123456%E2%80%9D%E7%99%BB%E5%BD%95%E8%BF%9B%E5%85%A5OA%E7%B3%BB%E7%BB%9F%E4%B8%BB%E7%95%8C%E9%9D%A2%E3%80%82">http://123.60.210.240:8088/。使用用户名“soli”和密码“123456”登录进入OA系统主界面。</a></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8723.png"></p><p><img src="/images/image_%E5%8D%8E%E4%B8%BA%E4%BA%91/%E5%9B%BE%E7%89%8724.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于ECS搭建云上博客</title>
      <link href="/2023/04/25/ji-yu-a-li-ecs-da-jian-yun-shang-bo-ke/"/>
      <url>/2023/04/25/ji-yu-a-li-ecs-da-jian-yun-shang-bo-ke/</url>
      
        <content type="html"><![CDATA[<h3 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h3><p><strong>LAMP</strong></p><p>LAMP是指Linux（操作系统）+Apache（HTTP 服务器）+MySQL（数据库）和PHP（网络编程语言），一般用来建立Web应用平台。</p><p><strong>WordPress</strong></p><p>WordPress是一种使用PHP语言开发的博客平台，用户可以在支持PHP和MySQ数据库的服务器上架设WordPress。可以使用WordPress搭建一个简单的独立博客。</p><p><strong>云服务器ECS</strong></p><h3 id="实验过程"><a href="#实验过程" class="headerlink" title="实验过程"></a>实验过程</h3><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/1.png"></p><h4 id="安装并配置Apache服务"><a href="#安装并配置Apache服务" class="headerlink" title="安装并配置Apache服务"></a>安装并配置Apache服务</h4><p>Apache是Web服务器软件。<br>在实验室切换至Web Terminal。输入ECS服务器登录用户名和密码，登录ECS。<br>执行如下命令，安装Apache服务及其扩展包。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token parameter variable">-y</span> <span class="token function">install</span> httpd mod_ssl mod_perl mod_auth_mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/2.png"></p><p>执行如下命令，查看Apache是否安装成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">httpd <span class="token parameter variable">-v</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/3.png"></p><p>执行如下命令，启动Apache服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start httpd.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在本机浏览器的地址栏中，访问<a href="http://ecs公网地址./">http://ECS公网地址。</a></p><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/4.png"></p><h4 id="安装MariaDB数据库"><a href="#安装MariaDB数据库" class="headerlink" title="安装MariaDB数据库"></a>安装MariaDB数据库</h4><p>执行一下命令安装</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token function">install</span> <span class="token parameter variable">-y</span> mariadb-server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/5.png"></p><p>执行如下命令，启动MariaDB Server。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl start mariadb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/6.png"></p><p>执行如下命令，查看MariaDB Server运行状态。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl status mariadb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/7.png"></p><p>执行如下命令，设置数据库root用户的初始密码。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysqladmin <span class="token parameter variable">-u</span> root <span class="token parameter variable">-p</span> password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/8.png"></p><p>123456789</p><p>执行如下命令，连接数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mysql <span class="token parameter variable">-uroot</span> <span class="token parameter variable">-p</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/9.png"></p><p>执行如下命令，创建WordPress数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">create database wordpress<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行如下命令，查看数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">show databases<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/10.png"></p><p>执行如下命令，退出数据库。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">exit</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h4 id="安装PHP"><a href="#安装PHP" class="headerlink" title="安装PHP"></a>安装PHP</h4><p>PHP是一种广泛使用的通用开源脚本语言，适合于Web网站开发，它可以嵌入HTML中。</p><p>执行如下命令，安装PHP。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token parameter variable">-y</span> <span class="token function">install</span> php php-mysql gd php-gd gd-devel php-xml php-common php-mbstring php-ldap php-pear php-xmlrpc php-imap<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/11.png"></p><p>执行如下命令，创建PHP测试页面。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token builtin class-name">echo</span> <span class="token string">"&lt;?php phpinfo(); ?&gt;"</span> <span class="token operator">&gt;</span> /var/www/html/phpinfo.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行如下命令，重启Apache服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart httpd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>在浏览器的地址栏中，访问http://&lt;ECS公网地址&gt;/phpinfo.php。</p><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/12.png"></p><h4 id="安装和配置WordPress"><a href="#安装和配置WordPress" class="headerlink" title="安装和配置WordPress"></a>安装和配置WordPress</h4><p>在实验室页面右侧，单击 图标，切换至Web Terminal。</p><p>执行如下命令，安装WordPress。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">yum <span class="token parameter variable">-y</span> <span class="token function">install</span> wordpress<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/13.png"></p><p>修改WordPress配置文件。</p><p>执行如下命令，修改wp-config.php指向路径为绝对路径。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 进入/usr/share/wordpress目录。</span><span class="token builtin class-name">cd</span> /usr/share/wordpress<span class="token comment"># 修改路径。</span><span class="token function">ln</span> <span class="token parameter variable">-snf</span> /etc/wordpress/wp-config.php wp-config.php<span class="token comment"># 查看修改后的目录结构。</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/14.png"></p><p>执行如下命令，移动wordpress文件到Apache根目录。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token comment"># 在Apache的根目录/var/www/html下，创建一个wp-blog文件夹。</span><span class="token function">mkdir</span> /var/www/html/wp-blog<span class="token function">mv</span> * /var/www/html/wp-blog/<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以下命令，修改wp-config.php配置文件。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/database_name_here/wordpress/'</span> /var/www/html/wp-blog/wp-config.php<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/username_here/root/'</span> /var/www/html/wp-blog/wp-config.php<span class="token function">sed</span> <span class="token parameter variable">-i</span> <span class="token string">'s/password_here/123456789/'</span> /var/www/html/wp-blog/wp-config.php<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>执行以下命令，查看配置文件信息是否修改成功。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token function">cat</span> <span class="token parameter variable">-n</span> /var/www/html/wp-blog/wp-config.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/15.png"></p><p>执行如下命令，重启Apache服务。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">systemctl restart httpd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="测试WordPress"><a href="#测试WordPress" class="headerlink" title="测试WordPress"></a>测试WordPress</h3><p>在浏览器地址栏中，访问http://&lt;ECS公网地址&gt;/wp-blog/wp-admin/install.php。</p><p>在WordPress配置页面，配置相关信息，然后单击Install WordPress。</p><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/16.png"></p><p>成功发布一篇博文</p><p><img src="/images/image_%E4%BA%91%E4%B8%8A%E5%8D%9A%E5%AE%A2/17.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 云计算 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL版本升级5.5-8.0.20</title>
      <link href="/2023/04/15/mysql-ban-ben-sheng-ji-5.5-8.0.20/"/>
      <url>/2023/04/15/mysql-ban-ben-sheng-ji-5.5-8.0.20/</url>
      
        <content type="html"><![CDATA[<h3 id="1-备份数据库"><a href="#1-备份数据库" class="headerlink" title="1. 备份数据库"></a>1. 备份数据库</h3><p>在数据库编辑器中对重要的数据库导出为<code>.sql</code>文件<br>版本升级后，可以在新版本的MySQL中新建数据库执行<code>.sql</code>文件，恢复数据</p><p><em><strong>（在此升级过程中并不会删掉原有数据库，数据备份是一个好习惯）</strong></em></p><h3 id="2-下载对应版本的MySQL"><a href="#2-下载对应版本的MySQL" class="headerlink" title="2. 下载对应版本的MySQL"></a>2. 下载对应版本的MySQL</h3><p><a href="https://downloads.mysql.com/archives/community/">官网：https://downloads.mysql.com/archives/community/</a></p><p><img src="/images/image_MySQL%E5%8D%87%E7%BA%A7/1.png"></p><p>然后将安装包解压，最好和MySQL5.5（老版本）放在一起，方便查找</p><h3 id="3-配置环境变量"><a href="#3-配置环境变量" class="headerlink" title="3. 配置环境变量"></a>3. 配置环境变量</h3><p><code>D:\MySQL\mysql-8.0.20\bin</code></p><p>在用户变量path 中添加MySQL的bin文件夹目录</p><p>删除老版本MySQL的环境变量</p><h3 id="4-配置文件"><a href="#4-配置文件" class="headerlink" title="4. 配置文件"></a>4. 配置文件</h3><p>在<code>mysql-8.0.20</code>目录下新建<code>my.ini</code>文件</p><p><img src="/images/image_MySQL%E5%8D%87%E7%BA%A7/2.png"></p><p>写入：</p><pre class="line-numbers language-none"><code class="language-none"># 设置3306端口port=3306# 设置mysql的安装目录，写你的目录basedir=D:\MySQL# 设置mysql数据库的数据的存放目录，这是隐藏的文件夹datadir=C:\ProgramData\MySQL/MySQL Server 8.0\Data\# 允许最大连接数max_connections=200# 允许连接失败的次数。防止有人从该主机试图攻击数据库系统max_connect_errors=10# 服务端使用的字符集默认为UTF8character-set-server=utf8# 创建新表时将使用的默认存储引擎default-storage-engine=INNODB# 默认使用“mysql_native_password”插件认证default_authentication_plugin=mysql_native_password[mysql]# 设置mysql客户端默认字符集default-character-set=utf8[client]# 设置mysql客户端连接服务端时默认使用的端口port=3306default-character-set=utf8<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-停止MySQL5-5服务"><a href="#5-停止MySQL5-5服务" class="headerlink" title="5. 停止MySQL5.5服务"></a>5. 停止MySQL5.5服务</h3><p>在任务管理器-&gt;服务 : 找到MySQL</p><p>停止MySQL服务</p><p>以管理员运行命令窗口</p><pre class="line-numbers language-none"><code class="language-none">C:\Windows\system32&gt;cd D:\MySQL\MySQL5.5\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>进入该文件夹，执行</p><pre class="line-numbers language-none"><code class="language-none">mysqld --remove mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="6-安装运行MySQL-8-0-2"><a href="#6-安装运行MySQL-8-0-2" class="headerlink" title="6. 安装运行MySQL 8.0.2"></a>6. 安装运行MySQL 8.0.2</h3><pre class="line-numbers language-none"><code class="language-none"># 设置mysql数据库的数据的存放目录，这是隐藏的文件夹datadir=C:\ProgramData\MySQL/MySQL Server 8.0\Data\<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>创建文件夹，存放数据<br>需要查看隐藏文件夹ProgramData<br><code>C:\ProgramData\MySQL/MySQL Server 8.0\Data\</code></p><pre class="line-numbers language-none"><code class="language-none">cd D:\MySQL\mysql-8.0.20\bin<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到mysql-8.0.20的bin目录下</p><p>执行安装命令</p><pre class="line-numbers language-none"><code class="language-none">mysqld -install<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>执行初始化命令</p><pre class="line-numbers language-none"><code class="language-none">mysqld --initialize --user=mysql --console<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>初始化成功后会给个root临时密码，类似 DQybZ_HT#76B</p><p>以root账号进入数据库  </p><pre class="line-numbers language-none"><code class="language-none">mysql -u root -p<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>连接</p><pre class="line-numbers language-none"><code class="language-none">net start mysql<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改密码</p><pre class="line-numbers language-none"><code class="language-none">ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '123456';<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>到此MySQL升级成功，在SQLyog编辑器中已经自动连接上8.0.20版本MySQL</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps流水线搭建03</title>
      <link href="/2023/04/15/devops-liu-shui-xian-da-jian-03/"/>
      <url>/2023/04/15/devops-liu-shui-xian-da-jian-03/</url>
      
        <content type="html"><![CDATA[<h2 id="1-测试DevOps流水线"><a href="#1-测试DevOps流水线" class="headerlink" title="1. 测试DevOps流水线"></a>1. 测试DevOps流水线</h2><h3 id="gitlab创建项目并拉取到本地"><a href="#gitlab创建项目并拉取到本地" class="headerlink" title="gitlab创建项目并拉取到本地"></a>gitlab创建项目并拉取到本地</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8730.png"><br>关闭防火墙，让本机访问gitlab</p><pre class="line-numbers language-none"><code class="language-none">$systemctl stop firewalld.service<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>clone项目，将我们需要打包发布的项目推送到gitlab</p><pre class="line-numbers language-none"><code class="language-none">git add .git commit -m "first push"git tag 1.0.0git push origin 1.0.0git push -u origin --all<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="harbor-server上构建基础镜像"><a href="#harbor-server上构建基础镜像" class="headerlink" title="harbor-server上构建基础镜像"></a>harbor-server上构建基础镜像</h3><p>遇到小问题</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8732.png"></p><p>重启harbor解决</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker-compose down$sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>拉取openjdk镜像</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker pull openjdk:8u201-jdk-alpine3.9<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8733.png"></p><pre class="line-numbers language-none"><code class="language-none">$sudo docker tag openjdk:8u201-jdk-alpine3.9 192.168.159.131:8077/library/openjdk8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8734.png"><br>登录harbor仓库</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker login 192.168.159.131:8077<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>推送</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker push 192.168.159.131:8077/library/openjdk8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8735.png"></p><h3 id="构建jenkins应用"><a href="#构建jenkins应用" class="headerlink" title="构建jenkins应用"></a>构建jenkins应用</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8736.png"><br>遇到问题：</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8737.png"></p><p>我这里是因为gitlab-server上没安装ssh服务,安装后解决<br>其他原因可能是私钥密钥配置错误</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8738.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8739.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8740.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8741.png"></p><p>开始构建</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8742.png"></p><p>构建成功<br>访问</p><p><img src="/images/image_DevOps/2.jpg"></p><p>修改代码后，再次push</p><p><img src="/images/image_DevOps/1.jpg"></p><p><img src="/images/image_DevOps/3.jpg"></p><p>流水线测试成功！</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> harbor </tag>
            
            <tag> jenkins </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps流水线搭建02</title>
      <link href="/2023/04/10/devops-liu-shui-xian-da-jian-02/"/>
      <url>/2023/04/10/devops-liu-shui-xian-da-jian-02/</url>
      
        <content type="html"><![CDATA[<h2 id="1-各主机中的工具配置"><a href="#1-各主机中的工具配置" class="headerlink" title="1. 各主机中的工具配置"></a>1. 各主机中的工具配置</h2><h3 id="jenkins-server"><a href="#jenkins-server" class="headerlink" title="jenkins-server"></a>jenkins-server</h3><p><strong>docker配置</strong><br>配置docker主机使用harbor，添加信任harbor-server中的私有仓库<br>（harbor仓库ip+端口号）</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/docker/daemon.json# 写入{"insecure-registries": ["http://192.168.159.131:8077"]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启docker</p><pre class="line-numbers language-none"><code class="language-none">$systemctl restart docker<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>登录harbor主机中的docker仓库服务</p><pre class="line-numbers language-none"><code class="language-none">$sudo docker login 192.168.159.131:8077<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8712.png"><br><strong>配置jenkins使用docker</strong></p><p>验证系统中是否有jenkins用户</p><pre class="line-numbers language-none"><code class="language-none">$grep jenkins /etc/passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>验证系统中是否有docker用户及用户组</p><pre class="line-numbers language-none"><code class="language-none">$grep docker /etc/group<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8713.png"><br>添加jenkins用户到docker用户组</p><pre class="line-numbers language-none"><code class="language-none">$sudo usermod -G docker jenkins$grep docker /etc/group<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8714.png"><br>重启jenkins服务</p><pre class="line-numbers language-none"><code class="language-none">$systemctl restart jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="harbor-server"><a href="#harbor-server" class="headerlink" title="harbor-server"></a>harbor-server</h3><p><strong>docker配置</strong><br>同上</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/docker/daemon.json# 写入{        "insecure-registries": ["http://192.168.159.131:8077"]}$cat /etc/docker/daemon.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启docker-compose</p><pre class="line-numbers language-none"><code class="language-none">$docker-compose down$systemctl restart docker$docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="web-server"><a href="#web-server" class="headerlink" title="web-server"></a>web-server</h3><p><strong>docker配置</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/docker/daemon.json# 写入{        "insecure-registries": ["http://192.168.159.131:8077"]}$cat /etc/docker/daemon.json<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>重启docker</p><pre class="line-numbers language-none"><code class="language-none">$systemctl restart docker$sudo docker login 192.168.159.131:8077<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="2-配置gitlab相关密钥"><a href="#2-配置gitlab相关密钥" class="headerlink" title="2. 配置gitlab相关密钥"></a>2. 配置gitlab相关密钥</h2><h3 id="Windows"><a href="#Windows" class="headerlink" title="Windows"></a>Windows</h3><p><strong>Windows下生成ssh密钥，并用ssh免密访问Linux服务器</strong></p><pre class="line-numbers language-none"><code class="language-none">$ssh-keygen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8715.png"></p><p>可以在 C:\User\XXX\ 文件夹下看到一个.ssh的文件夹，里面有两个文件</p><p>id_rsa.pub，就是公钥文件，需要给Linux服务器的管理者，让他将id_rsa.pub文件中的公钥内容注册到Linux中，以便能够通过ssh来访问该Linux服务器。公钥注册到Linux服务器后，就可以在本机ssh到远端Linux服务器，并访问了。</p><p>添加到gitlab ssh密钥中:</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8716.png"></p><h3 id="Jenkins"><a href="#Jenkins" class="headerlink" title="Jenkins"></a>Jenkins</h3><p><strong>jenkins-server主机生成公钥，添加公钥至gitlab-ce</strong></p><pre class="line-numbers language-none"><code class="language-none">$ssh-keygen<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8717.png"></p><pre class="line-numbers language-none"><code class="language-none">$cat /home/l/.ssh/id_rsa.pub<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8718.png"><br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8719.png"><br><strong>配置jenkins-sever主机的私钥到凭据列表</strong></p><pre class="line-numbers language-none"><code class="language-none">$cat /home/l/.ssh/id_rsa<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8720.png"></p><p><em><strong>（注意这里要全部复制，包括首尾）</strong></em></p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8721.png"><br>修改jenkins配置文件</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/default/jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>以root用户运行(因为上述操在作root用户下生成的公钥和私钥)</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8722.png"></p><h2 id="3-jenkins插件安装"><a href="#3-jenkins插件安装" class="headerlink" title="3. jenkins插件安装"></a>3. jenkins插件安装</h2><ul><li>maven integration：用于编译JAVA项目</li><li>git parameter：用于基于git版本提交进行参数构建项目</li><li>gitlab：用于jenkins-server拉取项目</li><li>Generic Webhook Trigger：用于项目自动化构建</li><li>ssh：用于jenkins-server对web-server实施项目部署</li></ul><h2 id="4-Jenkins全局工具配置"><a href="#4-Jenkins全局工具配置" class="headerlink" title="4. Jenkins全局工具配置"></a>4. Jenkins全局工具配置</h2><h3 id="JDK配置"><a href="#JDK配置" class="headerlink" title="JDK配置"></a>JDK配置</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8723.png"></p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8724.png"></p><h3 id="Git配置"><a href="#Git配置" class="headerlink" title="Git配置"></a>Git配置</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8725.png"></p><h3 id="Maven配置"><a href="#Maven配置" class="headerlink" title="Maven配置"></a>Maven配置</h3><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8726.png"></p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8727.png"></p><h2 id="5-jenkins系统配置"><a href="#5-jenkins系统配置" class="headerlink" title="5. jenkins系统配置"></a>5. jenkins系统配置</h2><p>主要配置jenkins-server通过ssh协议连接web-server<br>添加jenkins-server访问web-server凭据<br>测试连接是否成功（web-server对应的主机需要修改ssh配置允许用root账号密码连接）：</p><pre class="line-numbers language-none"><code class="language-none">$sudo vi /etc/ssh/sshd_config<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8728.png"><br>重启</p><pre class="line-numbers language-none"><code class="language-none">$service sshd restart<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>如果不行，应该是root密码错误，root密码不是开机解锁密码，忘记root密码可以修改root密码</p><pre class="line-numbers language-none"><code class="language-none">$sudo passwd root <span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>成功连接</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8729.png"><br>各工具配置完成，接下来可以测试DevOps流水线是否搭建成功。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> harbor </tag>
            
            <tag> jenkins </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DevOps流水线搭建01</title>
      <link href="/2023/04/07/devops-liu-shui-xian-da-jian-01/"/>
      <url>/2023/04/07/devops-liu-shui-xian-da-jian-01/</url>
      
        <content type="html"><![CDATA[<h2 id="1-环境搭建"><a href="#1-环境搭建" class="headerlink" title="1. 环境搭建"></a>1. 环境搭建</h2><p>个人主机，三台ubuntu虚拟机</p><p>工具安装：</p><ul><li>Git:用于提交业务代码或克隆业务代码仓库</li><li>Gitlab:用于存储业务代码</li><li>Jenkins:用于利用插件完成业务代码编译、构建、推送至Harbor容器镜像仓库及项目部署</li><li>Tomcat:用于运行JAVA业务代码</li><li>Maven:用于编译业务代码</li><li>Harbor:用于存储业务代码构建的容器镜像存储</li><li>Docker:用于构建容器镜像，部署项目</li></ul><h2 id="2-主机"><a href="#2-主机" class="headerlink" title="2. 主机"></a>2. 主机</h2><table><thead><tr><th>主机</th><th>主机IP</th><th>业务功能</th><th>安装软件</th></tr></thead><tbody><tr><td>Windows本机</td><td>192.168.159.1</td><td>开发项目代码</td><td>git</td></tr><tr><td>harbor-server</td><td>192.168.159.131</td><td>存储容器镜像</td><td>harbor、docker</td></tr><tr><td>jenkins-server</td><td>192.168.159.129</td><td>编译代码、打包镜像、项目构建</td><td>jenkins、docker、git</td></tr><tr><td>gitlab-server</td><td>192.168.159.130</td><td>代码仓库</td><td>gitlab-ce</td></tr><tr><td>web-server</td><td>192.168.159.129</td><td>运行容器，项目上线</td><td>docker</td></tr></tbody></table><h2 id="3-各主机工具安装"><a href="#3-各主机工具安装" class="headerlink" title="3. 各主机工具安装"></a>3. 各主机工具安装</h2><h3 id="windows本机"><a href="#windows本机" class="headerlink" title="windows本机"></a>windows本机</h3><p>安装git,直接去官网下载安装<br>控制台<code>git --version</code>,打印版本信息即成功安装</p><h3 id="Jenkins-server"><a href="#Jenkins-server" class="headerlink" title="Jenkins-server"></a>Jenkins-server</h3><p><strong>安装jdk</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo apt-get update$sudo apt-get install openjdk-17-jdk$java -version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>（如果没有版本信息，需要将路径添加到环境变量中）<br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%871.png"><br><strong>安装jenkins</strong><br>安装</p><pre class="line-numbers language-none"><code class="language-none">$wget -q -O - https://pkg.jenkins.io/debian/jenkins.io.key | sudo apt-key add -$sudo sh -c 'echo deb http://pkg.jenkins.io/debian-stable binary/ &gt; /etc/apt/sources.list.d/jenkins.list'$sudo apt-get install jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>启动</p><pre class="line-numbers language-none"><code class="language-none">$systemctl start jenkins<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动成功后访问，默认端口8080</p><p>登录admin账号，密钥获取</p><pre class="line-numbers language-none"><code class="language-none">$cat /var/lib/jenkins/secrets/initialAdminPassword<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>安装推荐插件<br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%872.png"><br>如果有插件安装失败，之后点击重试安装即可</p><p>完成安装：<br><img src="/images/image_DevOps/%E5%9B%BE%E7%89%873.png"><br><strong>安装git</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo apt-get update$git --version<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><strong>安装maven</strong></p><p>在这新建maven文件夹(随便)<br>/usr/local/src/maven/</p><p>在这个文件夹中执行命令，下载解压删除安装包</p><pre class="line-numbers language-none"><code class="language-none">$wget https://dlcdn.apache.org/maven/maven-3/3.8.8/binaries/apache-maven-3.8.8-bin.tar.gz$tar -zxvf apache-maven-3.8.8-bin.tar.gz$rm apache-maven-3.8.8-bin.tar.gz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>添加环境变量（注意路径和版本）</p><pre class="line-numbers language-none"><code class="language-none">$export MAVEN_HOME=/usr/local/src/maven/apache-maven-3.8.8 $export CLASSPATH=${MAVEN_HOME}/lib:$CLASSPATH$export PATH=${MAVEN_HOME}/bin:$PATH<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>检查是否成功</p><pre class="line-numbers language-none"><code class="language-none">$mvn -v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%874.png"></p><h3 id="gitlib-server"><a href="#gitlib-server" class="headerlink" title="gitlib-server"></a>gitlib-server</h3><p><strong>安装gitlab</strong></p><pre class="line-numbers language-none"><code class="language-none">$wget --content-disposition https://packages.gitlab.com/gitlab/gitlab-ce/packages/ubuntu/focal/gitlab-ce_15.5.2-ce.0_amd64.deb/download.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压</p><pre class="line-numbers language-none"><code class="language-none">$sudo dpkg -i gitlab-ce_15.5.2-ce.0_amd64.deb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%875.png"><br>查看当前gitlab网页ip和端口号：</p><pre class="line-numbers language-none"><code class="language-none">$sudo vim /etc/gitlab/gitlab.rb<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>只要修改配置文件就要reconfigure</p><pre class="line-numbers language-none"><code class="language-none">$sudo gitlab-ctl reconfigure<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>启动</p><pre class="line-numbers language-none"><code class="language-none">$sudo gitlab-ctl start<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>查看状态</p><pre class="line-numbers language-none"><code class="language-none">$sudo gitlab-ctl status<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>root密码</p><pre class="line-numbers language-none"><code class="language-none">$cat /etc/gitlab/initial_root_password<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>修改root密码</p><pre class="line-numbers language-none"><code class="language-none">#进入gitlab控制台$sudo gitlab-rails console production#获取root用户$user = User.where(id: 1).first#设置新密码，注意新密码要大于8位$user.password = newPwd#再次确认新密码$user.password_confirmation = newPwd#保存密码$user.save<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%876.png"></p><h3 id="web-server"><a href="#web-server" class="headerlink" title="web-server"></a>web-server</h3><p>只需安装docker</p><h3 id="harbor-server"><a href="#harbor-server" class="headerlink" title="harbor-server"></a>harbor-server</h3><p><strong>安装docker-compose</strong></p><pre class="line-numbers language-none"><code class="language-none">$sudo apt-get update$sudo apt-get install docker-compose-plugin<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%877.png"><br>检查安装</p><pre class="line-numbers language-none"><code class="language-none">$docker compose version<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%878.png"><br><strong>安装harbor</strong><br>下载</p><pre class="line-numbers language-none"><code class="language-none">$wget https://github.com/goharbor/harbor/releases/download/v2.3.2/harbor-offline-installer-v2.3.2.tgz<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>解压<br><strong>$sudo tar -zxvf harbor-offline-installer-v2.3.2.tgz</strong></p><p>修改配置文件</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%879.png"></p><p>修改hostname和port</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8710.png"><br>执行修改</p><pre class="line-numbers language-none"><code class="language-none">$sudo ./install.sh<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>默认admin账号密码：Harbor12345<br>访问登录</p><p><img src="/images/image_DevOps/%E5%9B%BE%E7%89%8711.png"></p><pre class="line-numbers language-none"><code class="language-none">#停止harbor$sudo docker-compose down -v#修改yml文件后需要重新加载$./prepare#重启harbor$sudo docker-compose up -d<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>各主机工具安装完成。</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
            <tag> harbor </tag>
            
            <tag> jenkins </tag>
            
            <tag> DevOps </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis_高可用</title>
      <link href="/2023/03/28/redis-gao-ke-yong/"/>
      <url>/2023/03/28/redis-gao-ke-yong/</url>
      
        <content type="html"><![CDATA[<p>Redis 实现高可用有三种部署模式：<strong>主从模式，哨兵模式，集群模式</strong>。</p><h3 id="主从模式"><a href="#主从模式" class="headerlink" title="主从模式"></a>主从模式</h3><p>主从模式中，Redis部署了多台机器，有主节点，负责读写操作，有从节点，只负责读操作。从节点的数据来自主节点，实现原理就是<strong>主从复制机制</strong></p><p>主从复制包括全量复制，增量复制两种。一般当slave第一次启动连接master，或者认为是第一次连接，就采用<strong>全量复制</strong>，全量复制流程如下：</p><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/01.webp"></p><ul><li>  1.slave发送sync命令到master。</li><li>  2.master接收到SYNC命令后，执行bgsave命令，生成RDB全量文件。</li><li>  3.master使用缓冲区，记录RDB快照生成期间的所有写命令。</li><li>  4.master执行完bgsave后，向所有slave发送RDB快照文件。</li><li>  5.slave收到RDB快照文件后，载入、解析收到的快照。</li><li>  6.master使用缓冲区，记录RDB同步期间生成的所有写的命令。</li><li>  7.master快照发送完毕后，开始向slave发送缓冲区中的写命令;</li><li>  8.salve接受命令请求，并执行来自master缓冲区的写命令</li></ul><p>redis2.8版本之后，已经使用<strong>psync来替代sync</strong>，因为sync命令非常消耗系统资源，psync的效率更高。</p><p>slave与master全量同步之后，master上的数据，如果再次发生更新，就会触发<strong>增量复制</strong>。</p><p>当master节点发生数据增减时，就会触发<code>replicationFeedSalves()</code>函数，接下来在 Master节点上调用的每一个命令会使用<code>replicationFeedSlaves()</code>来同步到Slave节点。执行此函数之前呢，master节点会判断用户执行的命令是否有数据更新，如果有数据更新的话，并且slave节点不为空，就会执行此函数。这个函数作用就是：<strong>把用户执行的命令发送到所有的slave节点</strong>，让slave节点执行。流程如下：</p><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/02.webp"></p><h3 id="哨兵模式"><a href="#哨兵模式" class="headerlink" title="哨兵模式"></a>哨兵模式</h3><p>主从模式中，一旦主节点由于故障不能提供服务，需要人工将从节点晋升为主节点，同时还要通知应用方更新主节点地址。显然，多数业务场景都不能接受这种故障处理方式。Redis从2.8开始正式提供了Redis Sentinel（哨兵）架构来解决这个问题。</p><p><strong>哨兵模式</strong>，由一个或多个Sentinel实例组成的Sentinel系统，它可以监视所有的Redis主节点和从节点，并在被监视的主节点进入下线状态时，<strong>自动将下线主服务器属下的某个从节点升级为新的主节点</strong>。但是呢，一个哨兵进程对Redis节点进行监控，就可能会出现问题（<strong>单点问题</strong>），因此，可以使用多个哨兵来进行监控Redis节点，并且各个哨兵之间还会进行监控。</p><p>简单来说，哨兵模式就三个作用：</p><ul><li>  发送命令，等待Redis服务器（包括主服务器和从服务器）返回监控其运行状态；</li><li>  哨兵监测到主节点宕机，会自动将从节点切换成主节点，然后通过发布订阅模式通知其他的从节点，修改配置文件，让它们切换主机；</li><li>  哨兵之间还会相互监控，从而达到高可用。</li></ul><p><strong>故障切换的过程是怎样的呢</strong></p><blockquote><p>假设主服务器宕机，哨兵1先检测到这个结果，系统并不会马上进行 failover 过程，仅仅是哨兵1主观的认为主服务器不可用，这个现象成为主观下线。当后面的哨兵也检测到主服务器不可用，并且数量达到一定值时，那么哨兵之间就会进行一次投票，投票的结果由一个哨兵发起，进行 failover 操作。切换成功后，就会通过发布订阅模式，让各个哨兵把自己监控的从服务器实现切换主机，这个过程称为客观下线。这样对于客户端而言，一切都是透明的。</p></blockquote><p>哨兵的工作模式如下：</p><ol><li> 每个Sentinel以每秒钟一次的频率向它所知的Master，Slave以及其他Sentinel实例发送一个 PING命令。</li><li> 如果一个实例（instance）距离最后一次有效回复 PING 命令的时间超过 down-after-milliseconds 选项所指定的值， 则这个实例会被 Sentinel标记为主观下线。</li><li> 如果一个Master被标记为主观下线，则正在监视这个Master的所有 Sentinel 要以每秒一次的频率确认Master的确进入了主观下线状态。</li><li> 当有足够数量的 Sentinel（大于等于配置文件指定的值）在指定的时间范围内确认Master的确进入了主观下线状态， 则Master会被标记为客观下线。</li><li> 在一般情况下， 每个 Sentinel 会以每10秒一次的频率向它已知的所有Master，Slave发送 INFO 命令。</li><li> 当Master被 Sentinel 标记为客观下线时，Sentinel 向下线的 Master 的所有 Slave 发送 INFO 命令的频率会从 10 秒一次改为每秒一次</li><li> 若没有足够数量的 Sentinel同意Master已经下线， Master的客观下线状态就会被移除；若Master 重新向 Sentinel 的 PING 命令返回有效回复， Master 的主观下线状态就会被移除。</li></ol><h3 id="Cluster集群模式"><a href="#Cluster集群模式" class="headerlink" title="Cluster集群模式"></a>Cluster集群模式</h3><p>哨兵模式基于主从模式，实现读写分离，它还可以自动切换，系统可用性更高。但是它每个节点存储的数据是一样的，浪费内存，并且不好在线扩容。 因此，Cluster集群应运而生，它在Redis3.0加入的，实现了Redis的<strong>分布式存储</strong>。对数据进行分片，也就是说<strong>每台Redis节点上存储不同的内容</strong>，来解决在线扩容的问题。并且，它也提供复制和故障转移的功能。</p><h4 id="Cluster集群节点的通讯"><a href="#Cluster集群节点的通讯" class="headerlink" title="Cluster集群节点的通讯"></a>Cluster集群节点的通讯</h4><p>一个Redis集群由多个节点组成，<strong>各个节点之间是怎么通信的呢</strong>？通过<strong>Gossip协议</strong>！</p><p>Redis Cluster集群通过Gossip协议进行通信，节点之前不断交换信息，交换的信息内容包括节点出现故障、新节点加入、主从节点变更信息、slot信息等等。常用的Gossip消息分为4种，分别是：ping、pong、meet、fail。</p><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/03.webp"></p><ul><li>  meet消息：通知新节点加入。消息发送者通知接收者加入到当前集群，meet消息通信正常完成后，接收节点会加入到集群中并进行周期性的ping、pong消息交换。</li><li>  ping消息：集群内交换最频繁的消息，集群内每个节点每秒向多个其他节点发送ping消息，用于检测节点是否在线和交换彼此状态信息。</li><li>  pong消息：当接收到ping、meet消息时，作为响应消息回复给发送方确认消息正常通信。pong消息内部封装了自身状态数据。节点也可以向集群内广播自身的pong消息来通知整个集群对自身状态进行更新。</li><li>  fail消息：当节点判定集群内另一个节点下线时，会向集群内广播一个fail消息，其他节点接收到fail消息之后把对应节点更新为下线状态。</li></ul><p>特别的，每个节点是通过<strong>集群总线(cluster bus)</strong> 与其他的节点进行通信的。通讯时，使用特殊的端口号，即对外服务端口号加10000。例如如果某个node的端口号是6379，那么它与其它nodes通信的端口号是 16379。nodes 之间的通信采用特殊的二进制协议。</p><h4 id="Hash-Slot插槽算法"><a href="#Hash-Slot插槽算法" class="headerlink" title="Hash Slot插槽算法"></a>Hash Slot插槽算法</h4><p>既然是分布式存储，Cluster集群使用的分布式算法是<strong>一致性Hash</strong>嘛？并不是，而是<strong>Hash Slot插槽算法</strong>。</p><p><strong>插槽算法</strong>把整个数据库被分为16384个slot（槽），每个进入Redis的键值对，根据key进行散列，分配到这16384插槽中的一个。使用的哈希映射也比较简单，用CRC16算法计算出一个16 位的值，再对16384取模。数据库中的每个键都属于这16384个槽的其中一个，集群中的每个节点都可以处理这16384个槽。</p><p>集群中的每个节点负责一部分的hash槽，比如当前集群有A、B、C个节点，每个节点上的哈希槽数 =16384/3，那么就有：</p><ul><li>  节点A负责0~5460号哈希槽</li><li>  节点B负责5461~10922号哈希槽</li><li>  节点C负责10923~16383号哈希槽</li></ul><h4 id="Redis-Cluster集群"><a href="#Redis-Cluster集群" class="headerlink" title="Redis Cluster集群"></a>Redis Cluster集群</h4><p>Redis Cluster集群中，需要确保16384个槽对应的node都正常工作，如果某个node出现故障，它负责的slot也会失效，整个集群将不能工作。</p><p>因此为了保证高可用，Cluster集群引入了主从复制，一个主节点对应一个或者多个从节点。当其它主节点 ping 一个主节点 A 时，如果半数以上的主节点与 A 通信超时，那么认为主节点 A 宕机了。如果主节点宕机时，就会启用从节点。</p><p>虽然数据是分开存储在不同节点上的，但是对客户端来说，整个集群Cluster，被看做一个整体。客户端端连接任意一个node，看起来跟操作单实例的Redis一样。当客户端操作的key没有被分配到正确的node节点时，Redis会返回转向指令，最后指向正确的node，这就有点像浏览器页面的302 重定向跳转。</p><h4 id="故障转移"><a href="#故障转移" class="headerlink" title="故障转移"></a>故障转移</h4><p>Redis集群实现了高可用，当集群内节点出现故障时，通过<strong>故障转移</strong>，以保证集群正常对外提供服务。</p><p>redis集群通过ping/pong消息，实现故障发现。这个环境包括<strong>主观下线和客观下线</strong>。</p><p><strong>主观下线：</strong>&nbsp;某个节点认为另一个节点不可用，即下线状态，这个状态并不是最终的故障判定，只能代表一个节点的意见，可能存在误判情况。</p><p><strong>客观下线：</strong> 指标记一个节点真正的下线，集群内多个节点都认为该节点不可用，从而达成共识的结果。如果是持有槽的主节点故障，需要为该节点进行故障转移。</p><ul><li>  假如节点A标记节点B为主观下线，一段时间后，节点A通过消息把节点B的状态发到其它节点，当节点C接受到消息并解析出消息体时，如果发现节点B的pfail状态时，会触发客观下线流程；</li><li>  当下线为主节点时，此时Redis Cluster集群为统计持有槽的主节点投票，看投票数是否达到一半，当下线报告统计数大于一半时，被标记为<strong>客观下线</strong>状态。</li></ul><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/04.webp"></p><p><strong>故障恢复</strong>：故障发现后，如果下线节点的是主节点，则需要在它的从节点中选一个替换它，以保证集群的高可用。流程如下：</p><p><img src="/images/image_redis%E9%AB%98%E5%8F%AF%E7%94%A8/05.webp"></p><ul><li>  资格检查：检查从节点是否具备替换故障主节点的条件。</li><li>  准备选举时间：资格检查通过后，更新触发故障选举时间。</li><li>  发起选举：到了故障选举时间，进行选举。</li><li>  选举投票：只有持有槽的<strong>主节点</strong>才有票，从节点收集到足够的选票（大于一半），触发<strong>替换主节点操作</strong></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> NoSQL </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>场景</title>
      <link href="/2023/03/26/chang-jing/"/>
      <url>/2023/03/26/chang-jing/</url>
      
        <content type="html"><![CDATA[<h2 id="Top-K问题"><a href="#Top-K问题" class="headerlink" title="Top K问题"></a>Top K问题</h2><h3 id="10亿个数据中找出最大的10000个"><a href="#10亿个数据中找出最大的10000个" class="headerlink" title="10亿个数据中找出最大的10000个"></a>10亿个数据中找出最大的10000个</h3><p><strong>最小堆法</strong></p><ol><li>先拿10000个数建堆</li><li>然后逐个添加剩余元素</li><li>如果大于堆顶的数（10000中最小的），将这个数替换堆顶，并调整结构使之仍然是一个最小堆</li><li>遍历完后，堆中的10000个数就是所需的最大的10000个。</li><li>复杂度分析：时间复杂度是O（mlogm），算法的时间复杂度为O（nmlogm）（n为10亿，m为10000）。</li></ol><p><strong>如果内存受限</strong>：可以直接在内存总使用Hash方法将数据划分成n个partition，每个partition交给一个线程处理，线程的处理逻辑可以采用最小堆，最后一个线程将结果归并。</p><h3 id="有几台机器存储着几亿淘宝搜索日志，你只有一台-2g-的电脑，怎么选出搜索热度最高的十个？"><a href="#有几台机器存储着几亿淘宝搜索日志，你只有一台-2g-的电脑，怎么选出搜索热度最高的十个？" class="headerlink" title="有几台机器存储着几亿淘宝搜索日志，你只有一台 2g 的电脑，怎么选出搜索热度最高的十个？"></a>有几台机器存储着几亿淘宝搜索日志，你只有一台 2g 的电脑，怎么选出搜索热度最高的十个？</h3><p>【分治+trie树/hash+小顶堆】</p><p>先将数据集按照hash方法分解成n个小数据集，然后使用trie树或者hash统计每个小数据集中的query词频，之后用小顶堆求出每个数据集中出频率最高的前K个数，最后在所有top K中求出最终的top K。</p><h2 id="海量数据排序、压缩问题"><a href="#海量数据排序、压缩问题" class="headerlink" title="海量数据排序、压缩问题"></a>海量数据排序、压缩问题</h2><h3 id="重要方法——位图法-Bitmap"><a href="#重要方法——位图法-Bitmap" class="headerlink" title="重要方法——位图法 Bitmap"></a>重要方法——位图法 Bitmap</h3><p>位图的基本概念：用一个位（bit）来标记某个数据的存放状态。例如，有{2, 4, 5, 6, 67, 5}这么几个整数，我维护一个 00…0000（共67位）的0/1字符串，1表示该索引（=数据值）处存在数，0则表示不存在。</p><p>应用：位图法可以用于海量数据排序，海量数据去重，海量数据压缩</p><p>优点：针对于稠密的数据集可以很好体现出位图法的优势，内存消耗少，速度较快</p><p>缺点：不适用于稀疏数据集，比如我们有一个长度为10的序列，最大值为20亿，则构造位串的内存消耗将相当大250M，而实际却只需要40个字节，此外位图法还存在可读性差等缺点。</p><h3 id="非重复排序"><a href="#非重复排序" class="headerlink" title="非重复排序"></a>非重复排序</h3><p>假设我们有一个不重复的整型序列{n1， n2， … ,nn}，假设最大值为nmax，则我们可以维护一个长度为nmax的位串。</p><p>主要过程：</p><ul><li>第一遍 遍历整个序列，将出现的数字在位串（java中可以用数组实现）中对应的位置置为1；</li><li>第二遍 遍历位图，依次输出值为1的位对应的数字，这些1所在的位串中的位置的索引代表序列数据，1出现的先后位置则代表序列的大小关系。<h3 id="重复排序"><a href="#重复排序" class="headerlink" title="重复排序"></a>重复排序</h3></li></ul><p>同上，只是子串中不只存在<code>0/1</code>，实际数量为多少，则值为多少.输出时，值为多少则输出多少遍</p><h3 id="数据压缩"><a href="#数据压缩" class="headerlink" title="数据压缩"></a>数据压缩</h3><p><strong>前提</strong>：数据中存在大量的冗余值<br>基本思路就是使用某个子串存储原数据中的海量值</p><h3 id="如何用redis存储统计1亿用户一年的登陆情况，并快速检索任意时间窗口内的活跃用户数量"><a href="#如何用redis存储统计1亿用户一年的登陆情况，并快速检索任意时间窗口内的活跃用户数量" class="headerlink" title="如何用redis存储统计1亿用户一年的登陆情况，并快速检索任意时间窗口内的活跃用户数量"></a>如何用redis存储统计1亿用户一年的登陆情况，并快速检索任意时间窗口内的活跃用户数量</h3><p>redis单独对bitmap提供了一套命令。可以对任意一位进行设置和读取。所以可以在位图中使用1表示活跃。</p><p>bitmap的核心命令：</p><p>SETBIT：设置某位为1<br>语法：SETBIT key offset value</p><p>GETBIT：获取某位的值<br>语法：GETBIT key offset</p><p>bitmap的其他命令还有bitcount，bitpos，bitop等命令。都是对位的操作。</p><p>获取某一天id为88000的用户是否活跃：getbit 2020-01-01 88000 (时间复杂度为O(1))<br>统计某一天的所有的活跃用户数：bitcount 2019-01-01 (时间复杂度为O(N))<br>-统计某一段时间内的活跃用户数，需要用到bitop命令。这个命令提供四种位运算，AND(与)，(OR)或，XOR(亦或)，NOT(非)。</p><p>以下例子求出了2019-01-01到2019-01-05这段时间内的活跃用户数。<br>bitop or result 2019-01-01 2019-01-02 2019-01-03 2019-01-04 2019-01-05 (时间复杂度为O(N))</p><h2 id="资源-vs-请求问题"><a href="#资源-vs-请求问题" class="headerlink" title="资源 vs 请求问题"></a>资源 vs 请求问题</h2><h3 id="如果一个外卖配送单子要发布，现在有200个骑手都想要接这一单，如何保证只有一个骑手接到单子？"><a href="#如果一个外卖配送单子要发布，现在有200个骑手都想要接这一单，如何保证只有一个骑手接到单子？" class="headerlink" title="如果一个外卖配送单子要发布，现在有200个骑手都想要接这一单，如何保证只有一个骑手接到单子？"></a>如果一个外卖配送单子要发布，现在有200个骑手都想要接这一单，如何保证只有一个骑手接到单子？</h3><p>单机情况</p><ul><li>采用volatile关键字修饰该订单采用CAS操作对其进行乐观锁操作。volatile保证可见性，CAS保证原子性</li></ul><p>集群：</p><ul><li>采用redis分布式锁加锁。</li><li>消息队列 实现幂等接口</li></ul><h3 id="多个微信用户抢红包"><a href="#多个微信用户抢红包" class="headerlink" title="多个微信用户抢红包"></a>多个微信用户抢红包</h3><p>类似于秒杀系统</p><ol><li>数据库加乐观锁、悲观锁</li><li>在逻辑处理界面加分布式锁</li><li>消息队列</li></ol><h3 id="1000个任务分给10个人做"><a href="#1000个任务分给10个人做" class="headerlink" title="1000个任务分给10个人做"></a>1000个任务分给10个人做</h3><ol><li>全局队列，每一个人都从一个队列中取  </li><li>分成10个队列对应每一个人</li></ol><h2 id="设计类问题"><a href="#设计类问题" class="headerlink" title="设计类问题"></a>设计类问题</h2><h3 id="你如何设计一个消息队列"><a href="#你如何设计一个消息队列" class="headerlink" title="你如何设计一个消息队列?"></a>你如何设计一个消息队列?</h3><p>首先这个 mq 得支持可伸缩性吧<br>就是需要的时候快速扩容，就可以增加吞吐量和容量，那怎么搞？设计个分布式的系统呗，参照一下 kafka 的设计理念，broker -&gt; topic -&gt; partition，每个 partition 放一个机器，就存一部分数据。如果现在资源不够了，简单啊，给 topic 增加 partition，然后做数据迁移，增加机器，不就可以存放更多数据，提供更高的吞吐量了？</p><p>其次你得考虑一下这个 mq 的数据要不要落地磁盘吧？<br>那肯定要了，落磁盘才能保证别进程挂了数据就丢了。那落磁盘的时候怎么落啊？顺序写，这样就没有磁盘随机读写的寻址开销，磁盘顺序读写的性能是很高的，这就是 kafka 的思路。</p><p>其次你考虑一下你的 mq 的可用性啊？<br>这个事儿，具体参考之前可用性那个环节讲解的 kafka 的高可用保障机制。多副本 -&gt; leader &amp; follower -&gt; broker 挂了重新选举 leader 即可对外服务。</p><p>能不能支持数据 0 丢失啊？<br>可以的，参考我们之前说的那个 kafka 数据零丢失方案。</p><h3 id="你如何设计一个缓存系统"><a href="#你如何设计一个缓存系统" class="headerlink" title="你如何设计一个缓存系统?"></a>你如何设计一个缓存系统?</h3><p>1.数据结构</p><p>首要考虑的就是数据该如何存储，用什么数据结构存储，最简单的就直接用Map来存储数据；或者复杂的如redis一样提供了多种数据类型哈希，列表，集合，有序集合等</p><p>2.对象上限</p><p>因为是本地缓存，内存有上限，所以一般都会指定缓存对象的数量比如1024，当达到某个上限后需要有某种策略去删除多余的数据；</p><p>3.清除策略</p><p>上面说到当达到对象上限之后需要有清除策略，常见的比如有LRU(最近最少使用)、FIFO(先进先出)、LFU(最近最不常用)；</p><p>4.过期时间</p><p>除了使用清除策略，一般本地缓存也会有一个过期时间设置，比如redis可以给每个key设置一个过期时间，这样当达到过期时间之后直接删除，采用清除策略+过期时间双重保证；</p><p>5.线程安全</p><p>像redis是直接使用单线程处理，所以就不存在线程安全问题；而我们现在提供的本地缓存往往是可以多个线程同时访问的，所以线程安全是不容忽视的问题；并且线程安全问题是不应该抛给使用者去保证；</p><p>6.简明的接口</p><p>提供常用的get，put，remove，clear，getSize方法即可；</p><p>7.是否持久化</p><p>这个不是必须的，是否需要将缓存数据持久化看需求</p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><h3 id="怎么判别淘宝刷单？怎么检验手段效果？"><a href="#怎么判别淘宝刷单？怎么检验手段效果？" class="headerlink" title="怎么判别淘宝刷单？怎么检验手段效果？"></a>怎么判别淘宝刷单？怎么检验手段效果？</h3><p><strong>商家角度：</strong></p><p>营业额远高于历史平均数据<br>营业额远高于行业平均数据<br>下单的用户很多均为存在异常行为被监控的账户</p><p><strong>顾客角度</strong>（账号维度）：判断是否存在异常行为</p><p>单次交易行为：是否精准搜索、货比三家、页面停留时间等<br>近期购物成功率：远高于历史时期平均购物成功率<br>是否可能为垫付：短时间支付宝账户内收到与下单金额相同的金额<br>下单的店铺很多均为存在异常行为被监控的账户</p><p><strong>商家与顾客：</strong></p><p>存在相近或者共同的网络环境：如ip、wifi等</p><h3 id="如何把一个文件快速下发到-100w-个服务器"><a href="#如何把一个文件快速下发到-100w-个服务器" class="headerlink" title="如何把一个文件快速下发到 100w 个服务器"></a>如何把一个文件快速下发到 100w 个服务器</h3><p>采用p2p网络形式，比如树状形式，网状形式，单个节点既可以从其他节点接收服务又可以向其他节点提供服务。<strong>广度优先遍历</strong></p><h3 id="如何实现两个线程交替打印"><a href="#如何实现两个线程交替打印" class="headerlink" title="如何实现两个线程交替打印"></a>如何实现两个线程交替打印</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">static</span> <span class="token keyword">volatile</span> <span class="token class-name">Integer</span> count <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">// volatile + synchronized</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">solution1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token punctuation">}</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"A"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token punctuation">}</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"B"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">-&gt;</span><span class="token punctuation">{</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">;</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">while</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token punctuation">}</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>count<span class="token punctuation">)</span><span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">%</span> <span class="token number">3</span> <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">print</span><span class="token punctuation">(</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    count<span class="token operator">++</span><span class="token punctuation">;</span>                    i<span class="token operator">++</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token string">"C"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 后端场景 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Reids_分布式锁</title>
      <link href="/2023/03/26/reids-fen-bu-shi-suo/"/>
      <url>/2023/03/26/reids-fen-bu-shi-suo/</url>
      
        <content type="html"><![CDATA[<p>对于单机多线程来说，在 Java 中，我们通常使用 <code>ReetrantLock</code> 类、<code>synchronized</code> 关键字这类 JDK 自带的 <strong>本地锁</strong> 来控制一个 JVM 进程内的多个线程对本地共享资源的访问。</p><p>分布式系统下，不同的服务/客户端通常运行在独立的 JVM 进程上。如果多个 JVM 进程共享同一份资源的话，使用本地锁就没办法实现资源的互斥访问了。于是，<strong>分布式锁</strong>&nbsp;就诞生了。</p><h3 id="基于-Redis-实现分布式锁"><a href="#基于-Redis-实现分布式锁" class="headerlink" title="基于 Redis 实现分布式锁"></a>基于 Redis 实现分布式锁</h3><h4 id="基于Redis实现一个最简易的分布式锁"><a href="#基于Redis实现一个最简易的分布式锁" class="headerlink" title="基于Redis实现一个最简易的分布式锁"></a>基于Redis实现一个最简易的分布式锁</h4><p>不论是本地锁还是分布式锁，核心都在于“互斥”。</p><p>在 Redis 中， <code>SETNX</code> 命令是可以帮助我们实现互斥。<code>SETNX</code> 即 <strong>SET</strong> if <strong>N</strong>ot e<strong>X</strong>ists (对应 Java 中的 <code>setIfAbsent</code> 方法)，如果 key 不存在的话，才会设置 key 的值。如果 key 已经存在， <code>SETNX</code> 啥也不做。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> SETNX lockKey uniqueValue<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span class="token operator">&gt;</span> SETNX lockKey uniqueValue<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>释放锁的话，直接通过 <code>DEL</code> 命令删除对应的 key 即可。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token operator">&gt;</span> DEL lockKey<span class="token punctuation">(</span>integer<span class="token punctuation">)</span> <span class="token number">1</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>为了防止误删到其他的锁，这里我们建议使用 Lua 脚本通过 key 对应的 value（唯一值）来判断。</p><p>选用 Lua 脚本是为了保证解锁操作的原子性。因为 Redis 在执行 Lua 脚本时，可以以原子性的方式执行，从而保证了锁释放操作的原子性。</p><pre class="line-numbers language-lua" data-language="lua"><code class="language-lua"><span class="token operator">//</span> 释放锁时，先比较锁对应的 value 值是否相等，避免锁的误释放<span class="token keyword">if</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"get"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">==</span> ARGV<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token keyword">then</span>    <span class="token keyword">return</span> redis<span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token string">"del"</span><span class="token punctuation">,</span>KEYS<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token keyword">else</span>    <span class="token keyword">return</span> <span class="token number">0</span><span class="token keyword">end</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这是一种最简易的 Redis 分布式锁实现，实现方式比较简单，性能也很高效。不过，这种方式实现分布式锁存在一些问题。就比如应用程序遇到一些问题比如释放锁的逻辑突然挂掉，可能会导致锁无法被释放，进而造成共享资源无法再被其他线程/进程访问。</p><h4 id="给锁设置一个过期时间"><a href="#给锁设置一个过期时间" class="headerlink" title="给锁设置一个过期时间"></a>给锁设置一个过期时间</h4><p>为了避免锁无法被释放，我们可以想到的一个解决办法就是：<strong>给这个 key（也就是锁） 设置一个过期时间</strong> 。</p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash"><span class="token number">127.0</span>.0.1:637<span class="token operator"><span class="token file-descriptor important">9</span>&gt;</span> SET lockKey uniqueValue EX <span class="token number">3</span> NXOK<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ul><li>  <strong>lockKey</strong>：加锁的锁名；</li><li>  <strong>uniqueValue</strong>：能够唯一标示锁的随机字符串；</li><li>  <strong>NX</strong>：只有当 lockKey 对应的 key 值不存在的时候才能 SET 成功；</li><li>  <strong>EX</strong>：过期时间设置（秒为单位）EX 3 标示这个锁有一个 3 秒的自动过期时间。与 EX 对应的是 PX（毫秒为单位），这两个都是过期时间设置。</li></ul><p><strong>一定要保证设置指定 key 的值和过期时间是一个原子操作！</strong> 不然的话，依然可能会出现锁无法被释放的问题。</p><p>这样确实可以解决问题，不过，这种解决办法同样存在漏洞：<strong>如果操作共享资源的时间大于过期时间，就会出现锁提前过期的问题，进而导致分布式锁直接失效。如果锁的超时时间设置过长，又会影响到性能。</strong></p><h4 id="实现锁的续期"><a href="#实现锁的续期" class="headerlink" title="实现锁的续期"></a>实现锁的续期</h4><p>Redisson 是一个开源的 Java 语言 Redis 客户端，提供了很多开箱即用的功能，不仅仅包括多种分布式锁的实现。并且，Redisson 还支持 Redis 单机、Redis Sentinel、Redis Cluster 等多种部署架构。</p><p>Redisson 中的分布式锁自带自动续期机制，使用起来非常简单，原理也比较简单，其提供了一个专门用来监控和续期锁的 <strong>Watch Dog（ 看门狗）</strong>，如果操作共享资源的线程还未执行完成的话，Watch Dog 会不断地延长锁的过期时间，进而保证锁不会因为超时而被释放。</p><p><img src="/images/image_redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/01.png"></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//默认 30秒，支持修改</span><span class="token keyword">private</span> <span class="token keyword">long</span> lockWatchdogTimeout <span class="token operator">=</span> <span class="token number">30</span> <span class="token operator">*</span> <span class="token number">1000</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Config</span> <span class="token function">setLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token keyword">long</span> lockWatchdogTimeout<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">this</span><span class="token punctuation">.</span>lockWatchdogTimeout <span class="token operator">=</span> lockWatchdogTimeout<span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">public</span> <span class="token keyword">long</span> <span class="token function">getLockWatchdogTimeout</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">return</span> lockWatchdogTimeout<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>renewExpiration()</code> 方法包含了看门狗的主要逻辑：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment">//......</span>        <span class="token class-name">Timeout</span> task <span class="token operator">=</span> commandExecutor<span class="token punctuation">.</span><span class="token function">getConnectionManager</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">newTimeout</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">TimerTask</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token class-name">Timeout</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>                <span class="token comment">//......</span>                <span class="token comment">// 异步续期，基于 Lua 脚本</span>                <span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> <span class="token function">renewExpirationAsync</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">;</span>                future<span class="token punctuation">.</span><span class="token function">whenComplete</span><span class="token punctuation">(</span><span class="token punctuation">(</span>res<span class="token punctuation">,</span> e<span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>e <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">// 无法续期</span>                        log<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"Can't update lock "</span> <span class="token operator">+</span> <span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">" expiration"</span><span class="token punctuation">,</span> e<span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token constant">EXPIRATION_RENEWAL_MAP</span><span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span><span class="token function">getEntryName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                        <span class="token keyword">return</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                    <span class="token keyword">if</span> <span class="token punctuation">(</span>res<span class="token punctuation">)</span> <span class="token punctuation">{</span>                        <span class="token comment">// 递归调用实现续期</span>                        <span class="token function">renewExpiration</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>                        <span class="token comment">// 取消续期</span>                        <span class="token function">cancelExpirationRenewal</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token punctuation">}</span>                <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>         <span class="token comment">// 延迟 internalLockLeaseTime/3（默认 10s，也就是 30/3） 再调用</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> internalLockLeaseTime <span class="token operator">/</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">MILLISECONDS</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        ee<span class="token punctuation">.</span><span class="token function">setTimeout</span><span class="token punctuation">(</span>task<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>默认情况下，每过 10 秒，看门狗就会执行续期操作，将锁的超时时间设置为 30 秒。看门狗续期前也会先判断是否需要执行续期操作，需要才会执行续期，否则取消续期操作。</p><p>Watch Dog 通过调用 <code>renewExpirationAsync()</code> 方法实现锁的异步续期：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">protected</span> <span class="token class-name">CompletionStage</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Boolean</span><span class="token punctuation">&gt;</span></span> <span class="token function">renewExpirationAsync</span><span class="token punctuation">(</span><span class="token keyword">long</span> threadId<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token function">evalWriteAsync</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token class-name">LongCodec</span><span class="token punctuation">.</span><span class="token constant">INSTANCE</span><span class="token punctuation">,</span> <span class="token class-name">RedisCommands</span><span class="token punctuation">.</span><span class="token constant">EVAL_BOOLEAN</span><span class="token punctuation">,</span>            <span class="token comment">// 判断是否为持锁线程，如果是就执行续期操作，就锁的过期时间设置为 30s（默认）</span>            <span class="token string">"if (redis.call('hexists', KEYS[1], ARGV[2]) == 1) then "</span> <span class="token operator">+</span>                    <span class="token string">"redis.call('pexpire', KEYS[1], ARGV[1]); "</span> <span class="token operator">+</span>                    <span class="token string">"return 1; "</span> <span class="token operator">+</span>                    <span class="token string">"end; "</span> <span class="token operator">+</span>                    <span class="token string">"return 0;"</span><span class="token punctuation">,</span>            <span class="token class-name">Collections</span><span class="token punctuation">.</span><span class="token function">singletonList</span><span class="token punctuation">(</span><span class="token function">getRawName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>            internalLockLeaseTime<span class="token punctuation">,</span> <span class="token function">getLockName</span><span class="token punctuation">(</span>threadId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出， <code>renewExpirationAsync</code> 方法其实是调用 Lua 脚本实现的续期，这样做主要是为了保证续期操作的原子性。</p><p>我这里以 Redisson 的分布式可重入锁 <code>RLock</code> 为例来说明如何使用 Redisson 实现分布式锁：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 1.获取指定的分布式锁对象</span><span class="token class-name">RLock</span> lock <span class="token operator">=</span> redisson<span class="token punctuation">.</span><span class="token function">getLock</span><span class="token punctuation">(</span><span class="token string">"lock"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2.拿锁且不设置锁超时时间，具备 Watch Dog 自动续期机制</span>lock<span class="token punctuation">.</span><span class="token function">lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 3.执行业务</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token comment">// 4.释放锁</span>lock<span class="token punctuation">.</span><span class="token function">unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>只有未指定锁超时时间，才会使用到 Watch Dog 自动续期机制。</p><pre class="line-numbers language-none"><code class="language-none">// 手动给锁设置过期时间，不具备 Watch Dog 自动续期机制lock.lock(10, TimeUnit.SECONDS);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>如果使用 Redis 来实现分布式锁的话，还是比较推荐直接基于 Redisson 来做的。</p><h4 id="实现可重入锁"><a href="#实现可重入锁" class="headerlink" title="实现可重入锁"></a>实现可重入锁</h4><p>所谓可重入锁指的是在一个线程中可以多次获取同一把锁，比如一个线程在执行一个带锁的方法，该方法中又调用了另一个需要相同锁的方法，则该线程可以直接执行调用的方法即可重入 ，而无需重新获得锁。像 Java 中的 <code>synchronized</code> 和 <code>ReentrantLock</code> 都属于可重入锁。</p><p><strong>不可重入的分布式锁基本可以满足绝大部分业务场景了，一些特殊的场景可能会需要使用可重入的分布式锁。</strong></p><p>可重入分布式锁的实现核心思路是线程在获取锁的时候判断是否为自己的锁，如果是的话，就不用再重新获取了。为此，我们可以为每个锁关联一个可重入计数器和一个占有它的线程。当可重入计数器大于 0 时，则锁被占有，需要判断占有该锁的线程和请求获取锁的线程是否为同一个。</p><p>实际项目中，我们不需要自己手动实现，推荐使用我们上面提到的 <strong>Redisson</strong> ，其内置了多种类型的锁比如可重入锁（Reentrant Lock）、自旋锁（Spin Lock）、公平锁（Fair Lock）、多重锁（MultiLock）、 红锁（RedLock）、 读写锁（ReadWriteLock）。</p><h4 id="分布式锁的可靠性"><a href="#分布式锁的可靠性" class="headerlink" title="分布式锁的可靠性"></a>分布式锁的可靠性</h4><p>为了避免单点故障，生产环境下的 Redis 服务通常是集群化部署的。</p><p>Redis 集群下，上面介绍到的分布式锁的实现会存在一些问题。由于 Redis 集群数据同步到各个节点时是异步的，如果在 Redis 主节点获取到锁后，在没有同步到其他节点时，Redis 主节点宕机了，此时新的 Redis 主节点依然可以获取锁，所以多个应用服务就可以同时获取到锁。</p><p><img src="/images/image_redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/02.png"></p><p>Redlock 算法的思想是让客户端向 Redis 集群中的多个独立的 Redis 实例依次请求申请加锁，如果客户端能够和半数以上的实例成功地完成加锁操作，那么我们就认为，客户端成功地获得分布式锁，否则加锁失败。</p><p>即使部分 Redis 节点出现问题，只要保证 Redis 集群中有半数以上的 Redis 节点可用，分布式锁服务就是正常的。</p><p>Redlock 是直接操作 Redis 节点的，并不是通过 Redis 集群操作的，这样才可以避免 Redis 集群主从切换导致的锁丢失问题。</p><p>如果不是非要实现绝对可靠的分布式锁的话，其实单机版 Redis 就完全够了，实现简单，性能也非常高。如果你必须要实现一个绝对可靠的分布式锁的话，可以基于 ZooKeeper 来做，只是性能会差一些。</p><h3 id="基于-ZooKeeper-实现分布式锁"><a href="#基于-ZooKeeper-实现分布式锁" class="headerlink" title="基于 ZooKeeper 实现分布式锁"></a>基于 ZooKeeper 实现分布式锁</h3><p>Redis 实现分布式锁性能较高，ZooKeeper 实现分布式锁可靠性更高。实际项目中，我们应该根据业务的具体需求来选择</p><h4 id="基于-ZooKeeper-实现分布式锁-1"><a href="#基于-ZooKeeper-实现分布式锁-1" class="headerlink" title="基于 ZooKeeper 实现分布式锁"></a>基于 ZooKeeper 实现分布式锁</h4><p>ZooKeeper 分布式锁是基于 <strong>临时顺序节点</strong> 和 <strong>Watcher（事件监听器）</strong> 实现的。</p><p>获取锁：</p><ol><li> 首先我们要有一个持久节点<code>/locks</code>，客户端获取锁就是在<code>locks</code>下创建临时顺序节点。</li><li> 假设客户端 1 创建了<code>/locks/lock1</code>节点，创建成功之后，会判断 <code>lock1</code>是否是 <code>/locks</code> 下最小的子节点。</li><li> 如果 <code>lock1</code>是最小的子节点，则获取锁成功。否则，获取锁失败。</li><li> 如果获取锁失败，则说明有其他的客户端已经成功获取锁。客户端 1 并不会不停地循环去尝试加锁，而是在前一个节点比如<code>/locks/lock0</code>上注册一个事件监听器。这个监听器的作用是当前一个节点释放锁之后通知客户端 1（避免无效自旋），这样客户端 1 就加锁成功了。</li></ol><p>释放锁：</p><ol><li> 成功获取锁的客户端在执行完业务流程之后，会将对应的子节点删除。</li><li> 成功获取锁的客户端在出现故障之后，对应的子节点由于是临时顺序节点，也会被自动删除，避免了锁无法被释放。</li><li> 我们前面说的事件监听器其实监听的就是这个子节点删除事件，子节点删除就意味着锁被释放</li></ol><p>实际项目中，推荐使用 Curator 来实现 ZooKeeper 分布式锁。Curator 是 Netflix 公司开源的一套 ZooKeeper Java 客户端框架，相比于 ZooKeeper 自带的客户端 zookeeper 来说，Curator 的封装更加完善，各种 API 都可以比较方便地使用。</p><p><code>Curator</code>主要实现了下面四种锁：</p><ul><li>  <code>InterProcessMutex</code>：分布式可重入排它锁</li><li>  <code>InterProcessSemaphoreMutex</code>：分布式不可重入排它锁</li><li>  <code>InterProcessReadWriteLock</code>：分布式读写锁</li><li>  <code>InterProcessMultiLock</code>：将多个锁作为单个实体管理的容器，获取锁的时候获取所有锁，释放锁也会释放所有锁资源（忽略释放失败的锁）。</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">CuratorFramework</span> client <span class="token operator">=</span> <span class="token class-name">ZKUtils</span><span class="token punctuation">.</span><span class="token function">getClient</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>client<span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 分布式可重入排它锁</span><span class="token class-name">InterProcessLock</span> lock1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessMutex</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> lockPath1<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 分布式不可重入排它锁</span><span class="token class-name">InterProcessLock</span> lock2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessSemaphoreMutex</span><span class="token punctuation">(</span>client<span class="token punctuation">,</span> lockPath2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 将多个锁作为一个整体</span><span class="token class-name">InterProcessMultiLock</span> lock <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">InterProcessMultiLock</span><span class="token punctuation">(</span><span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">asList</span><span class="token punctuation">(</span>lock1<span class="token punctuation">,</span> lock2<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>lock<span class="token punctuation">.</span><span class="token function">acquire</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span><span class="token punctuation">.</span><span class="token constant">SECONDS</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalStateException</span><span class="token punctuation">(</span><span class="token string">"不能获取多锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"已获取多锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第一个锁: "</span> <span class="token operator">+</span> lock1<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第二个锁: "</span> <span class="token operator">+</span> lock2<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span>    <span class="token comment">// 资源操作</span>    resource<span class="token punctuation">.</span><span class="token function">use</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">finally</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"释放多个锁"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    lock<span class="token punctuation">.</span><span class="token function">release</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第一个锁: "</span> <span class="token operator">+</span> lock1<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"是否有第二个锁: "</span> <span class="token operator">+</span> lock2<span class="token punctuation">.</span><span class="token function">isAcquiredInThisProcess</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>client<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="临时顺序节点"><a href="#临时顺序节点" class="headerlink" title="临时顺序节点"></a>临时顺序节点</h4><p>每个数据节点在 ZooKeeper 中被称为 <strong>znode</strong>，它是 ZooKeeper 中数据的最小单元。</p><p>我们通常是将 znode 分为 4 大类：</p><ul><li>  <strong>持久（PERSISTENT）节点</strong>：一旦创建就一直存在即使 ZooKeeper 集群宕机，直到将其删除。</li><li>  <strong>临时（EPHEMERAL）节点</strong>：临时节点的生命周期是与 <strong>客户端会话（session）</strong> 绑定的，<strong>会话消失则节点消失</strong> 。并且，<strong>临时节点只能做叶子节点</strong> ，不能创建子节点。</li><li>  <strong>持久顺序（PERSISTENT_SEQUENTIAL）节点</strong>：除了具有持久（PERSISTENT）节点的特性之外， 子节点的名称还具有顺序性。比如 <code>/node1/app0000000001</code>、<code>/node1/app0000000002</code> 。</li><li>  <strong>临时顺序（EPHEMERAL_SEQUENTIAL）节点</strong>：除了具备临时（EPHEMERAL）节点的特性之外，子节点的名称还具有顺序性。</li></ul><p>可以看出，临时节点相比持久节点，最主要的是对会话失效的情况处理不一样，临时节点会话消失则对应的节点消失。这样的话，如果客户端发生异常导致没来得及释放锁也没关系，会话失效节点自动被删除，不会发生死锁的问题。</p><p>使用 Redis 实现分布式锁的时候，我们是通过过期时间来避免锁无法被释放导致死锁问题的，而 ZooKeeper 直接利用临时节点的特性即可。</p><p>假设不适用顺序节点的话，所有尝试获取锁的客户端都会对持有锁的子节点加监听器。当该锁被释放之后，势必会造成所有尝试获取锁的客户端来争夺锁，这样对性能不友好。使用顺序节点之后，只需要监听前一个节点就好了，对性能更友好。</p><h4 id="设置对前一个节点的监听"><a href="#设置对前一个节点的监听" class="headerlink" title="设置对前一个节点的监听"></a>设置对前一个节点的监听</h4><blockquote><p>Watcher（事件监听器），是 ZooKeeper 中的一个很重要的特性。ZooKeeper 允许用户在指定节点上注册一些 Watcher，并且在一些特定事件触发的时候，ZooKeeper 服务端会将事件通知到感兴趣的客户端上去，该机制是 ZooKeeper 实现分布式协调服务的重要特性。</p></blockquote><p>同一时间段内，可能会有很多客户端同时获取锁，但只有一个可以获取成功。如果获取锁失败，则说明有其他的客户端已经成功获取锁。获取锁失败的客户端并不会不停地循环去尝试加锁，而是在前一个节点注册一个事件监听器。</p><p>这个事件监听器的作用是：<strong>当前一个节点对应的客户端释放锁之后（也就是前一个节点被删除之后，监听的是删除事件），通知获取锁失败的客户端（唤醒等待的线程，Java 中的 <code>wait/notifyAll</code> ），让它尝试去获取锁，然后就成功获取锁了。</strong></p><h4 id="实现可重入锁-1"><a href="#实现可重入锁-1" class="headerlink" title="实现可重入锁"></a>实现可重入锁</h4><p>这里以 Curator 的 <code>InterProcessMutex</code> 对可重入锁的实现来介绍</p><p>当我们调用 <code>InterProcessMutex#acquire</code>方法获取锁的时候，会调用<code>InterProcessMutex#internalLock</code>方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 获取可重入互斥锁，直到获取成功为止</span><span class="token annotation punctuation">@Override</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">acquire</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span><span class="token function">internalLock</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IOException</span><span class="token punctuation">(</span><span class="token string">"Lost connection while trying to acquire lock: "</span> <span class="token operator">+</span> basePath<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>internalLock</code> 方法会先获取当前请求锁的线程，然后从 <code>threadData</code>( <code>ConcurrentMap&lt;Thread, LockData&gt;</code> 类型)中获取当前线程对应的 <code>lockData</code> 。 <code>lockData</code> 包含锁的信息和加锁的次数，是实现可重入锁的关键。</p><p>第一次获取锁的时候，<code>lockData</code>为 <code>null</code>。获取锁成功之后，会将当前线程和对应的 <code>lockData</code> 放到 <code>threadData</code> 中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">internalLock</span><span class="token punctuation">(</span><span class="token keyword">long</span> time<span class="token punctuation">,</span> <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Exception</span> <span class="token punctuation">{</span>  <span class="token comment">// 获取当前请求锁的线程</span>  <span class="token class-name">Thread</span> currentThread <span class="token operator">=</span> <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 拿对应的 lockData</span>  <span class="token class-name">LockData</span> lockData <span class="token operator">=</span> threadData<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 第一次获取锁的话，lockData 为 null</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lockData <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// 当前线程获取过一次锁之后</span>    <span class="token comment">// 因为当前线程的锁存在， lockCount 自增后返回，实现锁重入.</span>    lockData<span class="token punctuation">.</span>lockCount<span class="token punctuation">.</span><span class="token function">incrementAndGet</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">// 尝试获取锁</span>  <span class="token class-name">String</span> lockPath <span class="token operator">=</span> internals<span class="token punctuation">.</span><span class="token function">attemptLock</span><span class="token punctuation">(</span>time<span class="token punctuation">,</span> unit<span class="token punctuation">,</span> <span class="token function">getLockNodeBytes</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>lockPath <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">LockData</span> newLockData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LockData</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">,</span> lockPath<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token comment">// 获取锁成功之后，将当前线程和对应的 lockData 放到 threadData 中</span>    threadData<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>currentThread<span class="token punctuation">,</span> newLockData<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>LockData</code>是 <code>InterProcessMutex</code>中的一个静态内部类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">final</span> <span class="token class-name">ConcurrentMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Thread</span><span class="token punctuation">,</span> <span class="token class-name">LockData</span><span class="token punctuation">&gt;</span></span> threadData <span class="token operator">=</span> <span class="token class-name">Maps</span><span class="token punctuation">.</span><span class="token function">newConcurrentMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">class</span> <span class="token class-name">LockData</span><span class="token punctuation">{</span>    <span class="token comment">// 当前持有锁的线程</span>    <span class="token keyword">final</span> <span class="token class-name">Thread</span> owningThread<span class="token punctuation">;</span>    <span class="token comment">// 锁对应的子节点</span>    <span class="token keyword">final</span> <span class="token class-name">String</span> lockPath<span class="token punctuation">;</span>    <span class="token comment">// 加锁的次数</span>    <span class="token keyword">final</span> <span class="token class-name">AtomicInteger</span> lockCount <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AtomicInteger</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">LockData</span><span class="token punctuation">(</span><span class="token class-name">Thread</span> owningThread<span class="token punctuation">,</span> <span class="token class-name">String</span> lockPath<span class="token punctuation">)</span>    <span class="token punctuation">{</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>owningThread <span class="token operator">=</span> owningThread<span class="token punctuation">;</span>      <span class="token keyword">this</span><span class="token punctuation">.</span>lockPath <span class="token operator">=</span> lockPath<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>如果已经获取过一次锁，后面再来获取锁的话，直接就会在 <code>if (lockData != null)</code> 这里被拦下了，然后就会执行<code>lockData.lockCount.incrementAndGet();</code> 将加锁次数加 1。</p><p>整个可重入锁的实现逻辑非常简单，直接在客户端判断当前线程有没有获取锁，有的话直接将加锁次数加 1 就可以了。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> NoSQL </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>设计模式(补档)</title>
      <link href="/2023/03/25/she-ji-mo-shi-bu-dang/"/>
      <url>/2023/03/25/she-ji-mo-shi-bu-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="软件设计原则"><a href="#软件设计原则" class="headerlink" title="软件设计原则"></a>软件设计原则</h3><p>常⽤的⾯向对象设计原则包括7个，这些原则并不是孤⽴存在的，它们相互 依赖，相互补充。</p><ul><li>开闭原则（Open Closed Principle，OCP）</li><li>单⼀职责原则（Single Responsibility Principle, SRP） </li><li>⾥⽒替换原则（Liskov Substitution Principle，LSP） </li><li>依赖倒置原则（Dependency Inversion Principle，DIP） </li><li>接⼝隔离原则（Interface Segregation Principle，ISP） </li><li>合成/聚合复⽤原则（Composite/Aggregate Reuse Principle， C/ARP） </li><li>最少知识原则（Least Knowledge Principle，LKP）</li><li>或者迪⽶特法则 （Law of Demeter，LOD</li></ul><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/01.png"></p><h3 id="什么是设计模式"><a href="#什么是设计模式" class="headerlink" title="什么是设计模式"></a>什么是设计模式</h3><p>设计模式是软件开发⼈员在软件开发过程中⾯临的⼀般问题的<strong>解决⽅案</strong>。这些解决⽅案是众多软件开发⼈员经过相当⻓的 ⼀段时间的试验和错误总结出来的。 </p><p>设计模式是⼀套被反复使⽤的、多数⼈知晓的、经过分类编⽬的、代码设计经验的总结。使⽤设计模式是为了重⽤代码、让代码更容易被他⼈理解、保证代码可靠性。</p><p>项⽬中合理地运⽤设计模式可以完美地解决很多问题，每种模式在现实中都有相应的原理来与之对应，每种模式都描述了 ⼀个在我们周围不断重复发⽣的问题，以及该问题的核⼼解决⽅案</p><h3 id="设计模式的分类"><a href="#设计模式的分类" class="headerlink" title="设计模式的分类"></a>设计模式的分类</h3><p><strong>创建型</strong>： 在创建对象的同时隐藏创建逻辑，不使⽤ new 直接实例化对象，程序在判断需要创建哪些对象时更灵活。包括⼯⼚/抽象⼯⼚/单例/ 建造者/原型模式。 </p><p><strong>结构型</strong>： 通过类和接⼝间的继承和引⽤实现创建复杂结构的对象。包 括适配器/桥接模式/过滤器/组合/装饰器/外观/享元/代理模式。 </p><p><strong>⾏为型</strong>： 通过类之间不同通信⽅式实现不同⾏为。包括责任链/命名/解 释器/迭代器/中介者/备忘录/观察者/状态/策略/模板/访问者模式</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/02.png"></p><h3 id="简单⼯⼚模式"><a href="#简单⼯⼚模式" class="headerlink" title="简单⼯⼚模式"></a>简单⼯⼚模式</h3><p>简单⼯⼚模式指由⼀个⼯⼚对象来创建实例，客户端不需要关注创建逻辑，只需提供传⼊⼯⼚的参数。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/03.png"></p><p>适⽤于⼯⼚类负责创建对象较少的情况，缺点是如果要增加新产品，就需 要修改⼯⼚类的判断逻辑，违背开闭原则，且产品多的话会使⼯⼚类⽐较 复杂。</p><p>抽象产品</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>具体产品</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Meizu</span> <span class="token keyword">implements</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"魅族"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Xiaomi</span> <span class="token keyword">implements</span> <span class="token class-name">Phone</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"小米"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>工厂类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">PhoneFactory</span><span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Phone</span> <span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token class-name">String</span> phone<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token string">"小米"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Xiaomi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token string">"魅族"</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>phone<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Meizu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>消费者</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">PhoneFactory</span><span class="token punctuation">.</span><span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token string">"Xiaomi"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">PhoneFactory</span><span class="token punctuation">.</span><span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token string">"Meizu"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="⼯⼚⽅法模式"><a href="#⼯⼚⽅法模式" class="headerlink" title="⼯⼚⽅法模式"></a>⼯⼚⽅法模式</h3><p>和简单⼯⼚模式中⼯⼚负责⽣产所有产品相⽐，⼯⼚⽅法模式将⽣成具体 产品的任务分发给具体的产品⼯⼚。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/04.png"></p><p>也就是定义⼀个抽象⼯⼚，其定义了产品的⽣产接⼝，但不负责具体的产 品，将⽣产任务交给不同的派⽣类⼯⼚。这样不⽤通过指定类型来创建对 象了。</p><p>在简单工厂模式中，在抽象工厂下分为具体工厂</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">XiaomiFactory</span> <span class="token keyword">implements</span> <span class="token class-name">PhoneFactory</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Phone</span> <span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Xiaomi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MeizuFactory</span> <span class="token keyword">implements</span> <span class="token class-name">PhoneFactory</span><span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Phone</span> <span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Meizu</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>消费者</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Customer</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Phone</span> xiaomi <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XiaomiFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Phone</span> meizu <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MeizuFactory</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getPhone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        xiaomi<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        meizu<span class="token punctuation">.</span><span class="token function">getBrand</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="抽象⼯⼚模式"><a href="#抽象⼯⼚模式" class="headerlink" title="抽象⼯⼚模式"></a>抽象⼯⼚模式</h3><p>简单⼯⼚模式和⼯⼚⽅法模式不管⼯⼚怎么拆分抽象，都只是针对⼀类产品，如果要⽣成另⼀种产品，就⽐较难办了</p><p>抽象⼯⼚模式通过在 AbstarctFactory 中增加创建产品的接⼝，并在具体⼦⼯⼚中实现新加产品的创建。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/05.png"></p><p>抽象工厂仅仅是在工厂方法模式下新增了一些接口，只是工厂模式的一个拓展，当抽象工厂模式只有一个产品体系的话就会退化成工厂模式。</p><h3 id="单例模式"><a href="#单例模式" class="headerlink" title="单例模式"></a>单例模式</h3><p>单例模式是一种创建型设计模式，它确保一个类只有一个实例，并提供了一个全局访问点来访问该实例。</p><p>Spring 中的 Bean 默认都是单例的，作用域是singleton</p><p><strong>懒汉式，线程不安全</strong></p><p>用private声明了构造方法，这样做其他类就不能直接通过new实例化了</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>懒汉式，线程安全</strong></p><p>synchronized修饰get()方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">synchronized</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>instance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>饿汉式</strong></p><p>用private声明了构造方法，这样做其他类就不能直接通过new实例化了<br>（类加载时就初始化）这样就会浪费了内存空间。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> instance<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>双重校验锁</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> singleton<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Singleton</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>      <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getSingleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>singleton <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  singleton <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> singleton<span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>为什么加上volatile关键字，有什么用呢？</strong></p><p>new的时候不是原子性， singleton = new Singleton(); 这段代码其实是分为三步执行：</p><ol><li> 分配内存空间</li><li> 执行构造方法，初始化对象</li><li> 将引用指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。</p><p>指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getSingleton</code>() 后发现 <code>singleton</code> 不为空，因此返回 <code>singleton</code>，但此时 <code>singleton</code> 还未被初始化。</p><p><strong>双重检查加锁单例模式为什么两次校验？</strong></p><p><strong>第一次校验</strong>：</p><p><strong>为了代码提高代码执行效率</strong>：由于单例模式只要一次创建实例即可，所以当创建了一个实例之后，再次调用getInstance方法就<strong>不必要进入同步代码块</strong>，不用竞争锁。直接返回前面创建的实例即可。</p><p><strong>第二次校验</strong>：</p><p><strong>防止二次创建实例</strong>：假如有一种情况，当singleton还未被创建时，线程t1调用getInstance方法，由于第一次判断singleton == null，此时线程t1准备继续执行，但是由于CPU资源被线程t2抢占了，此时t2页调用getInstance方法，同样的，由于singleton并没有实例化，t2同样可以通过第一个if，然后继续往下执行，同步代码块，第二个if也通过，然后t2线程创建了一个实例singleton。此时t2线程完成任务，资源又回到t1线程，t1此时也进入同步代码块，如果没有这个第二个if，那么，t1就也会创建一个singleton实例，那么，就会出现创建多个实例的情况，但是加上第二个if，就可以完全避免这个多线程导致多次创建实例的问题。</p><h3 id="代理模式"><a href="#代理模式" class="headerlink" title="代理模式"></a>代理模式</h3><p><strong>代理模式的本质就是将非核心事务转交给第三方处理</strong>，比如老板和秘书，明星和经纪人</p><p>代理模式的本质是⼀个中间件，主要⽬的是解耦合服务提供者和使⽤者。使⽤者通过代理<strong>间接</strong>的访问服务提供者，便于后者的封装和控制。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/06.png"></p><p>优点：</p><ul><li><strong>高内聚低耦合：核心代码专注业务本身，把非业务代码通通交给代理实现</strong></li><li><strong>增加扩展性：扩展其他功能时不影响核心业务代码</strong></li></ul><h4 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h4><p>静态代理是在程序运行前，代理类的.class文件就已经存在了</p><p>定义接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//定义一个明星的接口</span><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IStarDao</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现行为</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StarDao</span> <span class="token keyword">implements</span> <span class="token class-name">IStarDao</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拍广告"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>定义代理类，<strong>静态代理的关键代码</strong></p><p>经纪人代理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentProxy</span> <span class="token keyword">implements</span> <span class="token class-name">IStarDao</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">IStarDao</span> action<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AgentProxy</span><span class="token punctuation">(</span><span class="token class-name">IStarDao</span> target<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>action <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"经纪人接广告"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//表演行动开始::代理人是经纪人，但实际赚钱的是明星</span>        perform<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"经纪人数钱"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>实现</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token comment">//明星</span>        <span class="token class-name">StarDao</span> starDao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StarDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//帮明星代理的经纪人</span>        <span class="token class-name">AgentProxy</span> agentProxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">AgentProxy</span><span class="token punctuation">(</span>starDao<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token comment">//帮明星代理的经纪人,让明星开始他的表演</span>        agentProxy<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优点：<strong>拓展新功能时能不修改我们核心代码。</strong></p><p>缺点：<strong>代理对象和目标对象类需要实现一样的接口</strong>，会导致代理类会非常非常多。并且重用性不强</p><h4 id="动态代理"><a href="#动态代理" class="headerlink" title="动态代理"></a>动态代理</h4><p><strong>JDK动态代理</strong></p><p>JDK代理实现是利用lang包下的reflect</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">java<span class="token punctuation">.</span>lang<span class="token punctuation">.</span>reflect<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>定义一个明星的接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">IStarDao</span> <span class="token punctuation">{</span>    <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>实现明星的行为</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StarDao</span> <span class="token keyword">implements</span> <span class="token class-name">IStarDao</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拍广告"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>JDK动态代理的关键代码</strong></p><p>代理类无需再和目标对象类实现同样的接口，更加的灵活。</p><p>代理实例的三个参数：</p><ul><li>ClassLoader loader : 指定当前目标对象使用的类加载器</li><li>Class&lt; ? &gt;[] interfaces : 目标对象实现的接口类型</li><li>InvocationHandler : 事情处理，执行目标对象的方法时，会触发事情处理方法，把当前执行的目标对象方法作为参数传入</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentProxyFactory</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> target<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AgentProxyFactory</span><span class="token punctuation">(</span><span class="token class-name">Object</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>target <span class="token operator">=</span> target<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 给目标对象 生成一个代理对象     */</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Proxy</span><span class="token punctuation">.</span><span class="token function">newProxyInstance</span><span class="token punctuation">(</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getClassLoader</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> target<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getInterfaces</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">InvocationHandler</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token annotation punctuation">@Override</span>            <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">invoke</span><span class="token punctuation">(</span><span class="token class-name">Object</span> proxy<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>                <span class="token comment">//反射机制调用目标对象的方法</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"经纪人接广告"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">Object</span> returnValue <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"经纪人数钱"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">return</span> returnValue<span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以发现代理类不需要继承接口，但需要在真正实例化时将目标对象给代理对象既可。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//创建目标对象</span>        <span class="token class-name">StarDao</span> iStarDao <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StarDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//给目标对象，创建代理对象，可以转成Dao</span>        <span class="token class-name">IStarDao</span> proxyInstance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">IStarDao</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">AgentProxyFactory</span><span class="token punctuation">(</span>iStarDao<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//通过代理对象，调用目标对象</span>        proxyInstance<span class="token punctuation">.</span><span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优势：</p><ul><li>在扩展功能时不修改核心代码，</li><li>JDK动态代理类不需要和目标对象类一样都需要实现同样的接口，让代理类更加灵活。</li></ul><p>劣势：目标对象依然需要实现接口。</p><p><strong>cglib动态代理</strong></p><p>cglib代理也称&nbsp;<strong>子类代理</strong>，它是从内存中构建出一个子类来扩展目标对象的功能。</p><p>定义目标类，不同的不需要再定义接口，直接实现。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">StarDao</span>  <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">action</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"拍广告"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>代理类AgentProxyFactory 实现 MethodInterceptor 接口用来调用目标类，实现动态代理</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AgentProxyFactory</span> <span class="token keyword">implements</span> <span class="token class-name">MethodInterceptor</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token class-name">Object</span> targer<span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token class-name">AgentProxyFactory</span><span class="token punctuation">(</span><span class="token class-name">Object</span> targer<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>targer <span class="token operator">=</span> targer<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//返回一个代理对象,是target 对象的代理对象</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token comment">//1.创建一个工具类</span>        <span class="token class-name">Enhancer</span> enhancer <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Enhancer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//2.设置父类</span>        enhancer<span class="token punctuation">.</span><span class="token function">setSuperclass</span><span class="token punctuation">(</span>targer<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//3.设置回调函数</span>        enhancer<span class="token punctuation">.</span><span class="token function">setCallback</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//4.创建子类对象，即代理对象</span>        <span class="token keyword">return</span> enhancer<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token comment">//调用目标对象</span>    <span class="token annotation punctuation">@Override</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">intercept</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">,</span> <span class="token class-name">Method</span> method<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">,</span> <span class="token class-name">MethodProxy</span> methodProxy<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"经纪人接广告"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span> returnValue <span class="token operator">=</span> method<span class="token punctuation">.</span><span class="token function">invoke</span><span class="token punctuation">(</span>targer<span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token string">"经纪人数钱"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> returnValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Client</span> <span class="token punctuation">{</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//创建目标对象</span>        <span class="token class-name">StarDao</span> target <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">StarDao</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//获取到代理对象，并且将目标对象传给代理对象</span>        <span class="token class-name">StarDao</span> proxyInstance <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">StarDao</span><span class="token punctuation">)</span> <span class="token keyword">new</span> <span class="token class-name">AgentProxyFactory</span><span class="token punctuation">(</span>target<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">getProxyInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//执行代理对象的方法</span>        proxyInstance<span class="token punctuation">.</span><span class="token function">sing</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>优势：不用实现同一个接口。让代理模式真正灵动起来。</p><p>劣势：需要多导入jar包了</p><h4 id="静态代理和动态代理的区别"><a href="#静态代理和动态代理的区别" class="headerlink" title="静态代理和动态代理的区别"></a>静态代理和动态代理的区别</h4><p><strong>灵活性</strong> ：动态代理更加灵活，不需要必须实现接⼝，可以直接代理实现类，并且可以不需要针对每个⽬标类都创建⼀个代理类。静态代理中，接⼝⼀旦新增加⽅法，⽬标对象和代理对象都要进⾏修改，⾮常麻烦</p><p><strong>JVM 层⾯</strong> ：静态代理在编译时就将接⼝、实现类、代理类这些都变成了⼀个个实际的 class ⽂件。⽽动态代理是在运⾏时动态⽣成类字节码，并加载到 JVM 中的。</p><h3 id="观察者模式"><a href="#观察者模式" class="headerlink" title="观察者模式"></a>观察者模式</h3><p>观察者模式主要⽤于处理对象间的<strong>⼀对多的关系</strong>，是⼀种对象⾏为模式。该模式的实际应⽤场景⽐较容易确认，当⼀个对象状态发⽣变化时，所有该对象的关注者均能收到状态变化通知，以进⾏相应的处理。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/07.png"></p><h3 id="适配器模式"><a href="#适配器模式" class="headerlink" title="适配器模式"></a>适配器模式</h3><p>将两个不同接⼝的类来进⾏通信，在不修改这两个的前提下可能会需要某个中间件来完成这个衔接的过程。这个中间件就是适配器。</p><p>所谓适配器模式就是将⼀个类的接⼝，转换成客户期望的另⼀个接⼝。它可以让原本两个不兼容的接⼝能够⽆缝完成对接。作为中间件的适配器将⽬标类和适配者解耦，增加了类的透明性和可复⽤性。</p><p><img src="/images/image_%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/08.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 设计模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Redis(补档)</title>
      <link href="/2023/03/22/redis-bu-dang/"/>
      <url>/2023/03/22/redis-bu-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-Redis"><a href="#什么是-Redis" class="headerlink" title="什么是 Redis"></a>什么是 Redis</h3><p>Redis 是一个基于 C 语言开发的非关系型数据库，Redis 的数据是存在内存中的，读写速度非常快，被广泛应用于缓存方向。Redis 存储的是 KV 键值对数据。</p><h3 id="Redis-为什么这么快"><a href="#Redis-为什么这么快" class="headerlink" title="Redis 为什么这么快"></a>Redis 为什么这么快</h3><ul><li><p>Redis 基于内存，内存的访问速度是磁盘的上千倍；</p></li><li><p>Redis 采用IO多路复用机制</p></li><li><p>Redis 单线程的优势，没有线程上下文切换的开销</p></li><li><p>Redis 内置了多种优化过后的数据结构实现，性能非常高。</p><h3 id="Redis和Memcached相比有哪些优势"><a href="#Redis和Memcached相比有哪些优势" class="headerlink" title="Redis和Memcached相比有哪些优势"></a>Redis和Memcached相比有哪些优势</h3></li><li><p>Redis<strong>数据结构更丰富</strong>，支持string (字符串)、list (列表)、set (集合)、hash (哈希) 和 zset (有序集合)等数据结构存储，Memcached仅支持String数据类型。</p></li><li><p>Redis支持数据的<strong>持久化</strong>，可以把内存中的数据持久化到硬盘中，而Memcached不支持持久化，数据只能存在内存中，重启后数据就没了。</p></li><li><p>Memcached没有原生的<strong>集群模式</strong>，需要依靠客户端自己实现集群分片，而Redis原生支持集群模式。</p></li><li><p>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用<strong>单线程</strong>的多路 IO 复用模型。</p></li></ul><h3 id="Redis常用指令"><a href="#Redis常用指令" class="headerlink" title="Redis常用指令"></a>Redis常用指令</h3><ul><li> 设置key-value ：set key value</li><li>获取值：get key</li><li>删除：del key</li><li>判断key是否存在：exists key</li><li>设置10秒过期：expire key 10</li><li>设置10毫秒过期：pexpire key 10</li><li>删除过期时间：persist key</li><li>切换数据库：redis有16个数据库，默认使用0号数据库，切换数据库的命令为：select index</li><li>清空当前选中的数据库：flushdb</li><li>清空所有数据库：flushall</li><li>查看当前数据库的所有key：keys *</li><li>查看字段类型：type key</li></ul><h3 id="Redis有哪些数据结构-应⽤场景"><a href="#Redis有哪些数据结构-应⽤场景" class="headerlink" title="Redis有哪些数据结构 应⽤场景"></a>Redis有哪些数据结构 应⽤场景</h3><p>Redis的数据结构有：</p><ol><li><p>String字符串：可以⽤来做最简单的数据，可以缓存某个简单的字符串，也可以缓存某个json格式的字符串，Redis分布式锁的实现就利⽤了这种数据结构，还包括可以实现计数器、Session共享、分布式ID</p></li><li><p>HashMap哈希表：可以⽤来存储⼀些key-value对，更适合⽤来存储对象</p></li><li><p>List列表：Redis的列表通过命令的组合，既可以当做栈，也可以当做队列来使⽤，可以⽤来缓存类似微信公众号、微博等消息流数据</p></li><li><p>Set集合：和列表类似，也可以存储多个元素，但是不能重复，集合可以进⾏交集、并集、差集操作，从⽽可以实现类似，我和某⼈共同关注的⼈、朋友圈点赞等功能</p></li><li><p>zSet有序集合：集合是⽆序的，有序集合可以设置顺序，可以⽤来实现排⾏榜功能</p></li></ol><h3 id="String-的底层实现"><a href="#String-的底层实现" class="headerlink" title="String 的底层实现"></a>String 的底层实现</h3><p>redis的String类型在底层实现中有三种实现方式。</p><ol><li>使用整数值实现的字符串对象，使用的是<strong>8个字节的long</strong>类型进行存储。</li><li>使用<strong>embstr编码</strong>的动态字符串实现的字符串对象，存储长度小于44字节的字符串</li><li><strong>动态字符串</strong>实现的字符串对象，存储长度大于44字节的字符串。</li></ol><p>redis会根据值的类型和长度自动选择存储的类型。</p><p>动态字符串是redis写的一个抽象数据类型，存储了字符串的长度、空闲长度和字符数组等字段。</p><h3 id="Redis的过期策略有哪些"><a href="#Redis的过期策略有哪些" class="headerlink" title="Redis的过期策略有哪些"></a>Redis的过期策略有哪些</h3><ol><li> <strong>惰性删除</strong> ：只会在取出 key 的时候才对数据进行过期检查。这样对 CPU 最友好，但是可能会造成太多过期 key 没有被删除。</li><li> <strong>定期删除</strong> ： 每隔一段时间抽取一批 key 执行删除过期 key 操作。并且，Redis 底层会通过限制删除操作执行的时长和频率来减少删除操作对 CPU 时间的影响。</li></ol><p>定期删除对内存更加友好，惰性删除对 CPU 更加友好。两者各有千秋，所以 Redis 采用的是 <strong>定期删除+惰性删除</strong> 。</p><h3 id="如何解决大量key集中过期导致卡顿"><a href="#如何解决大量key集中过期导致卡顿" class="headerlink" title="如何解决大量key集中过期导致卡顿"></a>如何解决大量key集中过期导致卡顿</h3><p>定期删除执行过程中，如果突然遇到大量过期 key 的话，客户端请求必须等待定期清理过期 key 任务线程执行完成，因为这个这个定期任务线程是在 Redis 主线程中执行的</p><ol><li> 给 key 设置随机过期时间。</li><li> 开启 lazy-free（<strong>惰性删除</strong>/延迟释放）。 Redis 4.0 开始引入的，指的是让 Redis 采用异步方式延迟释放 key 使用的内存，将该操作交给单独的子线程处理，避免阻塞主线程。</li></ol><h3 id="Redis-内存淘汰机制有哪些"><a href="#Redis-内存淘汰机制有哪些" class="headerlink" title="Redis 内存淘汰机制有哪些"></a>Redis 内存淘汰机制有哪些</h3><ol><li> <strong>volatile-lru（least recently used）</strong>：从已设置过期时间的数据集中挑选最近最少使用的数据淘汰</li><li> <strong>volatile-ttl</strong>：从已设置过期时间的数据集中挑选将要过期的数据淘汰</li><li> <strong>volatile-random</strong>：从已设置过期时间的数据集中随机选择数据淘汰</li><li> <strong>allkeys-lru（least recently used）</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的 key（最常用的）</li><li> <strong>allkeys-random</strong>：从数据集中任意选择数据淘汰</li><li> <strong>no-eviction</strong>：禁止驱逐数据，当内存不足以容纳新写入数据时，新写入操作会报错。</li></ol><h3 id="Redis-持久化机制有哪些"><a href="#Redis-持久化机制有哪些" class="headerlink" title="Redis 持久化机制有哪些"></a>Redis 持久化机制有哪些</h3><p><strong>RDB</strong>：Redis DataBase，在指定的时间间隔内将内存中的<strong>数据集快照</strong>写⼊磁盘，实际操作过程是fork⼀个⼦进程，先将数据集写⼊临时⽂件，写⼊成功后，再替换之前的⽂件，⽤⼆进制压缩存储。（Redis 默认）</p><p>Redis提供了两个命令来生成 RDB 文件：</p><ul><li>save：在主进程中执行，会导致写请求阻塞。</li><li>bgsave：fork一个子进程，专门用于写入 RDB 文件，避免了主进程的阻塞。</li></ul><p>优点：</p><ul><li><p>RDB文件紧凑，体积小，网络传输快，适合全量复制</p></li><li><p>与AOF方式相比，通过RDB文件恢复数据比较快更快</p></li><li><p>RDB最大化了Redis的性能，因为Redis父进程持久化时只需要fork一个子进程，这个子进程可以共享主进程的所有内存数据，子进程会去读取主进程的内存数据，并把它们写入RDB文件。</p></li></ul><p>缺点：</p><ul><li><p>快照是定期生成的，所有在 Redis 故障时或多或少会丢失一部分数据</p></li><li><p>当数据量比较大时，fork 的过程是非常耗时的，fork 子进程时是会阻塞的，在这期间 Redis 是不能响应客户端的请求的。</p></li></ul><p><strong>AOF</strong>：Append Only File，以<strong>⽇志</strong>的形式记录服务器所处理的每⼀个写、删除操作，查询操作不会记录，以⽂本的⽅式记录，可以打开⽂件看到详细的操作记录</p><p>优点：</p><ul><li>数据安全，Redis中提供了3中同步策略，即每秒同步、每修改同步和不同步。事实上，每秒同步也是异步完成的，其效率也是⾮常⾼的，所差的是⼀旦系统出现宕机现象，那么这⼀秒钟之内修改的数据将会丢失。</li><li>通过 append 模式写⽂件，即使中途服务器宕机也不会破坏已经存在的内容，可以通过 redis-check-aof ⼯具解决数据⼀致性问题。</li><li>AOF 机制的 rewrite 模式。定期对AOF⽂件进⾏重写，以达到压缩的⽬的</li></ul><p>缺点：</p><ul><li>AOF ⽂件⽐ RDB ⽂件⼤，且恢复速度慢。</li><li>数据集⼤的时候，⽐ rdb 启动效率低。</li><li>运⾏效率没有RDB⾼</li></ul><h3 id="Redis事务机制"><a href="#Redis事务机制" class="headerlink" title="Redis事务机制"></a>Redis事务机制</h3><p>Redis通过<strong>MULTI、EXEC、WATCH</strong>等一组命令集合，来实现事务机制。<strong>顺序性、一次性、排他性</strong>的执行一个队列中的一系列命令。</p><p>Redis执行事务的流程如下：</p><ul><li>  开始事务（MULTI）</li><li>  命令入队</li><li>  执行事务（EXEC）、撤销事务（DISCARD ）</li></ul><p>Redis 事务是不支持回滚（roll back）操作的，不满足原子性的，而且不满足持久性</p><h3 id="缓存穿透、缓存击穿、缓存雪崩分别是什么"><a href="#缓存穿透、缓存击穿、缓存雪崩分别是什么" class="headerlink" title="缓存穿透、缓存击穿、缓存雪崩分别是什么"></a>缓存穿透、缓存击穿、缓存雪崩分别是什么</h3><ol><li><p>缓存雪崩：如果缓存中某⼀时刻⼤批热点数据同时过期，那么就可能导致⼤量请求直接访问Mysql了。解决办法就是在过期时间上增加⼀点随机值，另外如果搭建⼀个⾼可⽤的Redis集群也是防⽌缓存雪崩的有效⼿段</p></li><li><p>缓存击穿：和缓存雪崩类似，缓存雪崩是⼤批热点数据失效，⽽缓存击穿是指某⼀个热点key突然失效，也导致了⼤量请求直接访问Mysql数据库，这就是缓存击穿。解决⽅案就是考虑这个热点key不设过期时间</p></li><li><p>缓存穿透：假如某⼀时刻访问redis的⼤量key都在redis中不存在（⽐如⿊客故意伪造⼀些乱七⼋糟的key），那么也会给数据造成压⼒，这就是缓存穿透。解决⽅案是使⽤布隆过滤器，它的作⽤就是如果它认为⼀个key不存在，那么这个key就肯定不存在，所以可以在缓存之前加⼀层布隆过滤器来拦截不存在的key</p></li></ol><h3 id="Redis和Mysql如何保证数据⼀致"><a href="#Redis和Mysql如何保证数据⼀致" class="headerlink" title="Redis和Mysql如何保证数据⼀致"></a>Redis和Mysql如何保证数据⼀致</h3><p>延迟双删：</p><p>先删除Redis缓存数据，再更新Mysql，延迟⼏百毫秒再删除Redis缓存数据，这样就算在更新Mysql时，有其他线程读了Mysql，把⽼数据读到了Redis中，那么也会被删除掉，从⽽把数据保持⼀致</p><h3 id="Redis集群策略有哪些"><a href="#Redis集群策略有哪些" class="headerlink" title="Redis集群策略有哪些"></a>Redis集群策略有哪些</h3><p>Redis提供了三种集群策略：</p><ol><li><p>主从模式：这种模式⽐较简单，主库可以读写，并且会和从库进⾏数据同步，这种模式下，客户端直接连主库或某个从库，但是但主库或从库宕机后，客户端需要⼿动修改IP，另外，这种模式也⽐较难进⾏扩容，整个集群所能存储的数据受到某台机器的内存容量，所以不可能⽀持特⼤数据量</p></li><li><p>哨兵模式：这种模式在主从的基础上新增了哨兵节点，但主库节点宕机后，哨兵会发现主库节点宕机，然后在从库中选择⼀个库作为进的主库，另外哨兵也可以做集群，从⽽可以保证但某⼀个哨兵节点宕机后，还有其他哨兵节点可以继续⼯作，这种模式可以⽐较好的保证Redis集群的⾼可⽤，但是仍然不能很好的解决Redis的容量上限问题。</p></li><li><p>Cluster模式：Cluster模式是⽤得⽐较多的模式，它⽀持多主多从，这种模式会按照key进⾏槽位的分配，可以使得不同的key分散到不同的主节点上，利⽤这种模式可以使得整个集群⽀持更⼤的数据容量，同时每个主节点可以拥有⾃⼰的多个从节点，如果该主节点宕机，会从它的从节点中选举⼀个新的主节点。</p><h3 id="Redis-主从复制的核⼼原理"><a href="#Redis-主从复制的核⼼原理" class="headerlink" title="Redis 主从复制的核⼼原理"></a>Redis 主从复制的核⼼原理</h3></li></ol><p>通过执⾏slaveof命令或设置slaveof选项，让⼀个服务器去复制另⼀个服务器的数据。主数据库可以进⾏读写操作，当写操作导致数据变化时会⾃动将数据同步给从数据库。⽽从数据库⼀般是只读的，并接受主数据库同步过来的数据。⼀个主数据库可以拥有多个从数据库，⽽⼀个从数据库只能拥有⼀个主数据库。</p><p>全量复制：</p><ol><li><p>主节点通过bgsave命令fork⼦进程进⾏RDB持久化，该过程是⾮常消耗CPU、内存(⻚表复制)、硬盘IO的</p></li><li><p>主节点通过⽹络将RDB⽂件发送给从节点，对主从节点的带宽都会带来很⼤的消耗</p></li><li><p>从节点清空⽼数据、载⼊新RDB⽂件的过程是阻塞的，⽆法响应客户端的命令；如果从节点执⾏bgrewriteaof，也会带来额外的消耗</p></li></ol><p>部分复制：</p><ol><li><p>复制偏移量：执⾏复制的双⽅，主从节点，分别会维护⼀个复制偏移量offset</p></li><li><p>复制积压缓冲区：主节点内部维护了⼀个固定⻓度的、先进先出(FIFO)队列 作为复制积压缓冲区，当主从节点offset的差距过⼤超过缓冲区⻓度时，将⽆法执⾏部分复制，只能执⾏全量复制。</p></li><li><p>服务器运⾏ID(runid)：每个Redis节点，都有其运⾏ID，运⾏ID由节点在启动时⾃动⽣成，主节点会将⾃⼰的运⾏ID发送给从节点，从节点会将主节点的运⾏ID存起来。 从节点Redis断开重连的时候，就是根据运⾏ID来判断同步的进度：○ 如果从节点保存的runid与主节点现在的runid相同，说明主从节点之前同步过，主节点会继续尝试使⽤部分复制(到底能不能部分复制还要看offset和复制积压缓冲区的情况)；○ 如果从节点保存的runid与主节点现在的runid不同，说明从节点在断线前同步的Redis节点并不是当前的主节点，只能进⾏全量复制。</p></li></ol><h3 id="Redis分布式锁底层是如何实现的"><a href="#Redis分布式锁底层是如何实现的" class="headerlink" title="Redis分布式锁底层是如何实现的"></a>Redis分布式锁底层是如何实现的</h3><ol><li><p>⾸先利⽤setnx来保证：如果key不存在才能获取到锁，如果key存在，则获取不到锁。(SETNX key value：将 key 的值设为 value ，当且仅当 key 不存在。若给定的 key 已经存在，则 SETNX 不做任何动作，该命令在设置成功时返回 1，设置失败时返回 0。)</p></li><li><p>然后还要利⽤lua脚本来保证多个redis操作的原⼦性</p></li><li><p>同时还要考虑到锁过期，所以需要额外的⼀个看⻔狗定时任务来监听锁是否需要续约</p></li><li><p>同时还要考虑到redis节点挂掉后的情况，所以需要采⽤红锁的⽅式来同时向N/2+1个节点申请锁，都申请到了才证明获取锁成功，这样就算其中某个redis节点挂掉了，锁也不能被其他客户端获取到</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> NoSQL </tag>
            
            <tag> redis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kafka</title>
      <link href="/2023/03/15/xiao-xi-dui-lie-bu-dang/"/>
      <url>/2023/03/15/xiao-xi-dui-lie-bu-dang/</url>
      
        <content type="html"><![CDATA[<h2 id="消息队列"><a href="#消息队列" class="headerlink" title="消息队列"></a>消息队列</h2><h3 id="什么是消息队列"><a href="#什么是消息队列" class="headerlink" title="什么是消息队列"></a>什么是消息队列</h3><p>可以把消息队列看作是一个存放消息的容器，当我们需要使用消息的时候，直接从容器中取出消息供自己使用即可。</p><p>由于队列 Queue 是一种先进先出的数据结构，所以消费消息时也是按照顺序来消费的。</p><p>参与消息传递的双方称为&nbsp;<strong>生产者</strong>&nbsp;和&nbsp;<strong>消费者</strong>&nbsp;，生产者负责发送消息，消费者负责处理消息。</p><h3 id="消息队列的作用是什么（优点）"><a href="#消息队列的作用是什么（优点）" class="headerlink" title="消息队列的作用是什么（优点）"></a>消息队列的作用是什么（优点）</h3><ol><li> <strong>异步处理</strong>：提高系统性能（减少响应所需时间）</li><li> <strong>削峰/限流</strong>：把请求数据先存入消息队列中，消费系统再根据自己的消费能力拉取消费。</li><li> <strong>降低系统耦合性。</strong></li></ol><h3 id="使用消息队列会带来哪些问题（缺点）"><a href="#使用消息队列会带来哪些问题（缺点）" class="headerlink" title="使用消息队列会带来哪些问题（缺点）"></a>使用消息队列会带来哪些问题（缺点）</h3><ul><li>  <strong>系统可用性降低：</strong> 需要考虑消息丢失或者说 MQ 挂掉等等的情况</li><li>  <strong>系统复杂性提高：</strong> 需要保证消息没有被重复消费、处理消息丢失的情况、保证消息传递的顺序性等等问题</li><li>  <strong>一致性问题：</strong> 消息的真正消费者并没有正确消费消息，导致数据不一致</li></ul><h2 id="Kafka"><a href="#Kafka" class="headerlink" title="Kafka"></a>Kafka</h2><h3 id="Kafka-是什么"><a href="#Kafka-是什么" class="headerlink" title="Kafka 是什么"></a>Kafka 是什么</h3><p>Kafka 是一个分布式流式处理平台。​ </p><p>Kafka 是一个多分区、多副本且基于zookeeper协调的分布式消息系统。</p><h3 id="Kafka-应用场景有哪些"><a href="#Kafka-应用场景有哪些" class="headerlink" title="Kafka 应用场景有哪些"></a>Kafka 应用场景有哪些</h3><ol><li> <strong>消息队列</strong> ：建立实时流数据管道，以可靠地在系统或应用程序之间获取数据。</li><li> <strong>数据处理：</strong> 构建实时的流数据处理程序来转换或处理数据流</li></ol><h3 id="Kafka的优势"><a href="#Kafka的优势" class="headerlink" title="Kafka的优势"></a>Kafka的优势</h3><p>会经常拿它跟 RocketMQ、RabbitMQ 对比：</p><ul><li><p><strong>高吞吐量</strong>：Kafka 每秒可以生产约 25 万消息（50 MB），每秒处理 55 万消息（110 MB）</p></li><li><p><strong>持久化数据存储</strong>：将消息持久化到磁盘，防止数据丢失</p></li><li><p><strong>分布式系统易于扩展</strong>：所有的 producer、broker 和 consumer 都会有多个，均为分布式的。无需停机即可扩展机器。</p></li></ul><h3 id="Kafka和RabbitMQ的区别"><a href="#Kafka和RabbitMQ的区别" class="headerlink" title="Kafka和RabbitMQ的区别"></a>Kafka和RabbitMQ的区别</h3><ol><li>数据处理模型：Kafka是一个分布式发布-订阅消息系统，以高吞吐量和持久性为目标。RabbitMQ是一个基于AMQP（高级消息队列协议）的消息中间件，它使用队列模型来处理消息。</li><li>处理方式：Kafka通过分区和复制机制来实现高吞吐量和高可靠性。RabbitMQ使用先进先出（FIFO）的队列模型来处理消息，按照顺序逐一传递和消费消息。</li><li>数据保证：Kafka提供的是至少一次交付的语义，即消息不会丢失，但可能会重复。RabbitMQ提供的是恰好一次交付的语义，即消息不会丢失也不会重复。它使用确认机制和消息确认应答来确保消息的可靠性。</li><li>适用场景：Kafka适用于处理高吞吐量和持久化的流式数据，而RabbitMQ适用于可靠的点对点通信和任务队列。</li></ol><h3 id="什么是Producer、Consumer、Broker、Topic、Partition"><a href="#什么是Producer、Consumer、Broker、Topic、Partition" class="headerlink" title="什么是Producer、Consumer、Broker、Topic、Partition"></a>什么是Producer、Consumer、Broker、Topic、Partition</h3><ul><li> <strong>Producer（生产者）</strong> : 产生消息的一方。</li><li> <strong>Consumer（消费者）</strong> : 消费消息的一方。</li><li> <strong>Broker（代理）</strong> : 可以看作是一个独立的 Kafka 实例。多个Broker 组成一个 Kafka 集群。</li></ul><p>每个 Broker 中又包含了 Topic 以及 Partition ：</p><ul><li>  <strong>Topic（主题）</strong> : Producer 将消息发送到特定的主题，Consumer 通过订阅特定的 Topic(主题) 来消费消息。</li><li>  <strong>Partition（分区）</strong> : Partition 属于 Topic 的一部分。一个 Topic 可以有多个 Partition </li></ul><blockquote><p>Kafka 中的 Partition（分区） 实际上可以对应成为消息队列中的队列。</p></blockquote><h3 id="Zookeeper-在-Kafka-中的作用是什么"><a href="#Zookeeper-在-Kafka-中的作用是什么" class="headerlink" title="Zookeeper 在 Kafka 中的作用是什么"></a>Zookeeper 在 Kafka 中的作用是什么</h3><ul><li><p>  <strong>Broker 注册</strong> ：每个 Broker 在启动时，都会到 Zookeeper 上进行注册，创建属于自己的节点。每个 Broker 就会将自己的 IP 地址和端口等信息记录到该节点中去</p></li><li><p>  <strong>Topic 注册</strong> ： 同一个Topic 的消息会被分成多个分区，并将其分布在多个 Broker 上，这些分区信息及与 Broker 的对应关系也都是由 Zookeeper 在维护。</p></li><li><p>  <strong>负载均衡</strong> ： Kafka 通过给特定 Topic 指定多个 Partition, 而各个 Partition 可以分布在不同的 Broker 上, 这样便能提供比较好的并发能力。 对于同一个 Topic 的不同 Partition，Kafka 会尽力将这些 Partition 分布到不同的 Broker 服务器上。当生产者产生消息后也会尽量投递到不同 Broker 的 Partition 里面。当 Consumer 消费的时候，Zookeeper 可以根据当前的 Partition 数量以及 Consumer 数量来实现动态负载均衡。</p></li></ul><h3 id="如何保证Kafka消息队列的高可用"><a href="#如何保证Kafka消息队列的高可用" class="headerlink" title="如何保证Kafka消息队列的高可用"></a>如何保证Kafka消息队列的高可用</h3><ol><li><strong>多分区（Partition）</strong></li></ol><p>创建一个 topic 可以划分为多个 partition，每个 partition 可以存在于不同的 broker 上。就是说一个 topic 的数据，是分散放在多个机器上的，每个机器就放一部分数据。</p><ol start="2"><li><strong>多副本（Replica）</strong></li></ol><p>每个 partition 的数据都会同步到其他机器上，形成自己的多个 replica 副本。</p><p>分区（Partition）中的多个副本之间会有一个叫做 leader 的，其他副本称为 follower。发送的消息会被发送到 leader 副本，然后 follower 副本才能从 leader 副本中拉取消息进行同步。</p><p>写的时候，leader 会负责把数据同步到所有 follower 上去，读的时候就直接读 leader 上数据即可。Kafka 会均匀的将一个 partition 的所有 replica 分布在不同的机器上，这样才可以提高容错性。</p><p>这两种基准极大地提高了消息存储的安全性, 保证了kafka消息队列的高可用，不过也相应的增加了所需要的存储空间。</p><h3 id="Kafka-的分区策略有哪些"><a href="#Kafka-的分区策略有哪些" class="headerlink" title="Kafka 的分区策略有哪些"></a>Kafka 的分区策略有哪些</h3><p>所谓分区策略就是决定生产者将消息发送到哪个分区的算法。</p><ol><li>轮询策略：默认的分区策略，非常优秀的负载均衡表现，总是能保证消息最大限度地被平均分配到所有分区上；</li><li>随机策略：实现随机策略版的 partition 方法；</li><li>按消息键保序策略：可以保证同一个 Key 的所有消息都进入到相同的分区里，由于每个分区下的消息处理是有顺序的，所以称之为消息键保序策略；</li></ol><h3 id="Kafka-如何保证消息的消费顺序"><a href="#Kafka-如何保证消息的消费顺序" class="headerlink" title="Kafka 如何保证消息的消费顺序"></a>Kafka 如何保证消息的消费顺序</h3><p>Topic 有多个 Partition，从不同的Partition中消费消息可能满足不了我们需要的顺序</p><p><strong>1、1 个 Topic 只对应一个 Partition</strong></p><p>Kafka 只能为我们保证一个 Partition(分区) 中的消息有序。</p><blockquote><p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。Kafka 通过偏移量（offset）来保证消息在分区内的顺序性。</p></blockquote><p><strong>2 、发送消息的时候指定 key/Partition</strong></p><p>Kafka 中发送 1 条消息的时候，可以指定 topic, partition, key,data（数据） 4 个参数。如果你发送消息的时候指定了 Partition 的话，所有消息都会被发送到指定的 Partition。并且，同一个 key 的消息可以保证只发送到同一个 partition，这个我们可以采用表/对象的 id 来作为 key 。</p><h3 id="Kafka-如何保证消息不丢失"><a href="#Kafka-如何保证消息不丢失" class="headerlink" title="Kafka 如何保证消息不丢失"></a>Kafka 如何保证消息不丢失</h3><h4 id="生产者丢失消息"><a href="#生产者丢失消息" class="headerlink" title="生产者丢失消息"></a>生产者丢失消息</h4><p>生产者(Producer) 调用<code>send</code>方法发送消息之后，消息可能因为网络问题并没有发送过去。</p><p>Kafka 生产者(Producer) 使用 <code>send</code> 方法发送消息实际上是异步的操作，在项目中采用了ListenableFuture类接收返回值，为其添加回调函数，记录发送日志，发现送失败，检查失败的原因之后重新发送。设置生产者的<code>retries</code> （重试次数），一般是 3，设置重发时间间隔</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">ListenableFuture</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">SendResult</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> future <span class="token operator">=</span> kafkaTemplate<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>topic<span class="token punctuation">,</span> o<span class="token punctuation">)</span><span class="token punctuation">;</span>future<span class="token punctuation">.</span><span class="token function">addCallback</span><span class="token punctuation">(</span>result <span class="token operator">-&gt;</span> logger<span class="token punctuation">.</span><span class="token function">info</span><span class="token punctuation">(</span><span class="token string">"生产者成功发送消息到topic:{} partition:{}的消息"</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">topic</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> result<span class="token punctuation">.</span><span class="token function">getRecordMetadata</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">partition</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">,</span>        ex <span class="token operator">-&gt;</span> logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"生产者发送消失败，原因：{}"</span><span class="token punctuation">,</span> ex<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>或者设置acks = all</p><p>acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p><p>acks 的默认值即1，当我们配置 <strong>acks = all</strong> 表示只有所有副本收到消息时，生产者才会接收到来自服务器的响应。但是延迟高</p><h4 id="消费者丢失消息"><a href="#消费者丢失消息" class="headerlink" title="消费者丢失消息"></a><strong>消费者丢失消息</strong></h4><p>消息在被追加到 Partition(分区)的时候都会分配一个特定的偏移量（offset）。偏移量（offset)表示 Consumer 当前消费到的 Partition(分区)的所在的位置。Kafka 通过偏移量（offset）可以保证消息在分区内的顺序性。</p><p>当消费者拉取到了分区的某个消息之后，消费者会自动提交了 offset，如果消费者在正式消费之前突然挂掉了，消息实际上没有消费，但是 offset 却被自动提交了。kafka就会认为这个消息已经消费过了，造成了消息丢失。</p><p>这个情况解决办法是：<strong>关闭自动提交 offset，每次在真正消费完消息之后再自己手动提交 offset 。</strong></p><pre class="line-numbers language-text" data-language="text"><code class="language-text">enable-auto-commit: false<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>手动提交 ：ack.acknowledge();</p><p>但是，这样会带来消息被重新消费的问题。比如刚刚消费完消息之后，还没提交 offset，结果自己挂掉了，那么这个消息理论上就会被消费两次。</p><h4 id="Kafka-丢失消息"><a href="#Kafka-丢失消息" class="headerlink" title="Kafka 丢失消息"></a><strong>Kafka 丢失消息</strong></h4><p>考虑到：假如 leader 副本所在的 broker 突然挂掉，那么就要从 follower 副本重新选出一个 leader ，但是 leader 的数据还有一些没有被 follower 副本的同步的话，就会造成消息丢失。</p><p>解决办法：</p><p><strong>设置 acks = all</strong></p><p>acks 是 Kafka 生产者(Producer) 很重要的一个参数。</p><p>acks 的默认值即1，当我们配置 <strong>acks = all</strong> 表示只有所有副本收到消息时，生产者才会接收到来自服务器的响应。</p><p><strong>设置 replication.factor &gt;= 3</strong></p><p>这样就可以保证每个 分区(partition) 至少有 3 个副本。虽然造成了数据冗余，但是带来了数据的安全性。</p><p><strong>设置 min.insync.replicas &gt; 1</strong></p><p>代表消息至少要被写入到 2 个副本才算是被成功发送。<strong>min.insync.replicas</strong> 的默认值为 1 ，在实际生产中应尽量避免默认值 1。</p><p><strong>设置 unclean.leader.election.enable = false</strong></p><p>当 leader 副本发生故障时不会从 follower 副本中和 leader 同步程度达不到要求的副本中选择出 leader ，这样降低了消息丢失的可能性。</p><h3 id="如何保证消息不被重复消费"><a href="#如何保证消息不被重复消费" class="headerlink" title="如何保证消息不被重复消费"></a>如何保证消息不被重复消费</h3><p>kafka出现消息重复消费的原因：服务端侧已经消费的数据没有成功提交 offset（根本原因）</p><p>解决方案：消费消息服务做幂等校验，比如 Redis 的set、MySQL 的主键等天然的幂等功能。保证重复消费的消息也会得出正常结果</p><p><strong>Redis 的set</strong></p><ul><li>每个消息对应一个唯一id</li><li>在消费者receive函数中，先对这个id校验，是否存在redis中</li><li>如果存在，说明该消息已经被消费过了，不用再执行</li><li>如果不存在，说明消息没有被消费，将id放入redis，然后消费这个消息</li></ul><p>幂等校验的其他方法：</p><p><strong>1、token 机制</strong></p><ol><li>客户端会先发送一个请求去获取 token，服务端会生成一个全局唯一的 ID 作为 token 保存在 redis 中，同时把这个 ID 返回给客户端</li><li>客户端第二次调用业务请求的时候必须携带这个 token</li><li>服务端会校验这个 token，如果校验成功，则执行业务，并删除 redis 中的 token</li><li>如果校验失败，说明 redis 中已经没有对应的 token，则表示重复操作，直接返回指定的结果给客户端</li></ol><p><strong>2、基于 mysql 主键唯一</strong></p><p>利用 mysql 唯一索引的特性。</p><ol><li>建立一张去重表，其中某个字段需要建立唯一索引</li><li>客户端去请求服务端，服务端会将这次请求的一些信息插入这张去重表中</li><li>因为表中某个字段带有唯一索引，如果插入成功，证明表中没有这次请求的信息，则执行后续的业务逻辑</li><li>如果插入失败，则代表已经执行过当前请求，直接返回</li></ol><h3 id="Kafka时间轮片是什么"><a href="#Kafka时间轮片是什么" class="headerlink" title="Kafka时间轮片是什么"></a>Kafka时间轮片是什么</h3><p>Kafka中的时间轮片是用于处理延迟消息的一种机制。</p><p>时间轮片的概念基于时间轮（time wheel），时间轮是一种计时器算法，用于处理定时任务或延迟任务。Kafka中的时间轮由一组时间轮片组成，每个时间轮片代表一个时间单位，例如1秒、1分钟等。</p><p>当生产者发送一个延迟消息时，Kafka会将该消息放入对应的时间轮片中。随着时间的推移，时间轮不断转动，当一个时间轮片到达指定的时间单位后，其中的消息就可以被消费者消费了。消费者会定期检查时间轮，并处理到期的消息。</p><p>时间轮片提供了一种高效的方式来管理和触发到期的延迟消息。对于某些需要处理定时任务或具有延迟要求的场景非常有用，例如实时日志处理、事件驱动架构等。</p><h3 id="大量消息在-MQ-里长时间积压，该如何解决"><a href="#大量消息在-MQ-里长时间积压，该如何解决" class="headerlink" title="大量消息在 MQ 里长时间积压，该如何解决"></a>大量消息在 MQ 里长时间积压，该如何解决</h3><p>一般这个时候，只能临时紧急扩容了，具体操作步骤和思路如下：</p><ol><li>先修复 consumer 的问题，确保其恢复消费速度，然后将现有 consumer 都停掉；</li><li>新建一个 topic，partition 是原来的 10 倍，临时建立好原先 10 倍的 queue 数量；</li><li>然后写一个临时的分发数据的 consumer 程序，这个程序部署上去消费积压的数据，消费之后不做耗时的处理，直接均匀轮询写入临时建立好的 10 倍数量的 queue；</li><li>接着临时征用 10 倍的机器来部署 consumer，每一批 consumer 消费一个临时 queue 的数据。这种做法相当于是临时将 queue 资源和 consumer 资源扩大 10 倍，以正常的 10 倍速度来消费数据；</li><li>等快速消费完积压数据之后，得恢复原先部署的架构，重新用原先的 consumer 机器来消费消息。</li></ol><h2 id="Zookeeper"><a href="#Zookeeper" class="headerlink" title="Zookeeper"></a>Zookeeper</h2><h3 id="谈下你对-Zookeeper-的认识？"><a href="#谈下你对-Zookeeper-的认识？" class="headerlink" title="谈下你对 Zookeeper 的认识？"></a>谈下你对 Zookeeper 的认识？</h3><p>ZooKeeper 是一个分布式的，开源的分布式<strong>应用程序协调服务</strong></p><p>ZooKeeper主要<strong>服务于分布式系统</strong>，可以用ZooKeeper来做：统一配置管理、统一命名服务、分布式锁、集群管理、负载均衡、分布式协调与通知、数据发布/订阅等</p><h3 id="Zookeeper-有哪些功能"><a href="#Zookeeper-有哪些功能" class="headerlink" title="Zookeeper 有哪些功能"></a>Zookeeper 有哪些功能</h3><p><strong>1. 集群管理</strong>：监控节点存活状态、运行请求等；</p><p><strong>2. 主节点选举</strong>：主节点挂掉了之后可以从备用的节点开始新一轮选主，主节点选举说的就是这个选举的过程，使用 Zookeeper 可以协助完成这个过程；</p><p><strong>3. 分布式锁</strong>：Zookeeper 提供两种锁：独占锁、共享锁。</p><p><strong>4. 命名服务</strong>：在分布式系统中，通过使用命名服务，客户端应用能够根据指定名字来获取资源或服务的地址，提供者等信息</p><h3 id="谈下你对-ZAB-协议的了解"><a href="#谈下你对-ZAB-协议的了解" class="headerlink" title="谈下你对 ZAB 协议的了解"></a>谈下你对 ZAB 协议的了解</h3><p>ZAB 协议是为分布式协调服务 Zookeeper 专门设计的一种支持崩溃恢复的原子广播协议。</p><p>ZAB 协议包括两种基本的模式：崩溃恢复和消息广播。</p><p><strong>崩溃恢复（选主）</strong></p><p>当整个 Zookeeper 集群刚刚启动或者Leader服务器宕机、重启或者网络故障导致不存在过半的服务器与 Leader 服务器保持正常通信时，所有服务器进入崩溃恢复模式，首先选举产生新的 Leader 服务器，然后集群中 Follower 服务器开始与新的 Leader 服务器进行数据同步。<strong>（超半数投票）</strong></p><p><strong>消息广播（同步）</strong></p><p>当集群中超过半数机器与该 Leader 服务器完成数据同步之后，退出恢复模式进入消息广播模式，Leader 服务器开始接收客户端的事务请求，生成事物提案来进行事务请求处理。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Kafka </tag>
            
            <tag> 消息队列 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ElasticSearch(补档)</title>
      <link href="/2023/03/09/elasticsearch-bu-dang/"/>
      <url>/2023/03/09/elasticsearch-bu-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="ElasticSearch是什么"><a href="#ElasticSearch是什么" class="headerlink" title="ElasticSearch是什么"></a>ElasticSearch是什么</h3><p>Elasticsearch 是一个实时的分布式存储、搜索、分析的引擎。</p><p>采用以往的模糊查询，模糊查询前置配置，会放弃索引，导致商品查询是全表扫面，在百万级别的数据库中，效率非常低下，而我们使用ES做一个全文索引，我们将经常查询的商品的某些字段，比如说商品名，描述、价格还有id这些字段我们放入我们索引库里，可以提高查询速度。</p><h3 id="ES同类产品有哪些"><a href="#ES同类产品有哪些" class="headerlink" title="ES同类产品有哪些"></a>ES同类产品有哪些</h3><p>Solr：Solr是用Java编写、运行在Servlet容器的一个独立的全文搜索服务器。</p><h3 id="全文检索是什么"><a href="#全文检索是什么" class="headerlink" title="全文检索是什么"></a>全文检索是什么</h3><p>全文检索（Full-Text Search）：对文本或文档集合进行关键词搜索的技术和功能。它不仅仅是简单的字符串匹配，还包括了分析、索引和搜索等多个步骤。</p><ul><li><p>分词：首先需要对文本进行分析，将其切分成单词或词组的集合。</p></li><li><p>对分词索引构建：索引是根据关键词和其对应的文档信息构建起来的数据结构，一般采用倒排索引实现。索引会记录每个关键词出现的位置、频率以及相关的文档信息。</p></li></ul><p>当用户输入一个查询词时，全文检索系统会通过查询解析，分析用户输入的关键词，并根据建立的索引进行匹配。全文检索系统会返回与查询词相关性最高的文档列表</p><h3 id="倒排索引是什么"><a href="#倒排索引是什么" class="headerlink" title="倒排索引是什么"></a>倒排索引是什么</h3><p>以前是根据ID查内容，倒排索引之后是根据内容查ID，然后再拿着ID去查询出来真正需要的东西。</p><p>倒排索引（Inverted Index）是一种数据结构，用于实现全文搜索和快速查找的功能。它由两部分组成：<strong>词项（Term）和倒排列表（Inverted List）</strong>。</p><ul><li>词项：文档中的某个单词或短语。</li><li>倒排列表：将每个词项映射到包含该词项的文档列表中。每个文档列表中记录了出现该词项的文档的相关信息，比如文档的标识符、位置等。</li></ul><p>倒排索引的优势在于它能够快速定位和匹配文档，而无需遍历所有文档，适用于大规模文本数据的搜索和查询场景。</p><h3 id="Lucene是什么"><a href="#Lucene是什么" class="headerlink" title="Lucene是什么"></a>Lucene是什么</h3><p>Lucene就是一个jar包，里面包含了各种建立倒排索引的方法，java开发的时候只需要导入这个jar包就可以开发了。</p><p>ES 和 Lucene的区别:</p><p>Lucene不是分布式的。<br>ES的底层就是Lucene，ES是分布式的</p><h3 id="为什么不用数据库去实现搜索功能"><a href="#为什么不用数据库去实现搜索功能" class="headerlink" title="为什么不用数据库去实现搜索功能"></a>为什么不用数据库去实现搜索功能</h3><p>%***%模糊查询</p><ol><li>需要全表扫描</li><li>字段里的所有内容都需要匹配</li><li>%*、、、、*%这样的需要全文检索</li></ol><h3 id="ES的核心概念"><a href="#ES的核心概念" class="headerlink" title="ES的核心概念"></a>ES的核心概念</h3><p><strong>cluster集群，ES是一个分布式的系统</strong></p><p>群集是一个或多个节点（服务器）的集合，它们共同保存整个数据，并提供跨所有节点的联合索引和搜索功能。</p><p>群集由唯一名称标识，默认情况下为“elasticsearch”。</p><p><strong>shard：分片</strong></p><p>一台服务器，无法存储大量的数据，ES把一个index里面的数据，分为多个shard，分布式的存储在各个服务器上面。</p><p><strong>replica：副本</strong></p><p>在ES集群中，一模一样的数据有多份，能正常提供查询和插入的分片我们叫做 primary shard，其余的我们就管他们叫做 replica shard（备份的分片） </p><p>当查询数据的时候，数据是有备份的，它会同时发出命令让有数据的机器去查询结果，最后谁的查询结果快，就要谁的数据</p><p><strong>Node节点</strong></p><p>就是集群中的一台服务器，存储数据并参与群集索引和搜索功能。</p><p><strong>index 索引</strong></p><p>ES中的索引非传统索引的含义，ES中的索引是存放数据的地方，是ES中的一个概念词汇</p><p>索引就像关系数据库中的“数据库”。它有一个定义多种类型的映射。索引是逻辑名称空间，映射到一个或多个主分片，并且可以有零个或多个副本分片。</p><p><strong>type类型</strong></p><p>类型是用来定义数据结构的，是索引的逻辑分区</p><p>在每一个index下面，可以有一个或者多个type，就像数据库里面的一张表。</p><p>相当于表结构的描述，描述每个字段的类型。</p><p><strong>document：文档</strong></p><p>文档类似于关系数据库中的一行。</p><p>不同之处在于索引中的每个文档可以具有不同的结构（字段），但是对于通用字段应该具有相同的数据类型。</p><p><strong>Field 字段</strong></p><p>就像关系型数据库中列的概念，一个document有一个或者多个field组成。</p><h3 id="ES写数据过程"><a href="#ES写数据过程" class="headerlink" title="ES写数据过程"></a>ES写数据过程</h3><ul><li>客户端选择一个 node 发送请求过去，这个 node 就是&nbsp;<code>coordinating node</code>（协调节点）。</li><li><code>coordinating node</code>&nbsp;对 document 进行路由，将请求转发给对应的 node（有 primary shard）。</li><li>实际的 node 上的&nbsp;<code>primary shard</code>&nbsp;处理请求，然后将数据同步到&nbsp;<code>replica node</code>。</li><li>  <code>coordinating node</code>&nbsp;如果发现&nbsp;<code>primary node</code>&nbsp;和所有&nbsp;<code>replica node</code>&nbsp;都搞定之后，就返回响应结果给客户端。</li></ul><h3 id="写数据底层原理"><a href="#写数据底层原理" class="headerlink" title="写数据底层原理"></a>写数据底层原理</h3><p><img src="/images/image_ElasticSearch/05.jpg"></p><p>先写入内存 buffer，在 buffer 里的时候数据是搜索不到的；同时将数据写入 translog 日志文件。</p><p>如果 buffer 快满了，或者到一定时间，就会将内存 buffer 数据&nbsp;<code>refresh</code>&nbsp;到一个新的&nbsp;<code>segment file</code>&nbsp;中，但是此时数据不是直接进入&nbsp;<code>segment file</code>&nbsp;磁盘文件，而是先进入&nbsp;<code>os cache</code>&nbsp;。这个过程就是&nbsp;<code>refresh</code>。</p><p>每隔 1 秒钟，es 将 buffer 中的数据写入一个新的&nbsp;<code>segment file</code>，每秒钟会产生一个新的磁盘文件&nbsp;<code>segment file</code>，这个&nbsp;<code>segment file</code>&nbsp;中就存储最近 1 秒内 buffer 中写入的数据。</p><p>但是如果 buffer 里面此时没有数据，那当然不会执行 refresh 操作，如果 buffer 里面有数据，默认 1 秒钟执行一次 refresh 操作，刷入一个新的 segment file 中。</p><p><strong>总结</strong>：数据先写入内存 buffer，然后每隔 1s，将数据 refresh 到 os cache，到了 os cache 数据就能被搜索到（所以我们才说 es 从写入到能被搜索到，中间有 1s 的延迟）。每隔 5s，将数据写入 translog 文件（这样如果机器宕机，内存数据全没，最多会有 5s 的数据丢失），translog 大到一定程度，或者默认每隔 30mins，会触发 commit 操作，将缓冲区的数据都 flush 到 segment file 磁盘文件中。</p><h3 id="ES搜索数据过程"><a href="#ES搜索数据过程" class="headerlink" title="ES搜索数据过程"></a>ES搜索数据过程</h3><ul><li>客户端发送请求到一个&nbsp;<code>coordinate node</code>。</li><li>协调节点将搜索请求转发到所有的 shard 对应的&nbsp;<code>primary shard</code>&nbsp;或&nbsp;<code>replica shard</code>，都可以。</li><li>query phase：每个 shard 将自己的搜索结果（其实就是一些&nbsp;<code>doc id</code>）返回给协调节点，由协调节点进行数据的合并、排序、分页等操作，产出最终结果。</li><li>  fetch phase：接着由协调节点根据&nbsp;<code>doc id</code>&nbsp;去各个节点上拉取实际的&nbsp;<code>document</code>&nbsp;数据，最终返回给客户端。</li></ul><h3 id="ES读数据过程"><a href="#ES读数据过程" class="headerlink" title="ES读数据过程"></a>ES读数据过程</h3><p>可以通过&nbsp;<code>doc id</code>&nbsp;来查询，会根据&nbsp;<code>doc id</code>&nbsp;进行 hash，判断出来当时把&nbsp;<code>doc id</code>&nbsp;分配到了哪个 shard 上面去，从那个 shard 去查询。</p><ul><li>客户端发送请求到任意一个 node，成为&nbsp;<code>coordinate node</code>。</li><li><code>coordinate node</code>&nbsp;对&nbsp;<code>doc id</code>&nbsp;进行哈希路由，将请求转发到对应的 node，此时会使用&nbsp;<code>round-robin</code>随机轮询算法，在&nbsp;<code>primary shard</code>&nbsp;以及其所有 replica 中随机选择一个，让读请求负载均衡。</li><li>接收请求的 node 返回 document 给&nbsp;<code>coordinate node</code>。</li><li>  <code>coordinate node</code>&nbsp;返回 document 给客户端。</li></ul><blockquote><p>写请求是写入 primary shard，然后同步给所有的 replica shard；读请求可以从 primary shard 或replica shard 读取，采用的是随机轮询算法。</p></blockquote><h3 id="删除-更新数据底层原理"><a href="#删除-更新数据底层原理" class="headerlink" title="删除/更新数据底层原理"></a>删除/更新数据底层原理</h3><p>如果是删除操作，commit 的时候会生成一个&nbsp;<code>.del</code>&nbsp;文件，里面将某个 doc 标识为&nbsp;<code>deleted</code>&nbsp;状态，那么搜索的时候根据&nbsp;<code>.del</code>&nbsp;文件就知道这个 doc 是否被删除了。</p><p>如果是更新操作，就是将原来的 doc 标识为&nbsp;<code>deleted</code>&nbsp;状态，然后新写入一条数据。</p><p>buffer 每 refresh 一次，就会产生一个&nbsp;<code>segment file</code>，所以默认情况下是 1 秒钟一个&nbsp;<code>segment file</code>，这样下来&nbsp;<code>segment file</code>&nbsp;会越来越多，此时会定期执行 merge。每次 merge 的时候，会将多个&nbsp;<code>segment file</code>&nbsp;合并成一个，同时这里会将标识为&nbsp;<code>deleted</code>&nbsp;的 doc 给物理删除掉，然后将新的&nbsp;<code>segment file</code>&nbsp;写入磁盘，这里会写一个&nbsp;<code>commit point</code>，标识所有新的&nbsp;<code>segment file</code>，然后打开&nbsp;<code>segment file</code>&nbsp;供搜索使用，同时删除旧的&nbsp;<code>segment file</code>。</p><h3 id="Elasticsearch是如何实现Master选举的"><a href="#Elasticsearch是如何实现Master选举的" class="headerlink" title="Elasticsearch是如何实现Master选举的"></a>Elasticsearch是如何实现Master选举的</h3><p>Elasticsearch的选主是ZenDiscovery模块负责的，主要包含Ping（节点之间通过这个RPC来发现彼此）和Unicast（单播模块包含一个主机列表以控制哪些节点需要ping通）这两部分；<br>　<br>对所有可以成为master的节点（node.master: true）根据nodeId字典排序，每次选举每个节点都把自己所知道节点排一次序，然后选出第一个（第0位）节点，暂且认为它是master节点。<br>　<br>如果对某个节点的投票数达到一定的值（n/2+1）并且该节点自己也选举自己，那这个节点就是master。否则重新选举一直到满足上述条件。</p><h3 id="Elasticsearch中的节点（比如共20个），其中的10个选了一个master，另外10个选了另一个master，怎么办"><a href="#Elasticsearch中的节点（比如共20个），其中的10个选了一个master，另外10个选了另一个master，怎么办" class="headerlink" title="Elasticsearch中的节点（比如共20个），其中的10个选了一个master，另外10个选了另一个master，怎么办"></a>Elasticsearch中的节点（比如共20个），其中的10个选了一个master，另外10个选了另一个master，怎么办</h3><p>当集群master候选数量不小于3个时，可以通过设置最少投票通过数量，超过所有候选节点一半以上来解决脑裂问题；  </p><p>当候选数量为两个时，只能修改为唯一的一个master候选，其他作为data节点，避免脑裂问题</p><h3 id="在并发情况下，Elasticsearch如果保证读写一致"><a href="#在并发情况下，Elasticsearch如果保证读写一致" class="headerlink" title="在并发情况下，Elasticsearch如果保证读写一致"></a>在并发情况下，Elasticsearch如果保证读写一致</h3><p>可以通过版本号使用乐观并发控制，以确保新版本不会被旧版本覆盖，由应用层来处理具体的冲突；<br>　<br>对于写操作，一致性级别支持quorum/one/all，默认为quorum，即只有当大多数分片可用时才允许写操作。但即使大多数可用，也可能存在因为网络等原因导致写入副本失败，这样该副本被认为故障，分片将会在一个不同的节点上重建。</p><p>对于读操作，可以设置replication为sync(默认)，这使得操作在主分片和副本分片都完成后才会返回；如果设置replication为async时，也可以通过设置搜索请求参数_preference为primary来查询主分片，确保文档是最新版本。</p><h3 id="什么是-Analysis（分词）"><a href="#什么是-Analysis（分词）" class="headerlink" title="什么是 Analysis（分词）"></a>什么是 Analysis（分词）</h3><p>文本分析就是<strong>把全文本转换成一系列单词（term/token）的过程</strong>，也叫<strong>分词</strong>。</p><p>在 ES 中，Analysis 是通过<strong>分词器（Analyzer）</strong>&nbsp;来实现的，可使用 ES 内置的分析器或者按需定制化分析器。</p><h3 id="分词器是什么"><a href="#分词器是什么" class="headerlink" title="分词器是什么"></a>分词器是什么</h3><p>分词器是专门处理分词的组件，分词器由以下三部分组成：</p><ul><li><strong>Character Filters</strong>：针对原始文本处理，比如去除 html 标签</li><li><strong>Tokenizer</strong>：按照规则切分为单词，比如按照空格切分</li><li><strong>Token Filters</strong>：将切分的单词进行加工，比如大写转小写，删除 stopwords，增加同义语</li></ul><p>其中，ES 内置了许多分词器：</p><ul><li><strong>Standard Analyzer</strong>&nbsp;- 默认分词器，按词切分，小写处理</li><li><strong>Simple Analyzer</strong>&nbsp;- 按照非字母切分（符号被过滤），小写处理</li><li><strong>Stop Analyzer</strong>&nbsp;- 小写处理，停用词过滤（the ，a，is）</li><li><strong>Whitespace Analyzer</strong>&nbsp;- 按照空格切分，不转小写</li><li><strong>Keyword Analyzer</strong>&nbsp;- 不分词，直接将输入当做输出</li><li><strong>Pattern Analyzer</strong>&nbsp;- 正则表达式，默认 \W+</li><li><strong>Language</strong>&nbsp;- 提供了 30 多种常见语言的分词器</li><li><strong>Customer Analyzer</strong>&nbsp;- 自定义分词器</li></ul><h3 id="说说-Stamdard-Analyzer-分词器"><a href="#说说-Stamdard-Analyzer-分词器" class="headerlink" title="说说 Stamdard Analyzer&nbsp;分词器"></a>说说 Stamdard Analyzer&nbsp;分词器</h3><p>它是 ES&nbsp;<strong>默认的分词器</strong>，它会对输入的文本<strong>按词的方式进行切分</strong>，切分好以后会进行<strong>转小写</strong>处理，<strong>默认的 stopwords 是关闭的</strong>。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">GET _analyze{  "analyzer": "standard",  "text": "In 2020, Java is the best language in the world."}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>运行结果如下：</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">{  "tokens" : [    {      "token" : "in",      "start_offset" : 0,      "end_offset" : 2,      "type" : "&lt;ALPHANUM&gt;",      "position" : 0    },    {      "token" : "2020",      "start_offset" : 3,      "end_offset" : 7,      "type" : "&lt;NUM&gt;",      "position" : 1    },    {      "token" : "java",      "start_offset" : 9,      "end_offset" : 13,      "type" : "&lt;ALPHANUM&gt;",      "position" : 2    },    {      "token" : "is",      "start_offset" : 14,      "end_offset" : 16,      "type" : "&lt;ALPHANUM&gt;",      "position" : 3    },    {      "token" : "the",      "start_offset" : 17,      "end_offset" : 20,      "type" : "&lt;ALPHANUM&gt;",      "position" : 4    },    {      "token" : "best",      "start_offset" : 21,      "end_offset" : 25,      "type" : "&lt;ALPHANUM&gt;",      "position" : 5    },    {      "token" : "language",      "start_offset" : 26,      "end_offset" : 34,      "type" : "&lt;ALPHANUM&gt;",      "position" : 6    },    {      "token" : "in",      "start_offset" : 35,      "end_offset" : 37,      "type" : "&lt;ALPHANUM&gt;",      "position" : 7    },    {      "token" : "the",      "start_offset" : 38,      "end_offset" : 41,      "type" : "&lt;ALPHANUM&gt;",      "position" : 8    },    {      "token" : "world",      "start_offset" : 42,      "end_offset" : 47,      "type" : "&lt;ALPHANUM&gt;",      "position" : 9    }  ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看出是按照空格、非字母的方式对输入的文本进行了转换，比如对&nbsp;<code>Java</code>&nbsp;做了转小写，对一些停用词也没有去掉，比如&nbsp;<code>in</code>。</p><p>其中&nbsp;<code>token</code>&nbsp;为分词结果；<code>start_offset</code>&nbsp;为起始偏移；<code>end_offset</code>&nbsp;为结束偏移；<code>position</code>&nbsp;为分词位置。</p><h3 id="中文分词器"><a href="#中文分词器" class="headerlink" title="中文分词器"></a>中文分词器</h3><p>中文分词有特定的难点，不像英文，单词有自然的空格作为分隔，在中文句子中，不能简单地切分成一个个的字，而是需要分成有含义的词，但是在不同的上下文，是有不同的理解的。</p><p><code>ICU Analyzer</code>&nbsp;分词器，它提供了 Unicode 的支持，更好的支持亚洲语言</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">{  "tokens" : [    {      "token" : "各国",      "start_offset" : 0,      "end_offset" : 2,      "type" : "&lt;IDEOGRAPHIC&gt;",      "position" : 0    },    {      "token" : "有",      "start_offset" : 2,      "end_offset" : 3,      "type" : "&lt;IDEOGRAPHIC&gt;",      "position" : 1    },    {      "token" : "企业",      "start_offset" : 3,      "end_offset" : 5,      "type" : "&lt;IDEOGRAPHIC&gt;",      "position" : 2    },    {      "token" : "相继",      "start_offset" : 5,      "end_offset" : 7,      "type" : "&lt;IDEOGRAPHIC&gt;",      "position" : 3    },    {      "token" : "秋招",      "start_offset" : 7,      "end_offset" : 9,      "type" : "&lt;IDEOGRAPHIC&gt;",      "position" : 4    }  ]}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>可以看到分成了<code>各国</code>，<code>有</code>，<code>企业</code>，<code>相继</code>，<code>秋招</code>，显然比刚才的效果好了很多。</p><p>中文分词器还有 IK分词器</p><h3 id="说说IK分词器"><a href="#说说IK分词器" class="headerlink" title="说说IK分词器"></a>说说IK分词器</h3><p>ik分词器就是一个标准的中文分词器。它可以根据定义的字典对域进行分词，并且支持用户配置自己的字典，所以它除了可以按通用的习惯分词外，我们还可以定制化分词。</p><p>IK分词是一个基于<strong>词典</strong>的分词器，只有包含在词典的词才能被正确切分，IK解决分词歧义只是根据几条可能是最佳的分词实践规则，并没有用到任何概率模型，也不具有新词发现的功能。</p><p><strong>ik分词器2种模式</strong></p><p>ik_smart&nbsp;：最粗粒度的拆分<br>ik_max_word&nbsp;：最细粒度的拆分</p><p><strong>自定义字典</strong></p><p>2个配置&nbsp;<strong>ext_dict</strong>&nbsp;和&nbsp;<strong>ext_stopwords</strong>。分别是扩展和停用字典</p><p>在config目录新建 my_ext.dic 和 my_stop.dic</p><p>然后配置到 IKAnalyzer.cfg</p>]]></content>
      
      
      
        <tags>
            
            <tag> ElasticSearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis(补档)</title>
      <link href="/2023/03/04/mybatis-bu-dang/"/>
      <url>/2023/03/04/mybatis-bu-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="数据持久化是什么"><a href="#数据持久化是什么" class="headerlink" title="数据持久化是什么"></a>数据持久化是什么</h3><p>数据持久化是将内存中的数据模型转换为存储模型，以及将存储模型转换为内存中的数据模型的统称。</p><p>数据模型可以是任何数据结构或对象的模型、XML、二进制流等。 当我们编写应用程序操作数据库，对表数据进行增删改查的操作的时候就是数据持久化的操作。</p><h3 id="ORM是什么"><a href="#ORM是什么" class="headerlink" title="ORM是什么"></a>ORM是什么</h3><p>ORM（Object/Relational Mapping）即对象关系映射，是一种数据持久化技术。它在对象模型和关系型数据库直接建立起对应关系，并且提供一种机制，通过JavaBean对象去操作数据库表的数据。 </p><p>MyBatis通过简单的XML或者注解的方式进行配置和原始映射，将实体类和SQL语句之间建立映射关系，是一种半自动（之所以说是半自动，因为我们要自己写SQL）的ORM实现。</p><h3 id="Mybatis是什么"><a href="#Mybatis是什么" class="headerlink" title="Mybatis是什么"></a>Mybatis是什么</h3><ul><li>MyBatis框架是一个开源的数据持久层框架。</li><li>它的内部封装了通过JDBC访问数据库的操作，支持普通的SQL查询、存储过程和高级映射，几乎消除了所有的JDBC代码和参数的手工设置以及结果集的检索。</li><li>MyBatis作为持久层框架，其主要思想是将程序中的大量SQL语句剥离出来，配置在配置文件当中，实现SQL的灵活配置。</li><li>这样做的好处是将SQL与程序代码分离，可以在不修改代码的情况下，直接在配置文件当中修改SQL。</li></ul><p>MyBatis底层技术主要包括以下几个方面：</p><ol><li>JDBC：JDBC是Java语言中用于访问关系型数据库的API，MyBatis框架基于JDBC技术来实现与数据库的交互。MyBatis使用JDBC来执行SQL语句和处理结果集，同时还通过JDBC提供了事务管理支持。</li><li>SQL解析：MyBatis使用OGNL表达式语言进行SQL解析。在XML中配置的SQL语句会被解析成一个可执行的SQL对象。该SQL对象中存储了SQL语句的各种信息（例如参数、返回值等），以及与之对应的Java类和属性信息。</li><li>映射器：MyBatis使用映射器（Mapper）来定义SQL语句与Java类之间的映射关系。映射器中定义了方法与SQL语句之间的对应关系，以及方法的返回值类型等信息。MyBatis可以通过注解或XML文件来定义映射器。</li><li>缓存：MyBatis提供了强大的缓存机制，缓存可以大幅提高系统性能。MyBatis支持一级缓存和二级缓存。一级缓存指的是SqlSession级别的缓存，二级缓存指的是Mapper级别的缓存。</li><li>插件机制：MyBatis提供了插件机制，可以在框架的运行过程中对SQL语句进行拦截和修改。开发人员可以通过插件机制拓展MyBatis的功能，提高框架的灵活性和可扩展性。</li></ol><h3 id="MyBatis框架的优缺点及其适用的场合"><a href="#MyBatis框架的优缺点及其适用的场合" class="headerlink" title="MyBatis框架的优缺点及其适用的场合"></a>MyBatis框架的优缺点及其适用的场合</h3><p><strong>优点</strong></p><ol><li>与JDBC相比，减少了50%以上的代码量。</li><li>MyBatis是易学的持久层框架，小巧并且简单易学。</li><li>MyBatis相当灵活，不会对应用程序或者数据库的现有设计强加任何影响，SQL写在XML文件里，从程序代码中彻底分离，降低耦合度，便于统一的管理和优化，并可重用。</li><li>提供XML标签，支持编写动态的SQL，满足不同的业务需求。</li><li>提供映射标签，支持对象与数据库的ORM字段关系映射。</li></ol><p><strong>缺点</strong></p><ol><li>SQL语句的编写工作量较大，对开发人员编写SQL的能力有一定的要求。</li><li>SQL语句依赖于数据库，导致数据库不具有好的移植性，不可以随便更换数据库。</li></ol><p><strong>适用场景</strong></p><p>MyBatis专注于SQL自身，是一个足够灵活的DAO层解决方案。对性能的要求很高，或者需求变化较多的项目，例如Web项目，那么MyBatis是不二的选择。</p><h3 id="MyBatis与Hibernate有哪些不同"><a href="#MyBatis与Hibernate有哪些不同" class="headerlink" title="MyBatis与Hibernate有哪些不同"></a>MyBatis与Hibernate有哪些不同</h3><ol><li>Mybatis和hibernate不同，它不完全是一个ORM框架，因为MyBatis需要程序员自己编写Sql语句。</li><li>Mybatis直接编写原生态sql，可以严格控制sql执行性能，灵活度高</li><li>Hibernate数据库移植性远大于Mybatis，Mybatis无法做到数据库无关性，如果需要实现支持多种数据库的软件，则需要自定义多套sql映射文件，工作量大。</li><li>Hibernate对象/关系映射能力强，数据库无关性好，可以节省很多代码，但是使用难度比Mybatis高</li></ol><h3 id="Mybatis缓存了解吗"><a href="#Mybatis缓存了解吗" class="headerlink" title="Mybatis缓存了解吗"></a>Mybatis缓存了解吗</h3><p>mybatis有二级缓存的，其中一级缓存默认开启，二级缓存需要手动配置开启，</p><p><strong>一级缓存</strong></p><ol><li>一级缓存是默认开启的；  </li><li>底层其实是基于hashmap的本地内存缓存；  </li><li>作用域是session（其实就相当于一个方法）；  </li><li>当session关闭或者刷新的时候缓存清空；  </li><li>不同sqlsession之间缓存互不影响；</li></ol><p>一级缓存有数据一致性问题：</p><p>比如：有两个更新操作对同一条数据<br>如果是sqlsessionA进行了更新操作，则sqlsessionA对应的一级缓存被清空；<br>如果是sqlsessionB进行了更新操作，则此更新操作对改sqlsessionA不可见；<br>那么其实这个时候sqlsessionA再查的数据就是过期失效数据了；</p><p>建议：</p><ol><li>单个sqlsession的生命周期不能过长；  </li><li>如果是对同一个语句更新尽量使用同一个sql，也就是同一个sqlsession；  </li><li>建议关闭一级缓存，</li></ol><p><strong>二级缓存</strong></p><ol><li>二级缓存需要我们手动开启，它是mapper级别的缓存；  </li><li>也是基于HashMap存储</li><li>作用范围是同一个 namespace 下的mapper 映射文件内容。</li><li>多个 SqlSession 之间可以共享缓存内容</li></ol><p>如果对某一个表的操作查询可能有多个namespace，那么得到的数据就是有问题的；</p><p>建议关闭mybatis的一级缓存和二级缓存</p><h3 id="和-的区别是什么？"><a href="#和-的区别是什么？" class="headerlink" title="#{}和${}的区别是什么？"></a>#{}和${}的区别是什么？</h3><ol><li><code>#{}</code>&nbsp;是预编译处理，<code>${}</code>是字符串替换。</li><li>Mybatis在处理<code>#{}</code>时，会将sql中的<code>#{}</code>替换为?号，调用PreparedStatement的set方法来赋值；</li><li>Mybatis在处理<code>${}</code>时，就是把<code>${}</code>替换成变量的值。</li><li>使用<code>#{}</code>可以有效的防止SQL注入，提高系统安全性。#{}是经过预编译的，是安全的；${}是未经过预编译的，仅仅是取变量的值，是非安全的，存在SQL注入。</li></ol><h3 id="mybatis是如何做到防止sql注入的"><a href="#mybatis是如何做到防止sql注入的" class="headerlink" title="mybatis是如何做到防止sql注入的"></a>mybatis是如何做到防止sql注入的</h3><p>SQL注入是一种常见的攻击方式。攻击者在界面的表单信息或URL上输入一些奇怪的SQL片段（例如“or ‘1’=’1’”这样的语句），有可能入侵参数检验不足的应用程序。</p><p>MyBatis的SQL是一个具有“输入+输出”的功能，类似于函数的结构。使用#的即输入参数在SQL中拼接的部分，传入参数后，打印出执行的SQL语句，会看到SQL是这样的：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java">select id<span class="token punctuation">,</span> username<span class="token punctuation">,</span> password from user where username<span class="token operator">=</span><span class="token operator">?</span> and password<span class="token operator">=</span><span class="token operator">?</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>MyBatis启用了预编译功能，在SQL执行前，会先将上面的SQL发送给数据库进行编译；执行时，直接使用编译好的SQL，替换占位符“?”就可以了。</p><p>因为SQL注入只能对编译过程起作用，所以这样的方式就很好地避免了SQL注入的问题。</p><h3 id="实体类的属性名和表的字段名不一样怎么办"><a href="#实体类的属性名和表的字段名不一样怎么办" class="headerlink" title="实体类的属性名和表的字段名不一样怎么办"></a>实体类的属性名和表的字段名不一样怎么办</h3><ol><li>通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致。</li><li>使用 @Results 和 @Result 注解来配置映射关系。</li><li>在 SQL XML映射文件中通过 &lt; resultMap &gt; 和 &lt; result &gt; 标签来配置映射关系。</li></ol><h3 id="Dao接口的工作原理是什么"><a href="#Dao接口的工作原理是什么" class="headerlink" title="Dao接口的工作原理是什么"></a>Dao接口的工作原理是什么</h3><p>Dao接口即Mapper接口。<br>接口的全限名，就是映射文件中的namespace的值；<br>接口的方法名，就是映射文件中Mapper的Statement的id值；<br>接口方法内的参数，就是传递给sql的参数。</p><p>Mapper 接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Mapper接口生成代理对象proxy，代理对象会拦截接口方法，转而执行MapperStatement所代表的sql，然后将sql执行结果返回。</p><h3 id="Dao接口里的方法，参数不同时，方法能重载吗"><a href="#Dao接口里的方法，参数不同时，方法能重载吗" class="headerlink" title="Dao接口里的方法，参数不同时，方法能重载吗"></a>Dao接口里的方法，参数不同时，方法能重载吗</h3><p>Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MapperStatement。Mapper接口里的方法，是不能重载的，因为是使用 全限名+方法名 的保存和寻找策略。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SQL优化常用方法(补档)</title>
      <link href="/2023/02/28/sql-you-hua-chang-yong-fang-fa-bu-dang/"/>
      <url>/2023/02/28/sql-you-hua-chang-yong-fang-fa-bu-dang/</url>
      
        <content type="html"><![CDATA[<p>1、对查询进行优化，应尽量避免全表扫描，首先应考虑在 where 及 order by 涉及的列上建立索引。</p><p>2、应尽量避免在 where 子句中使用!=或&lt;&gt;操作符，否则将引擎放弃使用索引而进行全表扫描。</p><p>3、应尽量避免在 where 子句中对字段进行 null 值判断，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num <span class="token operator">is</span> <span class="token boolean">null</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以在num列设置默认值0，然后通过=等号查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>4、应尽量避免在 where 子句中使用 or 来连接条件，否则将导致引擎放弃使用索引而进行全表扫描，如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">10</span> <span class="token operator">or</span> num<span class="token operator">=</span><span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>此查询可优化为：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">10</span>    <span class="token keyword">union</span> <span class="token keyword">all</span>    <span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">20</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>5、下面的查询也将导致全表扫描：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'%abc%'</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若要提高效率，可以考虑全文检索。</p><p>6、in 和 not in 也要慎用，否则会导致全表扫描，如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num <span class="token operator">in</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>若查询的数值为连续值，则可以优化为between来查询：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num <span class="token operator">between</span> <span class="token number">1</span> <span class="token operator">and</span> <span class="token number">3</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>7、如果在 where 子句中使用参数，也会导致全表扫描。因为SQL只有在运行时才会解析局部变量，但优化程序不能将访问，计划的选择推迟到运行时；它必须在编译时进行选择。然而，如果在编译时建立访问计划，变量的值还是未知的，因而无法作为索引选择的输入项。如下面语句将进行全表扫描：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token variable">@num</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以改为强制查询使用索引：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">with</span><span class="token punctuation">(</span><span class="token keyword">index</span><span class="token punctuation">(</span>索引名<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token variable">@num</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>8、应尽量避免在 where 子句中对字段进行表达式操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">/</span><span class="token number">2</span><span class="token operator">=</span><span class="token number">100</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>应改为:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">elect id <span class="token keyword">from</span> t <span class="token keyword">where</span> num<span class="token operator">=</span><span class="token number">100</span><span class="token operator">*</span><span class="token number">2</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>9、应尽量避免在where子句中对字段进行函数操作，这将导致引擎放弃使用索引而进行全表扫描。如：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> substring<span class="token punctuation">(</span>name<span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token string">'abc'</span><span class="token comment">--name以abc开头的id</span><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> datediff<span class="token punctuation">(</span><span class="token keyword">day</span><span class="token punctuation">,</span>createdate<span class="token punctuation">,</span><span class="token string">'2005-11-30'</span><span class="token punctuation">)</span><span class="token operator">=</span><span class="token number">0</span><span class="token comment">--'2005-11-30'生成的id</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>应改为:</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> name <span class="token operator">like</span> <span class="token string">'abc%'</span><span class="token keyword">select</span> id <span class="token keyword">from</span> t <span class="token keyword">where</span> createdate<span class="token operator">&gt;=</span><span class="token string">'2005-11-30'</span> <span class="token operator">and</span> createdate<span class="token operator">&lt;</span><span class="token string">'2005-12-1'</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>10、不要在 where 子句中的“=”左边进行函数、算术运算或其他表达式运算，否则系统将可能无法正确使用索引。</p><p> 11、在使用索引字段作为条件时，如果该索引是复合索引，那么必须使用到该索引中的第一个字段作为条件时才能保证系统使用该索引，否则该索引将不会被使用，并且应尽可能的让字段顺序与索引顺序相一致。</p><p>12、不要写一些没有意义的查询，如需要生成一个空表结构：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> col1<span class="token punctuation">,</span>col2 <span class="token keyword">into</span> <span class="token comment">#t from t where 1=0</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>这类代码不会返回任何结果集，但是会消耗系统资源的，应改成这样：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">create</span> <span class="token keyword">table</span> <span class="token comment">#t(...)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>13、很多时候用 exists 代替 in 是一个好的选择：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> num <span class="token keyword">from</span> a <span class="token keyword">where</span> num <span class="token operator">in</span><span class="token punctuation">(</span><span class="token keyword">select</span> num <span class="token keyword">from</span> b<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>用下面的语句替换：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">select</span> num <span class="token keyword">from</span> a <span class="token keyword">where</span> <span class="token keyword">exists</span><span class="token punctuation">(</span><span class="token keyword">select</span> <span class="token number">1</span> <span class="token keyword">from</span> b <span class="token keyword">where</span> num<span class="token operator">=</span>a<span class="token punctuation">.</span>num<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>14、并不是所有索引对查询都有效，SQL是根据表中数据来进行查询优化的，当索引列有大量数据重复时，SQL查询可能不会去利用索引，如一表中有字段sex，male、female几乎各一半，那么即使在sex上建了索引也对查询效率起不了作用。</p><p>15、索引并不是越多越好，索引固然可以提高相应的 select 的效率，但同时也降低了 insert 及 update 的效率，因为 insert 或update 时有可能会重建索引，所以怎样建索引需要慎重考虑，视具体情况而定。一个表的索引数最好不要超过6个，若太多则应考虑一些不常使用到的列上建的索引是否有必要。</p><p>16、应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><p>17、应尽可能的避免更新 clustered 索引数据列，因为 clustered 索引数据列的顺序就是表记录的物理存储顺序，一旦该列值改变将导致整个表记录的顺序的调整，会耗费相当大的资源。若应用系统需要频繁更新 clustered 索引数据列，那么需要考虑是否应将该索引建为 clustered 索引。</p><p>18、尽可能的使用varchar/nvarchar 代替 char/nchar ，因为首先变长字段存储空间小，可以节省存储空间，其次对于查询来说，在一个相对较小的字段内搜索效率显然要高些。</p><p>19、任何地方都不要使用 select * from t ，用具体的字段列表代替“*”，不要返回用不到的任何字段。</p><p>20、尽量使用表变量来代替临时表。如果表变量包含大量数据，请注意索引非常有限（只有主键索引）。</p><p>21、避免频繁创建和删除临时表，以减少系统表资源的消耗。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring Boot(补档)</title>
      <link href="/2023/02/26/spring-boot-bu-dang/"/>
      <url>/2023/02/26/spring-boot-bu-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是-Spring-Boot"><a href="#什么是-Spring-Boot" class="headerlink" title="什么是 Spring Boot"></a>什么是 Spring Boot</h3><p>Spring Boot 是 Spring 开源组织下的子项目，简化了 Spring的开发，省去繁重的xml文件配置，提供了各种启动器（starter），使开发者能快速上手,更加专注业务开发，提高开发效率。</p><h3 id="Spring-Boot-有哪些优点"><a href="#Spring-Boot-有哪些优点" class="headerlink" title="Spring Boot 有哪些优点"></a>Spring Boot 有哪些优点</h3><ol><li>容易上手，提升开发效率，为 Spring 开发提供一个更快、更简单的开发框架。</li><li>开箱即用（指在pom.xml文件中加入需要的依赖包），远离繁琐的配置。</li><li>提供了一系列大型项目通用的非业务性功能，例如：内嵌服务器、安全管理、运行数据监控、运行状况检查和外部化配置等。</li><li>SpringBoot总结就是使编码变简单、配置变简单、部署变简单、监控变简单等</li></ol><h3 id="Spring-Boot常用注解"><a href="#Spring-Boot常用注解" class="headerlink" title="Spring Boot常用注解"></a>Spring Boot常用注解</h3><ol><li>@SpringBootApplication：该注解是Spring Boot项目的入口注解，用于标识一个类是Spring Boot的主配置类。是Spring Boot的核心注解，由@SpringBootConfiguration @EnableAutoConfiguration @ComponentScan 三个注解组合而成</li><li>@SpringBootConfiguration : 与@Configuration注解的功能一致，被标注的类等于在Spring的XML配置文件中（applicationContext.xml）,装配所有bean事务，提供了一个Spring的上下文环境</li><li>@EnableAutoConfiguration : SpringBoot根据应用所声明的依赖来对Spring框架进行自动配置</li><li>ComponentScan : 组件扫描，自动扫描和装配Bean。标识扫描路径，因为默认是没有配置实际扫描路径，所以SpringBoot扫描的路径是启动类所在的当前⽬录</li><li>@RestController：该注解用于创建RESTful风格的Controller，相当于@Controller和@ResponseBody的组合。</li><li>@GetMapping/@PostMapping：这两个注解用于处理HTTP GET/POST请求，根据请求路径匹配到相应的处理方法。</li><li>@PathVariable：该注解配合@RequestMapping使用，用于获取URL路径中的参数值。</li><li>@RequestParam：该注解也配合@RequestMapping使用，用于获取请求参数的值。</li><li>@Autowired：该注解用于自动装配一个Bean，Spring容器会自动找到合适的Bean进行注入。</li><li>@ConfigurationProperties：该注解用于将配置文件中的属性值注入到Java Bean中。</li><li>@Component：该注解用于将一个普通的Java类定义为一个Bean，使其能够被Spring容器管理。</li><li>@SpringBootTest：该注解用于测试Spring Boot应用程序，可以模拟出完整的Web服务接口供测试调用。</li></ol><h3 id="Spring-Boot自动装配的过程"><a href="#Spring-Boot自动装配的过程" class="headerlink" title="Spring Boot自动装配的过程"></a>Spring Boot自动装配的过程</h3><p>Spring Boot通过@EnableAutoConfiguration注解开启自动配置，加载spring.factories中注册的各种AutoConfiguration类。</p><p>当某个AutoConfiguration类满足其注解@Conditional指定的生效条件（Starters提供的依赖、配置或Spring容器中是否存在某个Bean等）时，实例化该AutoConfiguration类中定义的Bean（组件等），并注入Spring容器，就可以完成依赖框架的自动配置。</p><h3 id="Spring-Boot启动流程"><a href="#Spring-Boot启动流程" class="headerlink" title="Spring Boot启动流程"></a>Spring Boot启动流程</h3><ol><li>首先从main找到run()方法，在执行run()方法之前new一个SpringApplication对象</li><li>进入run()方法，创建应用监听器SpringApplicationRunListeners开始监听</li><li>然后加载SpringBoot配置环境(ConfigurableEnvironment)，然后把配置环境(Environment)加入监听对象中</li><li>然后加载应用上下文(ConfigurableApplicationContext)，当做run方法的返回对象</li><li>最后创建Spring容器，refreshContext(context)，实现starter自动化配置和bean的实例化等工作。</li></ol><h3 id="如何理解-Spring-Boot-中的-Starter"><a href="#如何理解-Spring-Boot-中的-Starter" class="headerlink" title="如何理解 Spring Boot 中的 Starter"></a>如何理解 Spring Boot 中的 Starter</h3><p>starter就是定义⼀个starter的jar包，写⼀个@Configuration配置类、将这些bean定义在⾥⾯，然后在starter包的META-INF/spring.factories中写⼊该配置类，springboot会按照约定来加载该配置类</p><p>开发⼈员只需要将相应的starter包依赖进应⽤，进⾏相应的属性配置（使⽤默认配置时，不需要配置），就可以直接进⾏代码开发，使⽤对应的功能了，⽐如mybatis-spring-boot–starter，spring-boot-starter-redis</p><h3 id="Spring-Boot是如何启动Tomcat的"><a href="#Spring-Boot是如何启动Tomcat的" class="headerlink" title="Spring Boot是如何启动Tomcat的"></a>Spring Boot是如何启动Tomcat的</h3><ol><li><p>⾸先，SpringBoot在启动时会先创建⼀个Spring容器</p></li><li><p>在创建Spring容器过程中，会利⽤@ConditionalOnClass技术来判断当前classpath中是否存在Tomcat依赖，如果存在则会⽣成⼀个启动Tomcat的Bean</p></li><li><p>Spring容器创建完之后，就会获取启动Tomcat的Bean，并创建Tomcat对象，并绑定端⼝等，然后启动Tomcat</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> SpringBoot </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring(补档)</title>
      <link href="/2023/02/15/spring-bu-dang/"/>
      <url>/2023/02/15/spring-bu-dang/</url>
      
        <content type="html"><![CDATA[<h2 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h2><h3 id="Spring是什么"><a href="#Spring是什么" class="headerlink" title="Spring是什么"></a>Spring是什么</h3><p>Spring 它包括许多框架，例如 Spring framework、SpringMVC、SpringBoot、Spring Cloud、Spring Data、Spring Security 等，所以有人将它们亲切的称之为：Spring 全家桶。</p><p>Spring framework 就是我们平时说的 Spring 框架。Spring 框架是全家桶内其它框架的基础和核心。</p><p>Spring是轻量级的开源的JavaSE/EE容器框架。以 IoC（Inverse of Control，控制反转）和 AOP（Aspect Oriented Programming，面向切面编程）为内核。</p><p>在 Spring 中，认为一切 Java 类都是资源，而资源都是类的实例对象（Bean）， Spring 所提供的 IoC 容器容纳并管理这些 Bean，Spring 是一种基于 Bean 的编程。</p><p>Spring 致力于 Java EE 应用各层的解决方案，对每一层都提供了技术支持。在表现层提供了与 Spring MVC、Struts2 框架的整合，在业务逻辑层可以管理事务和记录日志等，在持久层可以整合 MyBatis、Hibernate 和 JdbcTemplate 等技术。</p><p>Spring 框架充当了黏合剂和润滑剂的角色，能够将相应的 Java Web 系统柔顺地整合起来，并让它们更易使用。</p><p><strong>Spring 框架具有以下几个特点</strong></p><p><strong>1）方便解耦，简化开发</strong></p><p>Spring 就是一个大工厂，可以将所有对象的创建和依赖关系的维护交给 Spring Ioc容器管理。</p><p><strong>2）方便集成各种优秀框架</strong></p><p>Spring 不排斥各种优秀的开源框架，其内部提供了对各种优秀框架（如 Struts2、Hibernate、MyBatis 等）的直接支持。</p><p><strong>3）降低 Java EE API 的使用难度</strong></p><p>Spring 对 Java EE 开发中非常难用的一些 API（JDBC、JavaMail、远程调用等）都提供了封装，使这些 API 应用的难度大大降低。</p><p><strong>4）方便程序的测试</strong></p><p>Spring 支持 JUnit4，可以通过注解方便地测试 Spring 程序。</p><p><strong>5）AOP 编程的支持</strong></p><p>Spring 提供面向切面编程，可以方便地实现对程序进行权限拦截和运行监控等功能。</p><p><strong>6）声明式事务的支持</strong></p><p>只需要通过配置就可以完成对事务的管理，而无须手动编程。</p><h3 id="Spring包含的模块有哪些"><a href="#Spring包含的模块有哪些" class="headerlink" title="Spring包含的模块有哪些"></a>Spring包含的模块有哪些</h3><p><strong>1. Spring Core</strong></p><p>框架的最基础部分，提供 IoC 容器，对 bean 进行管理。</p><p><strong>2. Spring Context</strong></p><p>基于 bean，提供上下文信息，扩展出JNDI、EJB、电子邮件、国际化、校验和调度等功能。</p><p><strong>3. Spring DAO</strong></p><p>提供了JDBC的抽象层，它可消除冗长的JDBC编码和解析数据库厂商特有的错误代码，还提供了声明性事务管理方法。</p><p><strong>4. Spring ORM</strong></p><p>提供了常用的“对象/关系”映射APIs的集成层。 其中包括JPA、JDO、Hibernate、MyBatis 等。</p><p><strong>5. Spring AOP</strong></p><p>提供了符合AOP Alliance规范的面向方面的编程实现。并提供常用的拦截器，供用户自定义和配置。</p><p><strong>6. Spring Web</strong></p><p>提供了基础的 Web 开发的上下文信息，可与其他 web (Struts1，WEBWORK（Struts 2）)进行集成。</p><p><strong>7. Spring Web MVC</strong></p><p>提供了 Web 应用的 Model-View-Controller 全功能实现。</p><h3 id="Spring容器是什么"><a href="#Spring容器是什么" class="headerlink" title="Spring容器是什么"></a>Spring容器是什么</h3><p>容器是Spring框架实现功能的核心，容器不只是帮我们创建了对象那么简单，它负责了Bean的整个的生命周期的管理——创建、装配、销毁。</p><p><strong>怎么向容器中放入我们需要容器代为管理的对象呢？这就涉及到Spring的应用上下文了。</strong></p><p>应用上下文就是将需要IoC容器帮我们管理的bean、bean 与 bean之间的协作关系，基于xml 或 Java注解的形式配置好，通过Spring应用上下文对象将其加载进IoC容器中，这样容器就能提供我们需要的对象管理服务。</p><p>Spring中有的两种容器类型，分别是：<strong>BeanFactory</strong>和<strong>ApplicationContext</strong></p><p>BeanFactory是最简单的容器，只能提供基本的DI功能；ApplicationContext继承了BeanFactory</p><p>对于ApplicationContext接口，Spring也为我们提供了多种类型的容器实现，供我们在不同的应用场景选择：</p><ul><li><code>AnnotationConfigApplicationContext</code>:从一个或多个基于java的配置类中加载上下文定义，适用于java注解的方式；</li><li><code>ClassPathXmlApplicationContext</code>:从类路径下的一个或多个xml配置文件中加载上下文定义，适用于xml配置的方式；</li><li><code>FileSystemXmlApplicationContext</code>:从文件系统下的一个或多个xml配置文件中加载上下文定义，也就是说系统盘符中加载xml配置文件；</li><li><code>AnnotationConfigWebApplicationContext</code>:专门为web应用准备的，适用于注解方式；</li><li><code>XmlWebApplicationContext</code>:从web应用下的一个或多个xml配置文件加载上下文定义，适用于xml配置方式。</li></ul><p><strong>BeanFactory</strong>和<strong>ApplicationContext的不同点：</strong></p><p>1.对bean的加载方式不同</p><p>BeeanFactory是使用的懒加载的方式，只有在调用getBean（）时才会进行实例化。<br>ApplicationContext是使用预加载的方式，即在应用启动后就实例化所有的bean。</p><p>2.特性不同：</p><p>BeanFactory接口只提供了IOC/DI的支持，常用的API是XMLBeanFactory。</p><p>ApplicationContext是整个Spring应用中的中央接口，它继承了BeanFactory接口，具备BeanFactory的所有特性，还有一些其他特性比如：<strong>AOP的功能</strong>，<strong>事件发布/响应</strong>（ApplicationEvent）、国际化信息支持等。</p><p>3.应用场景不同：</p><p>BeanFactory适合系统资源（内存）较少的环境中使用延迟实例化，比如运行在移动应用中。<br>ApplicationContext适合企业级的大型web应用，将耗时的内容在系统启动的时候就完成。</p><h3 id="Spring容器启动流程"><a href="#Spring容器启动流程" class="headerlink" title="Spring容器启动流程"></a>Spring容器启动流程</h3><ol><li><p>扫描并注册Bean定义：Spring容器会扫描指定的包或目录，查找带有特定注解（如@Component、@Service、@Repository等）的类。它会创建对应的BeanDefinition对象，包含了Bean的元数据信息，并将这些BeanDefinition对象存储在一个Map中。</p></li><li><p>预处理Bean定义：在注册Bean定义后，Spring容器会对Bean定义进行预处理操作。这包括合并父子类的BeanDefinition，解析属性占位符，处理自动装配等。</p></li><li><p>实例化非懒加载的单例Bean：Spring容器会遍历所有非懒加载的单例BeanDefinition，并根据BeanDefinition创建相应的Bean实例。这涉及到实例化Bean、属性填充和依赖注入等操作。</p></li><li><p>初始化Bean：在单例Bean实例化后，Spring容器会调用各个Bean的初始化方法。这可以包括自定义的初始化逻辑，如初始化数据库连接、加载配置文件等。还可以执行BeanPostProcessor的前置初始化方法。</p></li><li><p>注册BeanPostProcessor：Spring容器会注册实现了BeanPostProcessor接口的Bean后处理器。这些后处理器可以在Bean实例化和初始化的过程中对Bean进行增强，如AOP代理、属性填充等。注册后处理器之后，会执行BeanPostProcessor的后置初始化方法。</p></li><li><p>完成启动过程：当所有非懒加载的单例Bean都被实例化、初始化完成后，Spring容器的启动过程结束。此时，可以发布容器启动事件，通知相关的监听器。</p></li></ol><h3 id="Spring用到了哪些设计模式"><a href="#Spring用到了哪些设计模式" class="headerlink" title="Spring用到了哪些设计模式"></a>Spring用到了哪些设计模式</h3><ul><li>  <strong>工厂设计模式</strong> : Spring 使用工厂模式通过 <code>BeanFactory</code>、<code>ApplicationContext</code> 创建 bean 对象。</li><li>  <strong>代理设计模式</strong> : Spring AOP 功能的实现。</li><li>  <strong>单例设计模式</strong> : Spring 中的 Bean 默认都是单例的。</li><li>  <strong>模板方法模式</strong> : Spring 中 <code>jdbcTemplate</code>、<code>hibernateTemplate</code> 等以 Template 结尾的对数据库操作的类，它们就使用到了模板模式。</li><li>  <strong>包装器设计模式</strong> : 我们的项目需要连接多个数据库，而且不同的客户在每次访问中根据需要会去访问不同的数据库。这种模式让我们可以根据客户的需求能够动态切换不同的数据源。</li><li>  <strong>观察者模式:</strong> Spring 事件驱动模型就是观察者模式很经典的一个应用。</li><li>  <strong>适配器模式</strong> : Spring AOP 的增强或通知(Advice)使用到了适配器模式、spring MVC 中也是用到了适配器模式适配<code>Controller</code>。</li></ul><h3 id="Spring是怎么解决循环依赖的"><a href="#Spring是怎么解决循环依赖的" class="headerlink" title="Spring是怎么解决循环依赖的"></a>Spring是怎么解决循环依赖的</h3><p>首先，需要明确的是spring对循环依赖的处理有三种情况：</p><ol><li>构造器的循环依赖：这种依赖spring是处理不了的，直接抛出BeanCurrentlylnCreationException异常。</li><li>单例模式下的setter循环依赖：通过“三级缓存”处理循环依赖。</li><li>非单例循环依赖：无法处理。</li></ol><p>接下来，我们具体看看spring是如何处理第二种循环依赖的。</p><p>Spring单例对象的初始化大略分为三步：</p><ol><li>createBeanInstance：实例化，其实也就是调用对象的构造方法实例化对象；</li><li>populateBean：填充属性，这一步主要是多bean的依赖属性进行填充；</li><li>initializeBean：初始化，调用spring xml中的init 方法。</li></ol><p>从上面讲述的单例bean初始化步骤我们可以知道，循环依赖主要发生在第一步、第二步。也就是构造器循环依赖和field循环依赖。 Spring为了解决单例的循环依赖问题，使用了三级缓存。</p><p>这三级缓存的作用分别是：</p><ul><li>singletonFactories ： 进入实例化阶段的单例对象工厂的cache （三级缓存）；</li><li>earlySingletonObjects ：完成实例化但是尚未初始化的，提前暴光的单例对象的Cache （二级缓存）；</li><li>  singletonObjects：完成初始化的单例对象的cache（一级缓存）。</li></ul><p>这样做有什么好处呢？让我们来分析一下</p><p>“A的某个field或者setter依赖了B的实例对象，同时B的某个field或者setter依赖了A的实例对象”这种循环依赖的情况。A首先完成了初始化的第一步，并且将自己提前曝光到singletonFactories中，此时进行初始化的第二步，发现自己依赖对象B，此时就尝试去get(B)，发现B还没有被create，所以走create流程，B在初始化第一步的时候发现自己依赖了对象A，于是尝试get(A)，尝试一级缓存singletonObjects(肯定没有，因为A还没初始化完全)，尝试二级缓存earlySingletonObjects（也没有），尝试三级缓存singletonFactories，由于A通过ObjectFactory将自己提前曝光了，所以B能够通过ObjectFactory.getObject拿到A对象(虽然A还没有初始化完全，但是总比没有好呀)，B拿到A对象后顺利完成了初始化阶段1、2、3，完全初始化之后将自己放入到一级缓存singletonObjects中。此时返回A中，A此时能拿到B的对象顺利完成自己的初始化阶段2、3，最终A也完成了初始化，进去了一级缓存singletonObjects中，而且更加幸运的是，由于B拿到了A的对象引用，所以B现在hold住的A对象完成了初始化。</p><h2 id="IoC"><a href="#IoC" class="headerlink" title="IoC"></a>IoC</h2><h3 id="什么是IoC"><a href="#什么是IoC" class="headerlink" title="什么是IoC"></a>什么是IoC</h3><p><strong>IoC（Inversion of Control:控制反转）</strong> 是一种设计思想，而不是一个具体的技术实现。IoC 的思想就是将原本在程序中手动创建对象的控制权，交由 Spring 框架来管理。</p><p>Ioc容器：实际上就是个map（key，value），⾥⾯存的是各种对象（在xml⾥配置的bean节点、@repository、@mapper、@service、@controller、@component），在项⽬启动的时候通过读取XML配置⽂件或者扫描注解，使⽤反射创建对象放到map⾥。</p><p>map⾥有各种对象，在代码⾥需要⽤到⾥⾯的对象时，再通过DI注⼊（@autowired、@resource等注解，xml⾥bean节点内的ref属性）</p><p>将对象之间的相互依赖关系交给 IoC 容器来管理，并由 IoC 容器完成对象的注入。简化开发，降低耦合度。 IoC 容器就像是一个工厂一样，当我们需要创建一个对象的时候，只需要配置好配置文件/注解即可，完全不用考虑对象是如何被创建出来的。</p><h3 id="Component-和-Bean-的区别"><a href="#Component-和-Bean-的区别" class="headerlink" title="@Component 和 @Bean 的区别"></a>@Component 和 @Bean 的区别</h3><ol><li><p> <code>@Component</code> 注解作用于类，而<code>@Bean</code>注解作用于方法。</p></li><li><p> <code>@Component</code>通常是通过类路径扫描来自动侦测以及自动装配到 Spring 容器中（我们可以使用 <code>@ComponentScan</code> 注解定义要扫描的路径从中找出标识了需要装配的类自动装配到 Spring 的 bean 容器中）。<code>@Bean</code> 注解通常是我们在标有该注解的方法中定义产生这个 bean,<code>@Bean</code>告诉了 Spring 这是某个类的实例，当我需要用它的时候还给我。</p></li><li><p> <code>@Bean</code> 注解比 <code>@Component</code> 注解的自定义性更强，而且很多地方我们只能通过 <code>@Bean</code> 注解来注册 bean。比如当我们引用第三方库中的类需要装配到 <code>Spring</code>容器时，则只能通过 <code>@Bean</code>来实现。</p></li></ol><p><code>@Bean</code>注解使用示例：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">AppConfig</span> <span class="token punctuation">{</span>    <span class="token annotation punctuation">@Bean</span>    <span class="token keyword">public</span> <span class="token class-name">TransferService</span> <span class="token function">transferService</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TransferServiceImpl</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>下面这个例子是通过 <code>@Component</code> 无法实现的。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token keyword">public</span> <span class="token class-name">OneService</span> <span class="token function">getService</span><span class="token punctuation">(</span>status<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">case</span> <span class="token punctuation">(</span>status<span class="token punctuation">)</span>  <span class="token punctuation">{</span>        when <span class="token number">1</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl1</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        when <span class="token number">2</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl2</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        when <span class="token number">3</span><span class="token operator">:</span>                <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token function">serviceImpl3</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Autowired-和-Resource-的区别"><a href="#Autowired-和-Resource-的区别" class="headerlink" title="@Autowired 和 @Resource 的区别"></a>@Autowired 和 @Resource 的区别</h3><ol><li><p> <code>@Autowired</code> 是 Spring 提供的注解，<code>@Resource</code> 是 JDK 提供的注解。</p></li><li><p>  <code>Autowired</code> 默认的注入方式为<code>byType</code>（根据类型进行匹配），<code>@Resource</code>默认注入方式为 <code>byName</code>（根据名称进行匹配）。</p></li><li><p>  当一个接口存在多个实现类的情况下，<code>@Autowired</code> 和<code>@Resource</code>都需要通过名称才能正确匹配到对应的 Bean。<code>Autowired</code> 可以通过 <code>@Qualifier</code> 注解来显式指定名称，<code>@Resource</code>可以通过 <code>name</code> 属性来显式指定名称。</p></li></ol><h3 id="常用的依赖注入-Bean的自动装配-的方式有哪些"><a href="#常用的依赖注入-Bean的自动装配-的方式有哪些" class="headerlink" title="常用的依赖注入(Bean的自动装配)的方式有哪些"></a>常用的依赖注入(Bean的自动装配)的方式有哪些</h3><p><strong>1. 属性注入</strong></p><p>属性注入是我们最熟悉，也是日常开发中使用最多的一种注入方式（@Autowired）</p><p><strong>优点分析</strong></p><p>属性注入最大的优点就是实现简单、使用简单，只需要给变量上添加一个注解（@Autowired）</p><p><strong>缺点分析</strong></p><ol><li>功能性问题：无法注入一个不可变的对象（final 修饰的对象）；</li><li>通用性问题：只能适应于 IoC 容器；</li><li>设计原则问题：更容易违背单一设计原则。</li></ol><p><strong>2. Setter 注入</strong></p><p><img src="/images/image_Spring%E8%A1%A5%E6%A1%A3/1.WEBP"></p><p><strong>优点分析</strong></p><p>符合单一职责的设计原则</p><p><strong>缺点分析</strong></p><ol><li>不能注入不可变对象（final 修饰的对象）；</li><li>注入的对象可被修改。</li></ol><p><strong>3.构造方法注入</strong></p><p><img src="/images/image_Spring%E8%A1%A5%E6%A1%A3/2.PNG"></p><p><strong>优点分析</strong></p><ol><li>可注入不可变对象；</li><li>注入对象不会被修改；</li><li>注入对象会被完全初始化；</li><li>通用性更好。</li></ol><p><em>(Spring 官方推荐的是构造方法注入)</em></p><h3 id="Spring⽀持的⼏种bean的作⽤域"><a href="#Spring⽀持的⼏种bean的作⽤域" class="headerlink" title="Spring⽀持的⼏种bean的作⽤域"></a>Spring⽀持的⼏种bean的作⽤域</h3><ol><li> <strong>singleton</strong> : IoC 容器中只有唯一的 bean 实例。Spring 中的 bean 默认都是单例的，是对单例设计模式的应用。</li><li>  <strong>prototype</strong> : 每次获取都会创建一个新的 bean 实例。也就是说，连续 <code>getBean()</code> 两次，得到的是不同的 Bean 实例。</li><li>  <strong>request</strong> （仅 Web 应用可用）: 每一次 HTTP 请求都会产生一个新的 bean（请求 bean），该 bean 仅在当前 HTTP request 内有效。</li><li>  <strong>session</strong> （仅 Web 应用可用） : 每一次来自新 session 的 HTTP 请求都会产生一个新的 bean（会话 bean），该 bean 仅在当前 HTTP session 内有效。</li><li>  <strong>application</strong> （仅 Web 应用可用）： 每个 Web 应用在启动时创建一个 Bean（应用 Bean），该 bean 仅在当前应用启动时间内有效。</li><li>  <strong>websocket</strong> （仅 Web 应用可用）：每一次 WebSocket 会话产生一个新的 bean。</li><li>global-session： 全局 session 作用域，仅仅在基于 Portlet 的 web 应用中才有意义，Spring5 已经没有了。Portlet 是能够生成语义代码（例如：HTML）片段的小型 Java Web 插件。它们基于 portlet 容器，可以像 servlet 一样处理 HTTP 请求。但是，与 servlet 不同，每个 portlet 都有不同的会话</li></ol><p><strong>如何配置 bean 的作用域</strong></p><p>xml 方式：</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>bean</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>...<span class="token punctuation">"</span></span> <span class="token attr-name">scope</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>singleton<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>bean</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>注解方式：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Bean</span><span class="token annotation punctuation">@Scope</span><span class="token punctuation">(</span>value <span class="token operator">=</span> <span class="token class-name">ConfigurableBeanFactory</span><span class="token punctuation">.</span><span class="token constant">SCOPE_PROTOTYPE</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token class-name">Person</span> <span class="token function">personPrototype</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="Spring中Bean是线程安全的吗"><a href="#Spring中Bean是线程安全的吗" class="headerlink" title="Spring中Bean是线程安全的吗"></a>Spring中Bean是线程安全的吗</h3><p>Spring本身并没有针对Bean做线程安全的处理，所以：</p><ol><li><p>如果Bean是⽆状态的，那么Bean则是线程安全的</p></li><li><p>如果Bean是有状态的，那么Bean则不是线程安全的</p></li></ol><p>Bean是不是线程安全，跟Bean的作⽤域没有关系，Bean的作⽤域只是表示Bean的⽣命周期范围，对于任何⽣命周期的Bean都是⼀个对象，这个对象是不是线程安全的，还是得看这个Bean对象本身。</p><p><strong>常见的有两种解决办法：</strong></p><ol><li> 在 Bean 中尽量避免定义可变的成员变量。</li><li> 在类中定义一个 <code>ThreadLocal</code> 成员变量，将需要的可变成员变量保存在 <code>ThreadLocal</code> 中（推荐）。</li></ol><p>大部分 Bean 实际都是无状态（没有实例变量）的（Dao、Service）， Bean 是线程安全的。</p><h3 id="Bean-的生命周期"><a href="#Bean-的生命周期" class="headerlink" title="Bean 的生命周期"></a>Bean 的生命周期</h3><ul><li>  实例化 Instantiation</li><li>  属性赋值 Populate</li><li>  初始化 Initialization</li><li>  销毁 Destruction</li></ul><p>实例化 -&gt; 属性赋值 -&gt; 初始化 -&gt; 销毁</p><p><img src="/images/image_Spring/10.webp"></p><ol><li>根据配置情况调用Bean构造方法或工厂方法实例化 Bean。</li><li>利用依赖注入完成Bean中所有属性值的配置注入。</li><li>如果Bean 实现了BeanNameAware 接口，则 Spring调用Bean的setBeanName()方法传入当前Bean的id值。</li><li>如果Bean实现了BeanFactoryAware 接口，则 Spring 调用setBeanFactory()方法传入当前工厂实例的引用。</li><li>如果Bean 实现了ApplicationContextAware 接口，则 Spring调用setApplicationContext()方法传入当前ApplicationContext 实例的引用。</li><li>如果BeanPostProcessor 和Bean关联，则 Spring将调用该接口的预初始化方法postProcessBeforelnitialzation()对 Bean进行加工操作，此处非常重要，Spring的AOP就是利用它实现的。</li><li>如果Bean实现了InitializingBean接口，则 Spring将调用afterPropertiesSet()方法。</li><li>如果在配置文件中通过 init-method属性指定了初始化方法，则调用该初始化方法。</li><li>如果BeanPostProcessor和 Bean关联，则 Spring将调用该接口的初始化方法、 postProcessAfterlntialization()。此时，Bean已经可以被应用系统使用了。</li><li>如果在 中指定了该Bean的作用范围为scope=“singleton”，则将该Bean放入Spring IOC的缓存池中，将触发Spring对该Bean 的生命周期管理;如果在中指定了该Bean的作用范围为scope=“prototype”，则将该Bean交给调用者，调用者管理该Bean的生命周期，Spring不再管理该 Bean。</li><li>如果Bean实现了DisposableBean接口，则 Spring 会调用destory()方法将Spring 中的 Bean销毁; 如果在配置文件中通过destory-method属性指定了Bean的销毁方法，则 Spring将调用该方法。<h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><h3 id="什么是AOP"><a href="#什么是AOP" class="headerlink" title="什么是AOP"></a>什么是AOP</h3></li></ol><p>AOP（Aspect Oriented Programing）是面向切面编程思想。简单来说，它可以统一解决一批组件的共性需求（如权限检查、记录日志、事务管理等）。在AOP思想下，我们可以将解决共性需求的代码独立出来，然后通过配置的方式，声明这些代码在什么地方、什么时机调用。当满足调用条件时，AOP会将该业务代码织入到我们指定的位置，从而统一解决了问题，又不需要修改这一批组件的代码。</p><p>Spring AOP 就基于动态代理的。如果要代理的对象，实现了某个接口，那么 Spring AOP 会使用 <strong>JDK Proxy</strong>，去创建代理对象，而对于没有实现接口的对象，就无法使用 JDK Proxy 去进行代理了，这时候 Spring AOP 会使用 <strong>Cglib</strong> 生成一个被代理对象的子类来作为代理</p><p>AOP 切面编程设计到的一些专业术语：</p><p><strong>(1)切面(Aspect)</strong></p><p>切面是一个横切关注点的模块化（日志处理）。切面由切入点和通知组成，它既包含了横切逻辑的定义，也包括了切入点的定义。</p><p><strong>可以简单地认为, 使用 @Aspect 注解的类就是切面</strong></p><p><strong>(2) 目标对象(Target)</strong></p><p>目标对象指将要被增强的对象，即包含主业务逻辑的类对象。或者说是被一个或者多个切面所通知的对象。</p><p><strong>(3) 连接点(JoinPoint)</strong></p><p>程序执行过程中明确的点，如方法的调用或特定的异常被抛出。连接点由两个信息确定：</p><ul><li>方法(表示程序执行点，即在哪个目标方法)</li><li>相对点(表示方位，即目标方法的什么位置，比如调用前，后等)</li></ul><p>简单来说，连接点就是被拦截到的程序执行点，因为Spring只支持方法类型的连接点，所以在Spring中连接点就是被拦截到的方法。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pointcut()"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token comment">//这个JoinPoint参数就是连接点</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><strong>(4) 切入点(PointCut)</strong></p><p>切入点是对连接点进行拦截的条件定义。切入点表达式如何和连接点匹配是AOP的核心</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Pointcut</span><span class="token punctuation">(</span><span class="token string">"execution(* com.test.aop.service..*(..))"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">pointcut</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>上边切入点的匹配规则是&nbsp;<code>com.test.aop.service</code>包下的所有类的所有函数。</p><p><strong>(5) 通知(Advice)</strong></p><p>通知是指拦截到连接点之后要执行的代码，包括了“around”、“before”和“after”等不同类型的通知。Spring AOP框架以拦截器来实现通知模型，并维护一个以连接点为中心的拦截器链。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// @Before说明这是一个前置通知，log函数中是要前置执行的代码，JoinPoint是连接点，</span><span class="token annotation punctuation">@Before</span><span class="token punctuation">(</span><span class="token string">"pointcut()"</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">JoinPoint</span> joinPoint<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><strong>(6) 织入(Weaving)</strong></p><p>织入是将切面和业务逻辑对象连接起来, 并创建通知代理的过程。织入可以在编译时，类加载时和运行时完成。在编译时进行织入就是静态代理，而在运行时进行织入则是动态代理。</p><h3 id="CGLib和JDK-Proxy的区别"><a href="#CGLib和JDK-Proxy的区别" class="headerlink" title="CGLib和JDK Proxy的区别"></a>CGLib和JDK Proxy的区别</h3><ol><li><p>JDK Proxy 是 Java 语言内置的动态代理，必须要通过实现接口的方式来代理相关的类； CGLib 是第三方提供的基于 ASM 的高效动态代理类，它通过实现被代理类的子类来实现动态代理的功能，因此被代理的类不能使用 final 修饰。</p></li><li><p>JDK 动态代理的实现方式是反射；CGLib 实现动态代理是基于 ASM（一个 Java 字节码操作框架）而非反射实现的。</p><h3 id="Spring-AOP-和-AspectJ-AOP-的区别"><a href="#Spring-AOP-和-AspectJ-AOP-的区别" class="headerlink" title="Spring AOP 和 AspectJ AOP 的区别"></a>Spring AOP 和 AspectJ AOP 的区别</h3></li><li><p>Spring AOP 属于运行时增强，而 AspectJ 是编译时增强。</p></li><li><p>Spring AOP 基于代理(Proxying)，而 AspectJ 基于字节码操作(Bytecode Manipulation)。</p></li><li><p>性能上，由于Spring AOP是基于动态代理来实现的，在容器启动时需要生成代理实例，在方法调用上也会增加栈的深度，使得Spring AOP的性能不如AspectJ的那么好。</p></li><li><p>Spring AOP需要依赖IOC容器来管理，并且只能作用于Spring容器，AspectJ可以在所有域对象上实现。</p></li><li><p>Spring AOP仅支持方法执行切入点，AspectJ支持所有切入点。</p></li><li><p>Spring AOP功能不强-仅支持方法级编织，AspectJ更强大 - 可以编织字段、方法、构造函数、静态初始值设定项、最终类/方法等……。</p></li><li><p>Spring AOP则致力于解决企业级开发中最普遍的AOP（方法织入，AspectJ是AOP编程的完全解决方案。</p></li></ol><h3 id="AspectJ-的通知类型"><a href="#AspectJ-的通知类型" class="headerlink" title="AspectJ 的通知类型"></a>AspectJ 的通知类型</h3><ol><li><p> 前置通知 <strong>Before</strong>：目标对象的方法调用之前触发</p></li><li><p> 后置通知 <strong>After</strong> ：目标对象的方法调用之后触发</p></li><li><p> 返回通知 <strong>AfterReturning</strong>：目标对象的方法调用完成，在返回结果值之后触发</p></li><li><p> 异常通知 <strong>AfterThrowing</strong> ：目标对象的方法运行中抛出 / 触发异常后触发。</p></li><li><p> 环绕通知 <strong>Around</strong> ：编程式控制目标对象的方法调用。环绕通知是所有通知类型中可操作范围最大的一种，因为它可以直接拿到目标对象，以及要执行的方法。</p><h3 id="Spring-aop-的通知类型"><a href="#Spring-aop-的通知类型" class="headerlink" title="Spring aop 的通知类型"></a>Spring aop 的通知类型</h3></li><li><p>前置通知 Before：在连接点前面执行，前置通知不会影响连接点的执行，除非此处抛出异常</p></li><li><p>后置通知 After returning ：在连接点正常执行完成后执行，如果连接点抛出异常，则不会执行</p></li><li><p>异常通知 After throwing ：在连接点抛出异常后执行</p></li><li><p>最终通知 After (finally) ：在连接点执行完成后执行，不管是正常执行完成，还是抛出异常，都会执行返回通知中的内容</p></li><li><p>环绕通知 Around ：环绕通知围绕在连接点前后，能在方法调用前后自定义一些操作</p><h2 id="Spring-MVC"><a href="#Spring-MVC" class="headerlink" title="Spring MVC"></a>Spring MVC</h2><h3 id="什么是Spring-MVC"><a href="#什么是Spring-MVC" class="headerlink" title="什么是Spring MVC"></a>什么是Spring MVC</h3></li></ol><p>MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p>MVC 是一种设计模式，Spring MVC 是一款很优秀的 MVC 框架，可以帮助我们进行更简洁的 Web 层的开发，并且它天生与 Spring 框架集成。</p><p>Spring MVC 下我们一般把后端项目分为 Service 层（处理业务）、Dao 层（数据库操作）、Entity 层（实体类）、Controller 层(控制层，返回数据给前台页面)。</p><h3 id="Spring-MVC的核心组件"><a href="#Spring-MVC的核心组件" class="headerlink" title="Spring MVC的核心组件"></a>Spring MVC的核心组件</h3><ol><li> <strong>DispatcherServlet</strong> ：<strong>核心的中央处理器</strong>，负责接收请求、分发，并给予客户端响应。</li><li> <strong>HandlerMapping</strong> ：<strong>处理器映射器</strong>，根据 uri 去匹配查找能处理的 <code>Handler</code> ，并会将请求涉及到的拦截器和 <code>Handler</code> 一起封装。</li><li> <strong>HandlerAdapter</strong> ：<strong>处理器适配器</strong>，根据 <code>HandlerMapping</code> 找到的 <code>Handler</code> ，适配执行对应的 <code>Handler</code>；因为SpringMVC中的Handler可以是任意的形式，只要能处理请求就行，但是Servlet需要的处理⽅法的结构却是固定的，都是以request和response为参数的⽅法，所以需要适配器。</li><li> <strong>Handler</strong> ：<strong>请求处理器</strong>，处理实际请求的处理器。在Controller层中@RequestMapping标注的所有⽅法都可以看成是⼀个Handler。</li><li> <strong>ViewResolver</strong> ：<strong>视图解析器</strong>，根据 <code>Handler</code> 返回的逻辑视图 / 视图，解析并渲染真正的视图View（View是⽤来渲染⻚⾯的，也就是将程序返回的参数填⼊模板⾥，⽣成html（也可能是其它类型）⽂件。），并传递给 <code>DispatcherServlet</code> 响应客户端<h3 id="Spring-MVC-⼯作流程"><a href="#Spring-MVC-⼯作流程" class="headerlink" title="Spring MVC ⼯作流程"></a>Spring MVC ⼯作流程</h3></li></ol><p>1）⽤户发送请求⾄前端控制器 DispatcherServlet。</p><p>2）DispatcherServlet 收到请求调⽤ HandlerMapping 处理器映射器。</p><p>3）处理器映射器找到具体的处理器(可以根据 xml 配置、注解进⾏查找)，⽣成处理器及处理器拦截器(如果有则⽣成)⼀并返回给 DispatcherServlet。</p><p>4）DispatcherServlet 调⽤ HandlerAdapter 处理器适配器。</p><p>5）HandlerAdapter 经过适配调⽤具体的处理器(Controller，也叫后端控制器)</p><p>6）Controller 执⾏完成返回 ModelAndView。</p><p>7）HandlerAdapter 将 controller 执⾏结果 ModelAndView 返回给 DispatcherServlet。</p><p>8）DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器。</p><p>9）ViewReslover 解析后返回具体 View。</p><p>10）DispatcherServlet 根据 View 进⾏渲染视图（即将模型数据填充⾄视图中）。</p><p>11）DispatcherServlet 响应⽤户。</p><h3 id="Spring-MVC注解"><a href="#Spring-MVC注解" class="headerlink" title="Spring MVC注解"></a>Spring MVC注解</h3><h5 id="Controller"><a href="#Controller" class="headerlink" title="@Controller"></a>@Controller</h5><p>Spring MVC框架中，@Controller注解用于标识一个类是控制器，主要用于处理HTTP请求和响应。当一个类被标注了@Controller注解后，Spring将会对其进行如下操作：</p><p>Spring会遍历扫描出来的所有bean，过滤出那些添加了注解@Controller的bean，将Controller中所有添加了注解@RequestMapping的方法解析出来封装成<strong>RequestMappingInfo</strong>存储到<strong>RequestMappingHandlerMapping</strong>中的<strong>mappingRegistry</strong>。后续请求到达时，会从mappingRegistry中查找能够处理该请求的方法。</p><h5 id="Repository-与-Mapper的区别"><a href="#Repository-与-Mapper的区别" class="headerlink" title="@Repository 与 @Mapper的区别"></a>@Repository 与 @Mapper的区别</h5><p>@Repository 是 Spring 的注解，用于声明一个 Bean。@Repository注解放在mapper接口上本来没只是为了标识，要想真正是这个接口被扫描，必须使用@MapperScannerConfigurer</p><pre class="line-numbers language-none"><code class="language-none">&lt;!-- 配置 Mapper 扫描器 --&gt;&lt;bean class="org.mybatis.spring.mapper.MapperScannerConfigurer"&gt;&lt;property name="basePackage" value="com.test.mapper"/&gt;&lt;/bean&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>这段配置会扫描com.test.mapper包下所有的接口，然后创建各自的动态代理类。</p><p>@Mapper是mybatis自身带的注解。在spring程序中，mybatis需要找到对应的mapper，在编译时生成动态代理类，与数据库进行交互，这时需要用到@Mapper注解</p><p>相同点：<br>@Mapper和@Repository都是作用在dao层接口，使得其生成代理对象bean，交给spring 容器管理</p><p>不同点：</p><ol><li>@Mapper不需要配置扫描地址，可以单独使用，如果有多个mapper文件的话，可以在项目启动类中加入@MapperScan(“mapper文件所在包”)</li><li>@Repository不可以单独使用，否则会报错误，要想用，必须配置扫描地址（@MapperScannerConfigurer）<h5 id="RequestMapping"><a href="#RequestMapping" class="headerlink" title="@RequestMapping"></a>@RequestMapping</h5></li></ol><p>作用：该注解的作用就是用来处理请求地址映射的，也就是说将其中的处理器方法映射到url路径上。</p><p>属性：</p><ul><li>  method：是让你指定请求的method的类型，比如常用的有get和post。</li><li>  value：是指请求的实际地址，如果是多个地址就用{}来指定就可以了。</li><li>  produces：指定返回的内容类型，当request请求头中的Accept类型中包含指定的类型才可以返回的。</li><li>  consumes：指定处理请求的提交内容类型，比如一些json、html、text等的类型。</li><li>  headers：指定request中必须包含那些的headed值时，它才会用该方法处理请求的。</li><li>  params：指定request中一定要有的参数值，它才会使用该方法处理请求。<h5 id="RequestParam"><a href="#RequestParam" class="headerlink" title="@RequestParam"></a>@RequestParam</h5></li></ul><p>作用：是将请求参数绑定到你的控制器的方法参数上，是Spring MVC中的接收普通参数的注解。</p><p>属性：</p><ul><li>  value是请求参数中的名称。</li><li>  required是请求参数是否必须提供参数，它的默认是true，意思是表示必须提供。<h5 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h5></li></ul><p>作用：如果作用在方法上，就表示该方法的返回结果是直接按写入的Http body中（一般在异步获取数据时使用的注解）。</p><p>属性：required，是否必须有请求体。它的默认值是true，在使用该注解时，值得注意的当为true时get的请求方式是报错的，如果你取值为false的话，get的请求是null。</p><h5 id="RequestBody"><a href="#RequestBody" class="headerlink" title="@RequestBody"></a>@RequestBody</h5><p>作用：作用在方法的参数前，将前端传来的json格式的数据转为自己定义好的javabean对象</p><h5 id="PathVaribale"><a href="#PathVaribale" class="headerlink" title="@PathVaribale"></a>@PathVaribale</h5><p>作用：该注解是用于绑定url中的占位符，但是注意，spring3.0以后，url才开始支持占位符的，它是Spring MVC支持的rest风格url的一个重要的标志。</p><h3 id="Spring-MVC的拦截器"><a href="#Spring-MVC的拦截器" class="headerlink" title="Spring MVC的拦截器"></a>Spring MVC的拦截器</h3><p>拦截器会对处理器进行拦截，这样通过拦截器就可以增强处理器的功能。</p><p>Spring MVC中，所有的拦截器都需要实现HandlerInterceptor接口，该接口包含如下三个方法：preHandle()、postHandle()、afterCompletion()。</p><p>Spring MVC拦截器的开发步骤如下：</p><ol><li>开发拦截器： 实现handlerInterceptor接口，从三个方法中选择合适的方法，实现拦截时要执行的具体业务逻辑。</li><li>注册拦截器： 定义配置类，并让它实现WebMvcConfigurer接口，在接口的addInterceptors方法中，注册拦截器，并定义该拦截器匹配哪些请求路径。</li></ol><h3 id="拦截器和过滤器的区别是什么"><a href="#拦截器和过滤器的区别是什么" class="headerlink" title="拦截器和过滤器的区别是什么"></a>拦截器和过滤器的区别是什么</h3><ol><li>位置不同：拦截器是在应用<strong>程序内部具体方法</strong>级别的组件。过滤器位于应用程序外部，处于<strong>请求和响应的路径之间</strong></li><li>作用不同：拦截器主要用于在方法调用前后执行特定的操作，如日志记录、性能监视、安全检查等。过滤器主要用于在请求进入应用程序或响应离开应用程序之前进行预处理或后处理操作，如身份验证、请求转发、响应包装等。</li><li>原理不同：拦截器通常是基于面向切面编程（AOP）的概念。过滤器则是基于Servlet规范的一部分，它们通过在web.xml文件中进行配置，并按照一定的顺序进行调用。</li><li>作用范围不同：拦截器作用范围局限于特定的方法或一组方法。过滤器是作用范围可以覆盖整个应用程序，甚至整个Web容器。</li></ol><p>拦截器适用于对<strong>方法级别</strong>的操作和控制，而过滤器更适用于对<strong>请求和响应</strong>进行全局的预处理和后处理。</p><h3 id="统一异常处理"><a href="#统一异常处理" class="headerlink" title="统一异常处理"></a>统一异常处理</h3><p>推荐使用注解的方式统一异常处理，具体会使用到 <code>@ControllerAdvice</code> + <code>@ExceptionHandler</code> 这两个注解 。</p><p>在这种异常处理方式下，会给所有或者指定的 <code>Controller</code> 织入异常处理的逻辑（AOP），当 <code>Controller</code> 中的方法抛出异常的时候，由被<code>@ExceptionHandler</code> 注解修饰的方法进行处理。</p><h3 id="Spring-Boot、Spring-MVC-和-Spring-有什么区别"><a href="#Spring-Boot、Spring-MVC-和-Spring-有什么区别" class="headerlink" title="Spring Boot、Spring MVC 和 Spring 有什么区别"></a>Spring Boot、Spring MVC 和 Spring 有什么区别</h3><p>spring是⼀个IOC容器，⽤来管理Bean，使⽤依赖注⼊实现控制反转，可以很⽅便的整合各种框架，提供AOP机制弥补OOP的代码重复问题、更⽅便将不同类不同⽅法中的共同处理抽取成切⾯、⾃动注⼊给⽅法执⾏，⽐如⽇志、异常等</p><p>Spring MVC 是 Spring 中的一个很重要的模块，主要赋予 Spring 快速构建 MVC 架构的 Web 程序的能力。MVC 是模型(Model)、视图(View)、控制器(Controller)的简写，其核心思想是通过将业务逻辑、数据、显示分离来组织代码。</p><p>Spring Boot是spring提供的⼀个快速开发⼯具包，让程序员能更⽅便、更快速的开发Spring+Spring MVC应⽤，简化了配置（约定了默认配置），整合了⼀系列的解决⽅案（starter机制）、redis、mongodb、es，可以开箱即⽤</p><h2 id="Spring-事务"><a href="#Spring-事务" class="headerlink" title="Spring 事务"></a>Spring 事务</h2><h3 id="Spring-事务的实现方式"><a href="#Spring-事务的实现方式" class="headerlink" title="Spring 事务的实现方式"></a>Spring 事务的实现方式</h3><ul><li>  <strong>编程式事务</strong> ： 在代码中硬编码(不推荐使用) : 通过 <code>TransactionTemplate</code>或者 <code>TransactionManager</code> 手动管理事务，实际应用中很少使用，但是对于你理解 Spring 事务管理原理有帮助。</li><li>  <strong>声明式事务</strong> ： 在 XML 配置文件中配置或者直接基于注解（推荐使用） : 实际是通过 AOP 实现（基于<code>@Transactional</code> 的全注解方式使用最多）<h3 id="Spring事务的实现原理"><a href="#Spring事务的实现原理" class="headerlink" title="Spring事务的实现原理"></a>Spring事务的实现原理</h3></li></ul><p>事务这个概念是数据库层⾯的，Spring只是基于数据库中的事务进⾏了扩展，以及提供了⼀些能让程序员更加⽅便操作事务的⽅式。</p><p>通过在某个⽅法上增加@Transactional注解，就可以开启事务，这个⽅法中所有的sql都会在⼀个事务中执⾏，统⼀成功或失败。</p><p>在⼀个⽅法上加了@Transactional注解后，Spring会基于这个类⽣成⼀个代理对象，会将这个代理对象作为bean，当在使⽤这个代理对象的⽅法时，如果这个⽅法上存在@Transactional注解，那么代理逻辑会先把事务的⾃动提交设置为false，然后再去执⾏原本的业务逻辑⽅法，如果执⾏业务逻辑⽅法没有出现异常，那么代理逻辑中就会将事务进⾏提交，如果执⾏业务逻辑⽅法出现了异常，那么则会将事务进⾏回滚。</p><p>针对哪些异常回滚事务是可以配置的，可以利⽤@Transactional注解中的rollbackFor属性进⾏配置，默认情况下会对RuntimeException和Error进⾏回滚。</p><h3 id="Spring-事务中的隔离级别"><a href="#Spring-事务中的隔离级别" class="headerlink" title="Spring 事务中的隔离级别"></a>Spring 事务中的隔离级别</h3><ol><li> 默认级别 <strong><code>ISOLATION_DEFAULT</code></strong> :默认的隔离级别，MySQL 默认采用的 <code>REPEATABLE_READ</code> 隔离级别 Oracle 默认采用的 <code>READ_COMMITTED</code> 隔离级别.</li><li>未提交读 <strong><code>ISOLATION_READ_UNCOMMITTED</code></strong> :最低的隔离级别，它允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong></li><li> 不可重复读 <strong><code>ISOLATION_READ_COMMITTED</code></strong> : 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong></li><li> 可重复读 <strong><code>ISOLATION_REPEATABLE_READ</code></strong> : 对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生。</strong></li><li> 可串⾏化 <strong><code>ISOLATION_SERIALIZABLE</code></strong> : 最高的隔离级别，事务之间完全不产生干扰，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。但是这将严重影响程序的性能。</li></ol><p>(数据库的配置隔离级别是Read Commited,⽽Spring配置的隔离级别是Repeatable Read，这时以Spring配置的为准，如果spring设置的隔离级别数据库不⽀持，效果取决于数据库)</p><h3 id="Spring事务传播行为"><a href="#Spring事务传播行为" class="headerlink" title="Spring事务传播行为"></a>Spring事务传播行为</h3><p>多个事务⽅法相互调⽤时，事务如何在这些⽅法间传播，⽅法A是⼀个事务的⽅法，⽅法A执⾏过程中调⽤了⽅法B，那么⽅法B有⽆事务以及⽅法B对事务的要求不同都会对⽅法A的事务具体执⾏造成影响，同时⽅法A的事务对⽅法B的事务执⾏也有影响，这种影响具体是什么就由两个⽅法所定义的事务传播类型所决定。</p><ol><li><p>REQUIRED(Spring默认的事务传播类型)：如果当前没有事务，则⾃⼰新建⼀个事务，如果当前存在事务，则加⼊这个事务</p></li><li><p>SUPPORTS：当前存在事务，则加⼊当前事务，如果当前没有事务，就以⾮事务⽅法执⾏</p></li><li><p>MANDATORY：当前存在事务，则加⼊当前事务，如果当前事务不存在，则抛出异常。</p></li><li><p>REQUIRES_NEW：创建⼀个新事务，如果存在当前事务，则挂起该事务。</p></li><li><p>NOT_SUPPORTED：以⾮事务⽅式执⾏,如果当前存在事务，则挂起当前事务</p></li><li><p>NEVER：不使⽤事务，如果当前事务存在，则抛出异常</p></li><li><p>NESTED：如果当前事务存在，则在嵌套事务中执⾏，否则REQUIRED的操作⼀样（开启⼀个事务）</p><h3 id="Spring的事务实现流程"><a href="#Spring的事务实现流程" class="headerlink" title="Spring的事务实现流程"></a>Spring的事务实现流程</h3></li><li><p>Spring事务底层是基于数据库事务和AOP机制的</p></li><li><p>⾸先对于使⽤了@Transactional注解的Bean，Spring会创建⼀个代理对象作为Bean</p></li><li><p>当调⽤代理对象的⽅法时，会先判断该⽅法上是否加了@Transactional注解</p></li><li><p>如果加了，那么则利⽤事务管理器创建⼀个数据库连接</p></li><li><p>并且修改数据库连接的autocommit属性为false，禁⽌此连接的⾃动提交，这是实现Spring事务⾮常重要的⼀步</p></li><li><p>然后执⾏当前⽅法，⽅法中会执⾏sql</p></li><li><p>执⾏完当前⽅法后，如果没有出现异常就直接提交事务</p></li><li><p>如果出现了异常，并且这个异常是需要回滚的就会回滚事务，否则仍然提交事务</p></li><li><p>Spring事务的隔离级别对应的就是数据库的隔离级别</p></li><li><p>Spring事务的传播机制是Spring事务⾃⼰实现的，也是Spring事务中最复杂的</p></li><li><p>Spring事务的传播机制是基于数据库连接来做的，⼀个数据库连接⼀个事务，如果传播机制配置为需要新开⼀个事务，那么实际上就是先建⽴⼀个数据库连接，在此新数据库连接上执⾏sql</p></li></ol><h3 id="Spring中什么时候-Transactional会失效"><a href="#Spring中什么时候-Transactional会失效" class="headerlink" title="Spring中什么时候@Transactional会失效"></a>Spring中什么时候@Transactional会失效</h3><p>因为Spring事务是基于代理来实现的，如果不是被代理对象来调⽤这个⽅法，@Transactional会失效。</p><p>如果某个⽅法是private的，那么@Transactional也会失效，因为底层cglib是基于⽗⼦类来实现的，⼦类是不能重载⽗类的private⽅法的，所以⽆法很好的利⽤代理，也会导致@Transactianal失效</p>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL(补档)</title>
      <link href="/2022/12/04/mysql-bu-dang/"/>
      <url>/2022/12/04/mysql-bu-dang/</url>
      
        <content type="html"><![CDATA[<h2 id="MySQL"><a href="#MySQL" class="headerlink" title="MySQL"></a>MySQL</h2><h4 id="什么是-MySQL"><a href="#什么是-MySQL" class="headerlink" title="什么是 MySQL"></a>什么是 MySQL</h4><p><strong>MySQL 是一种关系型数据库，主要用于持久化存储我们的系统中的一些数据比如用户信息。</strong></p><h4 id="MySQL-的优点"><a href="#MySQL-的优点" class="headerlink" title="MySQL 的优点"></a>MySQL 的优点</h4><p>MySQL 主要具有下面这些优点：</p><ol><li> 成熟稳定，功能完善。</li><li> 开源免费。</li><li> 文档丰富，既有详细的官方文档，又有非常多优质文章可供参考学习。</li><li> 开箱即用，操作简单，维护成本低。</li><li> 兼容性好，支持常见的操作系统，支持多种开发语言。</li><li> 社区活跃，生态完善。</li><li> 事务支持优秀， InnoDB 存储引擎默认使用 REPEATABLE-READ 并不会有任何性能损失，并且，InnoDB 实现的 REPEATABLE-READ 隔离级别其实是可以解决幻读问题发生的。</li><li> 支持分库分表、读写分离、高可用。<h3 id="一条SQL语句在MySQL中如何执行的"><a href="#一条SQL语句在MySQL中如何执行的" class="headerlink" title="一条SQL语句在MySQL中如何执行的"></a>一条SQL语句在MySQL中如何执行的</h3></li></ol><p>MySQL逻辑架构图</p><p>MySQL分为Server层和存储引擎层两个部分，不同的存储引擎共用一个Server层。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E5%BA%93/08.png"></p><p>Server层：大多数MySQL的核心服务功能都在这一层，包括连接处理、授权认证、查询解析、分析、优化、缓存以及所有的内置函数（例如，日期、时间、数学和加密函数），所有跨存储引擎的功能都在这一层实现，比如存储过程、触发器、视图等。</p><p>存储引擎层：存储引擎负责MySQL中数据的存储和提取。服务器通过API与存储引擎进行通信。这些接口屏蔽了不同存储引擎之间的差异，使得这些差异对上层的查询过程透明。</p><ol><li><p><strong>连接器</strong> 第一步，先连接到数据库上，当客户端（应用）连接到MySQL服务器时，服务器需要对其进行认证，认证基于用户名、原始主机信息和密码，一旦客户端连接成功，服务器会继续验证客户端是否具有执行某个特定查询的权限</p></li><li><p><strong>查询缓存</strong> 第二步，查询缓存，每次MySQL执行过的语句及其结果会以key-value形式缓存在内存中，key是查询语句，value是查询结果。如果查询能够在缓存中找到key，那么这个value就会被直接返回客户端。<br> 注意：MySQL8.0版本直接将缓存的整个功能模块删掉了</p></li><li><p><strong>分析器</strong> 第三步，分析器，如果没有命中缓存，就会执行SQL语句，首先让MySQL知道我们需要做什么，因此需要对SQL语句解析。解析器的工作：语法分析（生成句子），语义分析（确保这些句子讲得通），以及代码生成（为编译准备）</p></li><li><p><strong>优化器</strong> 第四步，优化器，经过分析器MySQL知道我们需要什么了，在开始执行前，还要经过优化器进行处理，优化器是在表里面有多个索引时，决定使用哪个索引，或者在一个语句有多表关联（join）时，决定各个表的连接顺序。优化器会生成执行计划</p></li><li><p><strong>执行器</strong> 第五步，执行器，MySQL通过分析器知道要做什么，通过优化器知道怎么做，开始执行前，要先判断一下是否有表TABLE查询权限，如果有打开表，根据表的引擎定义，去使用这个引擎提供的接口。根据执行计划，调用存储引擎API来查询数据</p></li></ol><h3 id="一条SQL的执行顺序是什么"><a href="#一条SQL的执行顺序是什么" class="headerlink" title="一条SQL的执行顺序是什么"></a>一条SQL的执行顺序是什么</h3><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token number">1.</span><span class="token keyword">FROM</span>     ：对<span class="token keyword">FROM</span>左边的表和右边的表计算笛卡尔积，产生虚拟表t1<span class="token number">2.</span><span class="token keyword">ON</span>       ：对表t1进行<span class="token keyword">ON</span>筛选，只有符合条件的行才会记录在表t2中<span class="token number">3.</span><span class="token keyword">JOIN</span>     ：如果指定了<span class="token keyword">OUTER</span> <span class="token keyword">JOIN</span>（如：<span class="token keyword">left</span> <span class="token keyword">join</span>、<span class="token keyword">right</span> <span class="token keyword">join</span>）<span class="token punctuation">,</span>那么未匹配到的行作为外部行添加到表t3中<span class="token number">4.</span><span class="token keyword">WHERE</span>    ：对表t3进行<span class="token keyword">where</span>条件过滤，只有符合条件的记录才会记录在表t4中<span class="token number">5.</span><span class="token keyword">GROUP</span> <span class="token keyword">BY</span> ：根据<span class="token keyword">group</span> <span class="token keyword">by</span> 子句中的列，对表t4记录进行分组操作，产生表t5<span class="token number">6.</span><span class="token keyword">HAVING</span>   ：对表t5进行<span class="token keyword">having</span>过滤，只有符合条件的行才会记录在表t6中<span class="token number">7.</span><span class="token keyword">SELECT</span>   ：执行<span class="token keyword">select</span>操作，选择指定的列，产生表t7<span class="token number">8.</span><span class="token keyword">DISTINCT</span> ：对表t7记录进行去重，产生表t8<span class="token number">9.</span><span class="token keyword">ORDER</span> <span class="token keyword">BY</span> ：对表t8记录进行排序，产生表t9<span class="token number">10.</span><span class="token keyword">LIMIT</span>   ：取出指定的行，产生表t10<span class="token punctuation">,</span>并将结果进行展示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MySQL-的默认存储引擎"><a href="#MySQL-的默认存储引擎" class="headerlink" title="MySQL 的默认存储引擎"></a>MySQL 的默认存储引擎</h3><p>MySQL 5.5.5 之前：MyISAM 是 MySQL 的默认存储引擎。<br>5.5.5 版本之后：InnoDB 是 MySQL 的默认存储引擎。</p><p>MySQL 存储引擎采用的是 <strong>插件式架构</strong> ，支持多种存储引擎，可以为不同的数据库表设置不同的存储引擎以适应不同场景的需要。<strong>存储引擎是基于表的，而不是数据库。</strong></p><h3 id="MyISAM-和-InnoDB-的区别"><a href="#MyISAM-和-InnoDB-的区别" class="headerlink" title="MyISAM 和 InnoDB 的区别"></a>MyISAM 和 InnoDB 的区别</h3><ul><li>  InnoDB 支持行级别的锁粒度，MyISAM 不支持，只支持表级别的锁粒度。</li><li>  MyISAM 不提供事务支持。InnoDB 提供事务支持，实现了 SQL 标准定义了四个隔离级别。</li><li>  MyISAM 不支持外键，而 InnoDB 支持。</li><li>  MyISAM 不支持 MVCC，而 InnoDB 支持。</li><li>  虽然 MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构，但是两者的实现方式不太一样。（非聚簇和聚簇）</li><li>  MyISAM 不支持数据库异常崩溃后的安全恢复，而 InnoDB 支持。</li><li>  InnoDB 的性能比 MyISAM 更强大。<h3 id="MySQL用什么类型数据存储时间"><a href="#MySQL用什么类型数据存储时间" class="headerlink" title="MySQL用什么类型数据存储时间"></a>MySQL用什么类型数据存储时间</h3></li></ul><ol><li>不要用字符串存储日期，简单直白，但是占用的空间更大，计算和比较效率低</li><li>DateTime 类型没有时区信息，Timestamp 和时区有关</li><li>DateTime 类型耗费空间更大，Timestamp 只需要使用 4 个字节的存储空间，但是 DateTime 需要耗费 8 个字节的存储空间</li><li>Timestamp 表示的时间范围更小。</li><li>用 int 或者 bigint 类型的数值也就是时间戳来表示时间，跨系统也很方便，排序以及对比效率高，但是数据的可读性太差</li></ol><h3 id="介绍一下join"><a href="#介绍一下join" class="headerlink" title="介绍一下join"></a>介绍一下join</h3><ul><li>A inner join B&nbsp;：取交集。</li><li>A left join B&nbsp;：取 A 全部，B 没有对应的值为 null。</li><li>A right join B&nbsp;：取 B 全部 A 没有对应的值为 null。</li><li>A full outer join B&nbsp;：取并集，彼此没有对应的值为 null。</li></ul><p>对应条件在&nbsp;<strong>on</strong>&nbsp;后面填写</p><p>在使用&nbsp;join&nbsp;时，<strong>on</strong>&nbsp;和&nbsp;<strong>where</strong>&nbsp;条件的区别如下：</p><ul><li>&nbsp;1、&nbsp;<strong>on</strong>&nbsp;条件是在生成临时表时使用的条件，它不管&nbsp;<strong>on</strong>&nbsp;中的条件是否为真，都会返回左边表中的记录。</li><li>&nbsp;2、<strong>where</strong>&nbsp;条件是在临时表生成好后，再对临时表进行过滤的条件。这时已经没有&nbsp;left join&nbsp;的含义（必须返回左边表的记录）了，条件不为真的就全部过滤掉。</li></ul><h3 id="MySQL的redo-log，undo-log，bin-log都是干什么的"><a href="#MySQL的redo-log，undo-log，bin-log都是干什么的" class="headerlink" title="MySQL的redo log，undo log，bin log都是干什么的"></a>MySQL的redo log，undo log，bin log都是干什么的</h3><p>1、redolog记录修改内容（哪一页发生了什么变化），写于事务开始前，用于数据未落磁盘，但数据库挂了后的数据恢复<br>2、binlog记录修改SQL，写于事务提交时，可用于读写分离 ，主从复制<br>3、undolog记录修改前记录，用于回滚和多版本并发控制</p><h2 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h2><h3 id="事务的基本特性"><a href="#事务的基本特性" class="headerlink" title="事务的基本特性"></a>事务的基本特性</h3><ol><li><p><strong>原⼦性</strong>：⼀个事务中的操作要么全部成功，要么全部失败。</p></li><li><p><strong>⼀致性</strong>：数据库总是从⼀个⼀致性的状态转换到另外⼀个⼀致性的状态。</p></li><li><p><strong>隔离性</strong>：⼀个事务的修改在最终提交前，对其他事务是不可⻅的。</p></li><li><p><strong>持久性</strong>：⼀旦事务提交，所做的修改就会永久保存到数据库中。</p></li></ol><h3 id="并发事务带来的问题"><a href="#并发事务带来的问题" class="headerlink" title="并发事务带来的问题"></a>并发事务带来的问题</h3><p><strong>脏读（Dirty read）</strong></p><p>一个事务读取数据并且对数据进行了修改，这个修改对其他事务来说是可见的，即使当前事务没有提交。这时另外一个事务读取了这个还未提交的数据，但第一个事务突然回滚，导致数据并没有被提交到数据库，那第二个事务读取到的就是脏数据。</p><p><strong>丢失修改（Lost to modify）</strong></p><p>在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。</p><p><strong>不可重复读（Unrepeatable read）</strong></p><p>在一个事务内两次读到的数据是不一样的情况。在一个事务内多次读同一数据。在这个事务还没有结束时，另一个事务也访问该数据。在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。</p><p><strong>幻读（Phantom read）</strong></p><p>幻读与不可重复读类似。它发生在一个事务读取了几行数据，接着另一个并发事务插入了一些数据时。在随后的查询中，第一个事务就会发现多了一些原本不存在的记录，就好像发生了幻觉一样，所以称为幻读。</p><h3 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h3><ol><li><p>read uncommit 读未提交，可能会读到其他事务未提交的数据，也叫做脏读。</p></li><li><p>read commit 读已提交，两次读取结果不⼀致，叫做不可重复读。不可重复读解决了脏读的问题，他只会读取已经提交的事务。</p></li><li><p>repeatable read 可重复复读，就是每次读取结果都⼀样，但是有可能产⽣幻读。</p></li><li><p>serializable 串⾏，给每⼀⾏读取的数据加锁，会导致⼤量超时和锁竞争的问题。</p></li></ol><h3 id="并发事务的控制方式"><a href="#并发事务的控制方式" class="headerlink" title="并发事务的控制方式"></a>并发事务的控制方式</h3><p><strong>锁</strong> 和 <strong>MVCC</strong></p><p>锁可以看作是悲观控制的模式</p><p>多版本并发控制（MVCC，Multiversion concurrency control）可以看作是乐观控制的模式</p><h3 id="ACID靠什么保证"><a href="#ACID靠什么保证" class="headerlink" title="ACID靠什么保证"></a>ACID靠什么保证</h3><p><strong>A原⼦性</strong>：由undo log⽇志保证，它记录了需要回滚的⽇志信息，事务回滚时撤销已经执⾏成功的sql</p><p><strong>C⼀致性</strong>：由其他三⼤特性保证、程序代码要保证业务上的⼀致性</p><p><strong>I隔离性</strong>：由锁和MVCC来保证</p><p><strong>D持久性</strong>：由内存+redo log来保证，mysql修改数据同时在内存和redo log记录这次操作，宕机的时候可以从redo log恢复</p><h2 id="锁"><a href="#锁" class="headerlink" title="锁"></a>锁</h2><h3 id="Mysql锁有哪些"><a href="#Mysql锁有哪些" class="headerlink" title="Mysql锁有哪些"></a>Mysql锁有哪些</h3><p>按锁粒度分类：</p><ol><li><p><strong>⾏锁</strong>：锁某⾏数据，锁粒度最⼩，并发度⾼</p></li><li><p><strong>表锁</strong>：锁整张表，锁粒度最⼤，并发度低</p></li><li><p><strong>间隙锁</strong>：锁的是⼀个区间</p></li></ol><p>还可以分为：</p><ol><li><p><strong>共享锁</strong>：也就是读锁，⼀个事务给某⾏数据加了读锁，其他事务也可以读，但是不能写</p></li><li><p><strong>排它锁</strong>：也就是写锁，⼀个事务给某⾏数据加了写锁，其他事务不能读，也不能写</p></li></ol><p>共享锁和排他锁是表级锁和行级锁</p><ol start="3"><li><p> <strong>意向共享锁（Intention Shared Lock，IS 锁）</strong>：事务有意向对表中的某些记录加共享锁（S 锁），加共享锁前必须先取得该表的 IS 锁。</p></li><li><p> <strong>意向排他锁（Intention Exclusive Lock，IX 锁）</strong>：事务有意向对表中的某些记录加排他锁（X 锁），加排他锁之前必须先取得该表的 IX 锁。</p></li></ol><p>意向锁是表级锁</p><pre class="line-numbers language-none"><code class="language-none"># 共享锁SELECT ... LOCK IN SHARE MODE;# 排他锁SELECT ... FOR UPDATE;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="InnoDB-锁有哪些"><a href="#InnoDB-锁有哪些" class="headerlink" title="InnoDB 锁有哪些"></a>InnoDB 锁有哪些</h3><ul><li>  <strong>记录锁（Record Lock）</strong> ：也被称为记录锁，属于单个行记录上的锁。</li><li>  <strong>间隙锁（Gap Lock）</strong> ：锁定一个范围，不包括记录本身。</li><li>  <strong>临键锁（Next-Key Lock）</strong> ：Record Lock+Gap Lock，锁定一个范围，包含记录本身，主要是为了解决幻读问题。</li></ul><p>在 InnoDB 默认的隔离级别 REPEATABLE-READ 下，行锁默认使用的是 Next-Key Lock</p><h3 id="当前读和快照读的区别"><a href="#当前读和快照读的区别" class="headerlink" title="当前读和快照读的区别"></a>当前读和快照读的区别</h3><p><strong>快照读</strong>（一致性非锁定读）就是单纯的 <code>SELECT</code> 语句，但不包括下面这两类 <code>SELECT</code> 语句：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token keyword">SELECT</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>只有在事务隔离级别 RC(读取已提交) 和 RR（可重读）下，InnoDB 才会使用一致性非锁定读：</p><ul><li>  在 RC 级别下，对于快照数据，一致性非锁定读总是读取被锁定行的最新一份快照数据。</li><li>  在 RR 级别下，对于快照数据，一致性非锁定读总是读取本事务开始时的行数据版本。</li></ul><p><strong>当前读</strong> （一致性锁定读）就是给行记录加 X 锁或 S 锁。</p><p>当前读的一些常见 SQL 语句类型如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token comment"># 对读的记录加一个X锁</span><span class="token keyword">SELECT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">FOR</span> <span class="token keyword">UPDATE</span><span class="token comment"># 对读的记录加一个S锁</span><span class="token keyword">SELECT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">LOCK</span> <span class="token operator">IN</span> <span class="token keyword">SHARE</span> <span class="token keyword">MODE</span><span class="token comment"># 对修改的记录加一个X锁</span><span class="token keyword">INSERT</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">UPDATE</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token keyword">DELETE</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="MVCC"><a href="#MVCC" class="headerlink" title="MVCC"></a>MVCC</h2><h3 id="什么是MVCC"><a href="#什么是MVCC" class="headerlink" title="什么是MVCC"></a>什么是MVCC</h3><p>多版本并发控制：读取数据时通过⼀种类似快照的⽅式将数据保存下来，这样读锁就和写锁不冲突了，不同的事务session会看到⾃⼰特定版本的数据，版本链</p><p>MVCC只在**READ COMMITTED(读已提交)<strong>和</strong>REPEATABLE READ(可重复读)**两个隔离级别下⼯作。</p><p>其他两个隔离级别够和MVCC不兼容, 因为 READ UNCOMMITTED 总是读取最新的数据⾏, ⽽不是符合当前事务版本的数据⾏。⽽ SERIALIZABLE 则会对所有读取的⾏都加锁。</p><p>对于InnoDB存储引擎，每一行记录都有隐藏列：</p><p><strong>trx_id</strong>：⽤来存储每次对某条记录进⾏修改的时候的事务id。<br><strong>roll_pointer</strong>：记录有修改的时候，都会把⽼版本写⼊undo⽇志中。roll_pointer就是存了⼀个指针，它指向这条记录的上⼀个版本的位置，通过它来获得上⼀个版本的记录信息。<br><strong>row_id</strong>：表中没有主键和非NULL唯一键时，则还会有第三个隐藏的主键列。</p><p>已提交读和可重复读的区别就在于它们⽣成ReadView的策略不同。</p><p>开始事务时创建readview，readView维护当前活动的事务id，即未提交的事务id，排序⽣成⼀个数组<br>，获取数据中的事务id（获取的是事务id最⼤的记录），对⽐readview：</p><ul><li>如果在readview的左边（⽐readview都⼩），可以访问（在左边意味着该事务已经提交）</li><li>如果在readview的右边（⽐readview都⼤）或者就在readview中，不可以访问，获取roll_pointer，取上⼀版本重新对⽐（在右边意味着，该事务在readview⽣成之后出现，在readview中意味着该事务还未提交）</li></ul><p>已提交读隔离级别下的事务在每次查询的开始都会⽣成⼀个独⽴的ReadView,⽽可重复读隔离级别则在第⼀次读的时候⽣成⼀个ReadView，之后的读都复⽤之前的ReadView。</p><p>这就是Mysql的MVCC,通过版本链，实现多版本，可并发读-写，写-读。通过ReadView⽣成策略的不同实现不同的隔离级别。</p><h3 id="基于MVCC查询一条记录，是怎样的流程"><a href="#基于MVCC查询一条记录，是怎样的流程" class="headerlink" title="基于MVCC查询一条记录，是怎样的流程"></a>基于MVCC查询一条记录，是怎样的流程</h3><ol><li> 获取事务自己的版本号，即事务ID</li><li> 获取Read View</li><li> 查询得到的数据，然后与Read View中的事务版本号进行比较。</li><li> 如果不符合Read View的可见性规则， 即就需要Undo log中查找可见的历史快照;</li><li> 最后返回符合规则的数据</li></ol><p>InnoDB 实现MVCC，是通过 <code>Read View+ Undo Log</code> 实现的，Undo Log 保存了历史快照，Read View可见性规则帮助判断当前版本的数据是否可见。</p><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><h3 id="什么是索引"><a href="#什么是索引" class="headerlink" title="什么是索引"></a>什么是索引</h3><p><strong>索引是一种用于快速查询和检索数据的数据结构，其本质可以看成是一种排序好的数据结构。</strong></p><p>索引的作用就相当于书的目录。</p><p><strong>优点</strong> ：</p><ul><li>  使用索引可以大大加快 数据的检索速度, 这也是创建索引的最主要的原因。</li></ul><p><strong>缺点</strong> ：</p><ul><li>  创建索引和维护索引需要耗费许多时间。当对表中的数据进行增删改的时候，如果数据有索引，那么索引也需要动态的修改，会降低 SQL 执行效率。</li><li>  索引需要使用物理文件存储，也会耗费一定空间。</li></ul><h3 id="索引的底层数据结构有哪些"><a href="#索引的底层数据结构有哪些" class="headerlink" title="索引的底层数据结构有哪些"></a>索引的底层数据结构有哪些</h3><p><strong>Hash 表</strong></p><p>哈希表是键值对的集合，通过键(key)即可快速取出对应的值(value)，因此哈希表可以快速检索数据（接近 O（1））。</p><p>哈希算法有<strong>Hash 冲突</strong>&nbsp;问题，哈希索引不支持顺序和范围查询。</p><p><strong>B+树</strong></p><p>B+树是⼀个平衡的多叉树，从根节点到每个叶⼦节点的⾼度差值不超过1，⽽且同层级的节点间有指针相互链接。在B+树上的常规检索，从根节点到叶⼦节点的搜索效率基本相当，不会出现⼤幅波动，⽽且基于索引的顺序扫描时，也可以利⽤双向指针快速左右移动，效率⾮常⾼。因此，B+树索引被⼴泛应⽤于数据库、⽂件系统等场景。</p><p>在 MySQL 中，MyISAM 引擎和 InnoDB 引擎都是使用 B+Tree 作为索引结构</p><h3 id="为什么用B-树而不用B-树"><a href="#为什么用B-树而不用B-树" class="headerlink" title="为什么用B+树而不用B-树"></a>为什么用B+树而不用B-树</h3><ol><li><p>B+树索引节点没有有Data域，内存占用小，索引范围大。</p></li><li><p>B+树节点小，磁盘IO次数少</p></li><li><p>B+树叶子节点用指针串连，可以进行区间访问</p></li></ol><p><strong>B 树&amp; B+树两者有何异同</strong></p><p>B 树也称 B-树,全称为 <strong>多路平衡查找树</strong> ，B+ 树是 B 树的一种变体。</p><ul><li>  B 树的所有节点既存放键(key) 也存放 数据(data)，而 B+树只有叶子节点存放 key 和 data，其他内节点只存放 key。</li><li>  B 树的叶子节点都是独立的;B+树的叶子节点有一条引用链指向与它相邻的叶子节点。</li><li>  B 树的检索的过程相当于对范围内的每个节点的关键字做二分查找，可能还没有到达叶子节点，检索就结束了。而 B+树的检索效率就很稳定了，任何查找都是从根节点到叶子节点的过程，叶子节点的顺序检索很明显。</li></ul><h3 id="为什么用B-树而不用红黑树或者AVL树"><a href="#为什么用B-树而不用红黑树或者AVL树" class="headerlink" title="为什么用B+树而不用红黑树或者AVL树"></a>为什么用B+树而不用红黑树或者AVL树</h3><p><strong>红黑树和AVL树的高度太大</strong>：<strong>AVL 树和红黑树基本都是存储在内存中才会使用的数据结构</strong>。在大规模数据存储的时候，红黑树往往出现由于<strong>树的深度过大</strong>而造成磁盘IO读写过于频繁，进而导致效率低下的情况。</p><p><strong>B+树一个node只需一次I/O</strong>：<strong>数据库系统的设计者巧妙利用了磁盘预读原理</strong>，将一个节点的大小设为等于一个页，这样每个节点只需要一次I/O就可以完全载入。</p><h3 id="索引有哪些类型"><a href="#索引有哪些类型" class="headerlink" title="索引有哪些类型"></a>索引有哪些类型</h3><p><strong>按照底层存储方式角度划分</strong></p><ul><li>  聚簇索引（聚集索引）：索引结构和数据一起存放的索引，InnoDB 中的主键索引就属于聚簇索引。</li><li>  非聚簇索引（非聚集索引）：索引结构和数据分开存放的索引，二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li></ul><p><strong>按照应用维度划分</strong></p><ul><li><p>  主键索引：是⼀种特殊的唯⼀索引，在⼀张表中只能定义⼀个主键索引，主键⽤于唯⼀标识⼀条记录，使⽤关键字 PRIMARY KEY 来创建。（不可以有 NULL）</p></li><li><p>  普通索引：允许被索引的数据列包含重复的值。（可以有 NULL）</p></li><li><p>  唯一索引：可以保证数据记录的唯⼀性。（可以有 NULL）</p></li><li><p>  覆盖索引：一个索引包含（或者说覆盖）所有需要查询的字段的值。</p></li><li><p>  联合索引：多列值组成一个索引，专门用于组合搜索，其效率大于索引合并。</p></li><li><p>  全文索引：通过建⽴倒排索引 ,可以极⼤的提升检索效率,解决判断字段是否包含的问题。目前只有 <code>CHAR</code>、<code>VARCHAR</code> ，<code>TEXT</code> 列上可以创建全文索引。一般不会使用，效率较低，通常使用搜索引擎如 ElasticSearch 代替。</p><h3 id="聚簇索引与非聚簇索引的区别是什么"><a href="#聚簇索引与非聚簇索引的区别是什么" class="headerlink" title="聚簇索引与非聚簇索引的区别是什么"></a>聚簇索引与非聚簇索引的区别是什么</h3></li><li><p>聚簇索引：即索引结构和数据一起存放的索引，并不是一种单独的索引类型。InnoDB 中的主键索引就属于聚簇索引。</p></li><li><p>对于 InnoDB 引擎表来说，该表的索引(B+树)的每个非叶子节点存储索引，叶子节点存储索引和索引对应的数据。</p></li></ul><hr><ul><li>非聚簇索引：即索引结构和数据分开存放的索引，并不是一种单独的索引类型。二级索引(辅助索引)就属于非聚簇索引。MySQL 的 MyISAM 引擎，不管主键还是非主键，使用的都是非聚簇索引。</li><li>非聚簇索引的叶子节点并不一定存放数据的指针，因为二级索引的叶子节点就存放的是主键，根据主键再回表查数据。</li></ul><p>聚簇索引的优缺点：</p><p><strong>优点</strong> ：</p><ul><li>  <strong>查询速度非常快</strong> ：相比于非聚簇索引， 聚簇索引少了一次读取数据的 IO 操作。</li><li>  <strong>对排序查找和范围查找优化</strong> ：聚簇索引对于主键的排序查找和范围查找速度非常快。</li></ul><p><strong>缺点</strong> ：</p><ul><li>  <strong>依赖于有序的数据</strong> ：如果索引的数据不是有序的，那么就需要在插入时排序，字符串或 UUID 这种又长又难比较的数据，插入或查找的速度比较慢。</li><li>  <strong>更新代价大</strong> ： 如果对索引列的数据被修改时，那么对应的索引也将会被修改</li></ul><p>非聚簇索引的优缺点：</p><p><strong>优点</strong> ：</p><ul><li>更新代价比聚簇索引要小 。非聚簇索引的叶子节点是不存放数据的</li></ul><p><strong>缺点</strong> ：</p><ul><li>  <strong>依赖于有序的数据</strong> ：跟聚簇索引一样，非聚簇索引也依赖于有序的数据</li><li>  <strong>可能会二次查询(回表)</strong> ：这应该是非聚簇索引最大的缺点了。 当查到索引对应的指针或主键后，可能还需要根据指针或主键再到数据文件或表中查询。</li></ul><h3 id="索引覆盖是什么"><a href="#索引覆盖是什么" class="headerlink" title="索引覆盖是什么"></a>索引覆盖是什么</h3><p>索引覆盖就是⼀个SQL在执⾏时，可以利⽤索引来快速查找，并且此SQL所要查询的字段在当前索引对应的字段中都包含了，那么就表示此SQL⾛完索引后不⽤回表了，所需要的字段都在当前索引的叶⼦节点上存在，可以直接作为结果返回了</p><h3 id="非聚簇索引一定回表查询吗-覆盖索引"><a href="#非聚簇索引一定回表查询吗-覆盖索引" class="headerlink" title="非聚簇索引一定回表查询吗(覆盖索引)"></a>非聚簇索引一定回表查询吗(覆盖索引)</h3><p><strong>非聚簇索引不一定回表查询。</strong></p><p>用户准备使用 SQL 查询用户名，而用户名字段正好建立了索引。</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql"><span class="token keyword">SELECT</span> name <span class="token keyword">FROM</span> <span class="token keyword">table</span> <span class="token keyword">WHERE</span> name<span class="token operator">=</span><span class="token string">'aiaa'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>那么这个索引的 key 本身就是 name，查到对应的 name 直接返回就行了，无需回表查询。</p><h3 id="索引下推是什么"><a href="#索引下推是什么" class="headerlink" title="索引下推是什么"></a>索引下推是什么</h3><p><strong>索引下推（Index Condition Pushdown）</strong> 是 <strong>MySQL 5.6</strong> 版本中提供的一项索引优化功能，可以在非聚簇索引遍历过程中，对索引中包含的字段先做判断，过滤掉不符合条件的记录，减少回表次数。</p><h3 id="最左前缀原则是什么"><a href="#最左前缀原则是什么" class="headerlink" title="最左前缀原则是什么"></a>最左前缀原则是什么</h3><p>当⼀个SQL想要利⽤索引，就⼀定要提供该索引所对应的字段中最左边的字段，也就是排在最前⾯的字段，⽐如针对a,b,c三个字段建⽴了⼀个联合索引，那么在写⼀个sql时就⼀定要提供a字段的条件，这样才能⽤到联合索引，这是由于在建⽴a,b,c三个字段的联合索引时，底层的B+树是按照a,b,c三个字段从左往右去⽐较⼤⼩进⾏排序的，所以如果想要利⽤B+树进⾏快速查找也得符合这个规则</p><h3 id="索引哪些情况会失效"><a href="#索引哪些情况会失效" class="headerlink" title="索引哪些情况会失效"></a>索引哪些情况会失效</h3><ul><li><p>查询条件包含or，会导致索引失效。</p></li><li><p>隐式类型转换，会导致索引失效，例如age字段类型是int，where age = “1”，这样就会触发隐式类型转换。</p></li><li><p>like通配符会导致索引失效。注意：”ABC%“会走range索引，”%ABC”索引才会失效。</p></li><li><p>联合索引，查询时的条件列不是联合索引中的第一个列，索引失效。</p></li><li><p>对索引字段进行函数运算。</p></li><li><p>对索引列运算（如，+、-、*、/），索引失效。</p></li><li><p>索引字段上使用（!= 或者 &lt; &gt;，not in）时，会导致索引失效。</p></li><li><p>索引字段上使用is null， is not null，可能导致索引失效。</p></li><li><p>相join的两个表的字符编码不同，不能命中索引，会导致笛卡尔积的循环计算</p></li><li><p>mysql估计使用全表扫描要比使用索引快,则不使用索引。</p><h3 id="索引不适合哪些场景"><a href="#索引不适合哪些场景" class="headerlink" title="索引不适合哪些场景"></a>索引不适合哪些场景</h3></li><li><p>数据量少的不适合加索引</p></li><li><p>更新比较频繁的也不适合加索引</p></li><li><p>离散性低的字段不适合加索引（如性别）</p></li></ul><p><strong>选择合适的字段创建索引</strong></p><ul><li>  <strong>不为 NULL 的字段</strong> ：索引字段的数据应该尽量不为 NULL，因为对于数据为 NULL 的字段，数据库较难优化。</li><li>  <strong>被频繁查询的字段</strong> ：我们创建索引的字段应该是查询操作非常频繁的字段。</li><li>  <strong>被作为条件查询的字段</strong> ：被作为 WHERE 条件查询的字段，应该被考虑建立索引。</li><li>  <strong>频繁需要排序的字段</strong> ：索引已经排序，这样查询可以利用索引的排序，加快排序查询时间。</li><li>  <strong>被经常频繁用于连接的字段</strong> ：经常用于连接的字段可能是一些外键列，对于外键列并不一定要建立外键，只是说该列涉及到表与表的关系。对于频繁被连接查询的字段，可以考虑建立索引，提高多表连接查询的效率。<h3 id="如何分析语句是否走索引查询"><a href="#如何分析语句是否走索引查询" class="headerlink" title="如何分析语句是否走索引查询"></a>如何分析语句是否走索引查询</h3></li></ul><p>我们可以使用 <code>EXPLAIN</code> 命令来分析 SQL 的 <strong>执行计划</strong> ，这样就知道语句是否命中索引了。执行计划是指一条 SQL 语句在经过 MySQL 查询优化器的优化会后，具体的执行方式。</p><p><code>EXPLAIN</code> 并不会真的去执行相关的语句，而是通过 <strong>查询优化器</strong> 对语句进行分析，找出最优的查询方案，并显示对应的信息。</p><p><code>EXPLAIN</code> 的输出格式如下：</p><pre class="line-numbers language-sql" data-language="sql"><code class="language-sql">mysql<span class="token operator">&gt;</span> <span class="token keyword">EXPLAIN</span> <span class="token keyword">SELECT</span> <span class="token identifier"><span class="token punctuation">`</span>score<span class="token punctuation">`</span></span><span class="token punctuation">,</span><span class="token identifier"><span class="token punctuation">`</span>name<span class="token punctuation">`</span></span> <span class="token keyword">FROM</span> <span class="token identifier"><span class="token punctuation">`</span>cus_order<span class="token punctuation">`</span></span> <span class="token keyword">ORDER</span> <span class="token keyword">BY</span> <span class="token identifier"><span class="token punctuation">`</span>score<span class="token punctuation">`</span></span> <span class="token keyword">DESC</span><span class="token punctuation">;</span><span class="token operator">+</span><span class="token comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><span class="token operator">|</span> id <span class="token operator">|</span> select_type <span class="token operator">|</span> <span class="token keyword">table</span>     <span class="token operator">|</span> partitions <span class="token operator">|</span> <span class="token keyword">type</span> <span class="token operator">|</span> possible_keys <span class="token operator">|</span> <span class="token keyword">key</span>  <span class="token operator">|</span> key_len <span class="token operator">|</span> ref  <span class="token operator">|</span> <span class="token keyword">rows</span>   <span class="token operator">|</span> filtered <span class="token operator">|</span> Extra          <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><span class="token operator">|</span>  <span class="token number">1</span> <span class="token operator">|</span> <span class="token keyword">SIMPLE</span>      <span class="token operator">|</span> cus_order <span class="token operator">|</span> <span class="token boolean">NULL</span>       <span class="token operator">|</span> <span class="token keyword">ALL</span>  <span class="token operator">|</span> <span class="token boolean">NULL</span>          <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token boolean">NULL</span>    <span class="token operator">|</span> <span class="token boolean">NULL</span> <span class="token operator">|</span> <span class="token number">997572</span> <span class="token operator">|</span>   <span class="token number">100.00</span> <span class="token operator">|</span> <span class="token keyword">Using</span> filesort <span class="token operator">|</span><span class="token operator">+</span><span class="token comment">----+-------------+-----------+------------+------+---------------+------+---------+------+--------+----------+----------------+</span><span class="token number">1</span> <span class="token keyword">row</span> <span class="token operator">in</span> <span class="token keyword">set</span><span class="token punctuation">,</span> <span class="token number">1</span> warning <span class="token punctuation">(</span><span class="token number">0.00</span> sec<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="MySQL的explain执行计划的type属性值表示的是什么"><a href="#MySQL的explain执行计划的type属性值表示的是什么" class="headerlink" title="MySQL的explain执行计划的type属性值表示的是什么"></a>MySQL的explain执行计划的type属性值表示的是什么</h3><p>常见取值及其含义：</p><ol><li>const（常量）：表示通过索引一次查找就可以定位到唯一的行。</li><li>ref（索引查找）：表示通过非唯一索引进行查找并返回匹配条件的行。</li><li>range（范围查找）：表示通过索引的范围查找，返回匹配指定条件范围的行。</li><li>index（索引扫描）：表示全索引扫描，遍历索引树上的每个节点。</li><li>all（全表扫描）：表示对整个表进行完全扫描，没有使用索引。</li></ol><h2 id="分库分表"><a href="#分库分表" class="headerlink" title="分库分表"></a>分库分表</h2><h4 id="什么是分库分表"><a href="#什么是分库分表" class="headerlink" title="什么是分库分表"></a>什么是分库分表</h4><p><strong>分库</strong> 就是将数据库中的数据分散到不同的数据库上，可以垂直分库，也可以水平分库。<br><strong>分表</strong> 就是对单表的数据进行拆分，可以是垂直拆分，也可以是水平拆分。</p><h3 id="分库分表的拆分方法有哪些"><a href="#分库分表的拆分方法有哪些" class="headerlink" title="分库分表的拆分方法有哪些"></a>分库分表的拆分方法有哪些</h3><ul><li>水平分库：以库为依据，按照一定策略（hash、range等），将一个库中的数据拆分到多个库中。</li><li>水平分表：以表为依据，按照一定策略（hash、range等），将一个表中的数据拆分到多个表中。</li><li>垂直分库：以表为依据，按照业务归属不同，将不同的表拆分到不同的库中。</li><li>垂直分表：以字段为依据，按照字段的活跃性，将表中字段拆到不同的表（主表和扩展表）中</li></ul><h3 id="什么情况下需要分库分表"><a href="#什么情况下需要分库分表" class="headerlink" title="什么情况下需要分库分表"></a>什么情况下需要分库分表</h3><ul><li>  单表的数据达到千万级别以上，数据库读写速度比较缓慢。</li><li>  数据库中的数据占用的空间越来越大，备份时间越来越长。</li><li>  应用的并发量太大。</li></ul><h3 id="常用的分库分表中间件"><a href="#常用的分库分表中间件" class="headerlink" title="常用的分库分表中间件"></a>常用的分库分表中间件</h3><ul><li>Sharding-Sphere</li><li>Mycat</li></ul><p>Sharding-Sphere 这种 client 层方案的优点在于不用部署，运维成本低，不需要代理层的二<br>次转发请求，性能很高，但是如果遇到升级啥的需要各个系统都重新升级版本再发布，各个<br>系统都需要耦合 Sharding-Sphere 的依赖；</p><p>mycat 这种 proxy 层方案的缺点在于需要部署，自己及运维一套中间件，运维成本高，<br>但是好处在于对于各个项目是透明的，如果遇到升级之类的都是自己中间件那里搞就行了</p><h3 id="分库分表会带的问题"><a href="#分库分表会带的问题" class="headerlink" title="分库分表会带的问题"></a>分库分表会带的问题</h3><ul><li>  <strong>join 操作</strong> ： 同一个数据库中的表分布在了不同的数据库中，导致无法使用 join 操作。这样就导致我们需要手动进行数据的封装。</li><li>  <strong>事务问题</strong> ：同一个数据库中的表分布在了不同的数据库中，如果单个操作涉及到多个数据库，那么数据库自带的事务就无法满足我们的要求了。</li><li>  <strong>分布式 id</strong> ：分库之后， 数据遍布在不同服务器上的数据库，数据库的自增主键已经没办法满足生成的主键唯一了。需要为系统引入分布式 id 。</li></ul><h3 id="如何解决id唯一性问题"><a href="#如何解决id唯一性问题" class="headerlink" title="如何解决id唯一性问题"></a>如何解决id唯一性问题</h3><ul><li>UUID：结合机器的网卡、当地时间、一个随机数来生成UUID。</li><li>为每个分片指定一个 ID 范围</li><li>数据库自增，多个Master库就设置不同的自增步长</li><li>雪花算法自增：64位long(1符号位，41时间戳，10机器id，12流水号：意味着每毫秒可以产生4096个id)</li><li>借助redis自增(incr 和 increby原子指令)</li></ul><h3 id="分库分表如何将老库的数据迁移到新库（实现方案）"><a href="#分库分表如何将老库的数据迁移到新库（实现方案）" class="headerlink" title="分库分表如何将老库的数据迁移到新库（实现方案）"></a>分库分表如何将老库的数据迁移到新库（实现方案）</h3><p><strong>停机迁移</strong>：维护升级预计 1 小时，写一个脚本将老库的数据都同步到新库中。</p><p><strong>双写方案</strong>：双写方案是针对那种不能停机迁移的场景，动态切换</p><ul><li>  对老库的更新操作（增删改），同时也要写入新库（双写）。如果操作的数据不存在于新库的话，需要插入到新库中。 这样就能保证，咱们新库里的数据是最新的。</li><li>  在迁移过程，双写只会让被更新操作过的老库中的数据同步到新库，我们还需要自己写脚本将老库中的数据和新库的数据做比对。如果新库中没有，那咱们就把数据插入到新库。如果新库有，旧库没有，就把新库对应的数据删除（冗余数据清理）。</li><li>  重复上一步的操作，直到老库和新库的数据一致为止。</li></ul><h2 id="读写分离"><a href="#读写分离" class="headerlink" title="读写分离"></a>读写分离</h2><p><strong>读写分离主要是为了将对数据库的读写操作分散到不同的数据库节点上。</strong>&nbsp;这样的话，就能够小幅提升写性能，大幅提升读性能。</p><p>一主多从，也就是一台主数据库负责写，其他的从数据库负责读。主库和从库之间会进行数据同步，以保证从库中数据的准确性。</p><p><strong>读写分离依赖于从主复制。</strong></p><h3 id="主从复制的原理是什么（过程怎么样的）"><a href="#主从复制的原理是什么（过程怎么样的）" class="headerlink" title="主从复制的原理是什么（过程怎么样的）"></a>主从复制的原理是什么（过程怎么样的）</h3><p>MySQL binlog(binary log 即二进制日志文件) 主要记录了 MySQL 数据库中数据的所有变化(数据库执行的所有 DDL 和 DML 语句)。因此，我们根据主库的 MySQL binlog 日志就能够将主库的数据同步到从库中。</p><ol><li> 主库将数据库中数据的变化写入到 binlog</li><li> 从库连接主库</li><li> 从库会创建一个 I/O 线程向主库请求更新的 binlog</li><li> 主库会创建一个 binlog dump 线程来发送 binlog ，从库中的 I/O 线程负责接收</li><li> 从库的 I/O 线程将接收的 binlog 写入到中转日志 relay log 中。</li><li> 从库的 SQL 线程读取 relay log 同步数据本地（也就是再执行一遍 SQL ）。</li></ol><p>binlog 还能帮助我们实现数据恢复。</p><h3 id="主从同步延迟是什么？怎么产生的？如何解决？"><a href="#主从同步延迟是什么？怎么产生的？如何解决？" class="headerlink" title="主从同步延迟是什么？怎么产生的？如何解决？"></a>主从同步延迟是什么？怎么产生的？如何解决？</h3><p>主库的数据同步到从库是需要时间的，这个时间差就导致了主库和从库的数据不一致性问题。这也就是我们经常说的 <strong>主从同步延迟</strong> 。</p><p>怎么产生的</p><p>主备延迟最直接的表现是，备库消费中转日志（relay log）的速度，比主库生产 binlog 的速度要慢。造成的原因可能有：</p><ul><li>从库所在机器的性能要比主库所在的机器性能差。</li><li>从库的压力太大：从库访问量高于主库，从库上的查询耗费了大量的 CPU 资源，影响了同步速度，造成主备延迟。</li><li>主库上执行了大事务。一次性修改了大量数据</li></ul><p>参考的解决办法：</p><ol><li>强制将读请求路由到主库处理。<code>Sharding-JDBC</code> 就是采用的这种方案。对于这种方案，可以将那些必须获取最新数据的读请求都交给主库处理。</li><li>延迟读取。但是影响性能</li><li>增加从服务器，降低服务器负载。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JVM(补档)</title>
      <link href="/2022/11/23/jvm-bu-dang/"/>
      <url>/2022/11/23/jvm-bu-dang/</url>
      
        <content type="html"><![CDATA[<h2 id="说一下-Jvm-的主要组成部分及其作用"><a href="#说一下-Jvm-的主要组成部分及其作用" class="headerlink" title="说一下 Jvm 的主要组成部分及其作用"></a>说一下 Jvm 的主要组成部分及其作用</h2><ol><li>类加载器（ClassLoader）</li><li>运行时数据区（Runtime Data Area）</li><li>执行引擎（Execution Engine）</li><li>本地库接口（Native Interface）</li></ol><ul><li>首先通过<strong>类加载器</strong>会把 Java 代码转换成字节码</li><li><strong>运行时数据区</strong>再把字节码加载到内存中</li><li>特定的命令解析器<strong>执行引擎</strong>，将字节码翻译成底层系统指令，再交由 CPU 去执行，而这个过程中需要调用其他语言的<strong>本地库接口</strong>来实现整个程序的功能。</li></ul><h2 id="内存区域"><a href="#内存区域" class="headerlink" title="内存区域"></a>内存区域</h2><h3 id="说说JVM运行时数据区域"><a href="#说说JVM运行时数据区域" class="headerlink" title="说说JVM运行时数据区域"></a>说说JVM运行时数据区域</h3><h4 id="JDK-1-8-之前"><a href="#JDK-1-8-之前" class="headerlink" title="JDK 1.8 之前"></a>JDK 1.8 之前</h4><p><img src="/images/image_JVM_01/13.png"></p><h4 id="JDK-1-8-之后"><a href="#JDK-1-8-之后" class="headerlink" title="JDK 1.8 之后"></a>JDK 1.8 之后</h4><p><img src="/images/image_JVM_01/14.png"></p><p><strong>线程私有的：</strong></p><ul><li>  程序计数器</li><li>  虚拟机栈</li><li>  本地方法栈</li></ul><p><strong>线程共享的：</strong></p><ul><li>  堆</li><li>  方法区</li><li>  直接内存 (非运行时数据区的一部分)</li></ul><h4 id="程序计数器"><a href="#程序计数器" class="headerlink" title="程序计数器"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，可以看作是当前线程所执行的字节码的行号指示器。</p><ul><li> 字节码解释器通过改变程序计数器来依次读取指令，从而实现代码的流程控制，如：顺序执行、选择、循环、异常处理。</li><li> 在多线程的情况下，程序计数器用于记录当前线程执行的位置，从而当线程被切换回来的时候能够知道该线程上次运行到哪儿了。</li></ul><h4 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h4><p>与程序计数器一样，Java 虚拟机栈也是线程私有的，它的生命周期和线程相同，随着线程的创建而创建，随着线程的死亡而死亡。</p><p>栈是 JVM 运行时数据区域的一个核心，除了一些 Native 方法，其他所有的 Java 方法调用都是通过栈来实现的。</p><p>方法调用的数据需要通过栈进行传递，每一次方法调用都会有一个对应的栈帧被压入栈中，每一个方法调用结束后，都会有一个栈帧被弹出。</p><p>栈由一个个栈帧组成，而每个栈帧中都拥有：<strong>局部变量表、操作数栈、动态链接、方法返回地址</strong>。</p><p><strong>局部变量表</strong> 主要存放了编译期可知的各种数据类型（boolean、byte、char、short、int、float、long、double）、对象引用</p><p><strong>操作数栈</strong> 主要作为方法调用的中转站使用，用于存放方法执行过程中产生的中间计算结果。</p><p><strong>动态链接</strong> 主要服务一个方法需要调用其他方法的场景。将方法的符号引用转换为调用方法的直接引用。</p><p>Java 方法有两种返回方式，一种是 return 语句正常返回，一种是抛出异常。不管哪种返回方式，都会导致栈帧被弹出。栈帧随着方法调用而创建，随着方法结束而销毁。无论方法正常完成还是异常完成都算作方法结束。</p><h4 id="本地方法栈"><a href="#本地方法栈" class="headerlink" title="本地方法栈"></a>本地方法栈</h4><p>和虚拟机栈所发挥的作用非常相似，区别是： <strong>虚拟机栈为虚拟机执行 Java 方法 （也就是字节码）服务，而本地方法栈则为虚拟机使用到的 Native 方法服务。</strong> </p><h4 id="堆"><a href="#堆" class="headerlink" title="堆"></a>堆</h4><p>Java 虚拟机所管理的内存中最大的一块，Java 堆是所有线程共享的一块内存区域，在虚拟机启动时创建。<strong>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</strong></p><p><strong>为什么说“几乎”所有的对象都在堆中分配？</strong></p><p>从 JDK 1.7 开始已经默认开启<strong>逃逸分析</strong>，如果某些方法中的对象引用没有被返回或者未被外面使用（也就是未逃逸出去），那么对象可以直接在栈上分配内存。</p><p>Java 堆是垃圾收集器管理的主要区域，因此也被称作 <strong>GC 堆（Garbage Collected Heap）</strong>。</p><p>在 JDK 7 版本及 JDK 7 版本之前，堆内存被通常分为下面三部分：</p><ol><li> 新生代内存(Eden、Survivor)</li><li> 老生代</li><li> 永久代(方法区)</li></ol><p><strong>JDK 8 版本之后 PermGen(永久) 已被 Metaspace(元空间) 取代，元空间使用的是直接内存</strong> 。</p><p>堆这里最容易出现的就是 <code>OutOfMemoryError</code> 错误</p><h4 id="方法区"><a href="#方法区" class="headerlink" title="方法区"></a>方法区</h4><p>方法区属于是 JVM 运行时数据区域的一块逻辑区域，是各个线程共享的内存区域。</p><p>当虚拟机要使用一个类时，它需要读取并解析 Class 文件获取相关信息，再将信息存入到方法区。方法区会存储已被虚拟机加载的 <strong>类信息、字段信息、方法信息、常量、静态变量、即时编译器编译后的代码缓存等数据</strong>。</p><p><strong>方法区和永久代以及元空间是什么关系呢？</strong> </p><p>永久代以及元空间是 HotSpot 虚拟机对虚拟机规范中方法区的两种实现方式。</p><p><strong>为什么要将永久代 (PermGen) 替换为元空间 (MetaSpace) 呢?</strong></p><ul><li><p><strong>OOM概率降低</strong>：整个永久代有一个 JVM 本身设置的固定大小上限，无法进行调整。而元空间使用的是直接内存，受本机可用内存的限制，一般元空间比永久代大</p></li><li><p><strong>加载更多的类</strong>：元空间里面存放的是类的元数据，这样加载多少类的元数据就不由 <code>MaxPermSize</code> 控制了, 而由系统的实际可用空间来控制，这样能加载的类就更多了。</p></li></ul><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有用于存放编译期生成的各种字面量（Literal）和符号引用（Symbolic Reference）的 <strong>常量池表</strong> 。</p><p><strong>字面量</strong>是源代码中的固定值的表示法，即通过字面我们就能知道其值的含义。字面量包括整数、浮点数和字符串字面量，</p><p><strong>符号引用</strong>包括类符号引用、字段符号引用、方法符号引用和接口方法符号引用。</p><p>常量池表会在类加载后存放到方法区的运行时常量池中。</p><h4 id="字符串常量池"><a href="#字符串常量池" class="headerlink" title="字符串常量池"></a>字符串常量池</h4><p><strong>字符串常量池</strong> 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 在堆中创建字符串对象”ab“</span><span class="token comment">// 将字符串对象”ab“的引用保存在字符串常量池中</span><span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span><span class="token comment">// 直接返回字符串常量池中字符串对象”ab“的引用</span><span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aa<span class="token operator">==</span>bb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>StringTable</code> 本质上就是一个<code>HashSet&lt;String&gt;</code> </p><p><strong><code>StringTable</code> 中保存的是字符串对象的引用，字符串对象的引用指向堆中的字符串对象。</strong></p><p>JDK1.7 之前，字符串常量池存放在永久代。<br>JDK1.7 字符串常量池和静态变量从永久代移动了<strong>堆</strong>中。</p><p><strong>JDK 1.7 为什么要将字符串常量池移动到堆中</strong></p><p>主要是因为方法区的 GC 回收效率太低，只有在整堆收集 (Full GC)的时候才会被执行 GC。</p><p>Java 程序中通常会有大量的被创建的字符串等待回收，将字符串常量池放到堆中，能够更高效及时地回收字符串内存。</p><h4 id="直接内存"><a href="#直接内存" class="headerlink" title="直接内存"></a>直接内存</h4><p>直接内存并不是虚拟机运行时数据区的一部分，也不是虚拟机规范中定义的内存区域，直接内存受到本机总内存大小以及处理器寻址空间的限制。</p><h2 id="HotSpot-虚拟机对象"><a href="#HotSpot-虚拟机对象" class="headerlink" title="HotSpot 虚拟机对象"></a>HotSpot 虚拟机对象</h2><h3 id="说说对象的创建过程"><a href="#说说对象的创建过程" class="headerlink" title="说说对象的创建过程"></a>说说对象的创建过程</h3><ol><li><p>类加载检查：JVM检查这个类否能在常量池中定位到这个类的符号引用，并且检查这个符号引用代表的类是否已被加载过、解析和初始化过。如果没有，那必须先执行相应的类加载过程。</p></li><li><p>分配内存：对象所需的内存大小在类加载完成后便可确定，把一块确定大小的内存从 Java 堆中划分出来。</p></li><li><p>初始化零值：将分配到的内存空间都初始化为零值，保证对象的实例字段在 Java 代码中可以不赋初始值就直接使用。</p></li><li><p>设置对象头：例如这个对象是哪个类的实例、如何才能找到类的元数据信息、对象的哈希码、对象的 GC 分代年龄等信息。 **这些信息存放在对象头中。</p></li><li><p>执行 init 方法：在上面工作都完成之后，从虚拟机的视角来看，一个新的对象已经产生了，但从 Java 程序的视角来看，对象创建才刚开始，<code>&lt;init&gt;</code> 方法还没有执行，所有的字段都还为零。执行构造方法。</p></li></ol><h3 id="对象内存分配方式了解吗"><a href="#对象内存分配方式了解吗" class="headerlink" title="对象内存分配方式了解吗"></a>对象内存分配方式了解吗</h3><ul><li>指针碰撞 ：<ul><li>  适用场合 ：堆内存规整（即没有内存碎片）的情况下。</li><li>  原理 ：用过的内存全部整合到一边，没有用过的内存放在另一边，中间有一个分界指针，只需要向着没用过的内存方向将该指针移动对象内存大小位置即可。</li><li>  使用该分配方式的 GC 收集器：Serial, ParNew</li></ul></li><li>空闲列表 ：<ul><li>  适用场合 ： 堆内存不规整的情况下。</li><li>  原理 ：虚拟机会维护一个列表，该列表中会记录哪些内存块是可用的，在分配的时候，找一块儿足够大的内存块儿来划分给对象实例，最后更新列表记录。</li><li>  使用该分配方式的 GC 收集器：CMS</li></ul></li></ul><p>选择以上两种方式中的哪一种，取决于 Java 堆内存是否规整。而 Java 堆内存是否规整，取决于 GC 收集器的算法是”标记-清除”，还是”标记-整理”，复制算法内存也是规整的。</p><h3 id="如何解决内存分配并发问题"><a href="#如何解决内存分配并发问题" class="headerlink" title="如何解决内存分配并发问题"></a>如何解决内存分配并发问题</h3><p>创建对象是很频繁的事情，作为虚拟机来说，必须要保证线程是安全的</p><ul><li>  <strong>CAS+失败重试：</strong> 采用 CAS 配上失败重试的方式保证更新操作的原子性。</li><li>  <strong>TLAB：</strong> 为每一个线程预先在 Eden 区分配一块儿内存，JVM 在给线程中的对象分配内存时，首先在 TLAB 分配，当对象大于 TLAB 中的剩余内存或 TLAB 的内存已用尽时，再采用上述的 CAS 进行内存分配<h3 id="对象的内存布局了解吗"><a href="#对象的内存布局了解吗" class="headerlink" title="对象的内存布局了解吗"></a>对象的内存布局了解吗</h3></li></ul><p>在 Hotspot 虚拟机中，对象在内存中的布局可以分为 3 块区域：<strong>对象头</strong>、<strong>实例数据</strong>和<strong>对齐填充</strong>。</p><ul><li><p><strong>对象头</strong>：</p><ul><li><strong>运行时数据</strong>：哈希码、GC 分代年龄、锁状态标志等等</li><li><strong>类型指针</strong>：指向它的类元数据的指针，通过这个指针来确定这个对象是哪个类的实例。</li></ul></li><li><p><strong>实例数据</strong>：对象真正存储的有效信息，也是在程序中所定义的各种类型的字段内容。</p></li><li><p><strong>对齐填充部分</strong>：占位作用。因为 Hotspot 虚拟机的自动内存管理系统要求对象起始地址必须是 8 字节的整数倍，也就是对象的大小必须是 8 字节的整数倍。</p></li></ul><h3 id="对象的访问定位方式有哪些"><a href="#对象的访问定位方式有哪些" class="headerlink" title="对象的访问定位方式有哪些"></a>对象的访问定位方式有哪些</h3><p>目前主流的访问方式有：<strong>句柄</strong>、<strong>直接指针</strong>。</p><p><strong>句柄</strong></p><p>那么 Java 堆中将会划分出一块内存来作为句柄池，reference 中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与对象类型数据各自的具体地址信息。</p><p><strong>直接指针</strong></p><p>如果使用直接指针访问，reference 中存储的直接就是对象的地址。</p><p><strong>各自优点：</strong></p><p>使用句柄来访问的最大好处是 reference 中存储的是稳定的句柄地址，在对象被移动时只会改变句柄中的实例数据指针，而 reference 本身不需要修改。</p><p>使用直接指针访问方式最大的好处就是速度快，它节省了一次指针定位的时间开销。</p><p>HotSpot 虚拟机主要使用的就是这种方式来进行对象访问。</p><h2 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h2><h3 id="内存分配和回收原则"><a href="#内存分配和回收原则" class="headerlink" title="内存分配和回收原则"></a>内存分配和回收原则</h3><h4 id="对象优先在-Eden-区分配"><a href="#对象优先在-Eden-区分配" class="headerlink" title="对象优先在 Eden 区分配"></a>对象优先在 Eden 区分配</h4><p>大多数情况下，对象在新生代中 Eden 区分配。当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。</p><p>当 Eden 区没有足够空间进行分配时，虚拟机将发起一次 Minor GC。GC 期间虚拟机又发现 Survivor 空间也不够，所以只好通过 <strong>分配担保机制</strong> 把新生代的对象提前转移到老年代中去，老年代上的空间足够存放，就不会出现 Full GC。</p><h4 id="大对象直接进入老年代"><a href="#大对象直接进入老年代" class="headerlink" title="大对象直接进入老年代"></a>大对象直接进入老年代</h4><p>大对象就是需要大量连续内存空间的对象（比如：字符串、数组）。</p><p>大对象直接进入老年代主要是为了避免为大对象分配内存时由于<strong>分配担保机制</strong>带来的复制而降低效率。</p><h4 id="长期存活的对象将进入老年代"><a href="#长期存活的对象将进入老年代" class="headerlink" title="长期存活的对象将进入老年代"></a>长期存活的对象将进入老年代</h4><p>虚拟机给每个对象一个对象年龄（Age）计数器。</p><p>对象在 Eden 出生并经过第一次 Minor GC 后仍然能够存活，并且能被 Survivor 容纳的话，将被移动到 Survivor 空间（s0 或者 s1）中，并将对象年龄设为 1</p><p>对象在 Survivor 中每熬过一次 MinorGC,年龄就增加 1 岁，当它的年龄增加到一定程度，就会被晋升到老年代中。</p><h4 id="主要进行-gc-的区域，gc分类"><a href="#主要进行-gc-的区域，gc分类" class="headerlink" title="主要进行 gc 的区域，gc分类"></a>主要进行 gc 的区域，gc分类</h4><p>部分收集 (Partial GC)：</p><ul><li>  新生代收集（Minor GC / Young GC）：只对新生代进行垃圾收集；</li><li>  老年代收集（Major GC / Old GC）：只对老年代进行垃圾收集。</li><li>  混合收集（Mixed GC）：对整个新生代和部分老年代进行垃圾收集。</li></ul><p>整堆收集 (Full GC)：收集整个 Java 堆和方法区。</p><h4 id="了解空间分配担保机制吗"><a href="#了解空间分配担保机制吗" class="headerlink" title="了解空间分配担保机制吗"></a>了解空间分配担保机制吗</h4><p>空间分配担保是为了确保在 Minor GC 之前老年代本身还有容纳新生代所有对象的剩余空间。</p><p>在发生 Minor GC 之前，虚拟机必须先检查老年代最大可用的连续空间是否大于新生代所有对象总空间，如果这个条件成立，那这一次 Minor GC 可以确保是安全的。就会进行 Minor GC，否则将进行 Full GC。</p><h4 id="新生代为什么要分为Eden和Survivor，它们的比例是多少"><a href="#新生代为什么要分为Eden和Survivor，它们的比例是多少" class="headerlink" title="新生代为什么要分为Eden和Survivor，它们的比例是多少"></a>新生代为什么要分为Eden和Survivor，它们的比例是多少</h4><p>实际上，新生代中的对象有98%熬不过第一轮收集，因此并不需要按照1∶1的比例来划分新生代的内存空间。</p><p>每次分配内存只使用Eden和其中一块Survivor。发生垃圾搜集时，将Eden和Survivor中仍然存活的对象一次性复制到另外一块Survivor空间上，然后直接清理掉Eden和已用过的那块Survivor空间。</p><p>HotSpot虚拟机默认Eden和Survivor的大小比例是8∶1，也即每次新生代中可用内存空间为整个新生代容量的90%（Eden的80%加上一个Survivor的10%），只有一个Survivor空间，即10%的新生代是会被“浪费”的。</p><p>这样可以提高垃圾的回收效率，合理利用内存空间。</p><h4 id="为什么要设置两个Survivor区域"><a href="#为什么要设置两个Survivor区域" class="headerlink" title="为什么要设置两个Survivor区域"></a>为什么要设置两个Survivor区域</h4><p>设置两个 Survivor 区最大的好处就是解决内存碎片化。</p><p>因为 Survivor 有 2 个区域，所以每次 Minor GC，会将之前 Eden 区和 From 区中的存活对象复制到 To 区域。第二次 Minor GC 时，<strong>From 与 To 职责兑换</strong>，这时候会将 Eden 区和 To 区中的存活对象再复制到 From 区域，以此反复。</p><p>这种机制最大的好处就是，整个过程中，永远有一个 Survivor space 是空的，另一个非空的 Survivor space 是无碎片的。</p><h4 id="说一下JVM中一次完整的GC流程"><a href="#说一下JVM中一次完整的GC流程" class="headerlink" title="说一下JVM中一次完整的GC流程"></a>说一下JVM中一次完整的GC流程</h4><p>我们创建的对象将 Eden 区全部挤满，此时，Minor GC 就触发了。</p><p>在正式 Minor GC 前，JVM 会先检查新生代中对象，是比老年代中剩余空间大还是小。为什么要做这样的检查呢？原因很简单，假如 Minor GC 之后 Survivor 区放不下剩余对象，这些对象就要进入到老年代，所以要提前检查老年代是不是够用。这样就有两种情况：</p><ol><li>老年代剩余空间大于新生代中的对象大小，那就直接Minor GC，GC完survivor不够放，老年代也绝对够放；</li><li>老年代剩余空间小于新生代中的对象大小，这时候根据老年代空间分配担保规则<ul><li>老年代中剩余空间大小，大于历次Minor GC之后剩余对象的大小，进行 Minor GC；</li><li>老年代中剩余空间大小，小于历次Minor GC之后剩余对象的大小，进行Full GC，把老年代空出来再检查。</li></ul></li></ol><p>开启老年代空间分配担保规则，Minor GC 剩余后的对象够放到老年代，Minor GC 后会有这样三种情况：</p><ol><li> Minor GC 之后的对象足够放到 Survivor 区，皆大欢喜，GC 结束；</li><li> Minor GC 之后的对象不够放到 Survivor 区，接着进入到老年代，老年代能放下，那也可以，GC 结束；</li><li> Minor GC 之后的对象不够放到 Survivor 区，老年代也放不下，那就只能 Full GC。Full GC 之后，老年代任然放不下剩余对象，就只能 OOM；</li></ol><p>未开启老年代分配担保机制，且一次 Full GC 后，老年代任然放不下剩余对象，只能 OOM；</p><h4 id="StackOverFlow与OOM的区别是什么"><a href="#StackOverFlow与OOM的区别是什么" class="headerlink" title="StackOverFlow与OOM的区别是什么"></a>StackOverFlow与OOM的区别是什么</h4><ul><li><p>StackOverFlow是<strong>栈</strong>空间不足出现的，主要是单个线程运行过程中调用方法过多或是方法递归操作时申请的栈帧使用存储空间超出了单个栈申请的存储空间。</p></li><li><p>OOM主要是<strong>堆</strong>区申请的内存空间不够用时出现，比如单次申请大对象超出了堆中连续的可用空间。</p></li></ul><h4 id="垃圾回收器为什么要STW"><a href="#垃圾回收器为什么要STW" class="headerlink" title="垃圾回收器为什么要STW"></a>垃圾回收器为什么要STW</h4><p>因为在进行垃圾回收过程中，需要确保没有对象正在被修改或引用关系正在改变。</p><p>如果在清理过程中中，应用程序仍然在运行，可能会导致以下问题：</p><ol><li>一致性：垃圾回收器必须保证回收过程中堆内存的一致性，即回收前后，对象的引用关系和状态保持一致。</li><li>安全性：如果应用程序在对象处于不一致状态时访问这些对象，可能会导致错误的结果。例如，如果一个对象已经被回收但应用程序仍然试图使用它，就可能引发空指针异常或其他运行时错误。</li></ol><p>虽然STW机制会导致应用程序的暂停和延迟，但可以提供较高的垃圾回收效率和保证正确性。</p><h3 id="死亡对象判断方法"><a href="#死亡对象判断方法" class="headerlink" title="死亡对象判断方法"></a>死亡对象判断方法</h3><h4 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h4><p>给对象中添加一个引用计数器：</p><ul><li>  每当有一个地方引用它，计数器就加 1；</li><li>  当引用失效，计数器就减 1；</li><li>  任何时候计数器为 0 的对象就是不可能再被使用的。</li></ul><p><strong>这个方法实现简单，效率高，但是目前主流的虚拟机中并没有选择这个算法来管理内存，其最主要的原因是它很难解决对象之间相互循环引用的问题。</strong></p><p>例如对象 <code>objA</code> 和 <code>objB</code> 相互引用着对方之外，这两个对象之间再无任何引用。但是他们因为互相引用对方，导致它们的引用计数器都不为 0，引用计数算法无法通知 GC 回收器回收他们。</p><h4 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h4><p>通过一系列的称为 <strong>“GC Roots”</strong> 的对象作为起点，从这些节点开始向下搜索，节点所走过的路径称为引用链，当一个对象到 GC Roots 没有任何引用链相连的话，则证明此对象是不可用的，需要被回收。</p><h4 id="哪些对象可以作为-GC-Roots"><a href="#哪些对象可以作为-GC-Roots" class="headerlink" title="哪些对象可以作为 GC Roots"></a>哪些对象可以作为 GC Roots</h4><ul><li>  虚拟机栈(栈帧中的本地变量表)中引用的对象</li><li>  本地方法栈(Native 方法)中引用的对象</li><li>  方法区中类静态属性引用的对象</li><li>  方法区中常量引用的对象</li><li>  所有被同步锁持有的对象</li></ul><h4 id="对象可以被回收就会马上被回收吗"><a href="#对象可以被回收就会马上被回收吗" class="headerlink" title="对象可以被回收就会马上被回收吗"></a>对象可以被回收就会马上被回收吗</h4><p>即使在可达性分析法中不可达的对象，也并非是“非死不可”的，这时候它们暂时处于“缓刑阶段”，要真正宣告一个对象死亡，至少要经历两次标记过程</p><p>被判定为需要执行的对象将会被放在一个队列中进行第二次标记，除非这个对象与引用链上的任何一个对象建立关联，否则就会被真的回收</p><h4 id="对象引用类型有哪些"><a href="#对象引用类型有哪些" class="headerlink" title="对象引用类型有哪些"></a>对象引用类型有哪些</h4><p>引用分为强引用、软引用、弱引用、虚引用四种（引用强度逐渐减弱）</p><p><strong>1．强引用</strong></p><ul><li>使用的大部分引用实际上都是强引用，这是使用最普遍的引用。如果一个对象具有强引用，垃圾回收器绝不会回收它。</li><li>当内存空间不足，Java 虚拟机宁愿抛出 OutOfMemoryError 错误，使程序异常终止。</li></ul><p><strong>2．软引用</strong></p><ul><li>一个对象只具有软引用，如果内存空间足够，垃圾回收器就不会回收它，如果内存空间不足了，就会回收这些对象的内存。</li><li><strong>软引用可用来实现内存敏感的高速缓存。加速 JVM 对垃圾内存的回收速度，减少OOM</strong></li><li>软引用可以和一个引用队列联合使用，如果软引用所引用的对象被垃圾回收，JAVA 虚拟机就会把这个软引用加入到与之关联的引用队列中。</li></ul><p><strong>3．弱引用</strong></p><ul><li><p>在垃圾回收器线程扫描它所管辖的内存区域的过程中，一旦发现了只具有弱引用的对象，不管当前内存空间足够与否，都会回收它的内存。</p></li><li><p>弱引用可以和一个引用队列联合使用，如果弱引用所引用的对象被垃圾回收，Java 虚拟机就会把这个弱引用加入到与之关联的引用队列中。</p></li></ul><p><strong>4．虚引用</strong></p><ul><li><p>“虚引用”，就是形同虚设，与其他几种引用都不同，虚引用并不会决定对象的生命周期。如果一个对象仅持有虚引用，那么它就和没有任何引用一样，在任何时候都可能被垃圾回收。</p></li><li><p><strong>虚引用主要用来跟踪对象被垃圾回收的活动</strong>。</p></li><li><p><strong>虚引用与软引用和弱引用的一个区别在于：</strong> 虚引用必须和引用队列（ReferenceQueue）联合使用。程序可以通过判断引用队列中是否已经加入了虚引用，来了解被引用的对象是否将要被垃圾回收。</p></li></ul><h4 id="如何判断一个字符串常量是废弃常量"><a href="#如何判断一个字符串常量是废弃常量" class="headerlink" title="如何判断一个字符串常量是废弃常量"></a>如何判断一个字符串常量是废弃常量</h4><p>假如在字符串常量池中存在字符串 “abc”，如果当前<strong>没有任何 String 对象引用</strong>该字符串常量的话，就说明常量 “abc” 就是废弃常量，如果这时发生内存回收的话而且有必要的话，”abc” 就会被系统清理出常量池了。</p><h4 id="如何判断一个类是无用的类"><a href="#如何判断一个类是无用的类" class="headerlink" title="如何判断一个类是无用的类"></a>如何判断一个类是无用的类</h4><ul><li>  该类所有的实例都已经被回收，也就是 Java 堆中不存在该类的任何实例。</li><li>  加载该类的 <code>ClassLoader</code> 已经被回收。</li><li>  该类对应的 <code>Class</code> 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法。</li></ul><h3 id="垃圾收集算法"><a href="#垃圾收集算法" class="headerlink" title="垃圾收集算法"></a>垃圾收集算法</h3><h4 id="标记-清除法"><a href="#标记-清除法" class="headerlink" title="标记-清除法"></a>标记-清除法</h4><p>该算法分为“标记”和“清除”阶段：首先标记出所有<strong>不需要回收</strong>的对象，在标记完成后统一回收掉所有没有被标记的对象。</p><ol><li> <strong>效率问题</strong></li><li> <strong>空间问题（标记清除后会产生大量不连续的碎片）</strong></li></ol><h4 id="标记-复制法"><a href="#标记-复制法" class="headerlink" title="标记-复制法"></a>标记-复制法</h4><p>为了解决效率问题，“标记-复制”收集算法出现了。</p><p>它可以将内存分为大小相同的两块，每次使用其中的一块。当这一块的内存使用完后，就将还存活的对象复制到另一块去，然后再把使用的空间一次清理掉。</p><h4 id="标记-整理法"><a href="#标记-整理法" class="headerlink" title="标记-整理法"></a>标记-整理法</h4><p>根据老年代的特点提出的一种标记算法，标记过程与“标记-清除”算法一样，然后让所有存活的对象向一端移动，然后直接清理掉端边界以外的内存。</p><h4 id="分代收集算法"><a href="#分代收集算法" class="headerlink" title="分代收集算法"></a>分代收集算法</h4><p>根据对象存活周期的不同将内存分为几块。一般将 java 堆分为新生代和老年代，这样我们就可以根据各个年代的特点选择合适的垃圾收集算法。</p><p>新生代：每次收集都会有大量对象死去，所以可以选择”标记-复制“算法，只需要付出少量对象的复制成本就可以完成每次垃圾收集。</p><p>老年代：对象存活几率是比较高的，而且没有额外的空间对它进行分配担保，所以我们必须选择“标记-清除”或“标记-整理”算法进行垃圾收集。</p><h3 id="垃圾收集器"><a href="#垃圾收集器" class="headerlink" title="垃圾收集器"></a>垃圾收集器</h3><h4 id="Serial-收集器"><a href="#Serial-收集器" class="headerlink" title="Serial 收集器"></a>Serial 收集器</h4><p>Serial（串行）收集器是最基本、历史最悠久的垃圾收集器了。单线程</p><p>它在进行垃圾收集工作的时候必须暂停其他所有的工作线程（ <strong>“Stop The World”</strong> ），直到它收集结束。</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="/images/image_java%E5%9F%BA%E7%A1%80_02/image_JVM_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/05.jpg"></p><h4 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h4><p><strong>ParNew 收集器其实就是 Serial 收集器的多线程版本，除了使用多线程进行垃圾收集外，其余行为（控制参数、收集算法、回收策略等等）和 Serial 收集器完全一样。</strong></p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="/images/image_java%E5%9F%BA%E7%A1%80_02/image_JVM_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/06.jpg"></p><h4 id="Parallel-Scavenge-收集器"><a href="#Parallel-Scavenge-收集器" class="headerlink" title="Parallel Scavenge 收集器"></a>Parallel Scavenge 收集器</h4><p>Parallel Scavenge 收集器关注点是吞吐量（高效率的利用 CPU）。吞吐量就是 CPU 中用于运行用户代码的时间与 CPU 总消耗时间的比值。</p><p>Parallel Scavenge 收集器提供了很多<strong>参数</strong>供用户找到最合适的停顿时间或最大吞吐量</p><p><strong>新生代采用标记-复制算法，老年代采用标记-整理算法。</strong></p><p><img src="/images/image_java%E5%9F%BA%E7%A1%80_02/image_JVM_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/07.jpg"></p><p><strong>这是 JDK1.8 默认收集器</strong></p><h4 id="Serial-Old-收集器"><a href="#Serial-Old-收集器" class="headerlink" title="Serial Old 收集器"></a>Serial Old 收集器</h4><p>Serial 收集器的老年代版本，它同样是一个单线程收集器。</p><h4 id="Parallel-Old-收集器"><a href="#Parallel-Old-收集器" class="headerlink" title="Parallel Old 收集器"></a>Parallel Old 收集器</h4><p>Parallel Scavenge 收集器的老年代版本。使用多线程和“标记-整理”算法。</p><h4 id="CMS-收集器"><a href="#CMS-收集器" class="headerlink" title="CMS 收集器"></a>CMS 收集器</h4><p>CMS（Concurrent Mark Sweep）收集器是一种以获取最短回收停顿时间为目标的收集器。非常符合在注重用户体验的应用上使用。</p><p><strong>CMS（Concurrent Mark Sweep）收集器是 HotSpot 虚拟机第一款真正意义上的并发收集器，它第一次实现了让垃圾收集线程与用户线程（基本上）同时工作。</strong></p><p>CMS 收集器是一种 <strong>“标记-清除”算法</strong>实现的，整个过程分为四个步骤：</p><ul><li>  <strong>初始标记：</strong> 暂停所有的其他线程，并记录下直接与 root 相连的对象</li><li>  <strong>并发标记：</strong> 同时开启 GC 和用户线程，用一个闭包结构去记录可达对象。GC 线程无法保证可达性分析的实时性，所以这个算法里会跟踪记录这些发生引用更新的地方。</li><li>  <strong>重新标记：</strong> 为了修正并发标记期间因为用户程序继续运行，而导致标记产生变动的那一部分对象的标记记录</li><li>  <strong>并发清除：</strong> 开启用户线程，同时 GC 线程开始对未标记的区域做清扫。</li></ul><p><img src="/images/image_java%E5%9F%BA%E7%A1%80_02/image_JVM_%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6/08.jpg"></p><p>主要优点：<strong>并发收集、低停顿</strong>。</p><p>但是它有下面三个明显的缺点：</p><ul><li>  <strong>对 CPU 资源敏感</strong>：需要占用额外的CPU资源，CPU资源紧张的情况下，CMS可能会导致更长的停顿时间</li><li>  <strong>无法处理浮动垃圾</strong>：标记阶段完成后，应用程序可能会继续产生新的垃圾对象（浮动垃圾），CMS收集器无法处理它们，只能等待下一次垃圾回收才能清理</li><li>  <strong>内存碎片问题</strong>：CMS收集器使用”标记-清除”算法</li></ul><h4 id="G1-收集器"><a href="#G1-收集器" class="headerlink" title="G1 收集器"></a>G1 收集器</h4><p>G1 (Garbage-First) 是一款<strong>面向服务器</strong>的垃圾收集器，主要针对配备<strong>多颗处理器及大容量内存</strong>的机器。 以极高概率满足 GC 停顿时间要求的同时，还具备高吞吐量性能特征。</p><p>具备以下特点：</p><ol><li><strong>区域化堆内存结构</strong>：G1收集器将堆内存划分为多个大小相等的区域（Region），每个区域既可以是Eden空间，也可以是Survivor空间或Old空间。有助于减少垃圾回收的范围，提高回收效率。</li><li><strong>并发标记和并发清理</strong>：在标记阶段，G1会与应用程序并发执行，以避免长时间的停顿。在清理阶段，G1会根据垃圾回收策略，优先清理垃圾最多的区域（Garbage-First），以达到最大收益。</li><li><strong>可预测的停顿时间</strong>：通过设定目标的<strong>吞吐量和可容忍的停顿时间</strong>，G1会根据实时的垃圾回收情况来动态调整回收策略。</li><li><strong>空间整理</strong>：在回收过程中对堆内存进行压缩和整理。这有助于减少内存碎片，并提高堆内存的利用率。</li></ol><p>G1 收集器的运作大致分为以下几个步骤：</p><ol><li><strong>初始标记</strong>：暂停所有的其他线程，并记录下直接与 root 相连的对象</li><li><strong>并发标记</strong>：在初始标记完成后，并发标记阶段开始。此时，应用程序可以继续运行，而G1收集器并发地标记所有可到达的对象。</li><li><strong>最终标记</strong>：最终标记会处理在并发标记过程中产生的新垃圾，并更新引用关系。</li><li><strong>筛选回收</strong>：根据实时的垃圾回收数据和停顿时间目标，进行区域评估和优先级排序。然后选择垃圾最多的区域作为回收目标，并将存活对象转移到其他未满的区域。(G1收集器的核心操作)</li></ol><p>G1 收集器在后台维护了一个优先列表，每次根据允许的收集时间，优先选择回收价值最大的Region。(G1收集器将堆内存划分为多个大小相等的区域（Region）)</p><p><strong>从 JDK9 开始，G1 垃圾收集器成为了默认的垃圾收集器。</strong></p><h4 id="ZGC-收集器"><a href="#ZGC-收集器" class="headerlink" title="ZGC 收集器"></a>ZGC 收集器</h4><p>ZGC 也标记-复制算法，不过 ZGC 对该算法做了重大改进。</p><p>在 ZGC 中出现 Stop The World 的情况会更少</p><h2 id="内存泄漏和内存溢出"><a href="#内存泄漏和内存溢出" class="headerlink" title="内存泄漏和内存溢出"></a>内存泄漏和内存溢出</h2><h3 id="内存泄露是什么"><a href="#内存泄露是什么" class="headerlink" title="内存泄露是什么"></a>内存泄露是什么</h3><p>在 Java 中，内存泄漏就是存在一些不会再被使用却没有被回收的对象：</p><ol><li>这些对象是可达的，即在有向图中，存在通路可以与其相连；</li><li>这些对象是无用的，即程序以后不会再使用这些对象。</li></ol><p>如果对象满足这两个条件，这些对象就可以判定为 Java 中的内存泄漏，这些对象不会被 GC 所回收，然而它却占用内存。</p><h3 id="内存泄露的根本原因是什么"><a href="#内存泄露的根本原因是什么" class="headerlink" title="内存泄露的根本原因是什么"></a>内存泄露的根本原因是什么</h3><p>长生命周期的对象持有短生命周期对象的引用就很可能发生内存泄漏，尽管短生命周期对象已经不再需要，但是因为长生命周期持有它的引用而导致不能被回收，这就是 Java 中内存泄漏的发生场景。</p><h3 id="举几个可能发生内存泄漏的情况"><a href="#举几个可能发生内存泄漏的情况" class="headerlink" title="举几个可能发生内存泄漏的情况"></a>举几个可能发生内存泄漏的情况</h3><ol><li><p>静态集合类引起的内存泄漏；</p></li><li><p>各种连接：比如数据库连接（dataSourse.getConnection()），网络连接(socket) 和 IO 连接，除非其显式的调用了其 close() 方法将其连接关闭，否则是不会自动被 GC 回收的；</p></li><li><p>内部类：内部类的引用是比较容易遗忘的一种，而且一旦没释放可能导致一系列的后继类对象没有释放；</p></li><li><p>单例模式：单例对象在初始化后将在 JVM 的整个生命周期中存在（以静态变量的方式），如果单例对象持有外部的引用，那么这个对象将不能被 JVM 正常回收，导致内存泄漏。</p></li><li><p>ThreadLocal类的key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p></li></ol><h3 id="尽量避免内存泄漏的方法"><a href="#尽量避免内存泄漏的方法" class="headerlink" title="尽量避免内存泄漏的方法"></a>尽量避免内存泄漏的方法</h3><ol><li>尽量不要使用 static 成员变量，减少生命周期</li><li>及时关闭资源</li><li> 使用字符串处理时避免使用String，应使用StringBuild</li><li>避免在循环中创建对象</li></ol><h3 id="内存溢出是什么"><a href="#内存溢出是什么" class="headerlink" title="内存溢出是什么"></a>内存溢出是什么</h3><p>内存溢出（out of memory）：简单地说内存溢出就是指程序运行过程中申请的内存大于系统能够提供的内存，导致无法申请到足够的内存，于是就发生了内存溢出。</p><h3 id="内存溢出的原因是什么"><a href="#内存溢出的原因是什么" class="headerlink" title="内存溢出的原因是什么"></a>内存溢出的原因是什么</h3><p>常见的有：</p><ol><li> 内存中加载的数据量过于庞大，如一次从数据库取出过多数据；</li><li> 代码中存在死循环或循环产生过多重复的对象实体；</li><li> 启动参数内存值设定的过小。</li></ol><h3 id="内存溢出的解决办法有哪些（如何避免）"><a href="#内存溢出的解决办法有哪些（如何避免）" class="headerlink" title="内存溢出的解决办法有哪些（如何避免）"></a>内存溢出的解决办法有哪些（如何避免）</h3><ul><li>第一步，修改JVM启动参数，直接增加内存。</li><li>第二步，检查错误日志，查看“OutOfMemory”错误前是否有其它异常或错误。</li><li>第三步，对代码进行走查和分析，找出可能发生内存溢出的位置。</li><li>  第四步，使用内存查看工具动态查看内存使用情况。</li></ul><h2 id="类加载"><a href="#类加载" class="headerlink" title="类加载"></a>类加载</h2><h3 id="谈谈你对类加载机制的了解（类生命周期）"><a href="#谈谈你对类加载机制的了解（类生命周期）" class="headerlink" title="谈谈你对类加载机制的了解（类生命周期）"></a>谈谈你对类加载机制的了解（类生命周期）</h3><p>虚拟机把描述类的数据从 Class 文件加载到内存，并对数据进行校验、转换、解析和初始化，最终形成可以被虚拟机直接使用的 Java 类型，这就是虚拟机的类加载机制。</p><p>类从被加载到虚拟机内存中开始，到卸载出内存为止，它的整个生命周期包括：加载、验证、准备、解析、初始化、使用、卸载 7 个阶段。其中验证、准备、解析 3 个部分统称为连接</p><p><img src="/images/image_JVM_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/01.png"></p><h3 id="说说类加载过程"><a href="#说说类加载过程" class="headerlink" title="说说类加载过程"></a>说说类加载过程</h3><p>JVM并不是一开始就会将所有的类加载到内存，而是用到某个类，才会去加载，只加载一次。</p><p>JVM加载 Class 类型的文件主要三步：<strong>加载-&gt;连接-&gt;初始化</strong>。<br>连接过程又可分为三步：<strong>验证-&gt;准备-&gt;解析</strong>。</p><p><img src="/images/image_JVM_%E7%B1%BB%E5%8A%A0%E8%BD%BD%E8%BF%87%E7%A8%8B/02.png"></p><h4 id="加载"><a href="#加载" class="headerlink" title="加载"></a>加载</h4><p>类加载过程的第一步，主要完成下面 3 件事情：</p><ol><li> 通过全类名获取定义此类的二进制字节流</li><li> 将二进制字节流读入内存(JDK1.7及之前为JVM内存，JDK1.8及之后为本地内存)</li><li> 在堆内存中生成一个代表该类的 <code>Class</code> 对象，作为（方法区/元空间）数据的访问入口</li></ol><h4 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h4><p>主要是为了确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全</p><p>1、文件格式校验：验证字节流是否符合 <strong>class 文件的规范</strong>，并且能被当前版本的虚拟机处理。</p><p>2、 元数据验证：对字节码描述的信息进行语义分析，以保证其描述的信息符合 <strong>Java 语言规范</strong>的要求。</p><p>3、 字节码验证：该阶段主要工作是进行<strong>数据流和控制流</strong>分析，保证被校验类的方法在运行时不会做出危害虚拟机安全的行为；</p><p>4、 符号引用验证：将符号引用转化为直接引用</p><h4 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h4><p>准备阶段的主要任务是为类的<strong>类变量开辟空间并赋默认值</strong>。</p><ul><li>1、静态变量是基本类型（int、long、short、char、byte、boolean、float、double）的默认值为0</li><li>2、静态变量是引用类型的，默认值为null</li><li>3、静态常量默认值为声明时设定的值<br>例如：public static final int i = 3; 在准备阶段，i的值即为3</li></ul><h4 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h4><p>该阶段的主要职责为将Class在常量池中的<strong>符号引用</strong>转变为<strong>直接引用</strong>，针对的是静态方法及属性和私有方法与属性</p><p><strong>符号引用</strong>就是一组符号来描述目标，可以是任何字面量。<br><strong>直接引用</strong>就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。</p><p>例如，一个类的方法为test()，则符号引用即为test，这个方法存在于内存中的地址假设为0x123456，则这个地址则为直接引用。</p><h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>根据程序制定的主观计划去初始化类变量和其他资源，初始化阶段是执行类构造器&nbsp;() 方法的过程。</p><h3 id="什么时候会去加载一个类"><a href="#什么时候会去加载一个类" class="headerlink" title="什么时候会去加载一个类"></a>什么时候会去加载一个类</h3><ul><li>1.创建该类的实例</li><li>2.调用该类的类方法</li><li>3.访问类或接口的类变量，或为类变量赋值</li><li>4.利用反射Class.forName();</li><li>5.初始化该类的子类</li><li>6.运行main方法，main方法所在类会被加载</li></ul><h3 id="类加载器有哪些"><a href="#类加载器有哪些" class="headerlink" title="类加载器有哪些"></a>类加载器有哪些</h3><p>JVM 中内置了三个重要的 ClassLoader，除了 BootstrapClassLoader 其他类加载器均由 Java 实现且全部继承自<code>java.lang.ClassLoader</code>：</p><ol><li> <strong>BootstrapClassLoader(启动类加载器)</strong> ：最顶层的加载类，由 C++实现，负责加载 <code>%JAVA_HOME%/lib</code>目录下的 jar 包和类或者被 <code>-Xbootclasspath</code>参数指定的路径中的所有类。</li><li> <strong>ExtensionClassLoader(扩展类加载器)</strong> ：主要负责加载 <code>%JRE_HOME%/lib/ext</code> 目录下的 jar 包和类，或被 <code>java.ext.dirs</code> 系统变量所指定的路径下的 jar 包。</li><li> <strong>AppClassLoader(应用程序类加载器)</strong> ：面向我们用户的加载器，负责加载当前应用 classpath 下的所有 jar 包和类。</li></ol><h3 id="类加载器的加载机制有哪些"><a href="#类加载器的加载机制有哪些" class="headerlink" title="类加载器的加载机制有哪些"></a>类加载器的加载机制有哪些</h3><p>类加载器负责将.class文件加载到内存，系统为所有被载入到内存的类生成Class对象，类一但被加载，便不会加载第二次</p><p>每个类，都拥有一个独立的类名称空间，类全限定名+类加载器，确立其在 JVM中的唯一性</p><h4 id="全盘负责"><a href="#全盘负责" class="headerlink" title="全盘负责"></a>全盘负责</h4><p>当一个类加载器负责加载某个类时，那这个类所引用的所有类都用这个加载器去加载，除非显示调用其他类加载器，这样可以避免一个类被重复加载。</p><h4 id="双亲委派"><a href="#双亲委派" class="headerlink" title="双亲委派"></a>双亲委派</h4><p><strong>工作流程：</strong></p><p>在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。</p><p>如果一个类加载器收到了类加载请求，它首先不会自己去尝试加载这个类，而是把这个请求委派给父类加载器去完成。每一个层次的类加载器都是如此，因此所有的加载请求最终都应该传送到顶层的启动类加载器中，只有当父类加载器反馈自己无法完成这个加载请求（它的搜索范围中没有找到所需的类）时，子加载器才会尝试自己去加载。</p><p><strong>自底向上检查类是否被加载，自顶向下尝试加载类</strong></p><h4 id="缓存机制"><a href="#缓存机制" class="headerlink" title="缓存机制"></a>缓存机制</h4><p>当jvm加载完成一个类是会将类放入jvm缓存中，加载流程为先去缓存区查看当前类是否被加载，如果没有则读.class文件并加载，如果加载则直接返回。</p><h3 id="双亲委派模型的优点有哪些"><a href="#双亲委派模型的优点有哪些" class="headerlink" title="双亲委派模型的优点有哪些"></a>双亲委派模型的优点有哪些</h3><ul><li><p><strong>避免类的重复加载</strong>：JVM 区分不同类的方式不仅仅根据类名，相同的类文件被不同的类加载器加载产生的是两个不同的类</p></li><li><p><strong>保证了 Java 的核心 API 不被篡改</strong>。如果没有使用双亲委派模型，而是每个类加载器加载自己的话就会出现一些问题，比如我们编写一个称为 <code>java.lang.Object</code> 类的话，那么程序运行的时候，系统就会出现多个不同的 <code>Object</code> 类。</p></li></ul><h3 id="怎么打破双亲委派模型"><a href="#怎么打破双亲委派模型" class="headerlink" title="怎么打破双亲委派模型"></a>怎么打破双亲委派模型</h3><ol><li>自己写一个类加载器，继承ClassLoader类；</li><li>重写 loadClass() 方法</li><li>重写 findClass() 方法</li></ol><p>这里最主要的是重写 loadClass 方法，因为双亲委派机制的实现都是通过这个方法实现的</p><h3 id="有哪些实际场景是需要打破双亲委派模型的"><a href="#有哪些实际场景是需要打破双亲委派模型的" class="headerlink" title="有哪些实际场景是需要打破双亲委派模型的"></a>有哪些实际场景是需要打破双亲委派模型的</h3><p>以JDBC为例，它的代码在rt.jar中，由启动类加载器去加载，但它需要调用厂商实现的SPI代码，这些代码部署在ClassPath下面。  </p><p>根据双亲委派模型，启动类加载器无法直接委派应用程序类加载器(Application ClassLoader)来加载SPI的实现代码。那么启动类加载器如何找到这些代码呢?  </p><p>JDK引入了线程上下文类加载器(TCCL: Thread Context ClassLoader)，线程上下文类加载器破坏了“双亲委派模型”，可以在执行线程中抛弃双亲委派加载链，利用线程上下文类加载器去加载所需要的SPI代码。</p><h3 id="如何自定义类加载器"><a href="#如何自定义类加载器" class="headerlink" title="如何自定义类加载器"></a>如何自定义类加载器</h3><p>实现一个用户自定义类加载器需要去继承ClassLoader类并重写findClass方法</p><p><strong>应用场景</strong></p><ol><li>加密保护<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;公司的有些核心类库的字节码是经过加密的，这样的话，就需要实现自己的加载器，在加载这些类库的时候进行解密，然后再载入到内存  </li><li>其他来源<br>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;字节码是放在数据库，硬盘其他路径，甚至有可能放在云上。需要自定义加载器去加载。</li></ol><h2 id="Class文件结构"><a href="#Class文件结构" class="headerlink" title="Class文件结构"></a>Class文件结构</h2><h3 id="谈谈你对类文件结构的理解？有哪些部分组成？"><a href="#谈谈你对类文件结构的理解？有哪些部分组成？" class="headerlink" title="谈谈你对类文件结构的理解？有哪些部分组成？"></a>谈谈你对类文件结构的理解？有哪些部分组成？</h3><ol><li><p>魔数（magic）：每个 Class 文件的头 4 个字节称为魔数（Magic Number），它的唯一作用是确定这个文件是否为一个能被虚拟机接受的Class 文件，即判断这个文件是否符合 Class 文件规范。</p></li><li><p>文件的版本：minor_version 和 major_version。</p></li><li><p>常量池：constant_pool_count 和 constant_pool：常量池中主要存放两大类常量：字面量（Literal）和符号引用（Symbolic References）。</p></li><li><p>访问标志：access_flags：用于识别一些类或者接口层次的访问信息。包括：这个 Class 是类还是接口、是否定义了 Public 类型、是否定义为 abstract 类型、如果是类，是否被声明为了 final 等等。</p></li><li><p>类索引、父类索引与接口索引集合：this_class、super_class和interfaces。</p></li><li><p>字段表集合：field_info、fields_count：字段表（field_info）用于描述接口或者类中声明的变量；fields_count 字段数目：表示Class文件的类和实例变量总数。</p></li><li><p>方法表集合：methods、methods_count</p></li><li><p>属性表集合：attributes、attributes_count</p></li></ol><h2 id="JVM调优"><a href="#JVM调优" class="headerlink" title="JVM调优"></a>JVM调优</h2><h3 id="说下你用过的-JVM-监控工具？"><a href="#说下你用过的-JVM-监控工具？" class="headerlink" title="说下你用过的 JVM 监控工具？"></a>说下你用过的 JVM 监控工具？</h3><p>指令：</p><ol><li>jps ：查看当前 Java 进程信息</li><li>jmap：内存监控</li><li>jhat：分析 heapdump 文件</li><li>jstack：线程快照，查看各个线程的调用堆栈，定位线程出现长时间停顿的原因，如线程间死锁、死循环、请求外部资源导致的长时间等待等。</li></ol><h3 id="如何利用监控工具调优"><a href="#如何利用监控工具调优" class="headerlink" title="如何利用监控工具调优"></a>如何利用监控工具调优</h3><p><strong>1、堆信息查看</strong></p><ol><li>可查看堆空间大小分配（年轻代、年老代、持久代分配）</li><li>提供即时的垃圾回收功能</li><li>垃圾监控（长时间监控回收情况）</li><li>查看堆内类、对象信息查看：数量、类型等</li><li>对象引用情况查看</li></ol><p><strong>2、线程监控</strong></p><ol><li>线程信息监控：系统线程数量</li><li>线程状态监控：各个线程都处在什么样的状态下</li><li>Dump 线程详细信息：查看线程内部运行情况</li><li>死锁检查</li></ol><p><strong>3、 热点分析</strong></p><ol><li>CPU 热点：检查系统哪些方法占用的大量 CPU 时间；</li><li>内存热点：检查哪些对象在系统中数量最大</li></ol><p><strong>4、快照</strong></p><p>快照是系统运行到某一时刻的一个定格。</p><p>在我们进行调优的时候，依赖快照功能，就可以进行系统两个不同运行时刻，对象的不同，以便快速找到问题。</p><p><strong>5、内存泄露检查</strong></p><h3 id="JVM-的一些参数"><a href="#JVM-的一些参数" class="headerlink" title="JVM 的一些参数"></a>JVM 的一些参数</h3><ul><li><strong>1. 堆设置</strong></li></ul><p>-Xms：初始堆大小<br>-Xmx：最大堆大小</p><p>-XX:NewSize=n：设置年轻代大小</p><p>-XX:NewRatio=n：设置年轻代和年老代的比值。如:为3，表示年轻代与年老代比值为 1：3，年轻代占整个年轻代年老代和的 1/4</p><p>-XX:SurvivorRatio=n：年轻代中 Eden 区与两个 Survivor 区的比值。</p><p>-XX:MaxPermSize=n：设置永久代大小</p><ul><li><strong>2. 收集器设置</strong></li></ul><p>-XX:+UseSerialGC：设置串行收集器<br>-XX:+UseParallelGC：设置并行收集器<br>-XX:+UseParalledlOldGC：设置并行年老代收集器<br>-XX:+UseConcMarkSweepGC：设置并发收集器</p><ul><li><strong>3. 垃圾回收统计信息</strong></li></ul><p>-XX:+PrintGC：开启打印 gc 信息<br>-XX:+PrintGCDetails：打印 gc 详细信息</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> JVM </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程2(补档)</title>
      <link href="/2022/11/19/java-duo-xian-cheng-3-bu-dang/"/>
      <url>/2022/11/19/java-duo-xian-cheng-3-bu-dang/</url>
      
        <content type="html"><![CDATA[<h2 id="ThreadLocal"><a href="#ThreadLocal" class="headerlink" title="ThreadLocal"></a>ThreadLocal</h2><h3 id="ThreadLocal-了解吗"><a href="#ThreadLocal-了解吗" class="headerlink" title="ThreadLocal 了解吗"></a>ThreadLocal 了解吗</h3><p>ThreadLocal是线程本地变量，只属于当前线程，其他线程无法获取这个变量，是隔离的。<br>，让每一个线程都有自己的专属本地变量</p><h3 id="说说ThreadLocal-的原理"><a href="#说说ThreadLocal-的原理" class="headerlink" title="说说ThreadLocal 的原理"></a>说说ThreadLocal 的原理</h3><p><strong>每个线程Thead对象具有一个自己的ThreadLocalMap对象</strong>，把线程信息放入到ThreadLocalMap对象中，同一个线程thread在任何地方都可以拿出来。  </p><p>ThreadLocalMap对象的元素的key是ThreadLocal对象，value是需要存储的数据，可以具有多个Threadlocal对象(多个不同key)及对应的value数据。</p><p>ThreadLocal 提供 get 和 set 方法，实际上调用这两个方法的时候，我们调用的是<code>ThreadLocalMap</code>类对应的 <code>get()</code>、<code>set()</code>方法。</p><h3 id="ThreadLocal-内存泄露问题是怎么导致的"><a href="#ThreadLocal-内存泄露问题是怎么导致的" class="headerlink" title="ThreadLocal 内存泄露问题是怎么导致的"></a>ThreadLocal 内存泄露问题是怎么导致的</h3><p><code>ThreadLocalMap</code> 中使用的 key 为 <code>ThreadLocal</code> 的弱引用，而 value 是强引用。如果 <code>ThreadLocal</code> 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。</p><p>这样一来，<code>ThreadLocalMap</code> 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。</p><p><strong>处理方法：</strong></p><p><code>ThreadLocalMap</code> 实现中已经考虑了这种情况，在调用 <code>set()</code>、<code>get()</code>、<code>remove()</code> 方法的时候，会清理掉 key 为 null 的记录。使用完 <code>ThreadLocal</code>方法后最好手动调用<code>remove()</code>方法</p><h2 id="线程池"><a href="#线程池" class="headerlink" title="线程池"></a>线程池</h2><h3 id="什么是线程池"><a href="#什么是线程池" class="headerlink" title="什么是线程池?"></a>什么是线程池?</h3><p>线程池就是管理一系列线程的资源池。当有任务要处理时，直接从线程池中获取线程来处理，处理完之后线程并不会立即被销毁，而是等待下一个任务。</p><h3 id="为什么要用线程池"><a href="#为什么要用线程池" class="headerlink" title="为什么要用线程池"></a>为什么要用线程池</h3><p>池化技术，线程池、数据库连接池、Http 连接池等等都是对这个思想的应用。池化技术的思想主要是为了减少每次获取资源的消耗，提高对资源的利用率。</p><p><strong>使用线程池的好处</strong>：</p><ul><li>  <strong>降低资源消耗</strong>。通过重复利用已创建的线程降低线程创建和销毁造成的消耗。</li><li>  <strong>提高响应速度</strong>。当任务到达时，任务可以不需要等到线程创建就能立即执行。</li><li>  <strong>提高线程的可管理性</strong>。线程是稀缺资源，如果无限制的创建，不仅会消耗系统资源，还会降低系统的稳定性，使用线程池可以进行统一的分配，调优和监控。</li></ul><h3 id="如何创建线程池"><a href="#如何创建线程池" class="headerlink" title="如何创建线程池"></a>如何创建线程池</h3><p><strong>方式一：通过<code>ThreadPoolExecutor</code>构造函数来创建（推荐）。</strong></p><p><img src="/images/image_Java%E5%A4%9A%E7%BA%BF%E7%A8%8B_03/02.jpg"></p><p><strong>方式二：通过 <code>Executor</code> 框架的工具类 <code>Executors</code> 来创建。</strong></p><p>可以创建多种类型的 <code>ThreadPoolExecutor</code>：</p><ul><li>  <strong><code>FixedThreadPool</code></strong> ： 该方法返回一个固定线程数量的线程池。</li><li>  <strong><code>SingleThreadExecutor</code>：</strong> 该方法返回一个只有一个线程的线程池。</li><li>  <strong><code>CachedThreadPool</code>：</strong> 该方法返回一个可根据实际情况调整线程数量的线程池。</li><li>  <strong><code>ScheduledThreadPool</code></strong> ：该返回一个用来在给定的延迟后运行任务或者定期执行任务的线程池。</li></ul><h3 id="为什么不推荐使用内置线程池"><a href="#为什么不推荐使用内置线程池" class="headerlink" title="为什么不推荐使用内置线程池"></a>为什么不推荐使用内置线程池</h3><p>《阿里巴巴 Java 开发手册》中强制线程池不允许使用 <code>Executors</code> 去创建，而是通过 <code>ThreadPoolExecutor</code> 构造函数的方式，这样更加明确线程池的运行规则，规避资源耗尽的风险</p><p><code>Executors</code> 返回线程池对象的弊端如下：</p><ul><li>  <strong><code>FixedThreadPool</code> 和 <code>SingleThreadExecutor</code></strong> ： 使用的是无界的 <code>LinkedBlockingQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li><li>  <strong><code>CachedThreadPool</code></strong> ：使用的是同步队列 <code>SynchronousQueue</code>, 允许创建的线程数量为 <code>Integer.MAX_VALUE</code> ，可能会创建大量线程，从而导致 OOM。</li><li>  <strong><code>ScheduledThreadPool</code> 和 <code>SingleThreadScheduledExecutor</code></strong> : 使用的无界的延迟阻塞队列<code>DelayedWorkQueue</code>，任务队列最大长度为 <code>Integer.MAX_VALUE</code>,可能堆积大量的请求，从而导致 OOM。</li></ul><h3 id="线程池常见参数有哪些"><a href="#线程池常见参数有哪些" class="headerlink" title="线程池常见参数有哪些"></a>线程池常见参数有哪些</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 用给定的初始参数创建一个新的ThreadPoolExecutor。 */</span><span class="token keyword">public</span> <span class="token class-name">ThreadPoolExecutor</span><span class="token punctuation">(</span><span class="token keyword">int</span> corePoolSize<span class="token punctuation">,</span><span class="token comment">//线程池的核心线程数量</span>                          <span class="token keyword">int</span> maximumPoolSize<span class="token punctuation">,</span><span class="token comment">//线程池的最大线程数</span>                          <span class="token keyword">long</span> keepAliveTime<span class="token punctuation">,</span><span class="token comment">//当线程数大于核心线程数时，多余的空闲线程存活的最长时间</span>                          <span class="token class-name">TimeUnit</span> unit<span class="token punctuation">,</span><span class="token comment">//时间单位</span>                          <span class="token class-name">BlockingQueue</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Runnable</span><span class="token punctuation">&gt;</span></span> workQueue<span class="token punctuation">,</span><span class="token comment">//任务队列，用来储存等待执行任务的队列</span>                          <span class="token class-name">ThreadFactory</span> threadFactory<span class="token punctuation">,</span><span class="token comment">//线程工厂，用来创建线程，一般默认即可</span>                          <span class="token class-name">RejectedExecutionHandler</span> handler<span class="token comment">//拒绝(饱和)策略，当提交的任务过多而不能及时处理时，我们可以定制策略来处理任务</span>                           <span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong><code>ThreadPoolExecutor</code> 3 个最重要的参数：</strong></p><ul><li>  <strong><code>corePoolSize</code> :</strong> 线程池的核心线程数量。任务队列未达到队列容量时，最大可以同时运行的线程数量。</li><li>  <strong><code>maximumPoolSize</code> :</strong> 线程池的最大线程数。任务队列中存放的任务达到队列容量的时候，当前可以同时运行的线程数量变为最大线程数。</li><li>  <strong><code>workQueue</code>:</strong> 任务队列。新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</li></ul><p><code>ThreadPoolExecutor</code>其他常见参数 :</p><ul><li>  <strong><code>keepAliveTime</code></strong>:线程池中的线程数量大于 <code>corePoolSize</code> 的时候，核心线程外的线程不会立即销毁，而是会等待，直到等待的时间超过了 <code>keepAliveTime</code>才会被回收销毁；</li><li>  <strong><code>unit</code></strong> : <code>keepAliveTime</code> 参数的时间单位。</li><li>  <strong><code>threadFactory</code></strong> :executor 创建新线程的时候会用到。</li><li>  <strong><code>handler</code></strong> :饱和策略。</li></ul><h3 id="线程池的饱和策略有哪些"><a href="#线程池的饱和策略有哪些" class="headerlink" title="线程池的饱和策略有哪些"></a>线程池的饱和策略有哪些</h3><p>如果当前同时运行的线程数量达到最大线程数量并且队列也已经被放满了任务时，<code>ThreadPoolTaskExecutor</code> 定义一些策略:</p><ol><li>AbortPolicy：拒绝新任务，抛出异常。</li><li>CallerRunsPolicy：只用调用者所在线程来运行任务。</li><li>DiscardOldestPolicy：丢弃队列里最近的一个任务，并执行当前任务。</li><li>DiscardPolicy：不处理，丢弃掉。</li></ol><h3 id="线程池常用的阻塞队列有哪些"><a href="#线程池常用的阻塞队列有哪些" class="headerlink" title="线程池常用的阻塞队列有哪些"></a>线程池常用的阻塞队列有哪些</h3><p>新任务来的时候会先判断当前运行的线程数量是否达到核心线程数，如果达到的话，新任务就会被存放在队列中。</p><p>不同的线程池会选用不同的阻塞队列，我们可以结合内置线程池来分析。</p><p>1） ArrayBlockingQueue：是一个基于数组结构的有界阻塞队列，此队列按 FIFO（先进先出）原则对元素进行排序。</p><p>2）LinkedBlockingQueue：一个基于链表结构的无界阻塞队列，此队列按 FIFO 排序元素</p><p>3）SynchronousQueue：一个不存储元素的阻塞队列。目的是保证对于提交的任务，如果有空闲线程，则使用空闲线程来处理；否则新建一个线程来处理任务。</p><p>4）PriorityBlockingQueue：一个具有优先级的无限阻塞队列。</p><h3 id="线程池处理任务的流程了解吗"><a href="#线程池处理任务的流程了解吗" class="headerlink" title="线程池处理任务的流程了解吗"></a>线程池处理任务的流程了解吗</h3><p><img src="/images/image_Java%E5%A4%9A%E7%BA%BF%E7%A8%8B_03/05.png"></p><ol><li> 如果当前运行的线程数小于核心线程数，那么就会新建一个线程来执行任务。</li><li> 如果当前运行的线程数等于或大于核心线程数，但是小于最大线程数，那么就把该任务放入到任务队列里等待执行。</li><li> 如果向任务队列投放任务失败（任务队列已经满了），但是当前运行的线程数是小于最大线程数的，就新建一个线程来执行任务。</li><li> 如果当前运行的线程数已经等同于最大线程数了，新建线程将会使当前运行的线程超出最大线程数，那么当前任务会被拒绝，按照饱和策略处理。</li></ol><h3 id="线程池中的的线程数一般怎么设置？需要考虑哪些问题"><a href="#线程池中的的线程数一般怎么设置？需要考虑哪些问题" class="headerlink" title="线程池中的的线程数一般怎么设置？需要考虑哪些问题"></a>线程池中的的线程数一般怎么设置？需要考虑哪些问题</h3><p>主要考虑下面几个方面：</p><p><strong>1. 线程池中线程执行任务的性质：</strong></p><p>计算密集型的任务比较占 cpu，一般线程数设置的大小 等于或者略微大于 cpu 的核数（N+1）</p><p>IO 型任务主要时间消耗在 IO 等待上，cpu 压力并不大，所以线程数一般设置较大（2N）</p><p><strong>2. 内存使用率：</strong></p><p>线程数过多和队列的大小都会影响此项数据，队列的大小应该通过前期计算线程池任务的条数，来合理的设置队列的大小，不宜过小，让其不会溢出，因为溢出会走拒绝策略，多少会影响性能，也会增加复杂度。</p><h3 id="execute-和-submit-的区别是什么"><a href="#execute-和-submit-的区别是什么" class="headerlink" title="execute() 和 submit() 的区别是什么"></a>execute() 和 submit() 的区别是什么</h3><ul><li><p>execute() 方法用于提交不需要返回值的任务，所以无法判断任务是否被线程池执行成功与否；</p></li><li><p>submit() 方法用于提交需要返回值的任务。线程池会返回一个 Future 类型的对象，通过这个 Future 对象可以判断任务是否执行成功，并且可以通过 Future 的 get() 方法来获取返回值</p></li></ul><h2 id="Future"><a href="#Future" class="headerlink" title="Future"></a>Future</h2><h3 id="Future-类有什么用"><a href="#Future-类有什么用" class="headerlink" title="Future 类有什么用"></a>Future 类有什么用</h3><p><code>Future</code> 类是异步思想的典型运用，主要用在一些需要执行耗时任务的场景，避免程序一直原地等待耗时任务执行完成，执行效率太低。</p><p>在 Java 中，<code>Future</code> 类只是一个泛型接口，位于 <code>java.util.concurrent</code> 包下，主要包括下面这 4 个功能：</p><ul><li>取消任务；</li><li>判断任务是否被取消;</li><li>判断任务是否已经执行完成;</li><li>获取任务执行结果。</li></ul><p>简单理解：我有一个任务，提交给了 <code>Future</code> 来处理。任务执行期间我自己可以去做任何想做的事情。并且，在这期间我还可以取消任务以及获取任务的执行状态。一段时间之后，我就可以 <code>Future</code> 那里直接取出任务执行结果。</p><h3 id="CompletableFuture-类有什么用"><a href="#CompletableFuture-类有什么用" class="headerlink" title="CompletableFuture 类有什么用"></a>CompletableFuture 类有什么用</h3><p><code>Future</code> 在实际使用过程中存在一些局限性比如不支持异步任务的编排组合、获取计算结果的 <code>get()</code> 方法为阻塞调用。</p><p>Java 8 引入<code>CompletableFuture</code> 类可以解决<code>Future</code> 的这些缺陷。还提供了函数式编程、异步任务编排组合（可以将多个异步任务串联起来，组成一个完整的链式调用）等能力。</p><h2 id="AQS"><a href="#AQS" class="headerlink" title="AQS"></a>AQS</h2><h3 id="AQS是什么"><a href="#AQS是什么" class="headerlink" title="AQS是什么"></a>AQS是什么</h3><p>AQS 是抽象队列同步器。<code>AbstractQueuedSynchronizer</code>这个类在 <code>java.util.concurrent.locks</code> 包下面。</p><p>AQS 就是一个抽象类，主要用来构建锁和同步器。</p><h3 id="说说AQS-的原理"><a href="#说说AQS-的原理" class="headerlink" title="说说AQS 的原理"></a>说说AQS 的原理</h3><p>AQS 核心思想是，如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并且将共享资源设置为锁定状态。如果被请求的共享资源被占用，那么就需要一套线程阻塞等待以及被唤醒时锁分配的机制，这个机制 AQS 是用 <strong>CLH 队列锁</strong> 实现的，即将暂时获取不到锁的线程加入到队列中。</p><p>CLH队列是一个<strong>虚拟的双向队列</strong>。AQS 是将每条请求共享资源的线程封装成一个 CLH 锁队列的一个结点（Node）来实现锁的分配。</p><p>AQS 使用 <strong>int 成员变量 <code>state</code> 表示同步状态</strong>，通过内置的 <strong>线程等待队列</strong> 来完成获取资源线程的排队工作。</p><p><code>state</code> 变量由 <code>volatile</code> 修饰，用于展示当前临界资源的获锁情况。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 共享变量，使用volatile修饰保证线程可见性</span><span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">int</span> state<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>状态信息 <code>state</code> 可以通过<code>getState()</code>、<code>setState()</code>和CAS进行操作。</p><h3 id="说说Semaphore原理和作用"><a href="#说说Semaphore原理和作用" class="headerlink" title="说说Semaphore原理和作用"></a>说说Semaphore原理和作用</h3><p><code>Semaphore</code> (信号量)是共享锁的一种实现，可以用来控制同时访问特定资源的线程数量。</p><p>它默认构造 AQS 的 <code>state</code> 值为 <code>permits</code>，可以将 <code>permits</code> 的值理解为许可证的数量，只有拿到许可证的线程才能执行。</p><p>调用<code>semaphore.acquire()</code> ，线程尝试获取许可证，如果 <code>state &gt;= 0</code> 的话，则表示可以获取成功。如果获取成功的话，使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state-1</code>。如果 <code>state&lt;0</code> 的话，则表示许可证数量不足。此时会创建一个 Node 节点加入阻塞队列，挂起当前线程。</p><p>调用<code>semaphore.release();</code> ，线程尝试释放许可证，并使用 CAS 操作去修改 <code>state</code> 的值 <code>state=state+1</code>。释放许可证成功之后，同时会唤醒同步队列中的一个线程。被唤醒的线程会重新尝试去修改 <code>state</code> 的值 <code>state=state-1</code> ，如果 <code>state&gt;=0</code> 则获取令牌成功，否则重新进入阻塞队列，挂起线程。</p><h3 id="说说CountDownLatch原理和作用"><a href="#说说CountDownLatch原理和作用" class="headerlink" title="说说CountDownLatch原理和作用"></a>说说CountDownLatch原理和作用</h3><p><code>CountDownLatch</code> 允许 <code>count</code> 个线程阻塞在一个地方，直至所有线程的任务都执行完毕。</p><p><code>CountDownLatch</code> 是共享锁的一种实现,它默认构造 AQS 的 <code>state</code> 值为 <code>count</code>。</p><p>当调用 <code>await()</code> 方法的时候，如果 <code>state</code> 不为 0，那就证明任务还没有执行完毕，<code>await()</code> 方法就会一直阻塞，也就是说 <code>await()</code> 方法之后的语句不会被执行。</p><p>使用场景：</p><p>我们要读取处理 6 个文件，这 6 个任务都是没有执行顺序依赖的任务，但是我们需要返回给用户的时候将这几个文件的处理的结果进行统计整理。</p><p>调用<code>CountDownLatch</code>对象的 <code>await()</code>方法，直到所有文件读取完之后，才会接着执行后面的逻辑。</p><h3 id="说说CyclicBarrier原理和作用"><a href="#说说CyclicBarrier原理和作用" class="headerlink" title="说说CyclicBarrier原理和作用"></a>说说CyclicBarrier原理和作用</h3><p><code>CyclicBarrier</code> 的字面意思是可循环使用（Cyclic）的屏障（Barrier）。</p><p>CyclicBarrier可以让一组线程到达一个屏障（也可以叫同步点）时被阻塞，直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行。</p><p><code>CyclicBarrier</code> 内部通过一个 <code>count</code> 变量作为计数器，<code>count</code> 的初始值为 <code>parties</code> 属性的初始化值，每当一个线程到了栅栏这里了，那么就将计数器减 1。如果 count 值为 0 了，表示这是这一代最后一个线程到达栅栏，就尝试执行我们构造方法中输入的任务。</p><p>使用场景：</p><p>CyclicBarrier 可以用于多线程计算数据，最后合并计算结果的应用场景。</p><h2 id="JMM"><a href="#JMM" class="headerlink" title="JMM"></a>JMM</h2><h3 id="说说对-Java-内存模型的理解"><a href="#说说对-Java-内存模型的理解" class="headerlink" title="说说对 Java 内存模型的理解"></a>说说对 Java 内存模型的理解</h3><p>Java 内存模型的主要目标是定义程序中各个变量的<strong>访问规则</strong>，即在虚拟机中将变量存储到内存和从内存中取出变量这样的底层细节。</p><p>比如说：所有的变量都存储在主内存中，每个线程有自己的工作内存，保存主内存副本拷贝和自己私有变量，不同线程不能访问工作内存中的变量。线程间变量值的传递需要通过主内存来完成。</p><p>不同的操作系统内存模型不同。如果直接复用操作系统层面的内存模型，就可能会导致同样一套代码换了一个操作系统就无法执行了。Java 语言是跨平台的，它需要自己提供一套内存模型以屏蔽系统差异。</p><p>Java 内存模型屏蔽掉了各种硬件和操作系统的内存访问差异，以实现让 Java 程序在各种平台下都能达到一致性的内存访问效果</p><p>对于 Java 开发者说，不需要了解底层原理，直接使用并发相关的一些关键字和类即可开发出并发安全的程序。</p><p>JMM主要是为了<strong>简化多线程编程</strong>，<strong>增强程序可移植性的</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程2(补档)</title>
      <link href="/2022/11/17/java-duo-xian-cheng-2-bu-dang/"/>
      <url>/2022/11/17/java-duo-xian-cheng-2-bu-dang/</url>
      
        <content type="html"><![CDATA[<h2 id="volatile"><a href="#volatile" class="headerlink" title="volatile"></a>volatile</h2><h3 id="volatile-关键字了解吗，有什么作用"><a href="#volatile-关键字了解吗，有什么作用" class="headerlink" title="volatile 关键字了解吗，有什么作用"></a>volatile 关键字了解吗，有什么作用</h3><p>volatile是java中的关键字，有以下两个作用：</p><ol><li>保证变量的可见性</li><li>禁止指令重排序</li></ol><h3 id="volatile如何保证变量的可见性"><a href="#volatile如何保证变量的可见性" class="headerlink" title="volatile如何保证变量的可见性"></a>volatile如何保证变量的可见性</h3><p>java内存模型在变量修改后将新的变量值同步回主内存，在其他线程读取该变量之前从主内存刷新变量值来实现可见性。</p><h3 id="volatile如何保证代码有序性"><a href="#volatile如何保证代码有序性" class="headerlink" title="volatile如何保证代码有序性"></a>volatile如何保证代码有序性</h3><p><code>volatile</code> 关键字<strong>还有一个重要的作用就是防止 JVM 的指令重排序。</strong>&nbsp;在变量进行读写操作的时候，会通过插入特定的&nbsp;<strong>内存屏障</strong>&nbsp;的方式来禁止指令重排序。</p><p>&nbsp;<code>volatile</code>&nbsp;关键字禁止指令重排序的效果如下：</p><p><strong>双重校验锁实现对象单例（线程安全）</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Singleton</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">volatile</span> <span class="token keyword">static</span> <span class="token class-name">Singleton</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token keyword">private</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token punctuation">}</span>    <span class="token keyword">public</span>  <span class="token keyword">static</span> <span class="token class-name">Singleton</span> <span class="token function">getUniqueInstance</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>       <span class="token comment">//先判断对象是否已经实例过，没有实例化过才进入加锁代码</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//类对象加锁</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span><span class="token class-name">Singleton</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>uniqueInstance <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    uniqueInstance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Singleton</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> uniqueInstance<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><code>uniqueInstance</code> 采用 <code>volatile</code> 关键字修饰也是很有必要的， <code>uniqueInstance = new Singleton();</code> 这段代码其实是分为三步执行：</p><ol><li> 为 <code>uniqueInstance</code> 分配内存空间</li><li> 初始化 <code>uniqueInstance</code></li><li> 将 <code>uniqueInstance</code> 指向分配的内存地址</li></ol><p>但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1-&gt;3-&gt;2。</p><p>指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 <code>getUniqueInstance</code>() 后发现 <code>uniqueInstance</code> 不为空，因此返回 <code>uniqueInstance</code>，但此时 <code>uniqueInstance</code> 还未被初始化。</p><h3 id="volatile-可以保证原子性吗"><a href="#volatile-可以保证原子性吗" class="headerlink" title="volatile 可以保证原子性吗"></a>volatile 可以保证原子性吗</h3><p><strong><code>volatile</code>&nbsp;关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。</strong></p><h2 id="synchronized"><a href="#synchronized" class="headerlink" title="synchronized"></a>synchronized</h2><h3 id="synchronized-是什么？有什么用？"><a href="#synchronized-是什么？有什么用？" class="headerlink" title="synchronized 是什么？有什么用？"></a>synchronized 是什么？有什么用？</h3><p><code>synchronized</code> 是 Java 中的一个关键字，是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。</p><h3 id="synchronized-底层原理了解吗"><a href="#synchronized-底层原理了解吗" class="headerlink" title="synchronized 底层原理了解吗"></a>synchronized 底层原理了解吗</h3><p>synchronized 关键字底层原理属于 JVM 层面的东西。</p><p><strong>synchronized 修饰同步语句块：</strong></p><p><code>synchronized</code> 同步语句块的实现使用的是 <code>monitorenter</code> 和 <code>monitorexit</code> 指令，其中 <code>monitorenter</code> 指令指向同步代码块的开始位置，<code>monitorexit</code> 指令则指明同步代码块的结束位置。</p><p>当执行 <code>monitorenter</code> 指令时，线程试图获取锁也就是获取 <strong>对象监视器 <code>monitor</code></strong> 的持有权。</p><p>在执行<code>monitorenter</code>时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。</p><p>如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。</p><p><strong>synchronized 修饰方法：</strong></p><p><code>synchronized</code> 修饰的方法用<code>ACC_SYNCHRONIZED</code> 标识，该标识指明了该方法是一个同步方法。</p><p>如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。</p><p><strong>都是对对象监视器 monitor 的获取。</strong></p><h3 id="如何使用-synchronized？"><a href="#如何使用-synchronized？" class="headerlink" title="如何使用 synchronized？"></a>如何使用 synchronized？</h3><p><strong>1、修饰实例方法</strong>&nbsp;（锁当前对象实例）</p><p>给当前对象实例加锁，进入同步代码前要获得&nbsp;<strong>当前对象实例的锁</strong>&nbsp;。</p><p><strong>2、修饰静态方法</strong> （锁当前类）</p><p>给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 <strong>当前 class 的锁</strong>。</p><p><strong>3、修饰代码块</strong> （锁指定对象/类）</p><p>对括号里指定的对象/类加锁：</p><ul><li>  <code>synchronized(object)</code> 表示进入同步代码库前要获得 <strong>给定对象的锁</strong>。</li><li>  <code>synchronized(类.class)</code> 表示进入同步代码前要获得 <strong>给定 Class 的锁</strong></li></ul><h3 id="构造方法可以用-synchronized-修饰么？"><a href="#构造方法可以用-synchronized-修饰么？" class="headerlink" title="构造方法可以用 synchronized 修饰么？"></a>构造方法可以用 synchronized 修饰么？</h3><p>构造方法<strong>不能</strong>使用 synchronized 关键字修饰。</p><p>构造方法本身就属于线程安全的，不存在同步的构造方法一说。</p><h3 id="JDK1-6-之后的-synchronized-底层做了哪些优化"><a href="#JDK1-6-之后的-synchronized-底层做了哪些优化" class="headerlink" title="JDK1.6 之后的 synchronized 底层做了哪些优化"></a>JDK1.6 之后的 synchronized 底层做了哪些优化</h3><p>JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。</p><p>锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。</p><h3 id="synchronized-和-volatile-有什么区别？"><a href="#synchronized-和-volatile-有什么区别？" class="headerlink" title="synchronized 和 volatile 有什么区别？"></a>synchronized 和 volatile 有什么区别？</h3><p><code>synchronized</code> 关键字和 <code>volatile</code> 关键字是两个互补的存在，而不是对立的存在</p><ul><li><strong>性能</strong>：<code>volatile</code> 关键字是线程同步的轻量级实现，所以 <code>volatile</code>性能肯定比<code>synchronized</code>关键字要好 </li><li><strong>用法</strong>：<code>volatile</code> 关键字只能用于变量而 <code>synchronized</code> 关键字可以修饰方法以及代码块 。</li><li><strong>原子性</strong>：<code>volatile</code> 关键字能保证数据的可见性，但不能保证数据的原子性。<code>synchronized</code> 关键字两者都能保证。</li><li><strong>功能</strong>：<code>volatile</code>关键字主要用于解决变量在多个线程之间的可见性，而 <code>synchronized</code> 关键字解决的是多个线程之间访问资源的同步性。</li></ul><h2 id="ReentrantLock"><a href="#ReentrantLock" class="headerlink" title="ReentrantLock"></a>ReentrantLock</h2><h3 id="ReentrantLock-是什么"><a href="#ReentrantLock-是什么" class="headerlink" title="ReentrantLock 是什么"></a>ReentrantLock 是什么</h3><p><code>ReentrantLock</code> 实现了 <code>Lock</code> 接口，是一个可重入且独占式的锁，和 <code>synchronized</code> 关键字类似。不过，<code>ReentrantLock</code> 更灵活、更强大，增加了轮询、超时、中断、公平锁和非公平锁等高级功能。</p><p><code>ReentrantLock</code> 里面有一个内部类 <code>Sync</code>，<code>Sync</code> 继承 AQS，添加锁和释放锁的大部分操作都是在 <code>Sync</code> 中实现的。<code>Sync</code> 有公平锁 <code>FairSync</code> 和非公平锁 <code>NonfairSync</code> 两个子类。</p><p><code>ReentrantLock</code>&nbsp;的底层就是由 AQS 来实现的</p><h3 id="synchronized-和-ReentrantLock-有什么区别？"><a href="#synchronized-和-ReentrantLock-有什么区别？" class="headerlink" title="synchronized 和 ReentrantLock 有什么区别？"></a>synchronized 和 ReentrantLock 有什么区别？</h3><p>两者都是可重入锁可重入锁也叫递归锁，指的是线程可以再次获取自己的内部锁。</p><ol><li><p><code>synchronized</code> 是依赖于 JVM 实现的，<code>ReentrantLock</code> 是 JDK 层面实现的</p></li><li><p>ReentrantLock 比 synchronized 增加了一些高级功能</p></li><li><p>相比<code>synchronized</code>，<code>ReentrantLock</code>增加了一些高级功能。</p></li></ol><ul><li>  <strong>等待可中断</strong> : 正在等待的线程可以选择放弃等待，改为处理其他事情。</li><li>  <strong>可实现公平锁</strong> : <code>ReentrantLock</code>可以指定是公平锁还是非公平锁。而<code>synchronized</code>只能是非公平锁。</li><li>  <strong>可实现选择性通知</strong>: <code>synchronized</code>关键字与<code>wait()</code>和<code>notify()</code>/<code>notifyAll()</code>方法相结合可以实现等待/通知机制。<code>ReentrantLock</code>类当然也可以实现，但是需要借助于<code>Condition</code>接口与<code>newCondition()</code>方法。</li></ul><h3 id="说说对Condition的了解"><a href="#说说对Condition的了解" class="headerlink" title="说说对Condition的了解"></a>说说对Condition的了解</h3><p><code>Condition</code>是 JDK1.5 之后才有的，它具有很好的灵活性，</p><p>实现多路通知功能也就是在一个<code>Lock</code>对象中可以创建多个<code>Condition</code>实例（即对象监视器），线程对象可以注册在指定的<code>Condition</code>中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。</p><p>在使用<code>notify()/notifyAll()</code>方法进行通知时，被通知的线程是由 JVM 选择的，用<code>ReentrantLock</code>类结合<code>Condition</code>实例可以实现“<strong>选择性通知</strong>”*</p><h2 id="各种类型的锁"><a href="#各种类型的锁" class="headerlink" title="各种类型的锁"></a>各种类型的锁</h2><h3 id="公平锁和非公平锁有什么区别"><a href="#公平锁和非公平锁有什么区别" class="headerlink" title="公平锁和非公平锁有什么区别"></a>公平锁和非公平锁有什么区别</h3><ul><li>  <strong>公平锁</strong> : 锁被释放之后，先申请的线程先得到锁。性能较差一些，因为公平锁为了保证时间上的绝对顺序，上下文切换更频繁。</li><li>  <strong>非公平锁</strong> ：锁被释放之后，后申请的线程可能会先获取到锁，是随机或者按照其他优先级排序的。性能更好，但可能会导致某些线程永远无法获取到锁</li></ul><h3 id="可中断锁和不可中断锁有什么区别"><a href="#可中断锁和不可中断锁有什么区别" class="headerlink" title="可中断锁和不可中断锁有什么区别"></a>可中断锁和不可中断锁有什么区别</h3><ul><li><strong>可中断锁</strong>：获取锁的过程中可以被中断，不需要一直等到获取锁之后 才能进行其他逻辑处理。<code>ReentrantLock</code> 就属于是可中断锁。</li><li><strong>不可中断锁</strong>：一旦线程申请了锁，就只能等到拿到锁以后才能进行其他的逻辑处理。 <code>synchronized</code> 就属于是不可中断锁。</li></ul><h3 id="共享锁和独占锁有什么区别"><a href="#共享锁和独占锁有什么区别" class="headerlink" title="共享锁和独占锁有什么区别"></a>共享锁和独占锁有什么区别</h3><ul><li><strong>共享锁</strong>：一把锁可以被多个线程同时获得。（读锁）</li><li><strong>独占锁</strong>：一把锁只能被一个线程获得。（写锁）</li></ul><h3 id="线程持有读锁还能获取写锁吗"><a href="#线程持有读锁还能获取写锁吗" class="headerlink" title="线程持有读锁还能获取写锁吗"></a>线程持有读锁还能获取写锁吗</h3><ul><li>在线程持有读锁的情况下，该线程不能取得写锁（不管读锁是不是被当前线程持有）。</li><li>在线程持有写锁的情况下，该线程可以继续获取读锁（写锁被当前线程持有）<h3 id="读锁为什么不能升级为写锁"><a href="#读锁为什么不能升级为写锁" class="headerlink" title="读锁为什么不能升级为写锁"></a>读锁为什么不能升级为写锁</h3></li></ul><p>写锁可以降级为读锁，但是读锁却不能升级为写锁。</p><p>因为读锁升级为写锁会引起线程的争夺，会<strong>影响性能</strong>。</p><p>可能会有<strong>死锁</strong>问题发生。比如：假设两个线程的读锁都想升级写锁，则需要对方都释放自己锁，而双方都不释放，就会产生死锁。</p><h2 id="乐观锁和悲观锁"><a href="#乐观锁和悲观锁" class="headerlink" title="乐观锁和悲观锁"></a>乐观锁和悲观锁</h2><h3 id="什么是悲观锁"><a href="#什么是悲观锁" class="headerlink" title="什么是悲观锁"></a>什么是悲观锁</h3><p>悲观锁总是假设最坏的情况，认为共享资源每次被访问的时候就会出现问题，每次在获取资源操作的时候都会上锁。</p><p><strong>悲观锁通常多用于写比较多的情况下（多写场景），避免频繁失败和重试影响性能。</strong></p><h3 id="什么是乐观锁"><a href="#什么是乐观锁" class="headerlink" title="什么是乐观锁"></a>什么是乐观锁</h3><p>乐观锁总是假设最好的情况，认为共享资源每次被访问的时候不会出现问题，线程可以不停地执行，无需加锁也无需等待，只是在提交修改的时候去验证对应的资源是否被其它线程修改了。</p><p><strong>乐观锁通常多于写比较少的情况下（多读场景），避免频繁加锁影响性能，大大提升了系统的吞吐量。</strong></p><h3 id="如何实现乐观锁"><a href="#如何实现乐观锁" class="headerlink" title="如何实现乐观锁?"></a>如何实现乐观锁?</h3><p><strong>版本号机制</strong></p><p>一般是在数据表中加上一个数据版本号 <code>version</code> 字段，表示数据被修改的次数。当数据被修改时，<code>version</code> 值会加一。当线程 A 要更新数据值时，在读取数据的同时也会读取 <code>version</code> 值，在提交更新时，若刚才读取到的 version 值为当前数据库中的 <code>version</code> 值相等时才更新，否则重试更新操作，直到更新成功。</p><p><strong>CAS 算法</strong></p><p>CAS 的全称是 <strong>Compare And Swap（比较与交换）</strong> ，用于实现乐观锁，被广泛应用于各大框架中。CAS 的思想很简单，就是用一个预期值和要更新的变量值进行比较，两值相等才会进行更新。</p><p>CAS 是一个原子操作，底层依赖于一条 CPU 的原子指令。</p><h3 id="乐观锁存在哪些问题"><a href="#乐观锁存在哪些问题" class="headerlink" title="乐观锁存在哪些问题"></a>乐观锁存在哪些问题</h3><p><strong>ABA 问题</strong></p><p>如果一个变量 V 初次读取的时候是 A 值，并且在准备赋值的时候检查到它仍然是 A 值，它可能之前被修改过，但是检查之前又修改回A了</p><p>ABA 问题的解决思路是在变量前面追加上<strong>版本号或者时间戳</strong>。</p><p><strong>循环时间长开销大</strong></p><p>CAS 经常会用到自旋操作来进行重试，也就是不成功就一直循环执行直到成功。如果长时间不成功，会给 CPU 带来非常大的执行开销。</p><p><strong>只能保证一个共享变量的原子操作</strong></p><p>CAS 只对单个共享变量有效，当操作涉及跨多个共享变量时 CAS 无效。</p><p>但是从 JDK 1.5 开始，提供了<code>AtomicReference</code>类来保证引用对象之间的原子性，你可以把多个变量放在一个对象里来进行 CAS 操作。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java多线程1(补档)</title>
      <link href="/2022/11/15/java-duo-xian-cheng-1-bu-dang/"/>
      <url>/2022/11/15/java-duo-xian-cheng-1-bu-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是线程和进程-从Java方面讲一下"><a href="#什么是线程和进程-从Java方面讲一下" class="headerlink" title="什么是线程和进程?从Java方面讲一下"></a>什么是线程和进程?从Java方面讲一下</h3><p>进程是程序的一次执行过程，是系统运行程序的基本单位，因此进程是动态的。系统运行一个程序即是一个进程从创建，运行到消亡的过程。</p><p>在 Java 中，当我们启动 main 函数时其实就是启动了一个 JVM 的进程，而 main 函数所在的线程就是这个进程中的一个线程，也称主线程。</p><p>线程与进程相似，但线程是一个比进程更小的执行单位。一个进程在其执行的过程中可以产生多个线程。多个线程共享进程的<strong>堆</strong>和<strong>方法区</strong>资源，但每个线程有自己的<strong>程序计数器</strong>、<strong>虚拟机栈</strong>和<strong>本地方法栈</strong></p><p>基本上各进程是独立的，而各线程则不一定，因为同一进程中的线程极有可能会相互影响。</p><h3 id="创建线程的方式有哪些"><a href="#创建线程的方式有哪些" class="headerlink" title="创建线程的方式有哪些"></a>创建线程的方式有哪些</h3><ol><li><p>继承 Thread 类创建线程；</p></li><li><p>实现 Runnable 接口创建线程；</p></li><li><p>通过 Callable 接口并利用 Future 创建线程；</p></li><li><p>通过线程池创建线程。</p><h3 id="Runnable-和-Callable-有什么区别"><a href="#Runnable-和-Callable-有什么区别" class="headerlink" title="Runnable 和 Callable 有什么区别"></a>Runnable 和 Callable 有什么区别</h3></li><li><p>Runnable 接口中的 run() 方法的返回值是 void，它做的事情只是去执行 run() 方法中的代码</p></li><li><p>Callable 接口中的 call() 方法是有返回值的，是一个泛型，和 Future、FutureTask 配合可以用来获取异步执行的结果。</p></li></ol><h3 id="说说线程的生命周期和状态"><a href="#说说线程的生命周期和状态" class="headerlink" title="说说线程的生命周期和状态"></a>说说线程的生命周期和状态</h3><p>Java 线程在运行的生命周期中的指定时刻只可能处于下面 6 种不同状态的其中一个状态：</p><ul><li>NEW: 初始状态，线程被创建出来但没有被调用 <code>start()</code> 。</li><li>RUNNABLE: 运行状态，线程被调用了 <code>start()</code>等待运行的状态。</li><li>BLOCKED：阻塞状态，需要等待锁释放。</li><li>WAITING：等待状态，表示该线程需要等待其他线程做出一些特定动作（通知或中断）。</li><li>TIME_WAITING：超时等待状态，可以在指定的时间后自行返回而不是像 WAITING 那样一直等待。</li><li>TERMINATED：终止状态，表示该线程已经运行完毕。</li></ul><p><img src="/images/image_Java%E5%A4%9A%E7%BA%BF%E7%A8%8B_01/02.png"></p><h3 id="什么是线程上下文切换"><a href="#什么是线程上下文切换" class="headerlink" title="什么是线程上下文切换"></a>什么是线程上下文切换</h3><p>线程在执行过程中会有自己的运行条件和状态（也称上下文），比如线程私有的程序计数器，栈信息等。</p><p>线程切换时需要保存当前线程的上下文，留待线程下次占用 CPU 的时候恢复现场。并加载下一个将要占用 CPU 的线程上下文。这就是所谓的&nbsp;<strong>上下文切换</strong>。</p><h3 id="什么是线程死锁-写一个死锁"><a href="#什么是线程死锁-写一个死锁" class="headerlink" title="什么是线程死锁?写一个死锁"></a>什么是线程死锁?写一个死锁</h3><p>线程死锁：多个线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于线程被无限期地阻塞，因此程序不可能正常终止。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DeadLockDemo</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//资源 1</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token class-name">Object</span> resource2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//资源 2</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">[</span><span class="token punctuation">]</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程 1"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">new</span> <span class="token class-name">Thread</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">{</span>            <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource2<span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource2"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">try</span> <span class="token punctuation">{</span>                    <span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">InterruptedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    e<span class="token punctuation">.</span><span class="token function">printStackTrace</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>                <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"waiting get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token keyword">synchronized</span> <span class="token punctuation">(</span>resource1<span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token class-name">Thread</span><span class="token punctuation">.</span><span class="token function">currentThread</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"get resource1"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token string">"线程 2"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">start</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>Output</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">Thread[线程 1,5,main]get resource1Thread[线程 2,5,main]get resource2Thread[线程 1,5,main]waiting get resource2Thread[线程 2,5,main]waiting get resource1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="实现线程同步的方法有哪些"><a href="#实现线程同步的方法有哪些" class="headerlink" title="实现线程同步的方法有哪些"></a>实现线程同步的方法有哪些</h3><ol><li>使用 Synchronized 关键字；</li><li>wait 和 notify 等待和通知；</li><li>使用特殊域变量 volatile 实现线程同步；</li><li>使用ReentrantLock实现线程同步；</li><li>使用阻塞队列实现线程同步；</li><li>使用信号量 Semaphore。</li><li>原子变量</li></ol><h3 id="线程之间通信的方法有哪些"><a href="#线程之间通信的方法有哪些" class="headerlink" title="线程之间通信的方法有哪些"></a>线程之间通信的方法有哪些</h3><ol><li>线程之间采用synchronized：可以利用**wait()、notify()、notifyAll()**来实现线程通信。</li><li>线程之间采用Lock：可以利用**await()、signal()、signalAll()**来实现线程通信。</li><li><strong>BlockingQueue</strong>：程序的两个线程通过交替向BlockingQueue中放入元素、取出元素，即可很好地控制线程的通信。<h3 id="sleep-方法和-wait-方法对比"><a href="#sleep-方法和-wait-方法对比" class="headerlink" title="sleep() 方法和 wait() 方法对比"></a>sleep() 方法和 wait() 方法对比</h3></li></ol><p><strong>共同点</strong>：两者都可以暂停线程的执行。</p><p><strong>区别</strong>：</p><ul><li><strong>锁的释放</strong>：<code>sleep()</code> 方法没有释放锁，而 <code>wait()</code> 方法释放了锁 。</li><li><strong>使用场景</strong>：sleep() 方法可以在任何地方使用，而 wait() 方法则只能在同步方法或同步块中使用；</li><li><strong>功能</strong>：<code>wait()</code> 通常被用于线程间交互/通信，<code>sleep()</code>通常被用于暂停执行。</li><li><strong>自动苏醒</strong>：<code>wait()</code> 方法被调用后，线程不会自动苏醒，需要别的线程调用同一个对象上的 <code>notify()</code>或者 <code>notifyAll()</code> 方法。<code>sleep()</code>方法执行完成后，线程会自动苏醒，或者也可以使用 <code>wait(long timeout)</code> 超时后线程会自动苏醒。</li><li><strong>所属类</strong>：<code>sleep()</code> 是 <code>Thread</code> 类的静态本地方法，<code>wait()</code> 则是 <code>Object</code> 类的本地方法。</li></ul><h3 id="如何优雅的停止一个线程"><a href="#如何优雅的停止一个线程" class="headerlink" title="如何优雅的停止一个线程"></a>如何优雅的停止一个线程</h3><p><strong>interrupt 停止线程</strong></p><p>其核心就是通过调用线程的 isInterrupt()&nbsp;方法进而判断信号，当线程检测到为 true 时则说明接收到终止信号，此时我们需要做相应的处理来退出线程的运行，比如break循环。</p><p>如果 sleep、wait等可以让线程进入阻塞的方法使线程休眠了，而处于休眠中的线程被中断，那么线程是可以感受到中断信号的，并且会<strong>抛出一个 InterruptedException异常</strong>，同时清除中断信号，将中断标记位设置成 false。</p><p><strong>用 volatile 标记位的停止方法</strong></p><p>关于 volatile 作为标记位的核心就是他的可见性特性，可以while(mark)作为线程中循环的条件</p><h3 id="可以直接调用-Thread-类的-run-方法吗？"><a href="#可以直接调用-Thread-类的-run-方法吗？" class="headerlink" title="可以直接调用 Thread 类的 run 方法吗？"></a>可以直接调用 Thread 类的 run 方法吗？</h3><p>可以</p><p>但是，直接执行 <code>run()</code> 方法，会把 <code>run()</code> 方法当成一个 main 线程下的普通方法去执行，并不会在某个线程中执行它，所以这并不是多线程工作。</p><h3 id="JUC了解吗"><a href="#JUC了解吗" class="headerlink" title="JUC了解吗"></a>JUC了解吗</h3><p>JUC是java.util.concurrent的缩写，是Java提供的并发包，包含了我们在并发编程时用到的一些工具</p><ol><li><p><strong>原子更新</strong>：Java从JDK1.5开始提供了java.util.concurrent.atomic包，方便程序员在多线程环境下，无锁的进行原子操作。</p></li><li><p><strong>锁和条件变量</strong>：java.util.concurrent.locks包下包含了同步器的框架 AbstractQueuedSynchronizer，基于AQS构建的Lock以及与Lock配合可以实现等待/通知模式的Condition。</p></li><li><p><strong>线程池</strong>：涉及到的类比如：Executor、Executors、ThreadPoolExector、 AbstractExecutorService、Future、Callable、ScheduledThreadPoolExecutor等等。</p></li><li><p><strong>阻塞队列</strong>：涉及到的类比如：ArrayBlockingQueue、LinkedBlockingQueue、PriorityBlockingQueue、LinkedBlockingDeque等等。</p></li><li><p><strong>并发容器</strong>：涉及到的类比如：ConcurrentHashMap、CopyOnWriteArrayList、ConcurrentLinkedQueue、BlockingQueue等等。</p></li><li><p><strong>同步器</strong>：剩下的是一些在并发编程中时常会用到的工具类，主要用来协助线程同步。比如：CountDownLatch、CyclicBarrier、Exchanger、Semaphore、FutureTask等等。</p></li></ol><h3 id="并发编程三个重要特性是什么"><a href="#并发编程三个重要特性是什么" class="headerlink" title="并发编程三个重要特性是什么"></a>并发编程三个重要特性是什么</h3><p><strong>原子性</strong>：一次操作或者多次操作，要么所有的操作全部都得到执行并且不会受到任何因素的干扰而中断，要么都不执行。</p><p><strong>可见性</strong>：当一个线程对共享变量进行了修改，那么另外的线程都是立即可以看到修改后的最新值。</p><p><strong>有序性</strong>：由于指令重排序问题，代码的执行顺序未必就是编写代码时候的顺序。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
            <tag> 多线程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合_ArrayList源码&amp;扩容机制</title>
      <link href="/2022/11/10/java-ji-he-arraylist-yuan-ma-kuo-rong-ji-zhi/"/>
      <url>/2022/11/10/java-ji-he-arraylist-yuan-ma-kuo-rong-ji-zhi/</url>
      
        <content type="html"><![CDATA[<h3 id="ArrayList-简介"><a href="#ArrayList-简介" class="headerlink" title="ArrayList 简介"></a>ArrayList 简介</h3><p><code>ArrayList</code> 的底层是数组队列，相当于动态数组。与 Java 中的数组相比，它的容量能动态增长。在添加大量元素前，应用程序可以使用<code>ensureCapacity</code>操作来增加 <code>ArrayList</code> 实例的容量。这可以减少递增式再分配的数量。</p><p><code>ArrayList</code>继承于&nbsp;<strong><code>AbstractList</code></strong>&nbsp;，实现了&nbsp;<strong><code>List</code></strong>,&nbsp;<strong><code>RandomAccess</code></strong>,&nbsp;<strong><code>Cloneable</code></strong>,&nbsp;<strong><code>java.io.Serializable</code></strong>&nbsp;这些接口。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><ul><li>  <code>RandomAccess</code> 是一个标志接口，表明实现这个接口的 List 集合是支持<strong>快速随机访问</strong>的。在 <code>ArrayList</code> 中，我们即可以通过元素的序号快速获取元素对象，这就是快速随机访问。</li><li>  <code>ArrayList</code> 实现了 <strong><code>Cloneable</code> 接口</strong> ，即覆盖了函数<code>clone()</code>，能被克隆。</li><li>  <code>ArrayList</code> 实现了 <code>java.io.Serializable</code>接口，这意味着<code>ArrayList</code>支持序列化，能通过序列化去传输。</li></ul><h3 id="ArrayList-核心源码解读"><a href="#ArrayList-核心源码解读" class="headerlink" title="ArrayList 核心源码解读"></a>ArrayList 核心源码解读</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">package</span> <span class="token namespace">java<span class="token punctuation">.</span>util</span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span></span><span class="token class-name">Consumer</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span></span><span class="token class-name">Predicate</span></span><span class="token punctuation">;</span><span class="token keyword">import</span> <span class="token import"><span class="token namespace">java<span class="token punctuation">.</span>util<span class="token punctuation">.</span>function<span class="token punctuation">.</span></span><span class="token class-name">UnaryOperator</span></span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token keyword">extends</span> <span class="token class-name">AbstractList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span>        <span class="token keyword">implements</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">,</span> <span class="token class-name">RandomAccess</span><span class="token punctuation">,</span> <span class="token class-name">Cloneable</span><span class="token punctuation">,</span> <span class="token class-name"><span class="token namespace">java<span class="token punctuation">.</span>io<span class="token punctuation">.</span></span>Serializable</span><span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">long</span> serialVersionUID <span class="token operator">=</span> <span class="token number">8683452581122892189L</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 默认初始容量大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_CAPACITY</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 空数组（用于空实例）。     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">EMPTY_ELEMENTDATA</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>     <span class="token comment">//用于默认大小空实例的共享空数组实例。</span>      <span class="token comment">//我们把它从EMPTY_ELEMENTDATA数组中区分出来，以知道在添加第一个元素时容量需要增加多少。</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>    <span class="token comment">/**     * 保存ArrayList数据的数组     */</span>    <span class="token keyword">transient</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> elementData<span class="token punctuation">;</span> <span class="token comment">// non-private to simplify nested class access</span>    <span class="token comment">/**     * ArrayList 所包含的元素个数     */</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>    <span class="token comment">/**     * 带初始容量参数的构造函数（用户可以在创建ArrayList对象时自己指定集合的初始大小）     */</span>    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//如果传入的参数大于0，创建initialCapacity大小的数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">//如果传入的参数等于0，创建空数组</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">//其他情况，抛出异常</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                               initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     *默认无参构造函数     *DEFAULTCAPACITY_EMPTY_ELEMENTDATA 为0.初始化为10，也就是说初始其实是空数组 当添加第一个元素的时候数组容量才变成10     */</span>    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 构造一个包含指定集合的元素的列表，按照它们由集合的迭代器返回的顺序。     */</span>    <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//将指定集合转换为数组</span>        elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果elementData数组的长度不为0</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 如果elementData不是Object类型数据（c.toArray可能返回的不是Object类型的数组所以加上下面的语句用于判断）</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>                <span class="token comment">//将原来不是Object类型的elementData数组的内容，赋值给新的Object类型的elementData数组</span>                elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token comment">// 其他情况，用空数组代替</span>            <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 修改这个ArrayList实例的容量是列表的当前大小。 应用程序可以使用此操作来最小化ArrayList实例的存储。     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">trimToSize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>size <span class="token operator">&lt;</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>            elementData <span class="token operator">=</span> <span class="token punctuation">(</span>size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>              <span class="token operator">?</span> <span class="token constant">EMPTY_ELEMENTDATA</span>              <span class="token operator">:</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span class="token comment">//下面是ArrayList的扩容机制</span><span class="token comment">//ArrayList的扩容机制提高了性能，如果每次只扩充一个，</span><span class="token comment">//那么频繁的插入会导致频繁的拷贝，降低性能，而ArrayList的扩容机制避免了这种情况。</span>    <span class="token comment">/**     * 如有必要，增加此ArrayList实例的容量，以确保它至少能容纳元素的数量     * @param   minCapacity   所需的最小容量     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//如果是true，minExpand的值为0，如果是false,minExpand的值为10</span>        <span class="token keyword">int</span> minExpand <span class="token operator">=</span> <span class="token punctuation">(</span>elementData <span class="token operator">!=</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">)</span>            <span class="token comment">// any size if not default element table</span>            <span class="token operator">?</span> <span class="token number">0</span>            <span class="token comment">// larger than default for default empty table. It's already</span>            <span class="token comment">// supposed to be at default size.</span>            <span class="token operator">:</span> <span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">;</span>        <span class="token comment">//如果最小容量大于已有的最大容量</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&gt;</span> minExpand<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>   <span class="token comment">//1.得到最小扩容量</span>   <span class="token comment">//2.通过最小容量扩容</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment">// 获取“默认的容量”和“传入参数”两者之间的最大值</span>            minCapacity <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>  <span class="token comment">//判断是否需要扩容</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">// overflow-conscious code</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>            <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 要分配的最大数组大小     */</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span>    <span class="token comment">/**     * ArrayList扩容的核心方法。     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">// oldCapacity为旧容量，newCapacity为新容量</span>        <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>        <span class="token comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>        <span class="token comment">//再检查新容量是否超出了ArrayList所定义的最大容量，</span>        <span class="token comment">//若超出了，则调用hugeCapacity()来比较minCapacity和 MAX_ARRAY_SIZE，</span>        <span class="token comment">//如果minCapacity大于MAX_ARRAY_SIZE，则新容量则为Interger.MAX_VALUE，否则，新容量大小则为 MAX_ARRAY_SIZE。</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// minCapacity is usually close to size, so this is a win:</span>        elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//比较minCapacity和 MAX_ARRAY_SIZE</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&gt;</span> <span class="token constant">MAX_ARRAY_SIZE</span><span class="token punctuation">)</span> <span class="token operator">?</span>            <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">:</span>            <span class="token constant">MAX_ARRAY_SIZE</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     *返回此列表中的元素数。     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 如果此列表不包含元素，则返回 true 。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//注意=和==的区别</span>        <span class="token keyword">return</span> size <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 如果此列表包含指定的元素，则返回true 。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">contains</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//indexOf()方法：返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1</span>        <span class="token keyword">return</span> <span class="token function">indexOf</span><span class="token punctuation">(</span>o<span class="token punctuation">)</span> <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     *返回此列表中指定元素的首次出现的索引，如果此列表不包含此元素，则为-1     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">indexOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token comment">//equals()方法比较</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 返回此列表中指定元素的最后一次出现的索引，如果此列表不包含元素，则返回-1。.     */</span>    <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">lastIndexOf</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> size<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">--</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>                    <span class="token keyword">return</span> i<span class="token punctuation">;</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 返回此ArrayList实例的浅拷贝。 （元素本身不被复制。）     */</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">try</span> <span class="token punctuation">{</span>            <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> v <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">)</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//Arrays.copyOf功能是实现数组的复制，返回复制后的数组。参数是被复制的数组和复制的长度</span>            v<span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>            v<span class="token punctuation">.</span>modCount <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>            <span class="token keyword">return</span> v<span class="token punctuation">;</span>        <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">CloneNotSupportedException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token comment">// 这不应该发生，因为我们是可以克隆的</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">InternalError</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     *以正确的顺序（从第一个到最后一个元素）返回一个包含此列表中所有元素的数组。     *返回的数组将是“安全的”，因为该列表不保留对它的引用。 （换句话说，这个方法必须分配一个新的数组）。     *因此，调用者可以自由地修改返回的数组。 此方法充当基于阵列和基于集合的API之间的桥梁。     */</span>    <span class="token keyword">public</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 以正确的顺序返回一个包含此列表中所有元素的数组（从第一个到最后一个元素）;     *返回的数组的运行时类型是指定数组的运行时类型。 如果列表适合指定的数组，则返回其中。     *否则，将为指定数组的运行时类型和此列表的大小分配一个新数组。     *如果列表适用于指定的数组，其余空间（即数组的列表数量多于此元素），则紧跟在集合结束后的数组中的元素设置为null 。     *（这仅在调用者知道列表不包含任何空元素的情况下才能确定列表的长度。）     */</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token keyword">public</span> <span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span><span class="token punctuation">&gt;</span></span> <span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">toArray</span><span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&lt;</span> size<span class="token punctuation">)</span>            <span class="token comment">// 新建一个运行时类型的数组，但是ArrayList数组的内容</span>            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">T</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> a<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token comment">//调用System提供的arraycopy()方法实现数组之间的复制</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> size<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>a<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> size<span class="token punctuation">)</span>            a<span class="token punctuation">[</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> a<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">// Positional Access Operations</span>    <span class="token annotation punctuation">@SuppressWarnings</span><span class="token punctuation">(</span><span class="token string">"unchecked"</span><span class="token punctuation">)</span>    <span class="token class-name">E</span> <span class="token function">elementData</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token class-name">E</span><span class="token punctuation">)</span> elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 返回此列表中指定位置的元素。     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 用指定的元素替换此列表中指定位置的元素。     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">set</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//对index进行界限检查</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        <span class="token comment">//返回原来在这个位置的元素</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 将指定的元素追加到此列表的末尾。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>        <span class="token comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>        elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 在此列表中的指定位置插入指定的元素。     *先调用 rangeCheckForAdd 对index进行界限检查；然后调用 ensureCapacityInternal 方法保证capacity足够大；     *再将从index开始之后的所有成员后移一个位置；将element插入index位置；最后size加1。     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">E</span> element<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>        <span class="token comment">//arraycopy()这个实现数组之间复制的方法一定要看一下，下面就用到了arraycopy()方法实现数组自己复制自己</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span>                         size <span class="token operator">-</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">=</span> element<span class="token punctuation">;</span>        size<span class="token operator">++</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 删除该列表中指定位置的元素。 将任何后续元素移动到左侧（从其索引中减去一个元素）。     */</span>    <span class="token keyword">public</span> <span class="token class-name">E</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheck</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token class-name">E</span> oldValue <span class="token operator">=</span> <span class="token function">elementData</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// clear to let GC do its work</span>      <span class="token comment">//从列表中删除的元素</span>        <span class="token keyword">return</span> oldValue<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 从列表中删除指定元素的第一个出现（如果存在）。 如果列表不包含该元素，则它不会更改。     *返回true，如果此列表包含指定的元素     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">remove</span><span class="token punctuation">(</span><span class="token class-name">Object</span> o<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>o <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span>                <span class="token keyword">if</span> <span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>elementData<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                    <span class="token function">fastRemove</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>                    <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>                <span class="token punctuation">}</span>        <span class="token punctuation">}</span>        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/*     * Private remove method that skips bounds checking and does not     * return the value removed.     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">fastRemove</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        elementData<span class="token punctuation">[</span><span class="token operator">--</span>size<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span> <span class="token comment">// clear to let GC do its work</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 从列表中删除所有元素。     */</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">clear</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token comment">// 把数组中所有的元素的值设为null</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span>            elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 按指定集合的Iterator返回的顺序将指定集合中的所有元素追加到此列表的末尾。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>        size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>        <span class="token keyword">return</span> numNew <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 将指定集合中的所有元素插入到此列表中，从指定的位置开始。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">addAll</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">,</span> <span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> a <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numNew <span class="token operator">=</span> a<span class="token punctuation">.</span>length<span class="token punctuation">;</span>        <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> index<span class="token punctuation">;</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>numMoved <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index <span class="token operator">+</span> numNew<span class="token punctuation">,</span>                             numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> index<span class="token punctuation">,</span> numNew<span class="token punctuation">)</span><span class="token punctuation">;</span>        size <span class="token operator">+=</span> numNew<span class="token punctuation">;</span>        <span class="token keyword">return</span> numNew <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 从此列表中删除所有索引为fromIndex （含）和toIndex之间的元素。     *将任何后续元素移动到左侧（减少其索引）。     */</span>    <span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">removeRange</span><span class="token punctuation">(</span><span class="token keyword">int</span> fromIndex<span class="token punctuation">,</span> <span class="token keyword">int</span> toIndex<span class="token punctuation">)</span> <span class="token punctuation">{</span>        modCount<span class="token operator">++</span><span class="token punctuation">;</span>        <span class="token keyword">int</span> numMoved <span class="token operator">=</span> size <span class="token operator">-</span> toIndex<span class="token punctuation">;</span>        <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> toIndex<span class="token punctuation">,</span> elementData<span class="token punctuation">,</span> fromIndex<span class="token punctuation">,</span>                         numMoved<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// clear to let GC do its work</span>        <span class="token keyword">int</span> newSize <span class="token operator">=</span> size <span class="token operator">-</span> <span class="token punctuation">(</span>toIndex<span class="token operator">-</span>fromIndex<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> newSize<span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            elementData<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        size <span class="token operator">=</span> newSize<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 检查给定的索引是否在范围内。     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rangeCheck</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;=</span> size<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * add和addAll使用的rangeCheck的一个版本     */</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">rangeCheckForAdd</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&gt;</span> size <span class="token operator">||</span> index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 返回IndexOutOfBoundsException细节信息     */</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> <span class="token function">outOfBoundsMsg</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token string">"Index: "</span><span class="token operator">+</span>index<span class="token operator">+</span><span class="token string">", Size: "</span><span class="token operator">+</span>size<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 从此列表中删除指定集合中包含的所有元素。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">removeAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">//如果此列表被修改则返回true</span>        <span class="token keyword">return</span> <span class="token function">batchRemove</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 仅保留此列表中包含在指定集合中的元素。     *换句话说，从此列表中删除其中不包含在指定集合中的所有元素。     */</span>    <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">retainAll</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token class-name">Objects</span><span class="token punctuation">.</span><span class="token function">requireNonNull</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token function">batchRemove</span><span class="token punctuation">(</span>c<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     * 从列表中的指定位置开始，返回列表中的元素（按正确顺序）的列表迭代器。     *指定的索引表示初始调用将返回的第一个元素为next 。 初始调用previous将返回指定索引减1的元素。     *返回的列表迭代器是fail-fast 。     */</span>    <span class="token keyword">public</span> <span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token keyword">int</span> index<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span> <span class="token operator">||</span> index <span class="token operator">&gt;</span> size<span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IndexOutOfBoundsException</span><span class="token punctuation">(</span><span class="token string">"Index: "</span><span class="token operator">+</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ListItr</span><span class="token punctuation">(</span>index<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     *返回列表中的列表迭代器（按适当的顺序）。     *返回的列表迭代器是fail-fast 。     */</span>    <span class="token keyword">public</span> <span class="token class-name">ListIterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">listIterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">ListItr</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">/**     *以正确的顺序返回该列表中的元素的迭代器。     *返回的迭代器是fail-fast 。     */</span>    <span class="token keyword">public</span> <span class="token class-name">Iterator</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> <span class="token function">iterator</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Itr</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="ArrayList-扩容机制分析"><a href="#ArrayList-扩容机制分析" class="headerlink" title="ArrayList 扩容机制分析"></a>ArrayList 扩容机制分析</h3><h4 id="ArrayList-的构造函数"><a href="#ArrayList-的构造函数" class="headerlink" title="ArrayList 的构造函数"></a>ArrayList 的构造函数</h4><p><strong>（JDK8）ArrayList 有三种方式来初始化，构造方法源码如下：</strong></p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**  * 默认初始容量大小  */</span> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">DEFAULT_CAPACITY</span> <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span> <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span> <span class="token comment">/**  *默认构造函数，使用初始容量10构造一个空列表(无参数构造)  */</span> <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span> <span class="token punctuation">}</span> <span class="token comment">/**  * 带初始容量参数的构造函数。（用户自己指定容量）  */</span> <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//初始容量大于0</span>         <span class="token comment">//创建initialCapacity大小的数组</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Object</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//初始容量等于0</span>         <span class="token comment">//创建空数组</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span><span class="token comment">//初始容量小于0，抛出异常</span>         <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Illegal Capacity: "</span><span class="token operator">+</span>                                            initialCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span> <span class="token comment">/** *构造包含指定collection元素的列表，这些元素利用该集合的迭代器按顺序返回 *如果指定的集合为null，throws NullPointerException。 */</span>  <span class="token keyword">public</span> <span class="token class-name">ArrayList</span><span class="token punctuation">(</span><span class="token class-name">Collection</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">E</span><span class="token punctuation">&gt;</span></span> c<span class="token punctuation">)</span> <span class="token punctuation">{</span>     elementData <span class="token operator">=</span> c<span class="token punctuation">.</span><span class="token function">toArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token punctuation">(</span>size <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>         <span class="token comment">// c.toArray might (incorrectly) not return Object[] (see 6260652)</span>         <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData<span class="token punctuation">.</span><span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span>             elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> size<span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>         <span class="token comment">// replace with empty array.</span>         <span class="token keyword">this</span><span class="token punctuation">.</span>elementData <span class="token operator">=</span> <span class="token constant">EMPTY_ELEMENTDATA</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>以无参数构造方法创建&nbsp;<code>ArrayList</code>&nbsp;时，实际上初始化赋值的是一个空数组。当真正对数组进行添加元素操作时，才真正分配容量。即向数组中添加第一个元素时，数组容量扩为 10。</strong></p><p>以无参构造函数创建的 ArrayList 为例分析</p><h4 id="add-方法"><a href="#add-方法" class="headerlink" title="add()方法"></a>add()方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"> <span class="token comment">/**  * 将指定的元素追加到此列表的末尾。  */</span> <span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token class-name">E</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token comment">//添加元素之前，先调用ensureCapacityInternal方法</span>     <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span>size <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// Increments modCount!!</span>     <span class="token comment">//这里看到ArrayList添加元素的实质就相当于为数组赋值</span>     elementData<span class="token punctuation">[</span>size<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> e<span class="token punctuation">;</span>     <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="ensureCapacityInternal-size-1"><a href="#ensureCapacityInternal-size-1" class="headerlink" title="ensureCapacityInternal(size + 1)"></a>ensureCapacityInternal(size + 1)</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//得到最小扩容量</span> <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacityInternal</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>     <span class="token keyword">if</span> <span class="token punctuation">(</span>elementData <span class="token operator">==</span> <span class="token constant">DEFAULTCAPACITY_EMPTY_ELEMENTDATA</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>           <span class="token comment">// 获取默认的容量和传入参数的较大值</span>         minCapacity <span class="token operator">=</span> <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">max</span><span class="token punctuation">(</span><span class="token constant">DEFAULT_CAPACITY</span><span class="token punctuation">,</span> minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>     <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>当 要 add 进第 1 个元素时，minCapacity 为 1，在 Math.max()方法比较后，minCapacity 为 10。</strong></p><h4 id="ensureExplicitCapacity-方法"><a href="#ensureExplicitCapacity-方法" class="headerlink" title="ensureExplicitCapacity()方法"></a>ensureExplicitCapacity()方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//判断是否需要扩容</span>  <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureExplicitCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>      modCount<span class="token operator">++</span><span class="token punctuation">;</span>      <span class="token comment">// overflow-conscious code</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">-</span> elementData<span class="token punctuation">.</span>length <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>          <span class="token comment">//调用grow方法进行扩容，调用此方法代表已经开始扩容了</span>          <span class="token function">grow</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ul><li>  当我们要 add 进第 1 个元素到 ArrayList 时，elementData.length 为 0 （因为还是一个空的 list），因为执行了 <code>ensureCapacityInternal()</code> 方法 ，所以 minCapacity 此时为 10。此时，<code>minCapacity - elementData.length &gt; 0</code>成立，所以会进入 <code>grow(minCapacity)</code> 方法。</li><li>  当 add 第 2 个元素时，minCapacity 为 2，此时 e lementData.length(容量)在添加第一个元素后扩容成 10 了。此时，<code>minCapacity - elementData.length &gt; 0</code> 不成立，所以不会进入 （执行）<code>grow(minCapacity)</code> 方法。</li><li>  添加第 3、4···到第 10 个元素时，依然不会执行 grow 方法，数组容量都为 10。</li></ul><p>直到添加第 11 个元素，minCapacity(为 11)比 elementData.length（为 10）要大。进入 grow 方法进行扩容。</p><h4 id="grow-方法"><a href="#grow-方法" class="headerlink" title="grow ()方法"></a>grow ()方法</h4><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * 要分配的最大数组大小 */</span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">=</span> <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">-</span> <span class="token number">8</span><span class="token punctuation">;</span><span class="token comment">/** * ArrayList扩容的核心方法。 */</span><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">grow</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token comment">// oldCapacity为旧容量，newCapacity为新容量</span>    <span class="token keyword">int</span> oldCapacity <span class="token operator">=</span> elementData<span class="token punctuation">.</span>length<span class="token punctuation">;</span>    <span class="token comment">//将oldCapacity 右移一位，其效果相当于oldCapacity /2，</span>    <span class="token comment">//我们知道位运算的速度远远快于整除运算，整句运算式的结果就是将新容量更新为旧容量的1.5倍，</span>    <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> oldCapacity <span class="token operator">+</span> <span class="token punctuation">(</span>oldCapacity <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//然后检查新容量是否大于最小需要容量，若还是小于最小需要容量，那么就把最小需要容量当作数组的新容量，</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> minCapacity<span class="token punctuation">;</span>   <span class="token comment">// 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) `hugeCapacity()` 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，</span>   <span class="token comment">//如果minCapacity大于最大容量，则新容量则为`Integer.MAX_VALUE`，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 `Integer.MAX_VALUE - 8`。</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>newCapacity <span class="token operator">-</span> <span class="token constant">MAX_ARRAY_SIZE</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span>        newCapacity <span class="token operator">=</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span>minCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">// minCapacity is usually close to size, so this is a win:</span>    elementData <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>elementData<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1),所以 ArrayList 每次扩容之后容量都会变为原来的 1.5 倍左右（oldCapacity 为偶数就是 1.5 倍，否则是 1.5 倍左右）！</strong> 奇偶不同，比如 ：10+10/2 = 15, 33+33/2=49。如果是奇数的话会丢掉小数.</p><p><strong><code>grow()</code> 方法 ：</strong></p><ul><li>  当 add 第 1 个元素时，oldCapacity 为 0，经比较后第一个 if 判断成立，newCapacity = minCapacity(为 10)。但是第二个 if 判断不会成立，即 newCapacity 不比 MAX_ARRAY_SIZE 大，则不会进入 <code>hugeCapacity</code> 方法。数组容量为 10，add 方法中 return true,size 增为 1。</li><li>  当 add 第 11 个元素进入 grow 方法时，newCapacity 为 15，比 minCapacity（为 11）大，第一个 if 判断不成立。新容量没有大于数组最大 size，不会进入 hugeCapacity 方法。数组容量扩为 15，add 方法中 return true,size 增为 11。</li><li>  以此类推······</li></ul><h4 id="hugeCapacity-方法"><a href="#hugeCapacity-方法" class="headerlink" title="hugeCapacity() 方法"></a>hugeCapacity() 方法</h4><p>从上面 <code>grow()</code> 方法源码我们知道： 如果新容量大于 MAX_ARRAY_SIZE,进入(执行) <code>hugeCapacity()</code> 方法来比较 minCapacity 和 MAX_ARRAY_SIZE，如果 minCapacity 大于最大容量，则新容量则为<code>Integer.MAX_VALUE</code>，否则，新容量大小则为 MAX_ARRAY_SIZE 即为 <code>Integer.MAX_VALUE - 8</code>。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">int</span> <span class="token function">hugeCapacity</span><span class="token punctuation">(</span><span class="token keyword">int</span> minCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token comment">// overflow</span>        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">OutOfMemoryError</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token comment">//对minCapacity和MAX_ARRAY_SIZE进行比较</span>    <span class="token comment">//若minCapacity大，将Integer.MAX_VALUE作为新数组的大小</span>    <span class="token comment">//若MAX_ARRAY_SIZE大，将MAX_ARRAY_SIZE作为新数组的大小</span>    <span class="token comment">//MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8;</span>    <span class="token keyword">return</span> <span class="token punctuation">(</span>minCapacity <span class="token operator">&gt;</span> <span class="token constant">MAX_ARRAY_SIZE</span><span class="token punctuation">)</span> <span class="token operator">?</span>        <span class="token class-name">Integer</span><span class="token punctuation">.</span><span class="token constant">MAX_VALUE</span> <span class="token operator">:</span>        <span class="token constant">MAX_ARRAY_SIZE</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="System-arraycopy-和Arrays-copyOf-方法"><a href="#System-arraycopy-和Arrays-copyOf-方法" class="headerlink" title="System.arraycopy()和Arrays.copyOf()方法"></a>System.arraycopy()和Arrays.copyOf()方法</h4><p>阅读源码的话，我们就会发现 ArrayList 中大量调用了这两个方法。比如：我们上面讲的扩容操作以及<code>add(int index, E element)</code>、<code>toArray()</code> 等方法中都用到了该方法！</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 我们发现 arraycopy 是一个 native 方法,接下来我们解释一下各个参数的具体意义</span><span class="token comment">/***   复制数组* @param src 源数组* @param srcPos 源数组中的起始位置* @param dest 目标数组* @param destPos 目标数组中的起始位置* @param length 要复制的数组元素的数量*/</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">arraycopy</span><span class="token punctuation">(</span><span class="token class-name">Object</span> src<span class="token punctuation">,</span>  <span class="token keyword">int</span>  srcPos<span class="token punctuation">,</span>                                    <span class="token class-name">Object</span> dest<span class="token punctuation">,</span> <span class="token keyword">int</span> destPos<span class="token punctuation">,</span>                                    <span class="token keyword">int</span> length<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-java" data-language="java"><code class="language-java">    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token function">copyOf</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> original<span class="token punctuation">,</span> <span class="token keyword">int</span> newLength<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">// 申请一个新的数组</span>       <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> copy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>newLength<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// 调用System.arraycopy,将源数组中的数据进行拷贝,并返回新的数组</span>       <span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">arraycopy</span><span class="token punctuation">(</span>original<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> copy<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span>                        <span class="token class-name">Math</span><span class="token punctuation">.</span><span class="token function">min</span><span class="token punctuation">(</span>original<span class="token punctuation">.</span>length<span class="token punctuation">,</span> newLength<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>       <span class="token keyword">return</span> copy<span class="token punctuation">;</span>   <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>联系：</strong></p><p>看两者源代码可以发现 <code>copyOf()</code>内部实际调用了 <code>System.arraycopy()</code> 方法</p><p><strong>区别：</strong></p><p><code>arraycopy()</code> 需要目标数组，将原数组拷贝到你自己定义的数组里或者原数组，而且可以选择拷贝的起点和长度以及放入新数组中的位置 <code>copyOf()</code> 是系统自动在内部新建一个数组，并返回该数组。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合2(补档)</title>
      <link href="/2022/11/09/java-ji-he-2-bu-dang/"/>
      <url>/2022/11/09/java-ji-he-2-bu-dang/</url>
      
        <content type="html"><![CDATA[<h2 id="HashMap"><a href="#HashMap" class="headerlink" title="HashMap"></a>HashMap</h2><h3 id="说说HashMap底层的实现原理"><a href="#说说HashMap底层的实现原理" class="headerlink" title="说说HashMap底层的实现原理"></a>说说HashMap底层的实现原理</h3><p>HashMap是Java中的一个哈希表实现，用于存储键值对（key-value）数据。它是基于哈希算法实现的，可以快速进行插入、删除和查找操作。</p><p>HashMap的核心思想是将键通过哈希函数转换为数组的下标，然后将值存储在该下标位置上</p><h4 id="JDK7和JDK8中HashMap的区别"><a href="#JDK7和JDK8中HashMap的区别" class="headerlink" title="JDK7和JDK8中HashMap的区别"></a>JDK7和JDK8中HashMap的区别</h4><ul><li>JDK7中的HashMap，是基于数组+链表来实现的，它的底层维护一个Entry数组。</li><li>JDK8中的HashMap，是基于数组+链表+红黑树来实现的，它的底层维护一个Node数组</li></ul><p>当链表上的元素个数超过 8 个并且数组长度 &gt;= 64 时自动转化成红黑树，节点变成树节点，以提高搜索效率和插入效率到 O(logN)</p><h4 id="Map-put的过程"><a href="#Map-put的过程" class="headerlink" title="Map put的过程"></a>Map put的过程</h4><ol><li>首次扩容： 先判断数组是否为空，若数组为空则进行第一次扩容（resize）；</li><li>计算索引： 对key的hashCode()做hash运算，计算数组中的index；</li><li>插入数据：<ul><li>如果当前位置元素为空，则直接插入数据；</li><li>如果当前位置元素非空，且key已存在，则直接覆盖其value；</li><li>如果当前位置元素非空，且key不存在，则将数据链到链表末端；</li><li>若链表长度达到8，则将链表转换成红黑树，并将数据插入树中；</li></ul></li><li>再次扩容 如果数组中元素个数（size）超过threshold，则再次进行扩容操作。</li></ol><h4 id="Map-get的过程"><a href="#Map-get的过程" class="headerlink" title="Map get的过程"></a>Map get的过程</h4><ul><li><p>1.对key的hashCode()做hash运算，计算index;  </p></li><li><p>2.如果在bucket⾥的第⼀个节点⾥直接命中，则直接返回；</p></li><li><p>3.如果有冲突，则通过key.equals(k)去查找对应的Entry;</p></li><li><p>4.若为树，则在树中通过key.equals(k)查找，O(logn);</p></li><li><p>5.若为链表，则在链表中通过key.equals(k)查找，O(n)。</p></li></ul><h4 id="HashMap的扩容机制"><a href="#HashMap的扩容机制" class="headerlink" title="HashMap的扩容机制"></a>HashMap的扩容机制</h4><p>一些关键的值：</p><ul><li>  <code>DEFAULT_INITIAL_CAPACITY</code>&nbsp;Table数组的初始化长度：&nbsp;16</li><li>  <code>DEFAULT_LOAD_FACTOR</code>&nbsp;负载因子：默认值为<code>0.75</code>。 当元素的总个数&gt;当前数组的长度 * 负载因子。数组会进行扩容，扩容为原来的两倍</li><li>  <code>TREEIFY_THRESHOLD</code>&nbsp;链表树化阙值： 默认值为&nbsp;<code>8</code>&nbsp;。</li><li>  <code>UNTREEIFY_THRESHOLD</code>&nbsp;红黑树链化阈值： 默认值为&nbsp;<code>6</code>&nbsp;。 </li><li>  <code>MIN_TREEIFY_CAPACITY = 64</code>&nbsp;最小树化阈值，当Table所有元素超过改值，才会进行树化（为了防止前期阶段频繁扩容和树化过程冲突）。</li></ul><p>扩容过程：</p><ol><li> 数组的初始容量为16，而容量是以2的次方扩充的</li><li> 数组是否需要扩充是通过负载因子判断的，如果当前元素个数为数组容量的0.75时，就会扩充数组。</li><li> 为了解决碰撞，数组中的元素是单向链表类型。当链表长度到达一个阈值8，会将链表转换成红黑树提高性能。而当链表长度缩小到另一个阈值6时（防止频繁转换），又会将红黑树转换回单向链表提高性能。</li><li> 检查链表长度转换成红黑树之前，还会先检测当前数组是否到达一个阈值（64），如果没有到达这个容量，会放弃转换，先去扩充数组。</li></ol><p>扩容后的元素处理：</p><p>元素在重新计算hash之后，n变为2倍，那么n-1的mask范围在高位多1bit，因此新的index就会发生这样的变化：</p><p><img src="/images/image_Java%E9%9B%86%E5%90%88_01/06.png"></p><p>值新增的那个bit是0的，索引没变。是1，索引变成“原索引+oldCap”。</p><p>省去了重新计算hash值的时间，同时由于新增的1bit是0还是1可以认为是随机的，因此resize的过程，均匀的把之前的冲突的节点分散到新的bucket了。</p><h4 id="为什么使用链表-数组"><a href="#为什么使用链表-数组" class="headerlink" title="为什么使用链表+数组"></a>为什么使用链表+数组</h4><p>链表可以解决哈希冲突问题</p><p><strong>⽤LinkedList代替数组结构可以吗？</strong></p><p>在源码中</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Entry</span><span class="token punctuation">[</span><span class="token punctuation">]</span> table<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">Entry</span><span class="token punctuation">[</span>capacity<span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">// entry就是一个链表的节点</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><p>进行替换</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&gt;</span></span> table<span class="token operator">=</span><span class="token keyword">new</span> <span class="token class-name">LinkedList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Entry</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p>可以替换，但是数组效率最高。在HashMap中，定位节点的位置是利⽤元素的key的哈希值对数组⻓度取模得到。</p><p><strong>ArrayList，底层也是数组，查找也快，为什么不⽤ArrayList?</strong></p><p>因为采⽤基本数组结构，扩容机制可以⾃⼰定义，HashMap中数组扩容刚好是2的次幂，在做取模运算的效率⾼。 ⽽ArrayList的扩容机制是1.5倍扩容。</p><h4 id="为什么不一开始就使用红黑树"><a href="#为什么不一开始就使用红黑树" class="headerlink" title="为什么不一开始就使用红黑树"></a>为什么不一开始就使用红黑树</h4><p>因为红⿊树需要进⾏左旋，右旋，变⾊这些操作来保持平衡，⽽单链表不需要。<br>当元素⼩于8个当时候，此时做查询操作，链表结构已经能保证查询性能。<br>当元素⼤于8个的时候，此时需要红⿊树来加快查询速度，但是新增节点的效率变慢了。</p><p>因此，如果⼀开始就⽤红⿊树结构，元素太少，新增效率⼜⽐较慢，影响性能。</p><h4 id="HashMap为什么用红黑树而不用其他的树"><a href="#HashMap为什么用红黑树而不用其他的树" class="headerlink" title="HashMap为什么用红黑树而不用其他的树"></a>HashMap为什么用红黑树而不用其他的树</h4><p><strong>相比于B/B+树</strong></p><p>B/B+树多用于外存上时，B/B+也被成为一个磁盘友好的数据结构。</p><p>如果用B/B+树的话，在数据量不是很多的情况下，数据都会“挤在”一个结点里面，这个时候遍历效率就退化成了链表。</p><p><strong>相比于AVL树</strong></p><p>AVL树是一种高度平衡的二叉树，为了维持这种高度的平衡，每次插入、删除都要做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用AVL树的代价就有点高了。</p><p>红黑树相比avl树，在检索的时候效率其实差不多，都是通过平衡来二分查找。但对于插入删除等操作效率提高很多。红黑树不像avl树一样追求绝对的平衡，他<strong>允许局部很少的不完全平衡</strong>，这样对于效率影响不大，但<strong>省去了很多没有必要的调平衡操作</strong>，avl树调平衡有时候代价较大，所以效率不如红黑树。</p><h4 id="HashMap-多线程操作导致死循环问题"><a href="#HashMap-多线程操作导致死循环问题" class="headerlink" title="HashMap 多线程操作导致死循环问题"></a>HashMap 多线程操作导致死循环问题</h4><p>JDK7中对链表采用头插法（效率高一些），多个线程同时对链表进行操作，头插法可能会导致链表中的节点指向错误的位置，从而形成一个环形链表，进而使得查询元素的操作陷入死循环无法结束。</p><p>为了解决这个问题，JDK1.8采用了尾插法来避免链表倒置，使得插入的节点永远都是放在链表的末尾，避免了链表中的环形结构。</p><p>并且尾插法将遍历链表，获取链表元素个数，方便判断是否应该树化</p><p>不建议在多线程下使用 <code>HashMap</code>，因为多线程下使用 <code>HashMap</code> 还是会存在数据覆盖的问题。<br>并发环境下，推荐使用 <code>ConcurrentHashMap</code> 。</p><h4 id="HashMap-的-length-为什么是-2-的整数次方"><a href="#HashMap-的-length-为什么是-2-的整数次方" class="headerlink" title="HashMap 的 length 为什么是 2 的整数次方"></a>HashMap 的 length 为什么是 2 的整数次方</h4><ol><li>当 length 为 2 的 n 次方时，计算bucket位置时h &amp; (length – 1) 相当于对 length 取模，位运算效率高。</li><li>每次扩容时都是翻倍。</li><li>如果 length 为 2 的次幂，则 length – 1 转化为二进制必定是 11111……的形式，在与 h 的二进制进行与操作时<strong>效率会非常的快，而且空间不浪费</strong>。</li></ol><h3 id="一般用什么作为key值"><a href="#一般用什么作为key值" class="headerlink" title="一般用什么作为key值"></a>一般用什么作为key值</h3><p>⼀般⽤Integer、String。</p><p>String更好</p><ul><li>String是不可变的，所以在它创建的时候hashcode就被缓存了，不需要重新计算。 </li><li>String很规范的覆写了hashCode()以及equals()⽅法。</li></ul><h3 id="解决哈希冲突的方法有哪些"><a href="#解决哈希冲突的方法有哪些" class="headerlink" title="解决哈希冲突的方法有哪些"></a>解决哈希冲突的方法有哪些</h3><p><strong>开放定址法</strong>：我们在遇到哈希冲突时，去寻找一个新的空闲的哈希地址。</p><ul><li><strong>线性探测法</strong>：当我们的所需要存放值的位置被占了，我们就往后面一直加1并对m取模直到存在一个空余的地址供我们存放值。</li><li><strong>平方探测法</strong>：当我们的所需要存放值的位置被占了，会前后寻找。</li></ul><p><strong>再哈希法</strong>：同时构造多个不同的哈希函数，等发生哈希冲突时就使用第二个、第三个……等其他的哈希函数计算地址，直到不发生冲突为止。</p><p><strong>拉链法</strong>：将所有哈希地址相同的记录都链接在同一链表中。</p><h3 id="实现一个自定义的class作为Hashmap的key"><a href="#实现一个自定义的class作为Hashmap的key" class="headerlink" title="实现一个自定义的class作为Hashmap的key"></a>实现一个自定义的class作为Hashmap的key</h3><ol><li> 重写hashcode和equals方法</li><li> 设计一个不变的类</li></ol><h3 id="HashMap-常见的遍历方式有哪些"><a href="#HashMap-常见的遍历方式有哪些" class="headerlink" title="HashMap 常见的遍历方式有哪些"></a>HashMap 常见的遍历方式有哪些</h3><p>HashMap&nbsp;<strong>遍历从大的方向来说，可分为以下 4 类</strong>：</p><ol><li>迭代器（Iterator）方式遍历；</li><li>For Each 方式遍历；</li><li>Lambda 表达式遍历（JDK 1.8+）;</li><li>Streams API 遍历（JDK 1.8+）。</li></ol><p>每种类型下又有不同的实现方式，因此具体的遍历方式又可以分为以下 7 种：</p><ol><li>使用迭代器（Iterator）EntrySet 的方式进行遍历；</li><li>使用迭代器（Iterator）KeySet 的方式进行遍历；</li><li>使用 For Each EntrySet 的方式进行遍历；</li><li>使用 For Each KeySet 的方式进行遍历；</li><li>使用 Lambda 表达式的方式进行遍历；</li><li>使用 Streams API 单线程的方式进行遍历；</li><li>使用 Streams API 多线程的方式进行遍历。</li></ol><h3 id="HashMap和HashTable的区别是什么"><a href="#HashMap和HashTable的区别是什么" class="headerlink" title="HashMap和HashTable的区别是什么"></a>HashMap和HashTable的区别是什么</h3><ul><li>  <strong>线程是否安全：</strong> <code>HashMap</code> 是非线程安全的，<code>Hashtable</code> 是线程安全的,因为 <code>Hashtable</code> 内部的方法基本都经过<code>synchronized</code> 修饰。</li><li>  <strong>效率：</strong> 因为线程安全的问题，<code>HashMap</code> 要比 <code>Hashtable</code> 效率高一点。</li><li>  <strong>对 Null key 和 Null value 的支持：</strong> <code>HashMap</code> 可以存储 null 的 key 和 value，但 null 作为键只能有一个，null 作为值可以有多个；Hashtable 不允许有 null 键和 null 值</li><li>  <strong>初始容量大小和每次扩充容量大小的不同 ：</strong> <code>Hashtable</code> 默认的初始大小为 11，之后每次扩充，容量变为原来的 2n+1。<code>HashMap</code> 默认的初始化大小为 16。之后每次扩充，容量变为原来的 2 倍。</li><li>  <strong>底层数据结构：</strong> JDK1.8 以后的 <code>HashMap</code> 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为 8）时，将链表转化为红黑树，以减少搜索时间。<code>Hashtable</code> 没有这样的机制。</li></ul><h3 id="HashMap-和-HashSet-区别是什么"><a href="#HashMap-和-HashSet-区别是什么" class="headerlink" title="HashMap 和 HashSet 区别是什么"></a>HashMap 和 HashSet 区别是什么</h3><p><code>HashSet</code> 底层就是基于 <code>HashMap</code> 实现的。大部分方法是直接调用 <code>HashMap</code> 中的方法。</p><p>HashMap实现了Map接口，存储键值对。HashSet实现Set接口，存储对象。</p><h3 id="HashMap-和-TreeMap-区别"><a href="#HashMap-和-TreeMap-区别" class="headerlink" title="HashMap 和 TreeMap 区别"></a>HashMap 和 TreeMap 区别</h3><p><code>TreeMap</code> 和<code>HashMap</code> 都继承自<code>AbstractMap</code> 。</p><p>TreeMap基于红黑树实现，HashMap基于数组+链表+红黑树实现</p><p>TreeMap能对集合中的元素根据键排序，并且能对集合内元素搜索。</p><h3 id="LinkedHashMap的实现原理"><a href="#LinkedHashMap的实现原理" class="headerlink" title="LinkedHashMap的实现原理"></a>LinkedHashMap的实现原理</h3><p>LinkedHashMap继承于HashMap，LinkedHashMap很多方法直接继承自HashMap</p><p>它在HashMap的基础上，定义了一条双向链表，保持遍历顺序和插入顺序一致的问题。</p><h2 id="ConcurrentHashMap"><a href="#ConcurrentHashMap" class="headerlink" title="ConcurrentHashMap"></a>ConcurrentHashMap</h2><h3 id="说说ConcurrentHashMap的实现原理"><a href="#说说ConcurrentHashMap的实现原理" class="headerlink" title="说说ConcurrentHashMap的实现原理"></a>说说ConcurrentHashMap的实现原理</h3><p><strong>JDK 1.7中</strong></p><p>ConcurrentHashMap 是由 Segment 数据结构和 HashEntry 数组结构构成，采取分段锁来保证安全性。Segment 是 ReentrantLock 重入锁</p><p><img src="/images/image_Java%E9%9B%86%E5%90%88_02/05.png"></p><p>一个 <code>ConcurrentHashMap</code> 里包含一个 <code>Segment</code> 数组，<code>Segment</code> 的个数一旦<strong>初始化就不能改变</strong>。 <code>Segment</code> 数组的大小默认是 16，也就是说默认可以同时支持 16 个线程并发写。</p><p><code>Segment</code> 的结构和 <code>HashMap</code> 类似，是一种数组和链表结构，一个 <code>Segment</code> 包含一个 <code>HashEntry</code> 数组，每个 <code>Segment</code> 守护着一个 <code>HashEntry</code> 数组里的元素，当对 <code>HashEntry</code> 数组的数据进行修改时，必须首先获得对应的 <code>Segment</code> 的锁。</p><p>对同一 <code>Segment</code> 的并发写入会被阻塞，不同 <code>Segment</code> 的写入是可以并发执行的。</p><p><strong>JDK 1.8中</strong></p><p>JDK1.8 的实现已经摒弃了 Segment 的概念，而是直接用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 Synchronized 和 CAS 来操作</p><p><img src="/images/image_Java%E9%9B%86%E5%90%88_02/06.png"></p><p>Java 8 中，锁粒度更细，<code>synchronized</code>&nbsp;只锁定当前链表或红黑二叉树的首节点</p><h3 id="Hashtable和ConcurrentHashMap的区别"><a href="#Hashtable和ConcurrentHashMap的区别" class="headerlink" title="Hashtable和ConcurrentHashMap的区别"></a>Hashtable和ConcurrentHashMap的区别</h3><ul><li>  <strong>底层数据结构：</strong> JDK1.7 的 <code>ConcurrentHashMap</code> 底层采用 <strong>分段的数组+链表</strong> 实现，JDK1.8 采用数组+链表/红黑二叉树。</li><li><strong>实现线程安全的方式（重要）：</strong><ul><li>  JDK1.7 ，<code>ConcurrentHashMap</code> 对整个桶数组进行了分割分段(<code>Segment</code>，分段锁)，每一把锁只锁容器其中一部分数据，多线程访问容器里不同数据段的数据，就不会存在锁竞争，提高并发访问率。</li><li>  JDK1.8 ，<code>ConcurrentHashMap</code> 已经摒弃了 <code>Segment</code> 的概念，而是直接用 <code>Node</code> 数组+链表+红黑树的数据结构来实现，并发控制使用 <code>synchronized</code> 和 CAS 来操作。</li><li>  <strong><code>Hashtable</code>(同一把锁)</strong> :使用 <code>synchronized</code> 对整张 Hash 表上锁来保证线程安全，效率低下。</li></ul></li></ul><h3 id="HashMap-与-ConcurrentHashMap-的区别是什么"><a href="#HashMap-与-ConcurrentHashMap-的区别是什么" class="headerlink" title="HashMap 与 ConcurrentHashMap 的区别是什么"></a>HashMap 与 ConcurrentHashMap 的区别是什么</h3><p>HashMap来自 java.util.HashMap包，ConcurrentHashMap来自java.util.concurrent包。</p><p>HashMap 不是线程安全的，而 ConcurrentHashMap 是线程安全的。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java集合1(补档)</title>
      <link href="/2022/11/03/java-ji-he-1-bu-dang/"/>
      <url>/2022/11/03/java-ji-he-1-bu-dang/</url>
      
        <content type="html"><![CDATA[<h2 id="集合概述"><a href="#集合概述" class="headerlink" title="集合概述"></a>集合概述</h2><h3 id="说说Java集合"><a href="#说说Java集合" class="headerlink" title="说说Java集合"></a>说说Java集合</h3><p>Java 集合， 也叫作容器，主要是由两大接口派生而来：一个是 <code>Collection</code>接口，主要用于存放单一元素；另一个是 <code>Map</code> 接口，主要用于存放键值对。对于<code>Collection</code> 接口，下面又有三个主要的子接口：<code>List</code>、<code>Set</code> 和 <code>Queue</code>。</p><ul><li>  Set代表无序的，元素不可重复的集合；</li><li>  List代表有序的，元素可以重复的集合；</li><li>  Queue代表先进先出（FIFO）的队列；</li><li>  Map代表具有映射关系的集合。使用键值对（key-value）存储</li></ul><p><img src="/images/image_Java%E9%9B%86%E5%90%88_01/16.png"></p><p>这些接口拥有众多的实现类，其中最常用的实现类有HashSet、TreeSet、ArrayList、LinkedList、ArrayDeque、HashMap、TreeMap等。</p><h3 id="集合框架底层数据结构"><a href="#集合框架底层数据结构" class="headerlink" title="集合框架底层数据结构"></a>集合框架底层数据结构</h3><p><strong>List</strong></p><ul><li><code>ArrayList</code>：<code>Object[]</code> 数组</li><li><code>Vector</code>：<code>Object[]</code> 数组</li><li><code>LinkedList</code>：双向链表</li></ul><p><strong>Set</strong></p><ul><li><code>HashSet</code>(无序，唯一): 基于 <code>HashMap</code> 实现</li><li><code>LinkedHashSet</code>: <code>LinkedHashSet</code> 是 <code>HashSet</code> 的子类，内部是通过 <code>LinkedHashMap</code> 来实现的。</li><li><code>TreeSet</code>(有序，唯一): 红黑树</li></ul><p><strong>Queue</strong></p><ul><li><code>PriorityQueue</code>: <code>Object[]</code> 数组来实现二叉堆</li><li><code>ArrayQueue</code>: <code>Object[]</code> 数组 + 双指针</li></ul><p><strong>Map</strong></p><ul><li><code>HashMap</code>：JDK1.8 之前 <code>HashMap</code> 由数组+链表组成。JDK1.8 后由数组+链表+红黑树组成</li><li><code>LinkedHashMap</code>：<code>LinkedHashMap</code> 继承自 <code>HashMap</code>，在上面HashMap结构的基础上，增加了一条<strong>双向链表</strong>，使得上面的结构可以保持键值对的插入顺序。</li><li><code>Hashtable</code>：数组+链表组成的</li><li><code>TreeMap</code>：红黑树</li></ul><h3 id="集合相比数组的优势有哪些"><a href="#集合相比数组的优势有哪些" class="headerlink" title="集合相比数组的优势有哪些"></a>集合相比数组的优势有哪些</h3><ul><li><p>Java 集合提供了更灵活、更有效的方法来存储多个数据对象。</p></li><li><p>各种集合类和接口可以存储不同类型和数量的对象，同时还具有多样化的操作方式。</p></li><li><p>Java 集合大小可变、支持泛型、具有内建算法等。</p></li></ul><h2 id="List"><a href="#List" class="headerlink" title="List"></a>List</h2><h3 id="ArrayList-和-Array（数组）的区别是什么"><a href="#ArrayList-和-Array（数组）的区别是什么" class="headerlink" title="ArrayList 和 Array（数组）的区别是什么"></a>ArrayList 和 Array（数组）的区别是什么</h3><p><code>ArrayList</code> 内部基于动态数组实现，比 <code>Array</code>（静态数组） 使用起来更加灵活：</p><ul><li><strong>扩容</strong>：<code>ArrayList</code>会根据实际存储的元素动态地扩容或缩容，而 <code>Array</code> 被创建之后就不能改变它的长度了。</li><li><strong>泛型支持</strong>：<code>ArrayList</code> 允许你使用泛型来确保类型安全，<code>Array</code> 则不可以。</li><li><strong>存储内容</strong>：<code>ArrayList</code> 中只能存储对象。对于基本类型数据，需要使用其对应的包装类。<code>Array</code> 可以直接存储基本类型数据，也可以存储对象。</li><li><strong>方法</strong>：<code>ArrayList</code> 支持插入、删除、遍历等常见操作，并且提供了丰富的 API 操作方法，比如 <code>add()</code>、<code>remove()</code>等。<code>Array</code> 只是一个固定长度的数组，只能按照下标访问其中的元素，不具备动态添加、删除元素的能力。</li></ul><h3 id="ArrayList-可以添加-null-值吗"><a href="#ArrayList-可以添加-null-值吗" class="headerlink" title="ArrayList 可以添加 null 值吗"></a>ArrayList 可以添加 null 值吗</h3><p><code>ArrayList</code> 中可以存储任何类型的对象，包括 <code>null</code> 值。</p><p>不建议向<code>ArrayList</code> 中添加 <code>null</code> 值， <code>null</code> 值无意义，会让代码难以维护(空指针异常)。</p><h3 id="ArrayList-插入和删除元素的时间复杂度"><a href="#ArrayList-插入和删除元素的时间复杂度" class="headerlink" title="ArrayList 插入和删除元素的时间复杂度"></a>ArrayList 插入和删除元素的时间复杂度</h3><p>对于插入：</p><ul><li>头部插入：由于需要将所有元素都依次向后移动一个位置，时间复杂度是 O(n)。</li><li>尾部插入：容量未达到极限时，往列表末尾插入元素的时间复杂度是 O(1)</li><li>指定位置插入：需要将目标位置之后的所有元素都向后移动一个位置，然后再把新元素放入指定位置。需要移动平均 n/2 个元素，因此时间复杂度为 O(n)。</li></ul><p>对于删除同理：</p><ul><li>头部删除：O(n)。</li><li>尾部删除：O(1)。</li><li>指定位置删除： O(n)。</li></ul><h3 id="LinkedList-插入和删除元素的时间复杂度"><a href="#LinkedList-插入和删除元素的时间复杂度" class="headerlink" title="LinkedList 插入和删除元素的时间复杂度"></a>LinkedList 插入和删除元素的时间复杂度</h3><ul><li>头部插入/删除：只需要修改头结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。</li><li>尾部插入/删除：只需要修改尾结点的指针即可完成插入/删除操作，因此时间复杂度为 O(1)。</li><li>指定位置插入/删除：需要先移动到指定位置，再修改指定节点的指针完成插入/删除，因此需要移动平均 n/2 个元素，时间复杂度为 O(n)。</li></ul><h3 id="ArrayList-实现-RandomAccess-接口有何作用？为何-LinkedList-却没实现这个接口？"><a href="#ArrayList-实现-RandomAccess-接口有何作用？为何-LinkedList-却没实现这个接口？" class="headerlink" title="ArrayList 实现 RandomAccess 接口有何作用？为何 LinkedList 却没实现这个接口？"></a>ArrayList 实现 RandomAccess 接口有何作用？为何 LinkedList 却没实现这个接口？</h3><p>RandomAccess 接口只是一个标志接口，只要 List 集合实现这个接口，就能支持快速随机访问。（通过下标快速访问元素）</p><p><code>LinkedList</code>&nbsp;底层数据结构是链表，内存地址不连续，只能通过指针来定位，不支持随机快速访问，所以不能实现&nbsp;<code>RandomAccess</code>&nbsp;接口。</p><p>另外：</p><p>实现 RandomAccess 接口的 List 集合采用一般的 for 循环遍历，而未实现这接口则采用迭代器，即 ArrayList 一般采用 for 循环遍历，而 LinkedList 一般采用迭代器遍历；</p><h3 id="ArrayList-与-LinkedList-区别是什么"><a href="#ArrayList-与-LinkedList-区别是什么" class="headerlink" title="ArrayList 与 LinkedList 区别是什么"></a>ArrayList 与 LinkedList 区别是什么</h3><ul><li><strong>是否保证线程安全：</strong> <code>ArrayList</code> 和 <code>LinkedList</code> 都是不同步的，也就是不保证线程安全；</li><li><strong>底层数据结构：</strong> <code>ArrayList</code> 底层使用的是 <strong><code>Object</code> 数组</strong>；<code>LinkedList</code> 底层使用的是 <strong>双向链表</strong> 数据结构</li><li><strong>插入和删除是否受元素位置的影响：</strong><ul><li><code>ArrayList</code> 采用数组存储，插入和删除元素的时间复杂度受元素位置的影响。</li><li><code>LinkedList</code> 采用链表存储，在头尾插入或者删除元素不受元素位置的影响，在指定位置 <code>i</code> 插入和删除元素的时间复杂度为 O(n) </li></ul></li><li><strong>是否支持快速随机访问：</strong> <code>LinkedList</code> 不支持高效的随机元素访问，而 <code>ArrayList</code> 支持。</li><li><strong>内存空间占用：</strong> <code>ArrayList</code> 在列表的结尾会预留一定的容量空间，而 LinkedList 的的每一个元素都需要消耗比 ArrayList 更多的空间。<h3 id="说说ArrayList-的扩容机制"><a href="#说说ArrayList-的扩容机制" class="headerlink" title="说说ArrayList 的扩容机制"></a>说说ArrayList 的扩容机制</h3></li></ul><ol><li>初始容量：ArrayList在创建时会分配一个初始容量，默认为10。可以通过构造函数或<code>ensureCapacity()</code>方法设置初始容量。（初始其实是空数组，当添加第一个元素的时候数组容量才变成10）</li><li>扩容策略：当向ArrayList中添加元素时，如果当前元素数量已达到容量上限，就会触发扩容操作。</li><li>增量扩容：默认情况下，ArrayList的扩容增量是当前容量的50%。扩容操作会将元素数据从旧数组复制到一个新的、更大容量的数组中。</li><li>使用System.arraycopy()方法：ArrayList使用<code>System.arraycopy()</code>方法来实现数组的复制。这个方法效率较高，能够快速地将旧数组中的元素复制到新数组中。</li></ol><h3 id="说说CopyOnWriteArrayList的原理"><a href="#说说CopyOnWriteArrayList的原理" class="headerlink" title="说说CopyOnWriteArrayList的原理"></a>说说CopyOnWriteArrayList的原理</h3><p>CopyOnWriteArrayList是Java并发包里提供的并发类，是一个线程安全且读操作无锁的ArrayList。</p><p>在写操作时会复制一份新的List，在新的List上完成写操作，然后再将原引用指向新的List。</p><p>在上锁执行写操作的过程中，如果有需要读操作，会作用在原容器上，因此上锁的写操作不会影响到并发访问的读操作。</p><ul><li><p>  优点：读操作性能很高，因为无需任何同步措施，比较适用于读多写少的并发场景。</p></li><li><p>  缺点：内存占用问题，可能会引起频繁GC。无法保证实时性，读到的可能是老数据</p><h3 id="ArrayList和Vector的区别是什么"><a href="#ArrayList和Vector的区别是什么" class="headerlink" title="ArrayList和Vector的区别是什么"></a>ArrayList和Vector的区别是什么</h3></li><li><p>  <code>ArrayList</code> 是 <code>List</code> 的主要实现类，底层使用 <code>Object[]</code>存储，线程不安全 ；</p></li><li><p>  <code>Vector</code> 是 <code>List</code> 的古老实现类，底层使用<code>Object[]</code> 存储，对读写操作上锁，线程安全。</p></li></ul><h2 id="Set"><a href="#Set" class="headerlink" title="Set"></a>Set</h2><h3 id="比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同"><a href="#比较-HashSet、LinkedHashSet-和-TreeSet-三者的异同" class="headerlink" title="比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同"></a>比较 HashSet、LinkedHashSet 和 TreeSet 三者的异同</h3><p>同：</p><ul><li><code>Set</code> 接口的实现类</li><li>能保证元素唯一</li><li>不是线程安全的</li></ul><p>不同：</p><ul><li><p>底层数据结构不同</p><ul><li><code>HashSet</code> 的底层数据结构是哈希表（基于 <code>HashMap</code> 实现）。</li><li><code>LinkedHashSet</code> 的底层数据结构是链表和哈希表，元素的插入和取出顺序满足 FIFO。</li><li><code>TreeSet</code> 底层数据结构是红黑树，元素是有序的，排序的方式有自然排序和定制排序。</li></ul></li><li><p>应用场景不同。</p><ul><li><code>HashSet</code> 用于不需要保证元素插入和取出顺序的场景</li><li><code>LinkedHashSet</code> 用于保证元素的插入和取出顺序满足 FIFO 的场景</li><li><code>TreeSet</code> 用于支持对元素自定义排序规则的场景。</li></ul></li></ul><h3 id="随机性、无序性和不可重复性是什么"><a href="#随机性、无序性和不可重复性是什么" class="headerlink" title="随机性、无序性和不可重复性是什么"></a>随机性、无序性和不可重复性是什么</h3><ul><li>随机性：存储的数据按照<strong>数组索引</strong>的顺序添加</li><li>无序性：存储的数据根据数据的<strong>哈希值</strong>决定的</li><li>不可重复性：添加的元素按照 <code>equals()</code> 判断时 ，返回 false，元素<strong>值不重复</strong></li></ul><h3 id="Comparable-和-Comparator-的区别是什么"><a href="#Comparable-和-Comparator-的区别是什么" class="headerlink" title="Comparable 和 Comparator 的区别是什么"></a>Comparable 和 Comparator 的区别是什么</h3><p><code>Comparable</code> 接口和 <code>Comparator</code> 接口都是 Java 中用于排序的接口</p><ul><li><code>Comparable</code> 接口实际上是出自<code>java.lang</code>包 它有一个 <code>compareTo(Object obj)</code>方法用来排序</li><li><code>Comparator</code>接口实际上是出自 <code>java.util</code> 包它有一个<code>compare(Object obj1, Object obj2)</code>方法用来排序</li></ul><p>需要对一个集合使用自定义排序时，就要重写<code>compareTo()</code>方法或<code>compare()</code>方法</p><h2 id="Queue"><a href="#Queue" class="headerlink" title="Queue"></a>Queue</h2><h3 id="Queue-与-Deque-的区别是什么"><a href="#Queue-与-Deque-的区别是什么" class="headerlink" title="Queue 与 Deque 的区别是什么"></a>Queue 与 Deque 的区别是什么</h3><p><code>Queue</code>&nbsp;是单端队列，只能从一端插入元素，另一端删除元素，实现上一般遵循&nbsp;<strong>先进先出（FIFO）</strong>&nbsp;规则。</p><p><code>Deque</code>&nbsp;是双端队列，在队列的两端均可以插入或删除元素。</p><h3 id="ArrayDeque-与-LinkedList-的区别是什么"><a href="#ArrayDeque-与-LinkedList-的区别是什么" class="headerlink" title="ArrayDeque 与 LinkedList 的区别是什么"></a>ArrayDeque 与 LinkedList 的区别是什么</h3><p><code>ArrayDeque</code> 和 <code>LinkedList</code> 都实现了 <code>Deque</code> 接口，两者都具有队列的功能</p><ul><li><strong>数据结构</strong>：<code>ArrayDeque</code> 是基于可变长的数组和双指针来实现，而 <code>LinkedList</code> 则通过链表来实现。</li><li><strong>对NULL的支持</strong>：<code>ArrayDeque</code> 不支持存储 <code>NULL</code> 数据，但 <code>LinkedList</code> 支持。</li><li><strong>性能</strong>：<code>LinkedList</code> 每次插入数据时均需要申请新的堆空间，<code>ArrayDeque</code>性能更好</li><li><strong>功能</strong>：ArrayDeque` 也可以用于实现栈。</li></ul><h3 id="说一说-PriorityQueue"><a href="#说一说-PriorityQueue" class="headerlink" title="说一说 PriorityQueue"></a>说一说 PriorityQueue</h3><p><code>PriorityQueue</code>与 <code>Queue</code> 的区别在于元素出队顺序是与优先级相关的，即总是优先级最高的元素先出队。</p><ul><li><code>PriorityQueue</code> 利用了<strong>二叉堆</strong>的数据结构来实现的，底层使用可变长的数组来存储数据</li><li><code>PriorityQueue</code> 通过堆元素的上浮和下沉，实现了在 O(logn) 的时间复杂度内插入元素和删除堆顶元素。</li><li><code>PriorityQueue</code> 是非线程安全的，不支持存储 <code>NULL</code> 。</li><li><code>PriorityQueue</code> 默认是小顶堆，但可以接收一个 <code>Comparator</code> 作为构造参数，从而来自定义元素优先级的先后。</li></ul><h3 id="什么是-BlockingQueue"><a href="#什么是-BlockingQueue" class="headerlink" title="什么是 BlockingQueue"></a>什么是 BlockingQueue</h3><p><code>BlockingQueue</code>阻塞队列 是一个接口，继承自 <code>Queue</code>。</p><p>当队列没有元素时一直阻塞，直到有元素；<br>当队列已满，一直等到队列可以放入新元素时再放入。</p><p><code>BlockingQueue</code> 常用于生产者-消费者模型中，生产者线程会向队列中添加数据，而消费者线程会从队列中取出数据进行处理。</p><h3 id="BlockingQueue-的实现类有哪些？"><a href="#BlockingQueue-的实现类有哪些？" class="headerlink" title="BlockingQueue 的实现类有哪些？"></a>BlockingQueue 的实现类有哪些？</h3><ul><li><code>ArrayBlockingQueue</code>：使用数组实现的有界阻塞队列。在创建时需要指定容量大小</li><li><code>LinkedBlockingQueue</code>：使用单向链表实现的可选有界阻塞队列。在创建时可以指定容量大小，如果不指定则默认为<code>Integer.MAX_VALUE</code>。</li><li><code>PriorityBlockingQueue</code>：支持优先级排序的无界阻塞队列。元素必须实现<code>Comparable</code>接口或者在构造函数中传入<code>Comparator</code>对象，并且不能插入 null 元素。</li><li><code>SynchronousQueue</code>：同步队列，是一种不存储元素的阻塞队列。常用于线程之间的直接传递数据。</li><li><code>DelayQueue</code>：延迟队列，其中的元素只有到了其指定的延迟时间，才能够从队列中出队。</li></ul><h3 id="ArrayBlockingQueue-和-LinkedBlockingQueue-有什么区别"><a href="#ArrayBlockingQueue-和-LinkedBlockingQueue-有什么区别" class="headerlink" title="ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别"></a>ArrayBlockingQueue 和 LinkedBlockingQueue 有什么区别</h3><p><code>ArrayBlockingQueue</code> 和 <code>LinkedBlockingQueue</code> 是 Java 并发包中常用的两种阻塞队列实现，它们都是线程安全的。</p><ul><li>底层实现：<code>ArrayBlockingQueue</code> 基于数组实现，而 <code>LinkedBlockingQueue</code> 基于链表实现。</li><li>是否有界：<code>ArrayBlockingQueue</code> 是有界队列，必须在创建时指定容量大小。<code>LinkedBlockingQueue</code> 创建时可以不指定容量大小，默认是<code>Integer.MAX_VALUE</code>，也就是无界的。但也可以指定队列大小，从而成为有界的。</li><li>锁是否分离： <code>ArrayBlockingQueue</code>中的锁是没有分离的，即生产和消费用的是同一个锁；<code>LinkedBlockingQueue</code>中的锁是分离的，可以防止生产者和消费者线程之间的锁争夺。</li><li>内存占用：<code>ArrayBlockingQueue</code> 需要提前分配数组内存，而 <code>LinkedBlockingQueue</code> 则是动态分配链表节点内存。</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础3(补档)</title>
      <link href="/2022/10/30/java-ji-chu-3-bu-dang/"/>
      <url>/2022/10/30/java-ji-chu-3-bu-dang/</url>
      
        <content type="html"><![CDATA[<h2 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h2><h3 id="异常类接口有哪些"><a href="#异常类接口有哪些" class="headerlink" title="异常类接口有哪些"></a>异常类接口有哪些</h3><p>Throwable</p><ul><li>Error</li><li>Exception<ul><li>Checked Exception</li><li>Unchecked Exception</li></ul></li></ul><h3 id="Exception-和-Error-有什么区别"><a href="#Exception-和-Error-有什么区别" class="headerlink" title="Exception 和 Error 有什么区别"></a>Exception 和 Error 有什么区别</h3><p>所有的异常都有一个共同的祖先 <code>java.lang</code> 包中的 <code>Throwable</code> 类。<code>Throwable</code> 类有两个重要的子类:</p><ul><li>**<code>Exception</code>**：程序本身可以处理的异常，可以通过 <code>catch</code> 来进行捕获。</li><li><strong><code>Error</code><strong>：<code>Error</code>：一般是指与虚拟机相关的问题，如：系统崩溃、虚拟机错误、内存空间不足、方法调用栈溢出等。这类错误将会导致应用</strong>程序中断</strong>，仅靠程序本身无法恢复和预防；</li></ul><h3 id="Checked-Exception-和-Unchecked-Exception-有什么区别"><a href="#Checked-Exception-和-Unchecked-Exception-有什么区别" class="headerlink" title="Checked Exception 和 Unchecked Exception 有什么区别"></a>Checked Exception 和 Unchecked Exception 有什么区别</h3><p><strong>Checked Exception</strong> 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 <code>catch</code>或者<code>throws</code> 关键字处理的话，就没办法通过编译。</p><p>除了<code>RuntimeException</code>及其子类以外，其他的<code>Exception</code>类及其子类都属于受检查异常 。常见的受检查异常有：IO 相关的异常、<code>ClassNotFoundException</code>、<code>SQLException</code>…。</p><p><strong>Unchecked Exception</strong> 即 <strong>不受检查异常</strong> ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。</p><p><code>RuntimeException</code> 及其子类都统称为非受检查异常，常见的有（建议记下来，日常开发中会经常用到）：</p><ul><li><code>NullPointerException</code>(空指针错误)</li><li><code>ArrayIndexOutOfBoundsException</code>（数组越界错误）</li><li><code>ClassCastException</code>（类型转换错误）</li><li><code>IllegalArgumentException</code>(参数错误)</li><li><code>NumberFormatException</code>（字符串转换为数字格式错误）</li><li><code>ArithmeticException</code>（算术错误）</li><li><code>SecurityException</code> （安全错误，比如权限不够）</li></ul><h3 id="Throwable-类常用方法有哪些"><a href="#Throwable-类常用方法有哪些" class="headerlink" title="Throwable 类常用方法有哪些"></a>Throwable 类常用方法有哪些</h3><ul><li><code>String getMessage()</code>: 返回异常发生时的简要描述</li><li><code>String toString()</code>: 返回异常发生时的详细信息</li><li><code>String getLocalizedMessage()</code>: 返回异常对象的本地化信息。使用 <code>Throwable</code> 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 <code>getMessage()</code>返回的结果相同</li><li><code>void printStackTrace()</code>: 在控制台上打印 <code>Throwable</code> 对象封装的异常信息</li></ul><h3 id="try-catch-finally-如何使用"><a href="#try-catch-finally-如何使用" class="headerlink" title="try-catch-finally 如何使用"></a>try-catch-finally 如何使用</h3><ul><li><code>try</code>块：用于捕获异常。其后可接零个或多个 <code>catch</code> 块，如果没有 <code>catch</code> 块，则必须跟一个 <code>finally</code> 块。</li><li><code>catch</code>块：用于处理 try 捕获到的异常。</li><li><code>finally</code> 块：无论是否捕获或处理异常，<code>finally</code> 块里的语句都会被执行。当在 <code>try</code> 块或 <code>catch</code> 块中遇到 <code>return</code> 语句时，<code>finally</code> 语句块将在方法返回之前被执行。</li></ul><p><strong>注意：不要在 finally 语句块中使用 return!</strong>&nbsp;当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。</p><h3 id="finally-中的代码一定会执行吗"><a href="#finally-中的代码一定会执行吗" class="headerlink" title="finally 中的代码一定会执行吗"></a>finally 中的代码一定会执行吗</h3><p>不一定</p><p>比如，finally 之前虚拟机被终止运行的话（exit 函数），finally 中的代码就不会被执行</p><h3 id="try-catch-finally-中那个部分可以省略"><a href="#try-catch-finally-中那个部分可以省略" class="headerlink" title="try-catch-finally 中那个部分可以省略"></a>try-catch-finally 中那个部分可以省略</h3><p>catch 和 finally可以省略其中一个</p><p>运行时异常是非受检异常，普通异常是受检异常；  </p><p>运行时异常：try+catch/finally<br>普通异常：try+catch（+finally），因为普通异常必须用catch显示声明进一步处理，否则编译器不通过。</p><h3 id="常见的异常类有哪些"><a href="#常见的异常类有哪些" class="headerlink" title="常见的异常类有哪些"></a>常见的异常类有哪些</h3><ol><li>NullPointerException：空指针异常</li><li>SQLException：数据库访问异常</li><li>IndexOutOfBoundsException：数组越界等异常</li><li>FileNotFoundException：当试图打开指定路径名表示的文件失败时，抛出此异常</li><li>IOException：当发生某种 I/O 异常时，抛出此异常</li><li>ClassCastException：类型转换异常</li><li>IllegalArgumentException：向方法传递了一个不合法或不正确的参数</li><li>ArithmeticException：除0异常</li><li>ConcurrentModificationException：多线程异常</li></ol><h2 id="泛型"><a href="#泛型" class="headerlink" title="泛型"></a>泛型</h2><h3 id="什么是泛型"><a href="#什么是泛型" class="headerlink" title="什么是泛型"></a>什么是泛型</h3><p>泛型（Generics）是一种提供参数化类型的机制。允许我们在定义类、接口和方法时使用类型参数，从而实现通用性和类型安全性。</p><h3 id="泛型有什么作用"><a href="#泛型有什么作用" class="headerlink" title="泛型有什么作用"></a>泛型有什么作用</h3><p>泛型的作用有以下几个方面：</p><ol><li>提高代码复用性：泛型使得我们可以编写更加通用的代码，以适用于多种数据类型</li><li>增强类型安全性：泛型在编译时进行类型检查，可以帮助我们在编译期间发现类型错误</li><li>简化代码开发：减少了手动进行类型转换的繁琐操作。</li></ol><h3 id="项目中哪里用到了泛型"><a href="#项目中哪里用到了泛型" class="headerlink" title="项目中哪里用到了泛型"></a>项目中哪里用到了泛型</h3><ul><li>自定义接口通用返回结果 <code>CommonResult&lt;T&gt;</code> 通过参数 <code>T</code> 可根据具体的返回类型动态指定结果的数据类型</li><li>集合类中，List&lt; String &gt;</li></ul><h3 id="泛型的通配符有哪些"><a href="#泛型的通配符有哪些" class="headerlink" title="泛型的通配符有哪些"></a>泛型的通配符有哪些</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">// 1：表示类型参数可以是任何类型</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 2：表示类型参数必须是A或者是A的子类</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">// 3: 表示类型参数必须是A或者是A的超类型</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Apple</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">T</span> supers <span class="token class-name">A</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">{</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>无边界的通配符, &lt; ? &gt;：让泛型能够接受未知类型的数据.</li><li>固定上边界的通配符，&lt; ? extends E &gt;：接受指定类及其子类类型的数据。</li><li>固定下边界的通配符，&lt; ? super E &gt;：接受指定类及其父类类型的数据.。</li></ol><h3 id="泛型擦除与泛型转换是什么"><a href="#泛型擦除与泛型转换是什么" class="headerlink" title="泛型擦除与泛型转换是什么"></a>泛型擦除与泛型转换是什么</h3><p><strong>泛型擦除</strong>：泛型擦除指的是在编译器将源代码转换成字节码的过程中，擦除了泛型类型的具体参数信息。在Java中，泛型是一种编译时的机制，在运行时并不存在泛型类型对象。编译器会把带有泛型参数的代码擦除为非泛型的原始类型。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">&gt;</span></span> stringList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> stringList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"Hello"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> stringList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">"World"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 泛型类型被擦除为原始类型 </span><span class="token class-name">List</span> rawList <span class="token operator">=</span> stringList<span class="token punctuation">;</span> <span class="token comment">// rawList将元素当做Object处理</span>rawList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 由于泛型擦除，在编译时不会发生错误 </span><span class="token class-name">String</span> firstElement <span class="token operator">=</span> stringList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 不需要进行强制类型转换 </span><span class="token class-name">String</span> secondElement <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> rawList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 需要进行强制类型转换</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>泛型转换</strong>：泛型转换是指在使用泛型时进行类型转换的过程。当使用一个泛型类或方法时，需要传入具体的类型参数。这些类型参数会被编译器进行类型检查，并在必要时进行类型转换，以保证类型的安全性。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> integerList <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> integerList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span> integerList<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span> <span class="token keyword">extends</span> <span class="token class-name">Number</span><span class="token punctuation">&gt;</span></span> numberList <span class="token operator">=</span> integerList<span class="token punctuation">;</span> <span class="token comment">// 泛型转换 </span><span class="token comment">// 无法添加新元素，但可以获取元素 </span><span class="token comment">// numberList.add(30); // 编译错误 因为编译器无法确定元素类型</span><span class="token class-name">Number</span> firstElement <span class="token operator">=</span> numberList<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h2><h3 id="什么是反射"><a href="#什么是反射" class="headerlink" title="什么是反射"></a>什么是反射</h3><p>反射（Reflection）是一种在运行时获取和操作类信息的能力。通过反射，可以动态地获取和使用在编译时可能无法确定的类和对象的信息。</p><p>使用反射，可以获取类的构造器、方法和字段等信息，并且可以动态地创建对象、调用方法、读取和修改字段的值，甚至可以操作私有成员。</p><p>java.lang.reflect 类库主要包含了以下三个类：</p><p>（1）Field ：可以使用 get() 和 set() 方法读取和修改 Field 对象关联的字段；<br>（2）Method ：可以使用 invoke() 方法调用与 Method 对象关联的方法；<br>（3）Constructor ：可以用 Constructor 创建新的对象。</p><h3 id="反射的作用有什么"><a href="#反射的作用有什么" class="headerlink" title="反射的作用有什么"></a>反射的作用有什么</h3><ol><li>获取类的信息：可以通过反射获得类的名称、父类、接口、字段、方法、构造器等信息。</li><li>创建对象：可以通过反射动态地创建类的实例，即使在编译时无法确定具体的类名。</li><li>调用方法：可以通过反射调用类的方法，包括公有方法、私有方法以及静态方法。</li><li>操作字段：可以通过反射读取和修改类的字段的值，包括公有字段和私有字段。</li><li>动态代理：反射可以用于实现动态代理，动态地生成代理类并在运行时处理方法的调用。<h3 id="反射的优缺点有哪些"><a href="#反射的优缺点有哪些" class="headerlink" title="反射的优缺点有哪些"></a>反射的优缺点有哪些</h3></li></ol><p><strong>优点：</strong></p><p>运行期类型的判断，class.forName() 动态加载类，提高代码的灵活度；</p><p><strong>缺点：</strong></p><p>（1）性能开销 ：反射涉及了动态类型的解析，JVM 无法对这些代码进行优化。</p><p>（2）内部暴露，安全问题：由于反射允许代码执行一些在正常情况下不被允许的操作（比如：访问私有的属性和方法）可能导致代码功能失调并破坏可移植性。</p><h3 id="Java反射在实际项目中的应用场景"><a href="#Java反射在实际项目中的应用场景" class="headerlink" title="Java反射在实际项目中的应用场景"></a>Java反射在实际项目中的应用场景</h3><ul><li>使用JDBC时，如果要创建数据库的连接，则需要先通过反射机制加载数据库的驱动程序；</li><li>多数框架都支持注解/XML配置，从配置中解析出来的类是字符串，需要利用反射机制实例化；</li><li>  面向切面编程（AOP）的实现方案，是在程序运行时创建目标对象的代理类，这必须由反射机制来实现。<h3 id="Java-中的动态代理是什么"><a href="#Java-中的动态代理是什么" class="headerlink" title="Java 中的动态代理是什么"></a>Java 中的动态代理是什么</h3></li></ul><p>动态代理（Dynamic Proxy）是一种在运行时创建代理类和对象的机制。</p><p>通过动态代理，可以在不事先知道接口具体实现类的情况下，动态地创建一个代理对象，该代理对象可以代替原始对象执行相同的操作，并且可以在方法调用前后进行额外的处理</p><h3 id="动态代理有哪些应用场景"><a href="#动态代理有哪些应用场景" class="headerlink" title="动态代理有哪些应用场景"></a>动态代理有哪些应用场景</h3><ul><li>添加日志、性能统计等横切逻辑，而不必修改原始类的代码。</li><li>实现AOP（面向切面编程）中的切面对象。</li><li>实现远程调用（RPC）框架中的代理对象。<h3 id="怎么实现动态代理？"><a href="#怎么实现动态代理？" class="headerlink" title="怎么实现动态代理？"></a>怎么实现动态代理？</h3></li></ul><p>Java 中，实现动态代理有两种方式：  </p><p>1、<strong>JDK 动态代理</strong>：java.lang.reflect 包中的 Proxy 类和 InvocationHandler 接口提供了生成动态代理类的能力。<br>2、<strong>Cglib 动态代理</strong>：Cglib (Code Generation Library )是一个第三方代码生成类库，运行时在内存中动态生成一个子类对象从而实现对目标对象功能的扩展。</p><h3 id="JDK-动态代理和-Cglib-动态代理的区别"><a href="#JDK-动态代理和-Cglib-动态代理的区别" class="headerlink" title="JDK 动态代理和 Cglib 动态代理的区别"></a>JDK 动态代理和 Cglib 动态代理的区别</h3><ol><li><p>JDK 的动态代理有一个限制，就是使用动态代理的对象必须实现一个或多个接口。  cglib 代理的对象则无需实现接口，达到代理类无侵入。</p></li><li><p>JDK 动态代理的实现方式是反射；CGLib 实现动态代理是基于 ASM（一个 Java 字节码操作框架）而非反射实现的。</p></li></ol><h2 id="注解"><a href="#注解" class="headerlink" title="注解"></a>注解</h2><h3 id="什么是注解"><a href="#什么是注解" class="headerlink" title="什么是注解"></a>什么是注解</h3><p><code>Annotation</code>&nbsp;可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。</p><p>注解本质是一个继承了<code>Annotation</code>&nbsp;的特殊接口</p><h3 id="注解的解析方法有哪几种"><a href="#注解的解析方法有哪几种" class="headerlink" title="注解的解析方法有哪几种"></a>注解的解析方法有哪几种</h3><p>注解只有被解析之后才会生效，常见的解析方法有两种：</p><ul><li><p><strong>编译期直接扫描</strong>：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用<code>@Override</code> 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。</p></li><li><p><strong>运行期通过反射处理</strong>：像框架中自带的注解(比如 Spring 框架的 <code>@Value</code>、<code>@Component</code>)都是通过反射来进行处理的。</p></li></ul><h3 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h3><h3 id="序列化和反序列化是什么"><a href="#序列化和反序列化是什么" class="headerlink" title="序列化和反序列化是什么"></a>序列化和反序列化是什么</h3><p><strong>序列化</strong>（serialization）：指将数据结构或对象状态转换成可取用格式，以留待后续在相同或另一台计算机环境中，能恢复原先状态的过程。</p><p>序列化协议属于 TCP/IP 协议应用层的一部分。</p><p>简单来说：</p><ul><li>  <strong>序列化</strong>： 将数据结构或对象转换成二进制字节流的过程</li><li>  <strong>反序列化</strong>：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程</li></ul><h3 id="序列化和反序列化常见应用场景"><a href="#序列化和反序列化常见应用场景" class="headerlink" title="序列化和反序列化常见应用场景"></a>序列化和反序列化常见应用场景</h3><ul><li><strong>网络传输</strong>：对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；</li><li><strong>存储到文件</strong>：将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；</li><li><strong>存储到Redis</strong>：将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；</li><li><strong>存储到内存</strong>：将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。</li></ul><h3 id="常见的序列化协议"><a href="#常见的序列化协议" class="headerlink" title="常见的序列化协议"></a>常见的序列化协议</h3><ul><li>1、XML</li><li>2、JSON</li><li>3、Fastjson</li><li>4、Thrift</li><li>5、Avro</li><li>6、Protobuf</li></ul><h3 id="JDK-自带的序列化方式"><a href="#JDK-自带的序列化方式" class="headerlink" title="JDK 自带的序列化方式"></a>JDK 自带的序列化方式</h3><p>JDK 自带的序列化，只需实现&nbsp;<code>java.io.Serializable</code>接口即可。</p><p><strong>如果有些字段不想进行序列化怎么办？</strong></p><p>对于不想进行序列化的变量，使用 <code>transient</code> 关键字修饰。</p><p><code>transient</code> 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 <code>transient</code> 修饰的变量值不会被持久化和恢复。</p><p>关于 <code>transient</code> 还有几点注意：</p><ul><li><code>transient</code> 只能修饰变量，不能修饰类和方法。</li><li><code>transient</code> 修饰的变量，在反序列化后变量值将会被置成类型的默认值。</li><li><code>static</code> 变量因为不属于任何对象，无论有没有 <code>transient</code> 关键字修饰，均不会被序列化。</li></ul><p><strong>为什么不推荐使用 JDK 自带的序列化？</strong></p><ul><li>  <strong>不支持跨语言调用</strong> : 如果调用的是其他语言开发的服务的时候就不支持了。</li><li>  <strong>性能差</strong> ：相比于其他序列化框架性能更低。</li><li>  <strong>存在安全问题</strong> ：序列化和反序列化本身并不存在问题。但是输入的反序列化的数据可被用户控制</li></ul><h2 id="I-O"><a href="#I-O" class="headerlink" title="I/O"></a>I/O</h2><h3 id="Java-IO流了解吗"><a href="#Java-IO流了解吗" class="headerlink" title="Java IO流了解吗"></a>Java IO流了解吗</h3><p>IO 即&nbsp;<code>Input/Output</code>，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此Java中称为 IO 流。</p><h3 id="Java-中的-IO-流的分类？说说几个你熟悉的实现类？"><a href="#Java-中的-IO-流的分类？说说几个你熟悉的实现类？" class="headerlink" title="Java 中的 IO 流的分类？说说几个你熟悉的实现类？"></a>Java 中的 IO 流的分类？说说几个你熟悉的实现类？</h3><p>IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。</p><p>Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。</p><ul><li><code>InputStream</code>/<code>Reader</code>: 所有的输入流的基类，前者是字节输入流，后者是字符输入流。</li><li><code>OutputStream</code>/<code>Writer</code>: 所有输出流的基类，前者是字节输出流，后者是字符输出流。</li></ul><p><img src="/images/image_Java_IO/01.png"></p><h3 id="字节流和字符流有什么区别？"><a href="#字节流和字符流有什么区别？" class="headerlink" title="字节流和字符流有什么区别？"></a>字节流和字符流有什么区别？</h3><p>字节流按 8 位传输，以字节为单位输入输出数据，<br>字符流按 16 位传输，以字符为单位输入输出数据。</p><p>但是不管文件读写还是网络发送接收，信息的最小存储单元都是字节。</p><h3 id="I-O-流为什么要分为字节流和字符流呢"><a href="#I-O-流为什么要分为字节流和字符流呢" class="headerlink" title="I/O 流为什么要分为字节流和字符流呢"></a>I/O 流为什么要分为字节流和字符流呢</h3><p>各有优缺点</p><ul><li><strong>字节流更快</strong>：字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时；</li><li><strong>字节流可能会乱码</strong>：如果我们不知道编码类型的话，使用字节流的过程中很容易出现乱码问题。<h3 id="BIO、NIO、AIO-有什么区别"><a href="#BIO、NIO、AIO-有什么区别" class="headerlink" title="BIO、NIO、AIO 有什么区别"></a>BIO、NIO、AIO 有什么区别</h3></li></ul><p>BIO（Blocking I/O）、NIO（Non-blocking I/O）和AIO（Asynchronous I/O）是Java中不同的I/O模型，它们有以下区别：</p><ol><li>阻塞与非阻塞：<ul><li>BIO是阻塞式I/O模型，即在执行I/O操作时，线程会被阻塞，直到操作完成。</li><li>NIO是非阻塞式I/O模型，使用了较少的线程处理更多的连接，并且线程在执行I/O操作时可以继续处理其他任务，提高了并发性能。</li><li>AIO是异步I/O模型，它使用了操作系统提供的异步通知机制，当I/O操作完成时，操作系统会通知应用程序进行处理。</li></ul></li><li>编程方式：<ul><li>BIO使用同步阻塞的方式，编程模型比较简单，但在大量连接的情况下，性能较低。</li><li>NIO使用选择器（Selector）和缓冲区（Buffer）来实现非阻塞，需要通过事件轮询来获取I/O事件的通知，编程模型稍微复杂。</li><li>AIO使用了回调机制，可以在I/O操作完成后得到通知，编程模型相对更为复杂。</li></ul></li><li>应用场景：<ul><li>BIO适用于连接数相对较少、请求响应时间要求较低的简单应用。</li><li>NIO适用于大量并发连接和高吞吐量的网络应用，如聊天服务器、即时通讯等。</li><li>AIO适用于大规模连接、每个连接处理时间较长的网络应用，如异步消息通知、Web后端处理等</li></ul></li></ol><h2 id="语法糖"><a href="#语法糖" class="headerlink" title="语法糖"></a>语法糖</h2><h3 id="什么是语法糖"><a href="#什么是语法糖" class="headerlink" title="什么是语法糖"></a>什么是语法糖</h3><p><strong>语法糖（Syntactic sugar）</strong> 代指的是编程语言为了方便程序员开发程序而设计的一种特殊语法，这种语法对编程语言的功能并没有影响。实现相同的功能，基于语法糖写出来的代码往往更简单简洁且更易阅读。</p><h3 id="Java-中有哪些常见的语法糖"><a href="#Java-中有哪些常见的语法糖" class="headerlink" title="Java 中有哪些常见的语法糖"></a>Java 中有哪些常见的语法糖</h3><p>Java 中最常用的语法糖主要有<strong>泛型</strong>、<strong>自动拆装箱</strong>、变长参数、枚举、内部类、<strong>增强 for 循环</strong>、try-with-resources 语法、<strong>lambda 表达式等</strong>。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础2(补档)</title>
      <link href="/2022/10/27/java-ji-chu-2-bu-dang/"/>
      <url>/2022/10/27/java-ji-chu-2-bu-dang/</url>
      
        <content type="html"><![CDATA[<h2 id="面向对象基础"><a href="#面向对象基础" class="headerlink" title="面向对象基础"></a>面向对象基础</h2><h3 id="什么是面向对象的程序设计方法"><a href="#什么是面向对象的程序设计方法" class="headerlink" title="什么是面向对象的程序设计方法"></a>什么是面向对象的程序设计方法</h3><p>面向对象是一种更优秀的程序设计方法，它的基本思想是使用类、对象、继承、封装等基本概念进行程序设计。</p><p>它从现实世界中客观存在的事物出发来构造软件系统，并在系统构造中尽可能运用人类的自然思维方式，强调直接以现实世界中的事物为中心来思考，认识问题，并根据这些事物的本质特点，把它们抽象地表示为系统中的类，作为系统的基本构成单元，这使得软件系统的组件可以直接映像到客观世界，并保持客观世界中事物及其相互关系的本来面貌。</p><h3 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h3><ul><li>面向过程把解决问题的过程拆成一个个功能方法，通过一个个方法的执行解决问题。</li><li>面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。</li></ul><p>面向对象开发的程序更易维护、易复用、易扩展。</p><h3 id="面向对象的三大特征"><a href="#面向对象的三大特征" class="headerlink" title="面向对象的三大特征"></a>面向对象的三大特征</h3><p>面向对象的程序设计方法具有三个基本特征：封装、继承、多态。</p><p><strong>封装</strong>指的是将对象的实现细节隐藏起来，然后通过一些公用方法来暴露该对象的功能</p><p><strong>继承</strong>是面向对象实现软件复用的重要手段，当子类继承父类后，子类作为一种特殊的父类，将直接获得父类的属性和方法</p><p>多态指的是子类对象可以直接赋给父类变量，但运行时依然表现出子类的行为特征，同一个类型的对象在执行同一个方法时，可能表现出多种行为特征。（父类的引用指向子类的实例）</p><h3 id="接口和抽象类有什么共同点和区别"><a href="#接口和抽象类有什么共同点和区别" class="headerlink" title="接口和抽象类有什么共同点和区别"></a>接口和抽象类有什么共同点和区别</h3><p><strong>共同点</strong>：</p><ul><li>都不能被实例化。</li><li>都可以包含抽象方法。</li><li>都可以有默认实现的方法（Java 8 可以用 <code>default</code> 关键字在接口中定义默认方法）。</li></ul><p><strong>区别</strong>：</p><ol><li>接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。</li><li>一个类只能继承一个类，但是可以实现多个接口。</li><li>接口不能为普通方法提供方法实现；抽象类可以包含普通方法。</li><li>接口中的成员变量只能是 <code>public static final</code> 类型的静态常量，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。</li><li> 接口里不能包含初始化块；但抽象类可以包含初始化块。</li><li>接口里不包含构造器；抽象类里可以包含构造器，抽象类里的构造器并不是用于创建对象，而是让其子类调用这些构造器来完成属于抽象类的初始化操作。</li></ol><h3 id="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"><a href="#深拷贝和浅拷贝区别了解吗？什么是引用拷贝？" class="headerlink" title="深拷贝和浅拷贝区别了解吗？什么是引用拷贝？"></a>深拷贝和浅拷贝区别了解吗？什么是引用拷贝？</h3><p>实现 Cloneable 接口并重写 Object 类中的 clone() 方法 来实现对象的克隆</p><ul><li><strong>浅拷贝</strong>：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。</li><li><strong>深拷贝</strong>：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。</li><li><strong>引用拷贝</strong>：两个不同的引用指向同一个对象。</li></ul><h2 id="Object类"><a href="#Object类" class="headerlink" title="Object类"></a>Object类</h2><h3 id="Object-类的常见方法有哪些？"><a href="#Object-类的常见方法有哪些？" class="headerlink" title="Object 类的常见方法有哪些？"></a>Object 类的常见方法有哪些？</h3><p>Object 类是一个特殊的类，是所有类的父类。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/** * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。 */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token class-name">Class</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token operator">?</span><span class="token punctuation">&gt;</span></span> <span class="token function">getClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">/** * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。 */</span><span class="token keyword">public</span> <span class="token keyword">native</span> <span class="token keyword">int</span> <span class="token function">hashCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">/** * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。 */</span><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">equals</span><span class="token punctuation">(</span><span class="token class-name">Object</span> obj<span class="token punctuation">)</span><span class="token comment">/** * naitive 方法，用于创建并返回当前对象的一份拷贝。 */</span><span class="token keyword">protected</span> <span class="token keyword">native</span> <span class="token class-name">Object</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">CloneNotSupportedException</span><span class="token comment">/** * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。 */</span><span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">/** * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。 */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notify</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">/** * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。 */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">notifyAll</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment">/** * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。 */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">native</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token comment">/** * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。 */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token keyword">long</span> timeout<span class="token punctuation">,</span> <span class="token keyword">int</span> nanos<span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token comment">/** * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念 */</span><span class="token keyword">public</span> <span class="token keyword">final</span> <span class="token keyword">void</span> <span class="token function">wait</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">InterruptedException</span><span class="token comment">/** * 实例被垃圾回收器回收的时候触发的操作 */</span><span class="token keyword">protected</span> <span class="token keyword">void</span> <span class="token function">finalize</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">throws</span> <span class="token class-name">Throwable</span> <span class="token punctuation">{</span> <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="和-equals-的区别"><a href="#和-equals-的区别" class="headerlink" title="== 和 equals() 的区别"></a>== 和 equals() 的区别</h3><p><strong><code>==</code></strong>&nbsp;对于基本类型和引用类型的作用效果是不同的：</p><ul><li>对于基本数据类型来说，<code>==</code>&nbsp;比较的是值。</li><li>对于引用数据类型来说，<code>==</code>&nbsp;比较的是对象的内存地址。</li></ul><p><code>equals()</code> 方法存在两种使用情况：</p><ul><li><strong>类没有重写 <code>equals()</code>方法</strong>：通过<code>equals()</code>比较该类的两个对象时，等价于通过“ == ”比较这两个对象，使用的默认是 <code>Object</code>类<code>equals()</code>方法。</li><li><strong>类重写了 <code>equals()</code>方法</strong>：一般我们都重写 <code>equals()</code>方法来比较两个对象中的属性是否相等；</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> a <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// a 为一个引用</span><span class="token class-name">String</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"ab"</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// b为另一个引用,对象的内容一样</span><span class="token class-name">String</span> aa <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span> <span class="token comment">// 放在常量池中</span><span class="token class-name">String</span> bb <span class="token operator">=</span> <span class="token string">"ab"</span><span class="token punctuation">;</span> <span class="token comment">// 从常量池中查找</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>aa <span class="token operator">==</span> bb<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// false</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span><span class="token number">42</span> <span class="token operator">==</span> <span class="token number">42.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="hashCode-有什么用"><a href="#hashCode-有什么用" class="headerlink" title="hashCode() 有什么用"></a>hashCode() 有什么用</h3><p><code>hashCode()</code>&nbsp;的作用是获取哈希码（<code>int</code>&nbsp;整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。</p><h3 id="为什么要有-hashCode"><a href="#为什么要有-hashCode" class="headerlink" title="为什么要有 hashCode"></a>为什么要有 hashCode</h3><p><code>hashCode()</code>&nbsp;和&nbsp;<code>equals()</code>都是用于比较两个对象是否相等。</p><ul><li>  如果两个对象相等，则它们必须有相同的哈希码。</li><li>  如果两个对象有相同的哈希码，则它们未必相等。</li></ul><p>以“<code>HashSet</code>&nbsp;如何检查重复”为例子来说明为什么要有&nbsp;<code>hashCode</code></p><p>当你把对象加入 <code>HashSet</code> 时，<code>HashSet</code> 会先计算对象的 <code>hashCode</code> 值来判断对象加入的位置，同时也会与其他已经加入的对象的 <code>hashCode</code> 值作比较，如果没有相符的 <code>hashCode</code>，<code>HashSet</code> 会假设对象没有重复出现。</p><p>但是如果发现有相同 <code>hashCode</code> 值的对象，这时会调用 <code>equals()</code> 方法来检查 <code>hashCode</code> 相等的对象是否真的相同。如果两者相同，<code>HashSet</code> 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。</p><p>这样我们就大大减少了 <code>equals</code> 的次数，相应就大大提高了执行速度。</p><h3 id="为什么重写-equals-时必须重写-hashCode-方法？"><a href="#为什么重写-equals-时必须重写-hashCode-方法？" class="headerlink" title="为什么重写 equals() 时必须重写 hashCode() 方法？"></a>为什么重写 equals() 时必须重写 hashCode() 方法？</h3><p>因为两个相等的对象的 <code>hashCode</code> 值必须是相等。也就是说如果 <code>equals</code> 方法判断两个对象是相等的，那这两个对象的 <code>hashCode</code> 值也要相等。</p><p>如果重写 <code>equals()</code> 时没有重写 <code>hashCode()</code> 方法的话就可能会导致 <code>equals</code> 方法判断是相等的两个对象，<code>hashCode</code> 值却不相等。</p><p>重写&nbsp;<code>equals()</code>&nbsp;时没有重写&nbsp;<code>hashCode()</code>&nbsp;方法的话，使用&nbsp;<code>HashMap</code>&nbsp;可能会出现什么问题？</p><ul><li>同一个对象在哈希表中根据默认的hashCode()得到不同的哈希码，相等的对象在哈希表中无法正确地进行查找和比较。</li><li>不同的对象可能被映射到相同的哈希桶中，将导致哈希表的性能下降</li></ul><h2 id="String类"><a href="#String类" class="headerlink" title="String类"></a>String类</h2><h3 id="String类的常用方法"><a href="#String类的常用方法" class="headerlink" title="String类的常用方法"></a>String类的常用方法</h3><ul><li>  char charAt(int index)：返回指定索引处的字符；</li><li>  String substring(int beginIndex, int endIndex)：从此字符串中截取出一部分子字符串；</li><li>  String[] split(String regex)：以指定的规则将此字符串分割成数组；</li><li>  String trim()：删除字符串前导和后置的空格；</li><li>  int indexOf(String str)：返回子串在此字符串首次出现的索引；</li><li>  int lastIndexOf(String str)：返回子串在此字符串最后出现的索引；</li><li>  boolean startsWith(String prefix)：判断此字符串是否以指定的前缀开头；</li><li>  boolean endsWith(String suffix)：判断此字符串是否以指定的后缀结尾；</li><li>  String toUpperCase()：将此字符串中所有的字符大写；</li><li>  String toLowerCase()：将此字符串中所有的字符小写；</li><li>  String replaceFirst(String regex, String replacement)：用指定字符串替换第一个匹配的子串；</li><li>  String replaceAll(String regex, String replacement)：用指定字符串替换所有的匹配的子串。</li></ul><h3 id="String-为什么是不可变的"><a href="#String-为什么是不可变的" class="headerlink" title="String 为什么是不可变的?"></a>String 为什么是不可变的?</h3><ul><li>保存字符串的数组被 <code>final</code> 修饰且为私有的，并且<code>String</code> 类没有提供修改这个字符串的方法。</li><li><code>String</code> 类被 <code>final</code> 修饰导致其不能被继承，进而避免了子类破坏 <code>String</code> 不可变性。</li></ul><h3 id="String-为什么要设计为不可变类"><a href="#String-为什么要设计为不可变类" class="headerlink" title="String 为什么要设计为不可变类"></a>String 为什么要设计为不可变类</h3><p>（1）字符串常量池的需要：字符串常量池是 Java 堆内存中一个特殊的存储区域, 当创建一个 String 对象时，假如此字符串值已经存在于常量池中，则不会创建一个新的对象，而是引用已经存在的对象；</p><p>（2）允许 String 对象缓存 HashCode：Java 中 String 对象的哈希码被频繁地使用, 比如在 HashMap 等容器中。字符串不变性保证了 hash 码的唯一性，因此可以放心地进行缓存。</p><p>（3）安全：String 被许多的 Java 类(库)用来当做参数，例如：网络连接地址 URL、文件路径 path、还有反射机制所需要的 String 参数等, 假若 String 不是固定不变的，将会引起各种安全隐患。</p><h3 id="如何设计一个不可变的类"><a href="#如何设计一个不可变的类" class="headerlink" title="如何设计一个不可变的类"></a>如何设计一个不可变的类</h3><ol><li>将类声明为<code>final</code>：通过将类声明为<code>final</code>，禁止其他类继承该类从而修改其行为。</li><li>声明所有字段为<code>private final</code>：将所有字段声明为私有和不可变的，通过使用<code>private</code>关键字限制对字段的直接访问，并使用<code>final</code>关键字确保字段在对象创建后不能被修改。</li><li>不提供修改字段的公共方法：避免提供任何公共方法（如setter）来修改字段的值。如果需要提供对字段的访问，可以提供只读（get）方法来返回字段的副本或变量。</li><li>保护性拷贝：如果类中包含可变对象的引用，需要进行保护性拷贝。即在返回可变对象引用之前，复制一份不可变的副本并返回。这样可以防止外部代码修改内部的可变对象。</li><li>构造函数初始化所有字段：通过构造函数初始化所有字段，并确保在对象创建后字段的值不会改变。</li><li>如果类中包含集合类型的字段，应使用不可变集合（如<code>Collections.unmodifiableList</code>）或者使用私有字段和访问方法来防止外部代码修改集合。</li><li>重写<code>equals()</code>和<code>hashCode()</code>方法：要正确比较两个不可变对象，需要重写<code>equals()</code>和<code>hashCode()</code>方法，以确保对象的内容相同时返回相等的结果。</li></ol><h3 id="Java-9-为何要将String的底层实现由-char-改成了-byte"><a href="#Java-9-为何要将String的底层实现由-char-改成了-byte" class="headerlink" title="Java 9 为何要将String的底层实现由&nbsp;char[]&nbsp;改成了&nbsp;byte[]"></a>Java 9 为何要将String的底层实现由&nbsp;<code>char[]</code>&nbsp;改成了&nbsp;<code>byte[]</code></h3><p>在大部分汉字的编码中，<code>byte</code> 占一个字节(8 位)，<code>char</code> 占用 2 个字节（16），<code>byte</code> 相较 <code>char</code> 节省一半的内存空间。</p><h3 id="String-equals-和-Object-equals-有何区别"><a href="#String-equals-和-Object-equals-有何区别" class="headerlink" title="String#equals() 和 Object#equals() 有何区别"></a>String#equals() 和 Object#equals() 有何区别</h3><p><code>String</code> 中的 <code>equals</code> 方法是被重写过的，比较的是 String 字符串的值是否相等。 <code>Object</code> 的 <code>equals</code> 方法是比较的对象的内存地址。</p><h3 id="String和StringBuffer的区别"><a href="#String和StringBuffer的区别" class="headerlink" title="String和StringBuffer的区别"></a>String和StringBuffer的区别</h3><p>String类是不可变类，每次对&nbsp;<code>String</code>&nbsp;类型进行改变的时候，都会生成一个新的&nbsp;<code>String</code>&nbsp;对象，然后将指针指向新的&nbsp;<code>String</code>&nbsp;对象。</p><p>StringBuffer是一个字符序列可变的字符串</p><p>当一个StringBuffer被创建以后，通过StringBuffer提供的append()、insert()、reverse()、setCharAt()、setLength()等方法可以改变这个字符串对象的字符序列。</p><h3 id="StringBuffer和StringBuilder的区别"><a href="#StringBuffer和StringBuilder的区别" class="headerlink" title="StringBuffer和StringBuilder的区别"></a>StringBuffer和StringBuilder的区别</h3><p>相同点：</p><p>StringBuffer、StringBuilder都代表可变的字符串对象，它们有共同的父类&nbsp;AbstractStringBuilder，并且两个类的构造方法和成员方法也基本相同。</p><p>不同点：</p><ul><li>StringBuffer是线程安全的，而StringBuilder是非线程安全的，StringBuffer类中的方法都添加了<strong>synchronized</strong>关键字，也就是给这个方法添加了一个锁，用来保证线程安全。</li><li>StringBuilder性能略高。</li></ul><h3 id="字符串拼接的方法有哪些"><a href="#字符串拼接的方法有哪些" class="headerlink" title="字符串拼接的方法有哪些"></a>字符串拼接的方法有哪些</h3><ol><li>+&nbsp;运算符：如果拼接的都是字符串直接量，则适合使用&nbsp;+&nbsp;运算符实现拼接；</li><li>StringBuilder：如果拼接的字符串中包含变量，并不要求线程安全，则适合使用StringBuilder；</li><li>StringBuffer：如果拼接的字符串中包含变量，并且要求线程安全，则适合使用StringBuffer；</li><li> String类的concat方法：如果只是对两个字符串进行拼接，并且包含变量，则适合使用concat方法；</li></ol><p><strong>+&nbsp;运算符</strong></p><ul><li><strong>字符串直接量拼接</strong>：编译器会将其直接优化为一个完整的字符串，直接写一个完整的字符串是一样的，所以效率非常的高。</li><li>  <strong>包含变量的拼接</strong>：编译器采用StringBuilder对其进行优化，即自动创建StringBuilder实例并调用其append()方法拼接，之后调用&nbsp;<code>toString()</code>&nbsp;得到一个&nbsp;<code>String</code>&nbsp;对象，效率也很高。</li></ul><p><strong>StringBuilder/StringBuffer类</strong></p><p>StringBuilder/StringBuffer都有字符串缓冲区，缓冲区的容量在创建对象时确定，并且默认为16。当拼接的字符串超过缓冲区的容量时，会触发缓冲区的扩容机制，即缓冲区加倍。</p><p><strong>String类的concat方法</strong></p><p>先创建一个足以容纳待拼接的两个字符串的字节数组，然后先后将两个字符串拼到这个数组里，最后将此数组转换为字符串。</p><p>只拼接2个字符串时，concat方法的效率要优于StringBuilder。</p><h3 id="String-a-“abc”-创建过程，存放位置"><a href="#String-a-“abc”-创建过程，存放位置" class="headerlink" title="String a = “abc”;&nbsp;创建过程，存放位置"></a>String a = “abc”;&nbsp;创建过程，存放位置</h3><p>JVM会使用常量池来管理字符串直接量。在执行这句话时，JVM会先检查常量池中是否已经存有”abc”，若没有则将”abc”存入常量池，否则就复用常量池中已有的”abc”，将其引用赋值给变量a。</p><h3 id="new-String-“abc”-创建过程，存放位置"><a href="#new-String-“abc”-创建过程，存放位置" class="headerlink" title="new String(“abc”)&nbsp;; 创建过程，存放位置"></a>new String(“abc”)&nbsp;; 创建过程，存放位置</h3><p>在执行这句话时，JVM会先使用常量池来管理字符串直接量，即将”abc”存入常量池（若已存在就不用再存了）。然后再创建一个新的String对象，这个对象会被保存在堆内存中。并且，堆中对象的数据会指向常量池中的直接量。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">String</span> str1 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span><span class="token class-name">String</span> str2 <span class="token operator">=</span> <span class="token string">"abc"</span><span class="token punctuation">;</span><span class="token class-name">String</span> str3 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">String</span> str4 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">"abc"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str2<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// true</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str1 <span class="token operator">==</span> str3<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// false</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str3 <span class="token operator">==</span> str4<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// false</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>str3<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>str4<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// true</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java基础1(补档)</title>
      <link href="/2022/10/25/java-ji-chu-1-bu-dang/"/>
      <url>/2022/10/25/java-ji-chu-1-bu-dang/</url>
      
        <content type="html"><![CDATA[<h2 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h2><h3 id="Java-语言有哪些特点"><a href="#Java-语言有哪些特点" class="headerlink" title="Java 语言有哪些特点"></a>Java 语言有哪些特点</h3><ol><li>简单易学；</li><li>面向对象（封装，继承，多态）；</li><li>跨平台，一次编写，随处运行（ Java 虚拟机实现平台无关性）；</li><li>支持多线程；</li><li>可靠性（具备异常处理和自动内存管理机制）；</li><li>安全性（如访问权限修饰符、限制程序直接访问操作系统资源）；</li><li>生态强（拥有许多开发框架，社区完善）</li><li>高效性（Just In Time 编译器等技术的优化的）；</li><li>支持网络编程并且很方便；</li><li>编译与解释并存；</li></ol><h3 id="JVM、JDK、JRE的区别"><a href="#JVM、JDK、JRE的区别" class="headerlink" title="JVM、JDK、JRE的区别"></a>JVM、JDK、JRE的区别</h3><p>Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。</p><p>JDK 是 Java开发工具，它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。</p><p>JRE 是 Java 运行时环境。包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。它不能用于创建新程序。</p><h3 id="什么是字节码，采用字节码的好处"><a href="#什么是字节码，采用字节码的好处" class="headerlink" title="什么是字节码，采用字节码的好处"></a>什么是字节码，采用字节码的好处</h3><p>在 Java 中，JVM 可以理解的代码就叫做字节码（即扩展名为 <code>.class</code> 的文件），它不面向任何特定的处理器，只面向虚拟机。</p><p><strong>高效性</strong>：Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。</p><p><strong>跨平台</strong>：字节码不针对一种特定的机器，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。</p><h3 id="JIT和AOT"><a href="#JIT和AOT" class="headerlink" title="JIT和AOT"></a>JIT和AOT</h3><p>JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。(编译，是编译与解释共存的语言)</p><p>AOT(Ahead of Time Compilation)编译模式，直接将字节码编译成机器码，这样避免了 JIT 预热等各方面的开销。</p><p>JIT支持动态代理，AOT不支持</p><h3 id="为什么说-Java-语言“编译与解释并存”"><a href="#为什么说-Java-语言“编译与解释并存”" class="headerlink" title="为什么说 Java 语言“编译与解释并存”"></a>为什么说 Java 语言“编译与解释并存”</h3><ul><li><strong>编译型</strong>：编译型语言会通过编译器将源代码一次性翻译成可被该平台执行的机器码。编译语言的执行速度比较快，开发效率比较低。 C、C++、Go、Rust </li><li><strong>解释型</strong>：解释型语言会通过解释器一句一句的将代码解释为机器代码后再执行。解释型语言开发效率比较快，执行速度比较慢。 Python、JavaScript、PHP </li></ul><p>因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。Java 程序要经过<strong>先编译，后解释</strong>两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（<code>.class</code> 文件），这种字节码必须由 Java 解释器来解释执行。</p><h3 id="Java-和-C-的区别是什么"><a href="#Java-和-C-的区别是什么" class="headerlink" title="Java 和 C++ 的区别是什么"></a>Java 和 C++ 的区别是什么</h3><ul><li>Java 不提供指针来直接访问内存，程序内存更加安全</li><li>Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。</li><li>Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。</li><li>C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载。</li></ul><h3 id="JDK8的新特性"><a href="#JDK8的新特性" class="headerlink" title="JDK8的新特性"></a>JDK8的新特性</h3><ol><li><strong>引入Lambda表达式</strong>：允许把函数作为一个方法的参数。</li><li><strong>方法与构造函数引用</strong>：允许使用 : : 关键字来传递方法或者构造函数引用</li><li><strong>接口默认方法和静态方法</strong>：支持在接口中定义默认方法和静态方法， 默认方法可以被接口实现引用。</li><li><strong>JVM新特性</strong>：使用metaSpace代替永久区</li><li><strong>Date API</strong>：在包java.time下包含了一组全新的时间日期API（Clock，LocalTime，LocalDate等）</li><li><strong>多重注解</strong>：允许把同一个类型的注解使用多次，只需要给该注解标注一下@Repeatable即可。</li><li><strong>HashMap变化</strong>：将链表方式修改成链表或者红黑树的形式，JDK1.7存储使用Entry数组， JDK8使用Node或者TreeNode数组存储，修改resize的过程，解决JDK7在resize在并发场景下死锁的隐患（JDK8插入从链表尾部插入）</li><li><strong>ConcurrentHashMap的实现</strong>：在 jdk 1.7 中，ConcurrentHashMap 是由 Segment 数据结构和 HashEntry 数组结构构成，采取分段锁来保证安全性。JDK1.8 中，用 Node 数组+链表+红黑树的数据结构来实现，并发控制使用 Synchronized 和 CAS 来操作</li></ol><h2 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h2><h3 id="标识符和关键字的区别是什么"><a href="#标识符和关键字的区别是什么" class="headerlink" title="标识符和关键字的区别是什么"></a>标识符和关键字的区别是什么</h3><p>编写程序的时需要为程序、类、变量、方法等取名字，于是就有了&nbsp;<strong>标识符</strong>&nbsp;。</p><p><strong>标识符就是一个名字</strong>&nbsp;</p><p><strong>关键字是被赋予特殊含义的标识符</strong></p><h3 id="final-关键字的作用"><a href="#final-关键字的作用" class="headerlink" title="final 关键字的作用"></a>final 关键字的作用</h3><p>用于声明属性、方法和类，分别表示属性不可变、方法不可覆盖、被其修饰的类不可继承</p><ul><li>修饰的变量是基本数据类型则<strong>值不能改变</strong></li><li>修饰的变量是引用类型则<strong>不能再指向其他对象</strong></li></ul><p>例如：final ArrayList中可以修改添加值，只是引用不能指向其他arraylist</p><h3 id="super-关键字的作用"><a href="#super-关键字的作用" class="headerlink" title="super 关键字的作用"></a>super 关键字的作用</h3><p>（1）访问父类的构造函数：可以使用 super() 函数访问父类的构造函数，从而委托父类完成一些初始化的工作。</p><p>（2）访问父类的成员：如果子类重写了父类的某个方法，可以通过使用 super 关键字来引用父类的方法实现。</p><p>（3）this 和 super 不能同时出现在一个构造函数里面，因为 this 必然会调用其它的构造函数，其它的构造函数必然也会有 super 语句的存在，所以在同一个构造函数里面有相同的语句，就失去了语句的意义，编译器也不会通过。</p><h3 id="访问权限有哪些"><a href="#访问权限有哪些" class="headerlink" title="访问权限有哪些"></a>访问权限有哪些</h3><p>在修饰成员变量/成员方法时，该成员的四种访问权限的含义如下：</p><ul><li>  private：该成员可以被该类内部成员访问；</li><li>  default：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问；</li><li>  protected：该成员可以被该类内部成员访问，也可以被同一包下其他的类访问，还可以被它的子类访问；</li><li>  public：该成员可以被任意包下，任意类的成员进行访问。</li></ul><p>在修饰类时，该类只有两种访问权限，对应的访问权限的含义如下：</p><ul><li>  default：该类可以被同一包下其他的类访问；</li><li>  public：该类可以被任意包下，任意的类所访问。<h3 id="i-和-i的区别是什么"><a href="#i-和-i的区别是什么" class="headerlink" title="i++和++i的区别是什么"></a>i++和++i的区别是什么</h3></li></ul><p>自增运算符（++)<br>自减运算符（- - )</p><p>当运算符放在变量之前时(前缀)，先自增/减，再赋值；<br>当运算符放在变量之后时(后缀)，先赋值，再自增/减。</p><h3 id="移位运算符"><a href="#移位运算符" class="headerlink" title="移位运算符"></a>移位运算符</h3><p>移位运算符是最基本的运算符之一，被操作的数据被视为二进制数，移位就是将其向左或向右移动若干位的运算。</p><p>在 Java 代码里使用&nbsp;<code>&lt;&lt;</code>&nbsp;、&nbsp;<code>&gt;&gt;</code>&nbsp;和<code>&gt;&gt;&gt;</code>转换成的指令码运行起来会更高效些。</p><p>Java 中有三种移位运算符：</p><ul><li>  <code>&lt;&lt;</code> :左移运算符，向左移若干位，高位丢弃，低位补零。</li><li>  <code>&gt;&gt;</code> :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。</li><li>  <code>&gt;&gt;&gt;</code> :无符号右移，忽略符号位，空位都以 0 补齐。</li></ul><p>由于 <code>double</code>，<code>float</code> 在二进制中的表现比较特殊，不能来进行移位操作。</p><p>移位操作符实际上支持的类型只有<code>int</code>和<code>long</code>，编译器在对<code>short</code>、<code>byte</code>、<code>char</code>类型进行移位前，都会将其转换为<code>int</code>类型再操作。</p><p><strong>如果移位的位数超过数值所占有的位数会怎样？</strong></p><p>当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。</p><p>也就是说：<code>x&lt;&lt;42</code>等同于<code>x&lt;&lt;10</code>，<code>x&gt;&gt;42</code>等同于<code>x&gt;&gt;10</code>，<code>x &gt;&gt;&gt;42</code>等同于<code>x &gt;&gt;&gt; 10</code>。</p><h3 id="continue、break-和-return-的区别"><a href="#continue、break-和-return-的区别" class="headerlink" title="continue、break 和 return 的区别"></a>continue、break 和 return 的区别</h3><ol><li> <code>continue</code> ：指跳出当前的这一次循环，继续下一次循环。</li><li> <code>break</code> ：指跳出整个循环体，继续执行循环下面的语句。</li><li><code>return</code> 用于跳出所在方法，结束该方法的运行。</li></ol><h3 id="switch-语句能否作用在-byte-上，能否作用在-long-上，能否作用在-String-上？"><a href="#switch-语句能否作用在-byte-上，能否作用在-long-上，能否作用在-String-上？" class="headerlink" title="switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上？"></a>switch 语句能否作用在 byte 上，能否作用在 long 上，能否作用在 String 上？</h3><p>在 switch(expr 1) 中，expr1 只能是一个整数表达式或者枚举常量。</p><p>而整数表达式可以是 int 基本数据类型或者 Integer 包装类型。由于，byte、short、char 都可以<strong>隐式转换</strong>为 int，所以，这些类型以及这些类型的包装类型也都是可以的。</p><p>而 long 和 String 类型都不符合 switch 的语法规定，并且不能被隐式的转换为 int 类型，所以，它们不能作用于 switch 语句中。</p><p>不过，需要注意的是在 JDK1.7 版本之后 switch 就可以作用在 String 上了。</p><h3 id="amp-和-amp-amp-的区别是什么"><a href="#amp-和-amp-amp-的区别是什么" class="headerlink" title="&amp; 和 &amp;&amp; 的区别是什么"></a>&amp; 和 &amp;&amp; 的区别是什么</h3><p>Java 中 &amp;&amp; 和 &amp; 都是表示与的逻辑运算符，都表示逻辑运算符 and</p><p>&amp;&amp;：有短路功能，当第一个表达式的值为 false 的时候，则不再计算第二个表达式；</p><p>&amp;：不管第一个表达式结果是否为 true，第二个都会执行。<br>&amp; 还可以用作位运算符：当 &amp; 两边的表达式不是 Boolean 类型的时候，&amp; 表示按位操作。</p><h2 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h2><h3 id="Java-中的几种基本数据类型了解么？"><a href="#Java-中的几种基本数据类型了解么？" class="headerlink" title="Java 中的几种基本数据类型了解么？"></a>Java 中的几种基本数据类型了解么？</h3><p>整数型：</p><ul><li>  byte：1字节（8位）默认值：0</li><li>  short：2字节（16位）默认值：0</li><li>  int：4字节（32位）默认值：0</li><li>  long：8字节（64位）默认值：0L<br>浮点型：</li><li>  float：4字节（32位）默认值：0f</li><li>  double：8字节（64位）0d<br>字符型：</li><li>  char：2字节（16位）默认值：’u0000’<br>布尔型：</li><li>  boolean：1位 默认值：false<h3 id="基本类型与包装类的区别"><a href="#基本类型与包装类的区别" class="headerlink" title="基本类型与包装类的区别"></a>基本类型与包装类的区别</h3></li></ul><p>Java语言是面向对象的语言，8种基本数据类型不具备对象的特性。所以Java为每个基本数据类型都定义了一个对应的引用类型，这就是包装类。</p><ul><li><strong>用途</strong>：包装类型可用于<strong>泛型</strong>，基本类型不可以。</li><li><strong>存储方式</strong>：基本数据类型的局部变量存放在 Java 虚拟机栈中的<strong>局部变量表</strong>中，基本数据类型的成员变量（未被 <code>static</code> 修饰 ）存放在 Java 虚拟机的<strong>堆</strong>中。</li><li><strong>占用空间</strong>：相比于包装类型， 基本数据类型占用的空间往往非常小。</li><li><strong>默认值</strong>：成员变量包装类型不赋值就是 <code>null</code> ，而基本类型有默认值且不是 <code>null</code>。</li><li><strong>比较方式</strong>：对于基本数据类型来说，<code>==</code> 比较的是值。对于包装数据类型来说，<code>==</code> 比较的是对象的内存地址。所有包装类对象之间值的比较，全部使用 <code>equals()</code> 方法<h3 id="包装类型的缓存机制了解么"><a href="#包装类型的缓存机制了解么" class="headerlink" title="包装类型的缓存机制了解么"></a>包装类型的缓存机制了解么</h3></li></ul><p>Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。</p><p><code>Byte</code>,<code>Short</code>,<code>Integer</code>,<code>Long</code> 这 4 种包装类默认创建了数值 <strong>[-128，127]</strong> 的相应类型的缓存数据，<code>Character</code> 创建了数值在 <strong>[0,127]</strong> 范围的缓存数据，<code>Boolean</code> 直接返回 <code>True</code> or <code>False</code>。</p><p>如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。</p><p>两种浮点数类型的包装类 <code>Float</code>,<code>Double</code> 并没有实现缓存机制。</p><p>下面的代码的输出结果是 <code>true</code> 还是 <code>false</code> 呢？</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">Integer</span> i1 <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span><span class="token class-name">Integer</span> i2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Integer</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>i1<span class="token operator">==</span>i2<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><code>Integer i1=40</code> 这一行代码会发生装箱，这行代码等价于 <code>Integer i1=Integer.valueOf(40)</code> 。因此，<code>i1</code> 直接使用的是缓存中的对象。而<code>Integer i2 = new Integer(40)</code> 会直接创建新的对象。</p><h3 id="自动装箱、自动拆箱是什么，原理是什么"><a href="#自动装箱、自动拆箱是什么，原理是什么" class="headerlink" title="自动装箱、自动拆箱是什么，原理是什么"></a>自动装箱、自动拆箱是什么，原理是什么</h3><p>自动装箱：可以把一个基本类型的数据直接赋值给对应的包装类型；<br>自动拆箱：可以把一个包装类型的对象直接赋值给对应的基本类型；</p><p>自动装箱时，编译器调用valueOf将原始类型值转换成对象，<br>自动拆箱时，编译器通过调用类似intValue(),doubleValue()这类的方法，将对象转换成原始类型值。</p><p>如果频繁拆装箱的话，也会严重影响系统的性能。我们应该尽量避免不必要的拆装箱操作。</p><h3 id="浮点数运算的时候为什么会有精度丢失的风险"><a href="#浮点数运算的时候为什么会有精度丢失的风险" class="headerlink" title="浮点数运算的时候为什么会有精度丢失的风险"></a>浮点数运算的时候为什么会有精度丢失的风险</h3><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">float</span> a <span class="token operator">=</span> <span class="token number">2.0f</span> <span class="token operator">-</span> <span class="token number">1.9f</span><span class="token punctuation">;</span><span class="token keyword">float</span> b <span class="token operator">=</span> <span class="token number">1.8f</span> <span class="token operator">-</span> <span class="token number">1.7f</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 0.100000024</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 0.099999905</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> b<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// false</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>这个和计算机保存浮点数的机制有很大关系。</p><p>计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。</p><h3 id="如何解决浮点数运算的精度丢失问题"><a href="#如何解决浮点数运算的精度丢失问题" class="headerlink" title="如何解决浮点数运算的精度丢失问题"></a>如何解决浮点数运算的精度丢失问题</h3><p><code>BigDecimal</code>类 可以实现对浮点数的运算，不会造成精度丢失。</p><p>通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 <code>BigDecimal</code> 来做的。</p><h3 id="超过-long-整型的数据应该如何表示"><a href="#超过-long-整型的数据应该如何表示" class="headerlink" title="超过 long 整型的数据应该如何表示"></a>超过 long 整型的数据应该如何表示</h3><p>基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。</p><p><strong>BigInteger</strong></p><p>内部使用&nbsp;<code>int[]</code>&nbsp;数组来存储任意大小的整形数据。相对于常规整数类型的运算来说，<code>BigInteger</code>&nbsp;运算的效率会相对较低。</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="成员变量和局部变量的区别"><a href="#成员变量和局部变量的区别" class="headerlink" title="成员变量和局部变量的区别"></a>成员变量和局部变量的区别</h3><p>Java中的变量分为成员变量和局部变量</p><ul><li><strong>语法形式</strong>：成员变量是在类的范围里定义的变量；局部变量是在方法里定义的变量；</li><li><strong>默认值</strong>：成员变量有默认初始值；（ 0, 0.0, ‘\u0000’, false ）；局部变量没有默认初始值；</li><li><strong>存储方式</strong>：未被static修饰的成员变量也叫实例变量，它存储于对象所在的堆内存中，被static修饰的成员变量也叫类变量，它存储于方法区中；局部变量存储于栈内存中</li><li><strong>生命周期</strong>：未被static修饰的成员变量是对象的一部分，生命周期与对象相同，被static修饰的成员变量是类的一部分，生命周期与类相同；局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。<h3 id="静态变量有什么作用"><a href="#静态变量有什么作用" class="headerlink" title="静态变量有什么作用"></a>静态变量有什么作用</h3></li></ul><p>静态变量也就是被 <code>static</code> 关键字修饰的变量。它可以被类的所有实例共享，无论一个类创建了多少个对象，它们都共享同一份静态变量。</p><p>静态变量只会被分配一次内存，即使创建多个对象，这样可以节省内存。</p><p>通常情况下，静态变量会被&nbsp;<code>final</code>&nbsp;关键字修饰成为常量</p><h3 id="字符型常量和字符串常量的区别"><a href="#字符型常量和字符串常量的区别" class="headerlink" title="字符型常量和字符串常量的区别"></a>字符型常量和字符串常量的区别</h3><ul><li><strong>形式</strong> : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。</li><li><strong>含义</strong> : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。</li><li><strong>占内存大小</strong>：字符常量只占 2 个字节; 字符串常量占若干个字节。</li></ul><h2 id="方法"><a href="#方法" class="headerlink" title="方法"></a>方法</h2><h3 id="静态方法为什么不能调用非静态成员"><a href="#静态方法为什么不能调用非静态成员" class="headerlink" title="静态方法为什么不能调用非静态成员"></a>静态方法为什么不能调用非静态成员</h3><p>需要结合 JVM 的相关知识，主要原因如下：</p><ol><li>静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。</li><li>在类的非静态成员不存在的时候静态方法就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。</li></ol><h3 id="静态方法和实例方法有什么不同"><a href="#静态方法和实例方法有什么不同" class="headerlink" title="静态方法和实例方法有什么不同"></a>静态方法和实例方法有什么不同</h3><p><strong>1、调用方式</strong></p><p>调用静态方法时，可以使用 <code>类名.方法名</code> 的方式，也可以使用 <code>对象.方法名</code> 的方式，而实例方法只有后面这种方式。也就是说，<strong>调用静态方法可以无需创建对象</strong> 。</p><p><strong>2、访问类成员是否存在限制</strong></p><p>静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制</p><h3 id="重载和重写有什么区别"><a href="#重载和重写有什么区别" class="headerlink" title="重载和重写有什么区别"></a>重载和重写有什么区别</h3><p><strong>重载</strong>：同样的一个方法能够根据输入数据的不同，做出不同的处理</p><p>重写发生在编译器，在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同。</p><p><strong>重写</strong>：当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法</p><p>重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。</p><ol><li>方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。</li><li>如果父类方法访问修饰符为 <code>private/final/static</code> 则子类就不能重写该方法，但是被 <code>static</code> 修饰的方法能够被再次声明。</li><li>构造方法无法被重写</li></ol><h3 id="为什么不能重写-private-或者-static-方法"><a href="#为什么不能重写-private-或者-static-方法" class="headerlink" title="为什么不能重写 private 或者 static 方法"></a>为什么不能重写 private 或者 static 方法</h3><p>static：因为方法覆盖是基于运行时动态绑定的，而 static 方法是编译时静态绑定的。<br>private：因为 private 修饰的变量和方法只能在当前类中使用， 如果是其他的类继承当前类是不能访问到 private 变量或方法的。</p><h3 id="什么是可变长参数"><a href="#什么是可变长参数" class="headerlink" title="什么是可变长参数"></a>什么是可变长参数</h3><p>可变长参数就是允许在调用方法时传入不定长度的参数。</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">method1</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> args<span class="token punctuation">)</span> <span class="token punctuation">{</span>   <span class="token comment">//......</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ul><li><p>可变参数只能作为函数的最后一个参数，但其前面可以有也可以没有任何其他参数。</p></li><li><p>Java 的可变参数编译后实际会被转换成一个数组</p></li><li><p>遇到方法重载时会优先匹配固定参数的方法</p></li></ul><h3 id="Java-中只有值传递"><a href="#Java-中只有值传递" class="headerlink" title="Java 中只有值传递"></a>Java 中只有值传递</h3><p>Java 中将实参传递给方法（或函数）的方式是 <strong>值传递</strong> ：</p><ul><li>  参数是基本类型：传递的是基本类型的字面量值的拷贝，会创建副本。</li><li>  参数是引用类型：传递的是实参所引用的对象在堆中地址值的拷贝，也会创建副本。</li></ul><h3 id="在-Java-中定义无参内容为空的构造方法有什么作用"><a href="#在-Java-中定义无参内容为空的构造方法有什么作用" class="headerlink" title="在 Java 中定义无参内容为空的构造方法有什么作用"></a>在 Java 中定义无参内容为空的构造方法有什么作用</h3><p><strong>Java 程序在执行子类的构造方法之前，如果没有用 super() 来调用父类特定的构造方法，则会调用父类中“无参构造方法”</strong>。</p><p>如果父类中只定义了有参数的构造方法，而在子类的构造方法中又没有用 super() 来调用父类中特定的构造方法，则编译时将发生错误，因为 Java 程序在父类中找不到没有参数的构造方法可供执行。</p>]]></content>
      
      
      
        <tags>
            
            <tag> Java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MySQL(补档)</title>
      <link href="/2022/10/21/shu-ju-ku-bu-dang/"/>
      <url>/2022/10/21/shu-ju-ku-bu-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="什么是数据库-数据库管理系统-数据库系统-数据库管理员"><a href="#什么是数据库-数据库管理系统-数据库系统-数据库管理员" class="headerlink" title="什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?"></a>什么是数据库, 数据库管理系统, 数据库系统, 数据库管理员?</h3><ul><li>  <strong>数据库（DB）</strong> : 信息的集合或者说数据库是由数据库管理系统管理的数据的集合。</li><li>  <strong>数据库管理系统(DBMS)</strong> : 操纵和管理数据库的大型软件，通常用于建立、使用和维护数据库。</li><li>  <strong>数据库系统(DBS)</strong> : 通常由软件、数据库和数据管理员(DBA)组成。</li><li>  <strong>数据库管理员(DBA)</strong> : 负责全面管理和控制数据库系统。</li></ul><h3 id="什么是元组-码-候选码-主码-外码-主属性-非主属性？"><a href="#什么是元组-码-候选码-主码-外码-主属性-非主属性？" class="headerlink" title="什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？"></a>什么是元组, 码, 候选码, 主码, 外码, 主属性, 非主属性？</h3><ul><li>  <strong>元组</strong> ： 表中的每行（即数据库中的每条记录）就是一个元组</li><li>  <strong>码</strong> ：码就是能唯一标识实体的属性，对应表中的列。</li><li>  <strong>候选码</strong> ： 关系中的某一属性或属性组的值能唯一的标识一个元组，而其任何、子集都不能再标识，则称该属性组为候选码。</li><li>  <strong>外码</strong> : 外码也叫外键。一个关系中的一个属性是另外一个关系中的主码，则这个属性为外码。</li><li>  <strong>主属性</strong> ： 候选码中出现过的属性称为主属性。</li><li>  <strong>非主属性：</strong> 不包含在任何一个候选码中的属性称为非主属性。</li></ul><h3 id="ER-图"><a href="#ER-图" class="headerlink" title="ER 图"></a>ER 图</h3><p><strong>ER 图</strong> 是实体联系图，提供了表示实体类型、属性和联系的方法。</p><p>ER 图由下面 3 个要素组成：</p><ul><li><p>  <strong>实体</strong> ：通常是现实世界的业务对象，当然使用一些逻辑对象也可以。矩形框</p></li><li><p>  <strong>属性</strong> ：即某个实体拥有的属性，属性用来描述组成实体的要素。椭圆形</p></li><li><p>  <strong>联系</strong> ：实体与实体之间的关系，这个关系不仅有业务关联关系，还能通过数字表示实体之间的数量对照关系。</p><h3 id="数据库范式有哪些"><a href="#数据库范式有哪些" class="headerlink" title="数据库范式有哪些"></a>数据库范式有哪些</h3></li><li><p>  1NF(第一范式)：属性不可再分。</p></li><li><p>  2NF(第二范式)：1NF 的基础之上，每一个非主属性完全函数依赖于任何一个候选码，消除了非主属性对于码的部分函数依赖。</p></li><li><p>  3NF(第三范式)：3NF 在 2NF 的基础之上，消除了非主属性对于码的传递函数依赖 。</p></li><li><p> BC范式 BCFN：关系模式R&lt;U,F&gt;中，若每一个决定因素都包含码，则R&lt;U,F&gt;属于BCFN。</p></li></ul><h3 id="DML-语句和-DDL-语句区别是什么"><a href="#DML-语句和-DDL-语句区别是什么" class="headerlink" title="DML 语句和 DDL 语句区别是什么"></a>DML 语句和 DDL 语句区别是什么</h3><ul><li>  DML 是数据库操作语言，主要包括表记录的插入、更新、删除和查询，是开发人员日常使用最频繁的操作。</li><li>  DDL 是数据定义语言，就是对数据库内部的对象进行创建、删除、修改的操作语言。</li></ul><h3 id="数据库设计通常分为哪几步"><a href="#数据库设计通常分为哪几步" class="headerlink" title="数据库设计通常分为哪几步"></a>数据库设计通常分为哪几步</h3><ol><li> <strong>需求分析</strong> : 分析用户的需求，包括数据、功能和性能需求。</li><li> <strong>概念结构设计</strong> : 主要采用 E-R 模型进行设计，包括画 E-R 图。</li><li> <strong>逻辑结构设计</strong> : 通过将 E-R 图转换成表，实现从 E-R 模型到关系模型的转换。</li><li> <strong>物理结构设计</strong> : 主要是为所设计的数据库选择合适的存储结构和存取路径。</li><li> <strong>数据库实施</strong> : 包括编程、测试和试运行</li><li> <strong>数据库的运行和维护</strong> : 系统的运行与数据库的日常维护。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>堆</title>
      <link href="/2022/10/20/dui/"/>
      <url>/2022/10/20/dui/</url>
      
        <content type="html"><![CDATA[<h3 id="1-什么是堆"><a href="#1-什么是堆" class="headerlink" title="1. 什么是堆"></a>1. 什么是堆</h3><p>堆是一种满足以下条件的树：</p><p>堆中的每一个节点值都大于等于（或小于等于）子树中所有节点的值。或者说，任意一个节点的值都大于等于（或小于等于）所有子节点的值。</p><h3 id="2-堆的用途"><a href="#2-堆的用途" class="headerlink" title="2. 堆的用途"></a>2. 堆的用途</h3><p>当我们只关心所有数据中的最大值或者最小值，存在多次获取最大值或者最小值，多次插入或删除数据时，就可以使用堆。</p><p>可能会想到用有序数组，初始化一个有序数组时间复杂度是 <code>O(nlog(n))</code>，查找最大值或者最小值时间复杂度都是 <code>O(1)</code>，但是，涉及到更新（插入或删除）数据时，时间复杂度为 <code>O(n)</code>，即使是使用复杂度为 <code>O(log(n))</code> 的二分法找到要插入或者删除的数据，在移动数据时也需要 <code>O(n)</code> 的时间复杂度。</p><p><strong>相对于有序数组而言，堆的主要优势在于更新数据效率较高。</strong> 堆的初始化时间复杂度为 <code>O(nlog(n))</code>，堆可以做到<code>O(1)</code>时间复杂度取出最大值或者最小值，<code>O(log(n))</code>时间复杂度插入或者删除数据，具体操作在后续章节详细介绍。</p><h3 id="3-堆的分类"><a href="#3-堆的分类" class="headerlink" title="3. 堆的分类"></a>3. 堆的分类</h3><p>堆分为 <strong>最大堆</strong> 和 <strong>最小堆</strong>。二者的区别在于节点的排序方式。</p><ul><li>  <strong>最大堆</strong> ：堆中的每一个节点的值都大于等于子树中所有节点的值</li><li>  <strong>最小堆</strong> ：堆中的每一个节点的值都小于等于子树中所有节点的值</li></ul><p>如下图所示，图1是最大堆，图2是最小堆</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/01.png"></p><h3 id="4-堆的存储"><a href="#4-堆的存储" class="headerlink" title="4. 堆的存储"></a>4. 堆的存储</h3><p>由于完全二叉树的优秀性质，利用数组存储二叉树即节省空间，又方便索引（若根结点的序号为1，那么对于树中任意节点i，其左子节点序号为 <code>2*i</code>，右子节点序号为 <code>2*i+1</code>）。</p><p>为了方便存储和索引，（二叉）堆可以用完全二叉树的形式进行存储。存储的方式如下图所示：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/02.png"></p><h3 id="5-堆的操作"><a href="#5-堆的操作" class="headerlink" title="5. 堆的操作"></a>5. 堆的操作</h3><p>堆的更新操作主要包括两种 : <strong>插入元素</strong> 和 <strong>删除堆顶元素</strong>。</p><h4 id="插入元素"><a href="#插入元素" class="headerlink" title="插入元素"></a>插入元素</h4><p><strong>1.将要插入的元素放到最后</strong></p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/03.png"></p><p><strong>2.从底向上，如果父结点比该元素小，则该节点和父结点交换，直到无法交换</strong></p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/04.png"></p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/05.png"></p><h4 id="删除堆顶元素"><a href="#删除堆顶元素" class="headerlink" title="删除堆顶元素"></a>删除堆顶元素</h4><p>根据堆的性质可知，最大堆的堆顶元素为所有元素中最大的，最小堆的堆顶元素是所有元素中最小的。当我们需要多次查找最大元素或者最小元素的时候，可以利用堆来实现。</p><p>删除堆顶元素后，为了保持堆的性质，需要对堆的结构进行调整，我们将这个过程称之为”<strong>堆化</strong>“，堆化的方法分为两种：</p><ul><li>  一种是自底向上的堆化，上述的插入元素所使用的就是自底向上的堆化，元素从最底部向上移动。</li><li>  另一种是自顶向下堆化，元素由最顶部向下移动。</li></ul><h5 id="自底向上堆化"><a href="#自底向上堆化" class="headerlink" title="自底向上堆化"></a>自底向上堆化</h5><p>首先删除堆顶元素，使得数组中下标为1的位置空出。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/06.png"></p><p>比较根结点的左子节点和右子节点，也就是下标为2,3的数组元素，将较大的元素填充到根结点(下标为1)的位置<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/07.png"></p><p>一直循环比较空出位置的左右子节点，并将较大者移至空位，直到堆的最底部<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/08.png"></p><p>这个时候已经完成了自底向上的堆化，没有元素可以填补空缺了，但是，我们可以看到数组中出现了“气泡”，这会导致存储空间的浪费。接下来我们试试自顶向下堆化。</p><h5 id="自顶向下堆化"><a href="#自顶向下堆化" class="headerlink" title="自顶向下堆化"></a>自顶向下堆化</h5><p>自顶向下的堆化用一个词形容就是“石沉大海”，那么第一件事情，就是把石头抬起来，从海面扔下去。这个石头就是堆的最后一个元素，我们将最后一个元素移动到堆顶。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/09.png"></p><p>然后开始将这个石头沉入海底，不停与左右子节点的值进行比较，和较大的子节点交换位置，直到无法交换位置。<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/10.png"></p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/11.png"></p><h4 id="堆的操作总结"><a href="#堆的操作总结" class="headerlink" title="堆的操作总结"></a>堆的操作总结</h4><ul><li>  <strong>插入元素</strong> ：先将元素放至数组末尾，再自底向上堆化，将末尾元素上浮</li><li>  <strong>删除堆顶元素</strong> ：删除堆顶元素，将末尾元素放至堆顶，再自顶向下堆化，将堆顶元素下沉。也可以自底向上堆化，只是会产生“气泡”，浪费存储空间。最好采用自顶向下堆化的方式。</li></ul><h3 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h3><p>堆排序的过程分为两步：</p><ul><li>  第一步是建堆，将一个无序的数组建立为一个堆</li><li>  第二步是排序，将堆顶元素取出，然后对剩下的元素进行堆化，反复迭代，直到所有元素被取出为止。</li></ul><h4 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h4><p>如果你已经足够了解堆化的过程，那么建堆的过程掌握起来就比较容易了。建堆的过程就是一个对所有非叶节点的自顶向下堆化过程。</p><p>首先要了解哪些是非叶节点，最后一个节点的父结点及它之前的元素，都是非叶节点。也就是说，如果节点个数为n，那么我们需要对n/2到1的节点进行自顶向下（沉底）堆化。</p><p>具体过程如下图：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/12.png"></p><p>将初始的无序数组抽象为一棵树，图中的节点个数为6，所以4,5,6节点为叶节点，1,2,3节点为非叶节点，所以要对1-3号节点进行自顶向下（沉底）堆化，注意，顺序是从后往前堆化，从3号节点开始，一直到1号节点。 3号节点堆化结果：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/13.png"></p><p>2号节点堆化结果：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/14.png"></p><p>1号节点堆化结果：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/15.png"></p><p>至此，数组所对应的树已经成为了一个最大堆</p><h4 id="排序"><a href="#排序" class="headerlink" title="排序"></a>排序</h4><p>由于堆顶元素是所有元素中最大的，所以我们重复取出堆顶元素，将这个最大的堆顶元素放至数组末尾，并对剩下的元素进行堆化即可。</p><p>我们需要执行自顶向下（沉底）堆化，这个堆化一开始要将末尾元素移动至堆顶，这个时候末尾的位置就空出来了，由于堆中元素已经减小，这个位置不会再被使用，所以我们可以将取出的元素放在末尾。</p><p>这其实是做了一次交换操作，将堆顶和末尾元素调换位置，从而将取出堆顶元素和堆化的第一步(将末尾元素放至根结点位置)进行合并。</p><p>取出第一个元素并堆化：<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/16.png"><br>取出第二个元素并堆化：<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/17.png"><br>取出第三个元素并堆化：<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/18.png"><br>取出第四个元素并堆化：<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/19.png"></p><p>取出第五个元素并堆化：<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/20.png"><br>取出第六个元素并堆化：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8403/21.png"></p><p>堆排序完成</p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构(补档)</title>
      <link href="/2022/10/20/shu-ju-jie-gou-bu-dang/"/>
      <url>/2022/10/20/shu-ju-jie-gou-bu-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="红黑树"><a href="#红黑树" class="headerlink" title="红黑树"></a>红黑树</h3><p><strong>红黑树特点</strong> :</p><ol><li> 每个节点非红即黑；</li><li> 根节点总是黑色的；</li><li> 每个叶子节点都是黑色的空节点（NIL节点）；</li><li> 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li> 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol><p><strong>红黑树的应用</strong> ：TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。</p><p><strong>为什么要用红黑树？</strong> 简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p><h3 id="B树和B-树"><a href="#B树和B-树" class="headerlink" title="B树和B+树"></a>B树和B+树</h3><h4 id="B树概念"><a href="#B树概念" class="headerlink" title="B树概念"></a>B树概念</h4><p>B树也称B-树,它是一颗多路平衡查找树。</p><p>阶数表示了一个节点最多有多少个孩子节点，一般用字母m表示阶数。</p><ul><li>  每个节点最多有m-1个<strong>关键字</strong>（可以存有的键值对）。</li><li>  根节点最少可以只有1个<strong>关键字</strong>。</li><li>  非根节点至少有m/2个<strong>关键字</strong>。</li><li>  每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>  所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</li><li>  每个节点都存有索引和数据，也就是对应的key和value。</li></ul><p>所以，根节点的<strong>关键字</strong>数量范围：<code>1 &lt;= k &lt;= m-1</code>，非根节点的<strong>关键字</strong>数量范围：<code>m/2 &lt;= k &lt;= m-1</code>。</p><h4 id="B-树概念"><a href="#B-树概念" class="headerlink" title="B+树概念"></a>B+树概念</h4><p>B+树和B树非常相似，<strong>相同点</strong>。</p><ul><li>  根节点至少一个元素</li><li>  非根节点元素范围：m/2 &lt;= k &lt;= m-1</li></ul><p><strong>不同点</strong>。</p><ul><li>  B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。</li><li>  每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</li><li>  父节点存有右孩子的第一个元素的索引。</li></ul><h4 id="B-树和B-树的区别"><a href="#B-树和B-树的区别" class="headerlink" title="B-树和B+树的区别"></a>B-树和B+树的区别</h4><p><strong>1.B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。</strong></p><p><strong>2. B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。</strong></p><p><strong>3.B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>树</title>
      <link href="/2022/10/19/shu/"/>
      <url>/2022/10/19/shu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-树的基本概念"><a href="#1-树的基本概念" class="headerlink" title="1. 树的基本概念"></a>1. 树的基本概念</h3><p>树就是一种类似现实生活中的树的数据结构（倒置的树）。任何一颗非空树只有一个根节点。</p><p>一棵树具有以下特点：</p><ol><li> 一棵树中的任意两个结点有且仅有唯一的一条路径连通。</li><li> 一棵树如果有 n 个结点，那么它一定恰好有 n-1 条边。</li><li> 一棵树不包含回路。</li></ol><p>下图就是一颗树，并且是一颗二叉树。<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/08.png"></p><p>如上图所示，通过上面这张图说明一下树中的常用概念：</p><ul><li>  <strong>节点</strong> ：树中的每个元素都可以统称为节点。</li><li>  <strong>根节点</strong> ：顶层节点或者说没有父节点的节点。上图中 A 节点就是根节点。</li><li>  <strong>父节点</strong> ：若一个节点含有子节点，则这个节点称为其子节点的父节点。上图中的 B 节点是 D 节点、E 节点的父节点。</li><li>  <strong>子节点</strong> ：一个节点含有的子树的根节点称为该节点的子节点。上图中 D 节点、E 节点是 B 节点的子节点。</li><li>  <strong>兄弟节点</strong> ：具有相同父节点的节点互称为兄弟节点。上图中 D 节点、E 节点的共同父节点是 B 节点，故 D 和 E 为兄弟节点。</li><li>  <strong>叶子节点</strong> ：没有子节点的节点。上图中的 D、F、H、I 都是叶子节点。</li><li>  <strong>节点的高度</strong> ：该节点到叶子节点的最长路径所包含的边数。</li><li>  <strong>节点的深度</strong> ：根节点到该节点的路径所包含的边数</li><li>  <strong>节点的层数</strong> ：节点的深度+1。</li><li>  <strong>树的高度</strong> ：根节点的高度。</li></ul><h3 id="2-二叉树的分类"><a href="#2-二叉树的分类" class="headerlink" title="2. 二叉树的分类"></a>2. 二叉树的分类</h3><p><strong>二叉树</strong>（Binary tree）是每个节点最多只有两个分支（即不存在分支度大于 2 的节点）的树结构。</p><p><strong>二叉树</strong> 的分支通常被称作“<strong>左子树</strong>”或“<strong>右子树</strong>”。并且，<strong>二叉树</strong> 的分支具有左右次序，不能随意颠倒。</p><h4 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h4><p>一个二叉树，如果每一个层的结点数都达到最大值，则这个二叉树就是&nbsp;<strong>满二叉树</strong>。也就是说，如果一个二叉树的层数为 K，且结点总数是(2^k) -1 ，则它就是&nbsp;<strong>满二叉树</strong>。如下图所示：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/09.png"></p><h4 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h4><p>除最后一层外，若其余层都是满的，并且最后一层或者是满的，或者是在右边缺少连续若干节点，则这个二叉树就是 <strong>完全二叉树</strong> 。</p><p>大家可以想象为一棵树从根结点开始扩展，扩展完左子节点才能开始扩展右子节点，每扩展完一层，才能继续扩展下一层。如下图所示：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/10.png"></p><p>完全二叉树有一个很好的性质：<strong>父结点和子节点的序号有着对应关系。</strong></p><p>当根节点的值为 1 的情况下，若父结点的序号是 i，那么左子节点的序号就是 2i，右子节点的序号是 2i+1。这个性质使得完全二叉树利用数组存储时可以极大地节省空间，以及利用序号找到某个节点的父结点和子节点</p><h4 id="平衡二叉树"><a href="#平衡二叉树" class="headerlink" title="平衡二叉树"></a>平衡二叉树</h4><p><strong>平衡二叉树</strong> 是一棵二叉排序树，且具有以下性质：</p><ol><li> 可以是一棵空树</li><li> 如果不是空树，它的左右两个子树的高度差的绝对值不超过 1，并且左右两个子树都是一棵平衡二叉树。</li></ol><p>平衡二叉树的常用实现方法有 <strong>红黑树</strong>、<strong>AVL 树</strong>、<strong>替罪羊树</strong>、<strong>加权平衡树</strong>、<strong>伸展树</strong> 等。</p><h3 id="3-二叉树的存储"><a href="#3-二叉树的存储" class="headerlink" title="3. 二叉树的存储"></a>3. 二叉树的存储</h3><p>二叉树的存储主要分为 <strong>链式存储</strong> 和 <strong>顺序存储</strong> 两种：</p><h4 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h4><p>和链表类似，二叉树的链式存储依靠指针将各个节点串联起来，不需要连续的存储空间。</p><p>每个节点包括三个属性：</p><ul><li>  数据 data。data 不一定是单一的数据，根据不同情况，可以是多个具有不同类型的数据。</li><li>  左节点指针 left</li><li>  右节点指针 right。<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/11.png"></li></ul><h4 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h4><p>顺序存储就是利用数组进行存储，数组中的每一个位置仅存储节点的 data，不存储左右子节点的指针，子节点的索引通过数组下标完成。根结点的序号为 1，对于每个节点 Node，假设它存储在数组中下标为 i 的位置，那么它的左子节点就存储在 2i 的位置，它的右子节点存储在下标为 2i+1 的位置。</p><p>一棵完全二叉树的数组顺序存储如下图所示：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/12.png"></p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/13.png"></p><p>如果我们要存储的二叉树不是完全二叉树，在数组中就会出现空隙，导致内存利用率降低</p><h3 id="4-二叉树的遍历"><a href="#4-二叉树的遍历" class="headerlink" title="4. 二叉树的遍历"></a>4. 二叉树的遍历</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/14.png"></p><p>二叉树的先序遍历，就是先输出根结点，再遍历左子树，最后遍历右子树，遍历左子树和右子树的时候，同样遵循先序遍历的规则，也就是说，我们可以递归实现先序遍历。</p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">preOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span>system<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">preOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>二叉树的中序遍历，就是先递归中序遍历左子树，再输出根结点的值，再递归中序遍历右子树</p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">inOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>system<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">inOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/15.png"></p><p>二叉树的后序遍历，就是先递归后序遍历左子树，再递归后序遍历右子树，最后输出根结点的值</p><p>代码如下：</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">postOrder</span><span class="token punctuation">(</span><span class="token class-name">TreeNode</span> root<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">if</span><span class="token punctuation">(</span>root <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token function">postOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token function">postOrder</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>system<span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="5-红黑树"><a href="#5-红黑树" class="headerlink" title="5. 红黑树"></a>5. 红黑树</h3><p><strong>红黑树特点</strong> :</p><ol><li> 每个节点非红即黑；</li><li> 根节点总是黑色的；</li><li> 每个叶子节点都是黑色的空节点（NIL节点）；</li><li> 如果节点是红色的，则它的子节点必须是黑色的（反之不一定）；</li><li> 从根节点到叶节点或空子节点的每条路径，必须包含相同数目的黑色节点（即相同的黑色高度）。</li></ol><p><strong>红黑树的应用</strong> ：TreeMap、TreeSet以及JDK1.8的HashMap底层都用到了红黑树。</p><p><strong>为什么要用红黑树？</strong> 简单来说红黑树就是为了解决二叉查找树的缺陷，因为二叉查找树在某些情况下会退化成一个线性结构。</p><p>详细了解： <a href="https://juejin.im/post/5a27c6946fb9a04509096248#comment">漫画：什么是红黑树？</a></p><h3 id="6-B树和B-树"><a href="#6-B树和B-树" class="headerlink" title="6. B树和B+树"></a>6. B树和B+树</h3><h4 id="B树概念"><a href="#B树概念" class="headerlink" title="B树概念"></a>B树概念</h4><p>B树也称B-树,它是一颗多路平衡查找树。二叉树我想大家都不陌生，其实，B树和后面讲到的B+树也是从最简单的二叉树变换而来的</p><ul><li>  每个节点最多有m-1个<strong>关键字</strong>（可以存有的键值对）。</li><li>  根节点最少可以只有1个<strong>关键字</strong>。</li><li>  非根节点至少有m/2个<strong>关键字</strong>。</li><li>  每个节点中的关键字都按照从小到大的顺序排列，每个关键字的左子树中的所有关键字都小于它，而右子树中的所有关键字都大于它。</li><li>  所有叶子节点都位于同一层，或者说根节点到每个叶子节点的长度都相同。</li><li>  每个节点都存有索引和数据，也就是对应的key和value。</li></ul><p>所以，根节点的<strong>关键字</strong>数量范围：<code>1 &lt;= k &lt;= m-1</code>，非根节点的<strong>关键字</strong>数量范围：<code>m/2 &lt;= k &lt;= m-1</code>。</p><p>另外，我们需要注意一个概念，描述一颗B树时需要指定它的阶数，阶数表示了一个节点最多有多少个孩子节点，一般用字母m表示阶数。</p><p>我们再举个例子来说明一下上面的概念，比如这里有一个5阶的B树，根节点数量范围：1 &lt;= k &lt;= 4，非根节点数量范围：2 &lt;= k &lt;= 4。</p><h4 id="B-树概念"><a href="#B-树概念" class="headerlink" title="B+树概念"></a>B+树概念</h4><p>B+树其实和B树是非常相似的，我们首先看看<strong>相同点</strong>。</p><ul><li>  根节点至少一个元素</li><li>  非根节点元素范围：m/2 &lt;= k &lt;= m-1</li></ul><p><strong>不同点</strong>。</p><ul><li>  B+树有两种类型的节点：内部结点（也称索引结点）和叶子结点。内部节点就是非叶子节点，内部节点不存储数据，只存储索引，数据都存储在叶子节点。</li><li>  每个叶子结点都存有相邻叶子结点的指针，叶子结点本身依关键字的大小自小而大顺序链接。</li><li>  父节点存有右孩子的第一个元素的索引。</li></ul><h4 id="B-树和B-树的区别"><a href="#B-树和B-树的区别" class="headerlink" title="B-树和B+树的区别"></a>B-树和B+树的区别</h4><p><strong>1.B+树内节点不存储数据，所有 data 存储在叶节点导致查询时间复杂度固定为 log n。而B-树查询时间复杂度不固定，与 key 在树中的位置有关，最好为O(1)。</strong></p><p><strong>2. B+树叶节点两两相连可大大增加区间访问性，可使用在范围查询等，而B-树每个节点 key 和 data 在一起，则无法区间查找。</strong></p><p><strong>3.B+树更适合外部存储。由于内节点无 data 域，每个节点能索引的范围更大更精确</strong></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>图</title>
      <link href="/2022/10/18/tu/"/>
      <url>/2022/10/18/tu/</url>
      
        <content type="html"><![CDATA[<h3 id="1-图的基本概念"><a href="#1-图的基本概念" class="headerlink" title="1. 图的基本概念"></a>1. 图的基本概念</h3><p>图就是由顶点的有穷非空集合和顶点之间的边组成的集合。通常表示为：**G(V,E)**，其中，G表示一个图，V表示顶点的集合，E表示边的集合。</p><h4 id="顶点"><a href="#顶点" class="headerlink" title="顶点"></a>顶点</h4><p>图中的数据元素，我们称之为顶点，图至少有一个顶点（非空有穷集合）</p><p>对应到好友关系图，每一个用户就代表一个顶点。</p><h4 id="边"><a href="#边" class="headerlink" title="边"></a>边</h4><p>顶点之间的关系用边表示。</p><p>对应到好友关系图，两个用户是好友的话，那两者之间就存在一条边。</p><h4 id="度"><a href="#度" class="headerlink" title="度"></a>度</h4><p>度表示一个顶点包含多少条边，在有向图中，还分为出度和入度，出度表示从该顶点出去的边的条数，入度表示进入该顶点的边的条数。</p><p>对应到好友关系图，度就代表了某个人的好友数量。</p><h4 id="无向图和有向图"><a href="#无向图和有向图" class="headerlink" title="无向图和有向图"></a>无向图和有向图</h4><p>边表示的是顶点之间的关系，有的关系是双向的，比如同学关系，A是B的同学，那么B也肯定是A的同学，那么在表示A和B的关系时，就不用关注方向，用不带箭头的边表示，这样的图就是无向图。</p><p>有的关系是有方向的，比如父子关系，师生关系，微博的关注关系，A是B的爸爸，但B肯定不是A的爸爸，A关注B，B不一定关注A。在这种情况下，我们就用带箭头的边表示二者的关系，这样的图就是有向图。</p><h4 id="无权图和带权图"><a href="#无权图和带权图" class="headerlink" title="无权图和带权图"></a>无权图和带权图</h4><p>对于一个关系，如果我们只关心关系的有无，而不关心关系有多强，那么就可以用无权图表示二者的关系。</p><p>对于一个关系，如果我们既关心关系的有无，也关心关系的强度，比如描述地图上两个城市的关系，需要用到距离，那么就用带权图来表示，带权图中的每一条边一个数值表示权值，代表关系的强度。</p><p>下图就是一个带权有向图。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/12.png"></p><h3 id="2-图的存储"><a href="#2-图的存储" class="headerlink" title="2. 图的存储"></a>2. 图的存储</h3><h4 id="邻接矩阵存储"><a href="#邻接矩阵存储" class="headerlink" title="邻接矩阵存储"></a>邻接矩阵存储</h4><p>邻接矩阵将图用二维矩阵存储，是一种较为直观的表示方式。</p><p>如果第i个顶点和第j个顶点之间有关系，且关系权值为n，则 <code>A[i][j]=n</code> 。</p><p>在无向图中，我们只关心关系的有无，所以当顶点i和顶点j有关系时，<code>A[i][j]</code>=1，当顶点i和顶点j没有关系时，<code>A[i][j]</code>=0。如下图所示：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/13.png"></p><p>值得注意的是：<strong>无向图的邻接矩阵是一个对称矩阵，因为在无向图中，顶点i和顶点j有关系，则顶点j和顶点i必有关系。</strong></p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/14.png"></p><p>邻接矩阵存储的方式优点是简单直接（直接使用一个二维数组即可），并且，在获取两个定点之间的关系的时候也非常高效（直接获取指定位置的数组元素的值即可）。但是，这种存储方式的缺点也比较明显，那就是比较浪费空间</p><h4 id="邻接表存储"><a href="#邻接表存储" class="headerlink" title="邻接表存储"></a>邻接表存储</h4><p>针对上面邻接矩阵比较浪费内存空间的问题，诞生了图的另外一种存储方法—<strong>邻接表</strong> 。</p><p>邻接链表使用一个链表来存储某个顶点的所有后继相邻顶点。对于图中每个顶点Vi，把所有邻接于Vi的顶点Vj链成一个单链表，这个单链表称为顶点Vi的 <strong>邻接表</strong>。如下图所示：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/15.png"></p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/16.png"></p><ul><li>  在无向图中，邻接表元素个数等于边的条数的两倍，如左图所示的无向图中，边的条数为7，邻接表存储的元素个数为14。</li><li>  在有向图中，邻接表元素个数等于边的条数，如右图所示的有向图中，边的条数为8，邻接表存储的元素个数为8。</li></ul><h3 id="3-图的搜索"><a href="#3-图的搜索" class="headerlink" title="3. 图的搜索"></a>3. 图的搜索</h3><h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>广度优先搜索就像水面上的波纹一样一层一层向外扩展，如下图所示：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/17.png"></p><p><strong>广度优先搜索的具体实现方式用到了线性数据结构——队列</strong></p><p>具体过程如下图所示：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/18.png"><br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/18.png"><br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/19.png"><br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/20.png"><br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/21.png"><br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/22.png"><br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/23.png"></p><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>深度优先搜索就是“一条路走到黑”，从源顶点开始，一直走到没有后继节点，才回溯到上一顶点，然后继续“一条路走到黑”，如下图所示：</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/01.png"></p><p><strong>深度优先搜索的具体实现用到了另一种线性数据结构——栈</strong></p><p>具体过程如下图所示：<br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/02.png"><br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/03.png"><br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/04.png"><br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/05.png"><br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/06.png"><br><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%8402/07.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>线性数据结构</title>
      <link href="/2022/10/18/xian-xing-shu-ju-jie-gou/"/>
      <url>/2022/10/18/xian-xing-shu-ju-jie-gou/</url>
      
        <content type="html"><![CDATA[<h3 id="1-数组"><a href="#1-数组" class="headerlink" title="1. 数组"></a>1. 数组</h3><p><strong>数组（Array）</strong> 是一种很常见的数据结构。它由相同类型的元素（element）组成，并且是使用一块连续的内存来存储。</p><p>我们直接可以利用元素的索引（index）可以计算出该元素对应的存储地址。</p><p>数组的特点是：<strong>提供随机访问</strong> 并且容量有限。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">假如数组的长度为 n。访问：O（1）//访问特定位置的元素插入：O（n ）//最坏的情况发生在插入发生在数组的首部并需要移动所有元素时删除：O（n）//最坏的情况发生在删除数组的开头发生并需要移动第一元素后面所有的元素时<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/01.png"></p><h3 id="2-链表"><a href="#2-链表" class="headerlink" title="2. 链表"></a>2. 链表</h3><h4 id="链表简介"><a href="#链表简介" class="headerlink" title="链表简介"></a>链表简介</h4><p><strong>链表（LinkedList）</strong> 虽然是一种线性表，但是并不会按线性的顺序存储数据，使用的不是连续的内存空间来存储数据。</p><p>链表的插入和删除操作的复杂度为 O(1) ，只需要知道目标位置元素的上一个元素即可。但是，在查找一个节点或者访问特定位置的节点的时候复杂度为 O(n) 。</p><p>使用链表结构可以克服数组需要预先知道数据大小的缺点，链表结构可以充分利用计算机内存空间,实现灵活的内存动态管理。但链表不会节省空间，相比于数组会占用更多的空间，因为链表中每个节点存放的还有指向其他节点的指针。除此之外，链表不具有数组随机读取的优点。</p><p><strong>常见链表分类：</strong></p><ol><li> 单链表</li><li> 双向链表</li><li> 循环链表</li><li> 双向循环链表</li></ol><pre class="line-numbers language-text" data-language="text"><code class="language-text">假如链表中有n个元素。访问：O（n）//访问特定位置的元素插入删除：O（1）//必须要要知道插入元素的位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h4><p><strong>单链表</strong> 单向链表只有一个方向，结点只有一个后继指针 next 指向后面的节点。因此，链表这种数据结构通常在物理内存上是不连续的。我们习惯性地把第一个结点叫作头结点，链表通常有一个不保存任何值的 head 节点(头结点)，通过头结点我们可以遍历整个链表。尾结点通常指向 null。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/02.png"></p><h4 id="循环链表"><a href="#循环链表" class="headerlink" title="循环链表"></a>循环链表</h4><p><strong>循环链表</strong>&nbsp;其实是一种特殊的单链表，和单链表不同的是循环链表的尾结点不是指向 null，而是指向链表的头结点。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/03.png"></p><h4 id="双向链表"><a href="#双向链表" class="headerlink" title="双向链表"></a>双向链表</h4><p><strong>双向链表</strong>&nbsp;包含两个指针，一个 prev 指向前一个节点，一个 next 指向后一个节点。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/04.png"></p><h4 id="双向循环链表"><a href="#双向循环链表" class="headerlink" title="双向循环链表"></a>双向循环链表</h4><p><strong>双向循环链表</strong>&nbsp;最后一个节点的 next 指向 head，而 head 的 prev 指向最后一个节点，构成一个环。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/05.png"></p><h4 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h4><ul><li>  如果需要支持随机访问的话，链表没办法做到。</li><li>  如果需要存储的数据元素的个数不确定，并且需要经常添加和删除数据的话，使用链表比较合适。</li><li>  如果需要存储的数据元素的个数确定，并且不需要经常添加和删除数据的话，使用数组比较合适。</li></ul><h4 id="数组-vs-链表"><a href="#数组-vs-链表" class="headerlink" title="数组 vs 链表"></a>数组 vs 链表</h4><ul><li>  数组支持随机访问，而链表不支持。</li><li>  数组使用的是连续内存空间对 CPU 的缓存机制友好，链表则相反。</li><li>  数组的大小固定，而链表则天然支持动态扩容。如果声明的数组过小，需要另外申请一个更大的内存空间存放数组元素，然后将原数组拷贝进去，这个操作是比较耗时的</li></ul><h3 id="3-栈"><a href="#3-栈" class="headerlink" title="3. 栈"></a>3. 栈</h3><h4 id="栈简介"><a href="#栈简介" class="headerlink" title="栈简介"></a>栈简介</h4><p><strong>栈</strong> (stack)只允许在有序的线性数据集合的一端（称为栈顶 top）进行加入数据（push）和移除数据（pop）。因而按照 <strong>后进先出（LIFO, Last In First Out）</strong> 的原理运作。<strong>在栈中，push 和 pop 的操作都发生在栈顶。</strong></p><p>栈常用一维数组或链表来实现，用数组实现的栈叫作 <strong>顺序栈</strong> ，用链表实现的栈叫作 <strong>链式栈</strong> 。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">假设堆栈中有n个元素。访问：O（n）//最坏情况插入删除：O（1）//顶端插入和删除元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/06.png"></p><h4 id="栈的常见应用常见应用场景"><a href="#栈的常见应用常见应用场景" class="headerlink" title="栈的常见应用常见应用场景"></a>栈的常见应用常见应用场景</h4><p>当我们我们要处理的数据只涉及在一端插入和删除数据，并且满足 <strong>后进先出（LIFO, Last In First Out）</strong> 的特性时，我们就可以使用栈这个数据结构。</p><h5 id="实现浏览器的回退和前进功能"><a href="#实现浏览器的回退和前进功能" class="headerlink" title="实现浏览器的回退和前进功能"></a>实现浏览器的回退和前进功能</h5><p>我们只需要使用两个栈(Stack1 和 Stack2)和就能实现这个功能。比如你按顺序查看了 1,2,3,4 这四个页面，我们依次把 1,2,3,4 这四个页面压入 Stack1 中。当你想回头看 2 这个页面的时候，你点击回退按钮，我们依次把 4,3 这两个页面从 Stack1 弹出，然后压入 Stack2 中。假如你又想回到页面 3，你点击前进按钮，我们将 3 页面从 Stack2 弹出，然后压入到 Stack1 中。示例图如下:</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/07.png"></p><h5 id="检查符号是否成对出现"><a href="#检查符号是否成对出现" class="headerlink" title="检查符号是否成对出现"></a>检查符号是否成对出现</h5><blockquote><p>给定一个只包括 <code>'('</code>，<code>')'</code>，<code>'{'</code>，<code>'}'</code>，<code>'['</code>，<code>']'</code> 的字符串，判断该字符串是否有效。</p><p>有效字符串需满足：</p><ol><li> 左括号必须用相同类型的右括号闭合。</li><li> 左括号必须以正确的顺序闭合。</li></ol><p>比如 “()”、”()[]{}”、”{[]}” 都是有效字符串，而 “(]” 、”([)]” 则不是。</p></blockquote><p>这个问题实际是 Leetcode 的一道题目，我们可以利用栈 <code>Stack</code> 来解决这个问题。</p><ol><li> 首先我们将括号间的对应规则存放在 <code>Map</code> 中，这一点应该毋容置疑；</li><li> 创建一个栈。遍历字符串，如果字符是左括号就直接加入<code>stack</code>中，否则将<code>stack</code> 的栈顶元素与这个括号做比较，如果不相等就直接返回 false。遍历结束，如果<code>stack</code>为空，返回 <code>true</code>。</li></ol><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">boolean</span> <span class="token function">isValid</span><span class="token punctuation">(</span><span class="token class-name">String</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>    <span class="token comment">// 括号之间的对应规则</span>    <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> mappings <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">,</span> <span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token char">')'</span><span class="token punctuation">,</span> <span class="token char">'('</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token char">'}'</span><span class="token punctuation">,</span> <span class="token char">'{'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    mappings<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token char">']'</span><span class="token punctuation">,</span> <span class="token char">'['</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span> stack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Stack</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Character</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">char</span><span class="token punctuation">[</span><span class="token punctuation">]</span> chars <span class="token operator">=</span> s<span class="token punctuation">.</span><span class="token function">toCharArray</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> chars<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>mappings<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token keyword">char</span> topElement <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">empty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">?</span> <span class="token char">'#'</span> <span class="token operator">:</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>topElement <span class="token operator">!=</span> mappings<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>            <span class="token punctuation">}</span>        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>            stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>chars<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token keyword">return</span> stack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h5 id="反转字符串"><a href="#反转字符串" class="headerlink" title="反转字符串"></a>反转字符串</h5><p>将字符串中的每个字符先入栈再出栈就可以了。</p><h5 id="维护函数调用"><a href="#维护函数调用" class="headerlink" title="维护函数调用"></a>维护函数调用</h5><p>最后一个被调用的函数必须先完成执行，符合栈的 <strong>后进先出（LIFO, Last In First Out）</strong> 特性。</p><h4 id="栈的实现"><a href="#栈的实现" class="headerlink" title="栈的实现"></a>栈的实现</h4><p>栈既可以通过数组实现，也可以通过链表来实现。不管基于数组还是链表，入栈、出栈的时间复杂度都为 O(1)。</p><p>下面我们使用数组来实现一个栈，并且这个栈具有<code>push()</code>、<code>pop()</code>（返回栈顶元素并出栈）、<code>peek()</code> （返回栈顶元素不出栈）、<code>isEmpty()</code>、<code>size()</code>这些基本的方法。</p><blockquote><p>提示：每次入栈之前先判断栈的容量是否够用，如果不够用就用<code>Arrays.copyOf()</code>进行扩容；</p></blockquote><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MyStack</span> <span class="token punctuation">{</span>    <span class="token keyword">private</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> storage<span class="token punctuation">;</span><span class="token comment">//存放栈中元素的数组</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span><span class="token comment">//栈的容量</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> count<span class="token punctuation">;</span><span class="token comment">//栈中元素数量</span>    <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token keyword">int</span> <span class="token constant">GROW_FACTOR</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>    <span class="token comment">//不带初始容量的构造方法。默认容量为8</span>    <span class="token keyword">public</span> <span class="token class-name">MyStack</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>storage<span class="token operator">=</span><span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//带初始容量的构造方法</span>    <span class="token keyword">public</span> <span class="token class-name">MyStack</span><span class="token punctuation">(</span><span class="token keyword">int</span> initialCapacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>initialCapacity <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Capacity too small."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> initialCapacity<span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>storage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span>initialCapacity<span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token keyword">this</span><span class="token punctuation">.</span>count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//入栈</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">push</span><span class="token punctuation">(</span><span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>            <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>        storage<span class="token punctuation">[</span>count<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//确保容量大小</span>    <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">ensureCapacity</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> newCapacity <span class="token operator">=</span> capacity <span class="token operator">*</span> <span class="token constant">GROW_FACTOR</span><span class="token punctuation">;</span>        storage <span class="token operator">=</span> <span class="token class-name">Arrays</span><span class="token punctuation">.</span><span class="token function">copyOf</span><span class="token punctuation">(</span>storage<span class="token punctuation">,</span> newCapacity<span class="token punctuation">)</span><span class="token punctuation">;</span>        capacity <span class="token operator">=</span> newCapacity<span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//返回栈顶元素并出栈</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Stack is empty."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        count<span class="token operator">--</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> storage<span class="token punctuation">[</span>count<span class="token punctuation">]</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//返回栈顶元素不出栈</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"Stack is empty."</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token punctuation">{</span>            <span class="token keyword">return</span> storage<span class="token punctuation">[</span>count<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>        <span class="token punctuation">}</span>    <span class="token punctuation">}</span>    <span class="token comment">//判断栈是否为空</span>    <span class="token keyword">private</span> <span class="token keyword">boolean</span> <span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> count <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span>    <span class="token comment">//返回栈中元素的个数</span>    <span class="token keyword">private</span> <span class="token keyword">int</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">return</span> count<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>验证</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token class-name">MyStack</span> myStack <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyStack</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>myStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myStack<span class="token punctuation">.</span><span class="token function">peek</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//8</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myStack<span class="token punctuation">.</span><span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//8</span><span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> <span class="token number">8</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>    <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>myStack<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>myStack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//报错：java.lang.IllegalArgumentException: Stack is empty.</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="4-队列"><a href="#4-队列" class="headerlink" title="4. 队列"></a>4. 队列</h3><h4 id="队列简介"><a href="#队列简介" class="headerlink" title="队列简介"></a>队列简介</h4><p><strong>队列</strong> 是 <strong>先进先出( FIFO，First In, First Out)</strong> 的线性表。在具体应用中通常用链表或者数组来实现，用数组实现的队列叫作 <strong>顺序队列</strong> ，用链表实现的队列叫作 <strong>链式队列</strong> 。<strong>队列只允许在后端（rear）进行插入操作也就是 入队 enqueue，在前端（front）进行删除操作也就是出队 dequeue</strong></p><p>队列的操作方式和堆栈类似，唯一的区别在于队列只允许新数据在后端进行添加。</p><pre class="line-numbers language-text" data-language="text"><code class="language-text">假设队列中有n个元素。访问：O（n）//最坏情况插入删除：O（1）//后端插入前端删除元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/08.png"></p><h4 id="队列分类"><a href="#队列分类" class="headerlink" title="队列分类"></a>队列分类</h4><h5 id="单队列"><a href="#单队列" class="headerlink" title="单队列"></a>单队列</h5><p>单队列就是常见的队列, 每次添加元素时，都是添加到队尾。单队列又分为 <strong>顺序队列（数组实现）</strong> 和 <strong>链式队列（链表实现）</strong>。</p><p><strong>顺序队列存在“假溢出”的问题也就是明明有位置却不能添加的情况。</strong></p><p>假设下图是一个顺序队列，我们将前两个元素 1,2 出队，并入队两个元素 7,8。当进行入队、出队操作的时候，front 和 rear 都会持续往后移动，当 rear 移动到最后的时候,我们无法再往队列中添加数据，即使数组中还有空余空间，这种现象就是 <strong>”假溢出“</strong> 。除了假溢出问题之外，如下图所示，当添加元素 8 的时候，rear 指针移动到数组之外（越界）。</p><blockquote><p>为了避免当只有一个元素的时候，队头和队尾重合使处理变得麻烦，所以引入两个指针，front 指针指向对头元素，rear 指针指向队列最后一个元素的下一个位置，这样当 front 等于 rear 时，此队列不是还剩一个元素，而是空队列。——From 《大话数据结构》</p></blockquote><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/09.png"></p><h5 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h5><p>循环队列可以解决顺序队列的假溢出和越界问题。解决办法就是：从头开始，这样也就会形成头尾相接的循环，这也就是循环队列名字的由来。</p><p>还是用上面的图，我们将 rear 指针指向数组下标为 0 的位置就不会有越界问题了。当我们再向队列中添加元素的时候， rear 向后移动。</p><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/10.png"></p><p>顺序队列中，我们说 <code>front==rear</code> 的时候队列为空，循环队列中则不一样，也可能为满，如上图所示。解决办法有两种：</p><ol><li> 可以设置一个标志变量 <code>flag</code>,当 <code>front==rear</code> 并且 <code>flag=0</code> 的时候队列为空，当<code>front==rear</code> 并且 <code>flag=1</code> 的时候队列为满。</li><li> 队列为空的时候就是 <code>front==rear</code> ，队列满的时候，我们保证数组还有一个空闲的位置，rear 就指向这个空闲位置，如下图所示，那么现在判断队列是否为满的条件就是： <code>(rear+1) % QueueSize= front</code> 。</li></ol><p><img src="/images/image_%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/11.png"></p><h4 id="常见应用场景"><a href="#常见应用场景" class="headerlink" title="常见应用场景"></a>常见应用场景</h4><p>当我们需要按照一定顺序来处理数据的时候可以考虑使用队列这个数据结构。</p><ul><li>  <strong>阻塞队列：</strong> 阻塞队列可以看成在队列基础上加了阻塞操作的队列。当队列为空的时候，出队操作阻塞，当队列满的时候，入队操作阻塞。使用阻塞队列我们可以很容易实现“生产者 - 消费者“模型。</li><li>  <strong>线程池中的请求/任务队列：</strong> 线程池中没有空闲线程时，新的任务请求线程资源时，线程池该如何处理呢？答案是将这些请求放在队列中，当有空闲线程的时候，会循环中反复从队列中获取任务来执行。队列分为无界队列(基于链表)和有界队列(基于数组)。无界队列的特点就是可以一直入列，除非系统资源耗尽，比如 ：<code>FixedThreadPool</code> 使用无界队列 <code>LinkedBlockingQueue</code>。但是有界队列就不一样了，当队列满的话后面再有任务/请求就会拒绝，在 Java 中的体现就是会抛出<code>java.util.concurrent.RejectedExecutionException</code> 异常。</li><li>  Linux 内核进程队列（按优先级排队）</li><li>  现实生活中的派对，播放器上的播放列表;</li><li>  消息队列</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>排序算法</title>
      <link href="/2022/10/15/pai-xu-suan-fa-bu-dang/"/>
      <url>/2022/10/15/pai-xu-suan-fa-bu-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><ul><li>  <strong>内部排序</strong> ：数据记录在内存中进行排序。</li><li>  <strong>外部排序</strong>：因排序的数据很大，一次不能容纳全部的排序记录，在排序过程中需要访问外存。</li></ul><p>常见的内部排序算法有：<strong>插入排序</strong>、<strong>希尔排序</strong>、<strong>选择排序</strong>、<strong>冒泡排序</strong>、<strong>归并排序</strong>、<strong>快速排序</strong>、<strong>堆排序</strong>、<strong>基数排序</strong>等</p><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/01.png"></p><p>稳定：冒泡排序、插入排序、归并排序<br>不稳定：快速排序、希尔排序、选择排序、堆排序</p><p><strong>图片名词解释：</strong></p><ul><li>  <strong>n</strong>：数据规模</li><li>  <strong>k</strong>：“桶” 的个数</li><li>  <strong>In-place</strong>：占用常数内存，不占用额外内存</li><li>  <strong>Out-place</strong>：占用额外内存</li></ul><p><strong>术语说明</strong></p><ul><li>  <strong>稳定</strong>：如果 A 原本在 B 前面，而 A=B，排序之后 A 仍然在 B 的前面。</li><li>  <strong>不稳定</strong>：如果 A 原本在 B 的前面，而 A=B，排序之后 A 可能会出现在 B 的后面。</li><li>  <strong>内排序</strong>：所有排序操作都在内存中完成。</li><li>  <strong>外排序</strong>：由于数据太大，因此把数据放在磁盘中，而排序通过磁盘和内存的数据传输才能进行。</li><li>  <strong>时间复杂度</strong>： 定性描述一个算法执行所耗费的时间。</li><li>  <strong>空间复杂度</strong>：定性描述一个算法执行所需内存的大小<br><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/02.png"></li></ul><h3 id="冒泡排序-Bubble-Sort"><a href="#冒泡排序-Bubble-Sort" class="headerlink" title="冒泡排序 (Bubble Sort)"></a>冒泡排序 (Bubble Sort)</h3><p>冒泡排序是一种简单的排序算法。它重复地遍历要排序的序列，依次比较两个元素，如果它们的顺序错误就把它们交换过来。遍历序列的工作是重复地进行直到没有再需要交换为止，此时说明该序列已经排序完成。这个算法的名字由来是因为越小的元素会经由交换慢慢 “浮” 到数列的顶端。</p><h4 id="算法步骤"><a href="#算法步骤" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li> 比较相邻的元素。如果第一个比第二个大，就交换它们两个；</li><li> 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对，这样在最后的元素应该会是最大的数；</li><li> 针对所有的元素重复以上的步骤，除了最后一个；</li><li> 重复步骤 1~3，直到排序完成。</li></ol><h4 id="图解算法"><a href="#图解算法" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/03.gif"></p><h4 id="算法分析"><a href="#算法分析" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong>：稳定</li><li>  <strong>时间复杂度</strong>&nbsp;：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li><li>  <strong>空间复杂度</strong>&nbsp;：O(1)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">bubbleSort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">int</span> n <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>      <span class="token keyword">boolean</span> swapped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> n <span class="token operator">-</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> swapped<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          swapped <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> j <span class="token operator">&lt;</span> n <span class="token operator">-</span> i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token comment">// 交换相邻元素  </span>                <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>                  arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>                  arr<span class="token punctuation">[</span>j <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>                  swapped <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="选择排序-Selection-Sort"><a href="#选择排序-Selection-Sort" class="headerlink" title="选择排序 (Selection Sort)"></a>选择排序 (Selection Sort)</h3><p>选择排序是一种简单直观的排序算法，无论什么数据进去都是 <code>O(n²)</code> 的时间复杂度。</p><p>它的工作原理：首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置，然后，再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。以此类推，直到所有元素均排序完毕。</p><h4 id="算法步骤-1"><a href="#算法步骤-1" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li> 首先在未排序序列中找到最小（大）元素，存放到排序序列的起始位置</li><li> 再从剩余未排序元素中继续寻找最小（大）元素，然后放到已排序序列的末尾。</li><li> 重复第 2 步，直到所有元素均排序完毕。</li></ol><h4 id="图解算法-1"><a href="#图解算法-1" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/04.gif"></p><h4 id="算法分析-1"><a href="#算法分析-1" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong>：不稳定</li><li>  <strong>时间复杂度</strong> ：最佳：O(n2) ，最差：O(n2)， 平均：O(n2)</li><li>  <strong>空间复杂度</strong> ：O(1)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">int</span> minIdx <span class="token operator">=</span> i<span class="token punctuation">;</span>          <span class="token comment">// 在数组区间[i+1,j]中找出一个最小（比arr[i]还小的）的，记录其下标为minIdx  </span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> i<span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>minIdx<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>                  minIdx <span class="token operator">=</span> j<span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>          <span class="token comment">// 当minIdx发生变动，证明数组区间[i+1,j]中有比arr[i]小的值，进行交换  </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>minIdx <span class="token operator">!=</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment">// 交换数组arr中下标为i和minIdx的值  </span>            <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> minIdx<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>      arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="插入排序-Insertion-Sort"><a href="#插入排序-Insertion-Sort" class="headerlink" title="插入排序 (Insertion Sort)"></a>插入排序 (Insertion Sort)</h3><p>插入排序是一种简单直观的排序算法。</p><p>它的工作原理是通过构建有序序列，对于未排序数据，在已排序序列中从后向前扫描，找到相应位置并插入。扑克牌抓牌</p><h4 id="算法步骤-2"><a href="#算法步骤-2" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li> 从第一个元素开始，该元素可以认为已经被排序；</li><li> 取出下一个元素，在已经排序的元素序列中从后向前扫描；</li><li> 如果该元素（已排序）大于新元素，将该元素移到下一位置；</li><li> 重复步骤 3，直到找到已排序的元素小于或者等于新元素的位置；</li><li> 将新元素插入到该位置后；</li><li> 重复步骤 2~5。<h4 id="图解算法-2"><a href="#图解算法-2" class="headerlink" title="图解算法"></a>图解算法</h4></li></ol><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/05.gif"></p><h4 id="算法分析-2"><a href="#算法分析-2" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong>：稳定</li><li>  <strong>时间复杂度</strong> ：最佳：O(n) ，最差：O(n2)， 平均：O(n2)</li><li>  <strong>空间复杂度</strong> ：O(1)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> arr<span class="token punctuation">.</span>length <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">// 每趟插入排序前，数组区间[0,i]经过上一趟插入排序处理后，是有序的  </span>        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token comment">// 数组元素交换  </span>            <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> j <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>      arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="希尔排序-Shell-Sort"><a href="#希尔排序-Shell-Sort" class="headerlink" title="希尔排序 (Shell Sort)"></a>希尔排序 (Shell Sort)</h3><p>希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为递减增量排序算法</p><p>希尔排序的基本思想是：先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录 “基本有序” 时，再对全体记录进行依次直接插入排序。</p><h4 id="算法步骤-3"><a href="#算法步骤-3" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>我们来看下希尔排序的基本步骤，在此我们选择增量 <code>gap=length/2</code>，缩小增量继续以 <code>gap = gap/2</code> 的方式，这种增量选择我们可以用一个序列来表示，<code>{n/2, (n/2)/2, ..., 1}</code>，称为<strong>增量序列</strong>。</p><p>先将整个待排序的记录序列分割成为若干子序列分别进行直接插入排序，具体算法描述：</p><ul><li>  选择一个增量序列 <code>{t1, t2, …, tk}</code>，其中 <code>(ti&gt;tj, i&lt;j, tk=1)</code>；</li><li>  按增量序列个数 k，对序列进行 k 趟排序；</li><li>  每趟排序，根据对应的增量 <code>t</code>，将待排序列分割成若干长度为 <code>m</code> 的子序列，分别对各子表进行直接插入排序。仅增量因子为 1 时，整个序列作为一个表来处理，表长度即为整个序列的长度。</li></ul><h4 id="图解算法-3"><a href="#图解算法-3" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/06.png"></p><h4 id="算法分析-3"><a href="#算法分析-3" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong>：不稳定</li><li>  <strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(n2) 平均：O(nlogn)</li><li>  <strong>空间复杂度</strong> ：<code>O(1)</code></li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>      <span class="token keyword">int</span> incr <span class="token operator">=</span> len<span class="token punctuation">;</span>      <span class="token keyword">while</span><span class="token punctuation">(</span>incr <span class="token operator">&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token comment">// 每趟希尔排序，都让增量的值折半  </span>        incr <span class="token operator">/=</span> <span class="token number">2</span><span class="token punctuation">;</span>          <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> incr<span class="token punctuation">;</span>i <span class="token operator">&lt;</span> len<span class="token punctuation">;</span><span class="token operator">++</span>i<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;</span> arr<span class="token punctuation">[</span>i <span class="token operator">-</span> incr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token comment">// 分组插入排序  </span>                <span class="token comment">// 当遍历时遇到相对有序，直接进行下一趟排序  </span>                <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> i<span class="token punctuation">;</span>j <span class="token operator">&gt;=</span> incr<span class="token punctuation">;</span>j <span class="token operator">-=</span> incr<span class="token punctuation">)</span><span class="token punctuation">{</span>                      <span class="token keyword">if</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token operator">&lt;</span>arr<span class="token punctuation">[</span>j <span class="token operator">-</span> incr<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>                          <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span>j<span class="token punctuation">,</span>j <span class="token operator">-</span> incr<span class="token punctuation">)</span><span class="token punctuation">;</span>                      <span class="token punctuation">}</span>                  <span class="token punctuation">}</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>      arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="归并排序-Merge-Sort"><a href="#归并排序-Merge-Sort" class="headerlink" title="归并排序 (Merge Sort)"></a>归并排序 (Merge Sort)</h3><p>将已有序的子序列合并，得到完全有序的序列；即先使每个子序列有序，再使子序列段间有序。若将两个有序表合并成一个有序表，称为 2 路归并。</p><h4 id="算法步骤-4"><a href="#算法步骤-4" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>归并排序算法是一个递归过程，边界条件为当输入序列仅有一个元素时，直接返回，具体过程如下：</p><ol><li> 如果输入内只有一个元素，则直接返回，否则将长度为 <code>n</code> 的输入序列分成两个长度为 <code>n/2</code> 的子序列；</li><li> 分别对这两个子序列进行归并排序，使子序列变为有序状态；</li><li> 设定两个指针，分别指向两个已经排序子序列的起始位置；</li><li> 比较两个指针所指向的元素，选择相对小的元素放入到合并空间（用于存放排序结果），并移动指针到下一位置；</li><li> 重复步骤 3 ~4 直到某一指针达到序列尾；</li><li> 将另一序列剩下的所有元素直接复制到合并序列尾。</li></ol><h4 id="图解算法-4"><a href="#图解算法-4" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/07.gif"></p><h4 id="算法分析-4"><a href="#算法分析-4" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong>：稳定</li><li>  <strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li><li>  <strong>空间复杂度</strong> ：O(n)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//拆分  </span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">L</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">L</span> <span class="token operator">&lt;</span> <span class="token class-name">R</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">int</span> mid <span class="token operator">=</span> <span class="token class-name">L</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">R</span> <span class="token operator">-</span> <span class="token class-name">L</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token class-name">L</span><span class="token punctuation">,</span> mid<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">merge</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token class-name">L</span><span class="token punctuation">,</span> mid<span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token comment">//合并  </span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">merge</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">L</span><span class="token punctuation">,</span> <span class="token keyword">int</span> mid<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> tmpArr <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token keyword">int</span><span class="token punctuation">[</span><span class="token class-name">R</span> <span class="token operator">-</span> <span class="token class-name">L</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> idx <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token class-name">L</span><span class="token punctuation">,</span> j <span class="token operator">=</span> mid <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">// 同时遍历arr数组中[L, mid]和[mid+1, R]两个区间，将较小值放入tmpArr临时数组中  </span>    <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid <span class="token operator">&amp;&amp;</span> j <span class="token operator">&lt;=</span> <span class="token class-name">R</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          tmpArr<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">(</span>arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">?</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">:</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;=</span> mid<span class="token punctuation">)</span> tmpArr<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>j <span class="token operator">&lt;=</span> <span class="token class-name">R</span><span class="token punctuation">)</span> tmpArr<span class="token punctuation">[</span>idx<span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 将tmpArr数组中排序完毕的值放回原数组中  </span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> val <span class="token operator">:</span> tmpArr<span class="token punctuation">)</span> <span class="token punctuation">{</span>          arr<span class="token punctuation">[</span><span class="token class-name">L</span><span class="token operator">++</span><span class="token punctuation">]</span> <span class="token operator">=</span> val<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="快速排序-Quick-Sort"><a href="#快速排序-Quick-Sort" class="headerlink" title="快速排序 (Quick Sort)"></a>快速排序 (Quick Sort)</h3><p>快速排序的基本思想：通过一趟排序将待排序列分隔成独立的两部分，其中一部分记录的元素均比另一部分的元素小，则可分别对这两部分子序列继续进行排序，以达到整个序列有序。</p><h4 id="算法步骤-5"><a href="#算法步骤-5" class="headerlink" title="算法步骤"></a>算法步骤</h4><p>快速排序使用分治法策略来把一个序列分为较小和较大的 2 个子序列，然后递回地排序两个子序列。具体算法描述如下：</p><ol><li> 从序列中<strong>随机</strong>挑出一个元素，做为 “基准”(<code>pivot</code>)；</li><li> 重新排列序列，将所有比基准值小的元素摆放在基准前面，所有比基准值大的摆在基准的后面（相同的数可以到任一边）。在这个操作结束之后，该基准就处于数列的中间位置。这个称为分区（partition）操作；</li><li> 递归地把小于基准值元素的子序列和大于基准值元素的子序列进行快速排序。</li></ol><h4 id="图解算法-5"><a href="#图解算法-5" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/08.gif"></p><h4 id="算法分析-5"><a href="#算法分析-5" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong> ：不稳定</li><li>  <strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)，平均：O(nlogn)</li><li>  <strong>空间复杂度</strong> ：O(logn)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">L</span><span class="token punctuation">,</span> <span class="token keyword">int</span> <span class="token class-name">R</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 递归出口为L追上R的时候  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">L</span> <span class="token operator">&gt;=</span> <span class="token class-name">R</span><span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token class-name">L</span><span class="token punctuation">,</span> j <span class="token operator">=</span> <span class="token class-name">R</span><span class="token punctuation">;</span>      <span class="token keyword">int</span> key <span class="token operator">=</span> arr<span class="token punctuation">[</span><span class="token class-name">L</span><span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">// 从右边开始，找到第一个小于key的数  </span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">&gt;=</span> key<span class="token punctuation">)</span> <span class="token operator">--</span>j<span class="token punctuation">;</span>          <span class="token comment">// 再从左边开始，找到第一个大于key的数  </span>        <span class="token keyword">while</span> <span class="token punctuation">(</span>i <span class="token operator">&lt;</span> j <span class="token operator">&amp;&amp;</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">&lt;=</span> key<span class="token punctuation">)</span> <span class="token operator">++</span>i<span class="token punctuation">;</span>          <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment">// 将基准值放在划分数组大小的中间轴上  </span>    <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token class-name">L</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// 递归进行排序  </span>    <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token class-name">L</span><span class="token punctuation">,</span> i<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token function">sort</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token class-name">R</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>      arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="堆排序-Heap-Sort"><a href="#堆排序-Heap-Sort" class="headerlink" title="堆排序 (Heap Sort)"></a>堆排序 (Heap Sort)</h3><p>堆排序是指利用堆这种数据结构所设计的一种排序算法。堆是一个近似完全二叉树的结构，并同时满足<strong>堆的性质</strong>：即<strong>子结点的值总是小于（或者大于）它的父节点</strong>。</p><h4 id="算法步骤-6"><a href="#算法步骤-6" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li> 将初始待排序列 <code>(R1, R2, ……, Rn)</code> 构建成大顶堆，此堆为初始的无序区；</li><li> 将堆顶元素 <code>R[1]</code> 与最后一个元素 <code>R[n]</code> 交换，此时得到新的无序区 <code>(R1, R2, ……, Rn-1)</code> 和新的有序区 (Rn), 且满足 <code>R[1, 2, ……, n-1]&lt;=R[n]</code>；</li><li> 由于交换后新的堆顶 <code>R[1]</code> 可能违反堆的性质，因此需要对当前无序区 <code>(R1, R2, ……, Rn-1)</code> 调整为新堆，然后再次将 R [1] 与无序区最后一个元素交换，得到新的无序区 <code>(R1, R2, ……, Rn-2)</code> 和新的有序区 <code>(Rn-1, Rn)</code>。不断重复此过程直到有序区的元素个数为 <code>n-1</code>，则整个排序过程完成。</li></ol><h4 id="图解算法-6"><a href="#图解算法-6" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/09.gif"></p><h4 id="算法分析-6"><a href="#算法分析-6" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong> ：不稳定</li><li>  <strong>时间复杂度</strong> ：最佳：O(nlogn)， 最差：O(nlogn)， 平均：O(nlogn)</li><li>  <strong>空间复杂度</strong> ：O(1)</li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">//调整堆  </span><span class="token comment">//小结点不断下沉  </span><span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">heapAdjust</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> heap<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> len<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token comment">// 记录传入节点值  </span>    <span class="token keyword">int</span> tmp <span class="token operator">=</span> heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      <span class="token comment">// 从i节点的左子节点开始，即i*2+1  </span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> k <span class="token operator">=</span> i <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span> k <span class="token operator">&lt;</span> len<span class="token punctuation">;</span> k <span class="token operator">=</span> k <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">// 当左子节点小于右子节点，则让父节点与右子节点相比  </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">&lt;</span> len <span class="token operator">&amp;&amp;</span> heap<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&lt;</span> heap<span class="token punctuation">[</span>k <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token operator">++</span>k<span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token comment">// 若最大的子节点比传入节点大，则将最大的子节点的位置移到传入节点上  </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>heap<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">&gt;</span> tmp<span class="token punctuation">)</span> <span class="token punctuation">{</span>              heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> heap<span class="token punctuation">[</span>k<span class="token punctuation">]</span><span class="token punctuation">;</span>              i <span class="token operator">=</span> k<span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>              <span class="token keyword">break</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      <span class="token comment">// 传入节点值放在最终的位置  </span>    heap<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> tmp<span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">sort</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> len <span class="token operator">=</span> arr<span class="token punctuation">.</span>length<span class="token punctuation">;</span>      <span class="token comment">// 1. 构建大顶堆  </span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> len <span class="token operator">/</span> <span class="token number">2</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> i <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">// 从第一个非叶子结点从下至上，从右至左调整结构  </span>        <span class="token function">heapAdjust</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> i<span class="token punctuation">,</span> len<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token comment">// 2. 每一趟排序，都将大顶堆的堆顶与数组的索引j处的值交换  </span>    <span class="token comment">// 索引j最开始指向数组尾部，随着每一趟排序的结束自减，直到指向数组头部  </span>    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">int</span> j <span class="token operator">=</span> len <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">;</span> j <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">;</span> <span class="token operator">--</span>j<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token function">swap</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">heapAdjust</span><span class="token punctuation">(</span>arr<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> j<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">void</span> <span class="token function">swap</span><span class="token punctuation">(</span><span class="token keyword">int</span><span class="token punctuation">[</span><span class="token punctuation">]</span> arr<span class="token punctuation">,</span> <span class="token keyword">int</span> i<span class="token punctuation">,</span> <span class="token keyword">int</span> j<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> temp <span class="token operator">=</span> arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">;</span>      arr<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span><span class="token punctuation">;</span>      arr<span class="token punctuation">[</span>j<span class="token punctuation">]</span> <span class="token operator">=</span> temp<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="计数排序-Counting-Sort"><a href="#计数排序-Counting-Sort" class="headerlink" title="计数排序 (Counting Sort)"></a>计数排序 (Counting Sort)</h3><p>计数排序的核心在于将输入的数据值转化为键存储在额外开辟的数组空间中。 作为一种线性时间复杂度的排序，<strong>计数排序要求输入的数据必须是有确定范围的整数</strong>。</p><h4 id="算法步骤-7"><a href="#算法步骤-7" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li> 找出数组中的最大值 <code>max</code>、最小值 <code>min</code>；</li><li> 创建一个新数组 <code>C</code>，其长度是 <code>max-min+1</code>，其元素默认值都为 0；</li><li> 遍历原数组 <code>A</code> 中的元素 <code>A[i]</code>，以 <code>A[i]-min</code> 作为 <code>C</code> 数组的索引，以 <code>A[i]</code> 的值在 <code>A</code> 中元素出现次数作为 <code>C[A[i]-min]</code> 的值；</li><li> 对 <code>C</code> 数组变形，<strong>新元素的值是该元素与前一个元素值的和</strong>，即当 <code>i&gt;1</code> 时 <code>C[i] = C[i] + C[i-1]</code>；</li><li> 创建结果数组 <code>R</code>，长度和原始数组一样。</li><li> <strong>从后向前</strong>遍历原始数组 <code>A</code> 中的元素 <code>A[i]</code>，使用 <code>A[i]</code> 减去最小值 <code>min</code> 作为索引，在计数数组 <code>C</code> 中找到对应的值 <code>C[A[i]-min]</code>，<code>C[A[i]-min]-1</code> 就是 <code>A[i]</code> 在结果数组 <code>R</code> 中的位置，做完上述这些操作，将 <code>count[A[i]-min]</code> 减小 1。</li></ol><h4 id="图解算法-7"><a href="#图解算法-7" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/10.gif"></p><h4 id="算法分析-7"><a href="#算法分析-7" class="headerlink" title="算法分析"></a>算法分析</h4><p>当输入的元素是 <code>n</code> 个 <code>0</code> 到 <code>k</code> 之间的整数时，它的运行时间是 <code>O(n+k)</code>。计数排序不是比较排序，排序的速度快于任何比较排序算法。由于用来计数的数组 <code>C</code> 的长度取决于待排序数组中数据的范围（等于待排序数组的<strong>最大值与最小值的差加上 1</strong>），这使得计数排序对于数据范围很大的数组，需要大量额外内存空间。</p><ul><li>  <strong>稳定性</strong> ：稳定</li><li>  <strong>时间复杂度</strong> ：最佳：<code>O(n+k)</code> 最差：<code>O(n+k)</code> 平均：<code>O(n+k)</code></li><li>  <strong>空间复杂度</strong> ：<code>O(k)</code></li></ul><h3 id="桶排序-Bucket-Sort"><a href="#桶排序-Bucket-Sort" class="headerlink" title="桶排序 (Bucket Sort)"></a>桶排序 (Bucket Sort)</h3><p>桶排序是计数排序的升级版。它利用了函数的映射关系，高效与否的关键就在于这个映射函数的确定。为了使桶排序更加高效，我们需要做到这两点：</p><ol><li> 在额外空间充足的情况下，尽量增大桶的数量</li><li> 使用的映射函数能够将输入的 N 个数据均匀的分配到 K 个桶中</li></ol><p>桶排序的工作的原理：假设输入数据服从均匀分布，将数据分到有限数量的桶里，每个桶再分别排序（有可能再使用别的排序算法或是以递归方式继续使用桶排序进行。</p><h4 id="算法步骤-8"><a href="#算法步骤-8" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li> 设置一个 BucketSize，作为每个桶所能放置多少个不同数值；</li><li> 遍历输入数据，并且把数据依次映射到对应的桶里去；</li><li> 对每个非空的桶进行排序，可以使用其它排序方法，也可以递归使用桶排序；</li><li> 从非空桶里把排好序的数据拼接起来。</li></ol><h4 id="图解算法-8"><a href="#图解算法-8" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/11.gif"></p><h4 id="算法分析-8"><a href="#算法分析-8" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong> ：稳定</li><li>  <strong>时间复杂度</strong> ：最佳：<code>O(n+k)</code> 最差：<code>O(n²)</code> 平均：<code>O(n+k)</code></li><li>  <strong>空间复杂度</strong> ：<code>O(k)</code></li></ul><h3 id="基数排序-Radix-Sort"><a href="#基数排序-Radix-Sort" class="headerlink" title="基数排序 (Radix Sort)"></a>基数排序 (Radix Sort)</h3><p>基数排序也是非比较的排序算法，对元素中的每一位数字进行排序，从最低位开始排序，复杂度为 <code>O(n×k)</code>，<code>n</code> 为数组长度，<code>k</code> 为数组中元素的最大的位数；</p><p>基数排序是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。</p><h4 id="算法步骤-9"><a href="#算法步骤-9" class="headerlink" title="算法步骤"></a>算法步骤</h4><ol><li> 取得数组中的最大数，并取得位数，即为迭代次数 <code>N</code>（例如：数组中最大数值为 1000，则 <code>N=4</code>）；</li><li> <code>A</code> 为原始数组，从最低位开始取每个位组成 <code>radix</code> 数组；</li><li> 对 <code>radix</code> 进行计数排序（利用计数排序适用于小范围数的特点）；</li><li> 将 <code>radix</code> 依次赋值给原数组；</li><li> 重复 2~4 步骤 <code>N</code> 次</li></ol><h4 id="图解算法-9"><a href="#图解算法-9" class="headerlink" title="图解算法"></a>图解算法</h4><p><img src="/images/image_%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/12.gif"></p><h4 id="算法分析-9"><a href="#算法分析-9" class="headerlink" title="算法分析"></a>算法分析</h4><ul><li>  <strong>稳定性</strong> ：稳定</li><li>  <strong>时间复杂度</strong> ：最佳：<code>O(n×k)</code> 最差：<code>O(n×k)</code> 平均：<code>O(n×k)</code></li><li>  <strong>空间复杂度</strong> ：<code>O(n+k)</code></li></ul><p><strong>基数排序 vs 计数排序 vs 桶排序</strong></p><p>这三种排序算法都利用了桶的概念，但对桶的使用方法上有明显差异：</p><ul><li>  基数排序：根据键值的每位数字来分配桶</li><li>  计数排序：每个桶只存储单一键值</li><li>  桶排序：每个桶存储一定范围的数值</li></ul><h3 id="LRU缓存"><a href="#LRU缓存" class="headerlink" title="LRU缓存"></a>LRU缓存</h3><p><strong>双向链表</strong>：按照被使用的顺序存储了这些键值对，靠近头部的键值对是最近使用的，而靠近尾部的键值对是最久未使用的。<br><strong>哈希表</strong>：即为普通的哈希映射（HashMap），通过缓存数据的键映射到其在双向链表中的位置。  </p><p>首先使用哈希表进行定位，找出缓存项在双向链表中的位置，随后将其移动到双向链表的头部， 即可在O(1) 的时间内完成 get 或者 put 操作。  </p><p>对于 get 操作，首先判断 key 是否存在： </p><ul><li>如果 key 不存在，则返回 −1-1−1；  </li><li>如果 key 存在，则 key 对应的节点是最近被使用的节点。通过哈希表定位到该节点在双向链表中的位置，并将其移动到双向链表的头部，最后返回该节点的值。  </li></ul><p>对于 put 操作，首先判断 key 是否存在：  </p><ul><li>如果 key 不存在，使用 key 和 value 创建一个新的节点，在双向链表的头部添加该节点，并将 key 和该节点添加进哈希表中。然后判断双向链表的节点数是否超出容量，如果超出容量，则删除双向链表的尾部节点，并删除哈希表中对应的项； </li><li>如果 key 存在，则与 get 操作类似，先通过哈希表定位，再将对应的节点的值更新为 value，并将该节点移到双向链表的头部。  </li></ul><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LRUCache</span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span><span class="token class-name">DLinkedNode</span><span class="token punctuation">&gt;</span></span> cache <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> size<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">DLinkedNode</span> head<span class="token punctuation">,</span>tail<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">LRUCache</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>size <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>          <span class="token comment">//虚拟头尾节点  </span>        head <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          tail <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          head<span class="token punctuation">.</span>next <span class="token operator">=</span> tail<span class="token punctuation">;</span>          tail<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token class-name">DLinkedNode</span> node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>          <span class="token comment">//移到头部  </span>        <span class="token function">moveToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> node<span class="token punctuation">.</span>value<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token class-name">DLinkedNode</span> node <span class="token operator">=</span> cache<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span><span class="token punctuation">(</span>node <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token comment">// 如果 key 不存在，创建一个新的节点  </span>            <span class="token class-name">DLinkedNode</span> newNode <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 添加进哈希表  </span>            cache<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token comment">// 添加至双向链表的头部  </span>            <span class="token function">addToHead</span><span class="token punctuation">(</span>newNode<span class="token punctuation">)</span><span class="token punctuation">;</span>              size<span class="token operator">++</span><span class="token punctuation">;</span>              <span class="token keyword">if</span><span class="token punctuation">(</span>size <span class="token operator">&gt;</span> capacity<span class="token punctuation">)</span><span class="token punctuation">{</span>                  <span class="token comment">// 如果超出容量，删除双向链表的尾部节点  </span>                <span class="token class-name">DLinkedNode</span> tail <span class="token operator">=</span> <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token comment">// 删除哈希表中对应的项  </span>                cache<span class="token punctuation">.</span><span class="token function">remove</span><span class="token punctuation">(</span>tail<span class="token punctuation">.</span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>                  size<span class="token operator">--</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>              <span class="token comment">// 如果 key 存在，先通过哈希表定位，再修改 value，并移到头部  </span>            node<span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>              <span class="token function">moveToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>        <span class="token comment">//定义双向链表  </span>    <span class="token keyword">class</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">{</span>          <span class="token keyword">int</span> key<span class="token punctuation">;</span>          <span class="token keyword">int</span> value<span class="token punctuation">;</span>          <span class="token class-name">DLinkedNode</span> prev<span class="token punctuation">;</span>          <span class="token class-name">DLinkedNode</span> next<span class="token punctuation">;</span>          <span class="token keyword">public</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>          <span class="token keyword">public</span> <span class="token class-name">DLinkedNode</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span><span class="token keyword">int</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>key <span class="token operator">=</span> key<span class="token punctuation">;</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">addToHead</span><span class="token punctuation">(</span><span class="token class-name">DLinkedNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>          node<span class="token punctuation">.</span>prev <span class="token operator">=</span> head<span class="token punctuation">;</span>          node<span class="token punctuation">.</span>next <span class="token operator">=</span> head<span class="token punctuation">.</span>next<span class="token punctuation">;</span>          head<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">;</span>          head<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">removeNode</span><span class="token punctuation">(</span><span class="token class-name">DLinkedNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>          node<span class="token punctuation">.</span>prev<span class="token punctuation">.</span>next <span class="token operator">=</span> node<span class="token punctuation">.</span>next<span class="token punctuation">;</span>          node<span class="token punctuation">.</span>next<span class="token punctuation">.</span>prev <span class="token operator">=</span> node<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token keyword">void</span> <span class="token function">moveToHead</span><span class="token punctuation">(</span><span class="token class-name">DLinkedNode</span> node<span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token function">removeNode</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token function">addToHead</span><span class="token punctuation">(</span>node<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">private</span> <span class="token class-name">DLinkedNode</span> <span class="token function">removeTail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token class-name">DLinkedNode</span> res <span class="token operator">=</span> tail<span class="token punctuation">.</span>prev<span class="token punctuation">;</span>          <span class="token function">removeNode</span><span class="token punctuation">(</span>res<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> res<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>使用内置数据结构LinkedHashMap</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">class</span> <span class="token class-name">LRUCache2</span> <span class="token keyword">extends</span> <span class="token class-name">LinkedHashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> <span class="token punctuation">{</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> capacity<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token class-name">LRUCache2</span><span class="token punctuation">(</span><span class="token keyword">int</span> capacity<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">//容量，负载因子，是否顺序访问（默认false插序访问）  </span>        <span class="token keyword">super</span><span class="token punctuation">(</span>capacity<span class="token punctuation">,</span> <span class="token number">0.75F</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>capacity <span class="token operator">=</span> capacity<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">get</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">getOrDefault</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">put</span><span class="token punctuation">(</span><span class="token keyword">int</span> key<span class="token punctuation">,</span> <span class="token keyword">int</span> value<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Override</span>      <span class="token keyword">protected</span> <span class="token keyword">boolean</span> <span class="token function">removeEldestEntry</span><span class="token punctuation">(</span><span class="token class-name">Map<span class="token punctuation">.</span>Entry</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Integer</span><span class="token punctuation">,</span> <span class="token class-name">Integer</span><span class="token punctuation">&gt;</span></span> eldest<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token function">size</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> capacity<span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机网络(补档)</title>
      <link href="/2022/10/13/ji-suan-ji-wang-luo-bu-dang/"/>
      <url>/2022/10/13/ji-suan-ji-wang-luo-bu-dang/</url>
      
        <content type="html"><![CDATA[<h3 id="OSI-的七层模型分别是什么"><a href="#OSI-的七层模型分别是什么" class="headerlink" title="OSI 的七层模型分别是什么"></a>OSI 的七层模型分别是什么</h3><ul><li>物理层：底层数据传输，屏蔽掉具体传输介质和物理设备的差异，如网线；网卡标准。(比特流)</li><li>数据链路层：定义数据的基本格式，如何传输，如何标识；如网卡MAC地址。(帧)</li><li>网络层：定义IP编址，定义路由功能；如不同设备的数据转发。(包)</li><li>传输层：端到端传输数据的基本功能；如 TCP、UDP。(段)</li><li>会话层：控制应用程序之间会话能力；如不同软件数据分发给不同软件。</li><li>表示层：数据格式标识，基本压缩加密功能。</li><li>应用层：各种应用软件，包括 Web 应用。</li></ul><p>TCP五层模型相比OSI七层模型，将OSI的应用层、表示层和会话层合为一层：应用层，其他不变。</p><h3 id="TCP-IP的四层模型是什么"><a href="#TCP-IP的四层模型是什么" class="headerlink" title="TCP/IP的四层模型是什么"></a>TCP/IP的四层模型是什么</h3><ul><li>应用层：定义了信息交换的格式，消息会交给下一层传输层来传输（HTTP，SMTP，DNS）</li><li>运输层：为进程之间的通信提供通用的数据传输服务（TCP，UDP）</li><li>网际层：为分组交换网上的不同主机提供通信服务（IP，ARP，NAT）</li><li>网络接口层：看作是数据链路层和物理层的合体</li></ul><h2 id="应用层"><a href="#应用层" class="headerlink" title="应用层"></a>应用层</h2><h3 id="DNS-是什么"><a href="#DNS-是什么" class="headerlink" title="DNS 是什么"></a>DNS 是什么</h3><p>DNS域名系统，将域名转换为IP地址，属于<strong>应用层协议</strong>，传输<strong>采用UDP协议</strong>。</p><h3 id="DNS-的解析过程"><a href="#DNS-的解析过程" class="headerlink" title="DNS 的解析过程"></a>DNS 的解析过程</h3><p>DNS解析过程类似一颗树，主机向本地域名服务器一般是<strong>递归查询</strong>； 向根用域名服务器查询是<strong>迭代查询</strong>。</p><p><strong>递归查询</strong>：本地域名服务器就以DNS客户的身份，向其他根域名服务器继续发出查询请求报文（即替该主机继续查询），而不是让该主机自己进行下一步的查询。</p><p><strong>迭代查询</strong>：根域名服务器收到请求报文时，要么给出所要查询的IP地址，要么告诉本地域名服务器，“你下一步应当向哪一个域名服务器进行查询”。</p><h3 id="DNS-为什么用-UDP"><a href="#DNS-为什么用-UDP" class="headerlink" title="DNS 为什么用 UDP"></a>DNS 为什么用 UDP</h3><p>其实 DNS 的整个过程是既使用 TCP 又使用 UDP。</p><p>当进行区域传送（主域名服务器向辅助域名服务器传送变化的那部分数据）时会使用 TCP，因为传送的数据量增多，而 TCP 允许的报文长度更长，为了保证数据的正确性，会使用基于可靠连接的 TCP。</p><p>当客户端向 DNS 服务器查询域名 ( 域名解析) 的时候，一般返回的内容不会超过 UDP 报文的最大长度，即 512 字节。用 UDP 传输时，<strong>不需要经过 TCP 三次握手的过程，从而大大提高了响应速度</strong></p><h3 id="HTTP协议是什么"><a href="#HTTP协议是什么" class="headerlink" title="HTTP协议是什么"></a>HTTP协议是什么</h3><p>HTTP是超文本传输协议，它是以TCP/IP为基础来传输HTML，文件图片等。 它本身处于应用层，端口号80。简单来说就是客户端和服务端进行数据传输的一种规则</p><ol><li>HTTP是基于<strong>浏览器/服务器</strong>架构；</li><li>HTTP是<strong>无状态</strong>协议：HTTP本身并不保存用户的任何信息，也不会对传输的数据，状态信息进行持久化；</li><li>HTTP是<strong>无连接</strong>协议：每次连接只处理一个请求，服务器处理完用户请求，即断开连接，借此节约传输时间。<h3 id="HTTP缓存了解吗"><a href="#HTTP缓存了解吗" class="headerlink" title="HTTP缓存了解吗"></a>HTTP缓存了解吗</h3></li></ol><p>http缓存指的是: 当客户端向服务器请求资源时，会先抵达<strong>浏览器缓存</strong>，如果浏览器有“要请求资源”的副本，就可以<strong>直接从浏览器缓存中提取</strong>而不是从原始服务器中提取这个资源。</p><p>常见的http缓存<strong>只能缓存get请求</strong>响应的资源</p><p>http缓存都是从第二次请求开始的。第一次请求资源时，服务器返回资源，并在respone header头中回传资源的缓存参数；第二次请求时，浏览器判断这些请求参数，命中强缓存就直接200，否则就把请求参数加到request header头中传给服务器，看是否命中协商缓存，命中则返回304，否则服务器会返回新的资源。</p><p><strong>强缓存</strong>: 在缓存数据未失效的情况下（即Cache-Control的max-age没有过期或者Expires的缓存时间没有过期），那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求。</p><p><strong>协商缓存</strong>：当第一次请求时服务器返回的响应头中没有Cache-Control和Expires，或Cache-Control和Expires过期，或者它的属性设置为no-cache时(即不走强缓存)，那么浏览器第二次请求时就会与服务器进行<strong>协商</strong>，与服务器端对比判断资源是否进行了修改更新。如果服务器端的资源没有修改，那么就会返回304状态码，告诉浏览器可以使用缓存中的数据，这样就减少了服务器的数据传输压力。</p><h3 id="HTTP常用状态码"><a href="#HTTP常用状态码" class="headerlink" title="HTTP常用状态码"></a>HTTP常用状态码</h3><p>1xx：<strong>目前是协议的中间状态，还需要后续请求。</strong><br>2xx：<strong>表示请求成功。</strong><br>3xx：<strong>表示重定向状态，需要重新请求。</strong><br>4xx：<strong>请求报文错误。</strong><br>5xx：<strong>服务器错误。</strong></p><p>常用状态码：</p><ul><li>101 切换请求协议，从 HTTP 切换到 WebSocket</li><li>200 请求成功，有响应体</li><li>201 请求被成功处理并且在服务端创建了一个新的资源。比如POST创建一个新的用户。</li><li>301 永久重定向：比如网站的网址更换</li><li>302 临时重定向：比如网站的某些资源被暂时转移到另外一个网址</li><li>304 协商缓存命中</li><li>403 服务器禁止访问，一般针对非法请求。</li><li>404 资源未找到</li><li>400 请求错误，请求参数不合法、请求方法错误等。</li><li>500 服务器端错误</li><li>502 网关将请求转发到服务端，服务端返回错误的响应。</li><li>503 服务器繁忙</li></ul><h3 id="HTTP长连接和短连接的区别"><a href="#HTTP长连接和短连接的区别" class="headerlink" title="HTTP长连接和短连接的区别"></a>HTTP长连接和短连接的区别</h3><p>在HTTP/1.0中采用短连接。客户端和服务器每进行一次HTTP通信，就建立一次连接，Connection: close</p><p>在HTTP/1.1默认采用长连接。Connection: keep-alive，就是保持连接。</p><p>长连接适用的场景：一些游戏/即时通讯场景应该使用长连接；</p><p>短连接适用的场景： Web【wapWeb/H5等】的http服务，长连接对于服务端来说会耗费一定资源。</p><h3 id="HTTPS协议是什么"><a href="#HTTPS协议是什么" class="headerlink" title="HTTPS协议是什么"></a>HTTPS协议是什么</h3><p>HTTPS 是安全通信的超文本传输协议。HTTPS 由 HTTP 进行通信，利用&nbsp;<strong>SSL/TLS</strong>&nbsp;来加密数据包。主要目的是提供对网站服务器的<strong>身份认证，保护交换数据的隐私与完整性</strong>。HTTPS工作在TCP协议443端口</p><h3 id="HTTPS-的工作过程"><a href="#HTTPS-的工作过程" class="headerlink" title="HTTPS 的工作过程"></a>HTTPS 的工作过程</h3><p>HTTPS在传输数据之前需要客户端（浏览器）与服务端（网站）之间进行一次握手，在握手过程中将确立双方加密传输数据的密码信息。TLS/SSL中使用了非对称加密，对称加密以及HASH算法。</p><p>1）浏览器将自己支持的一套加密规则发送给网站。</p><p>2）网站从中选出一组加密算法与HASH算法，并将自己的身份信息以<strong>证书</strong>的形式发回给浏览器。证书里面包含了网站地址，加密公钥，以及证书的颁发机构等信息。</p><p>a) 验证证书的合法性，否则会给出证书不受信的提示。</p><p> b) 如果证书受信任，浏览器会生成一串<strong>随机数的key</strong>，并用证书中提供的<strong>公钥加密</strong>。  </p><p>c) 使用约定好的HASH算法计算握手消息（数字签名），并使用生成的key对消息进行加密，最后将之前生成的所有信息发送给网站。</p><p>4）网站接收浏览器发来的数据之后要做以下的操作：  </p><p>a) 使用自己的私钥将信息解密取出密码key，使用密码解密浏览器发来的握手消息，并验证HASH是否与浏览器发来的一致。  </p><p>b) 使用密码加密一段握手消息，发送给浏览器。</p><p> 5）浏览器解密并计算握手消息的HASH，如果与服务端发来的HASH一致，此时握手过程结束，之后所有的通信数据将由之前浏览器生成的随机密码并利用对称加密算法进行加密。</p><p>浏览器与网站互相发送加密的握手消息并验证，是为了保证双方都获得了一致的密码，并且可以正常的加密解密数据，为后续真正数据的传输做一次测试。</p><p><strong>对称加密与非对称加密的区别</strong></p><p><strong>对称加密</strong>是指加密和解密使用同一个密钥的方式，这种方式存在的最大问题就是密钥发送问题，即如何安全地将密钥发给对方。</p><p><strong>非对称加密</strong>是指使用一对非对称密钥，即公钥和私钥，公钥可以随意发布，但私钥只有自己知道。发送密文的一方使用对方的公钥进行加密处理，对方接收到加密信息后，使用自己的私钥进行解密。</p><p><strong>什么是数字签名</strong></p><p>数据的摘要消息进行一个加密，比如 MD5，得到一个签名，和数据一起发送。然后接收端把数据摘要进行 MD5 加密，如果和签名一样，则说明数据确实是真的。避免数据在传输过程中被替换</p><p><strong>什么是数字证书</strong></p><p>如果公钥也被替换，则仍然可以伪造数据。为了保证发送方的公钥是真的，CA 证书机构会负责颁发一个证书，里面的公钥保证是真的</p><h3 id="HTTP-和-HTTPS-的区别"><a href="#HTTP-和-HTTPS-的区别" class="headerlink" title="HTTP 和 HTTPS 的区别"></a>HTTP 和 HTTPS 的区别</h3><ol><li>开销：HTTPS 协议需要到 CA 申请证书，一般免费证书很少，需要交费；</li><li>响应速度：HTTP 是超文本传输协议，信息是明文传输，HTTPS 则是具有安全性的 ssl 加密传输协议，需要消耗更多的 CPU 和内存资源；基于HTTP协议的响应更快</li><li>端口不同：HTTP使用80端口，HTTPS使用443端口；</li><li>安全性：HTTP 的连接很简单，是无状态的；HTTPS 协议是由 TLS+HTTP 协议构建的可进行加密传输、身份认证的网络协议，比 HTTP 协议安全<h3 id="HTTP1-0，1-1，2-0-的区别"><a href="#HTTP1-0，1-1，2-0-的区别" class="headerlink" title="HTTP1.0，1.1，2.0 的区别"></a>HTTP1.0，1.1，2.0 的区别</h3></li></ol><p>HTTP/1.0：<strong>短连接</strong>。浏览器的每次请求都需要与服务器建立一个TCP连接，服务器完成请求处理后立即断开TCP连接</p><p>HTTP/1.1：<strong>长连接</strong>。TCP连接默认不关闭，可以被多个请求复用</p><p>HTTP2.0： </p><ul><li><strong>二进制格式</strong>。采用<strong>二进制</strong>而非文本格式；</li><li><strong>完全多路复用</strong>。无序，不阻塞，一个连接就实现并行；（依赖<strong>二进制分帧</strong>）</li><li><strong>报头压缩</strong>。减小开销；</li><li><strong>服务端推送</strong>。服务器可以将响应主动“推送”到客户端缓存中。<h3 id="GET和POST的区别是什么"><a href="#GET和POST的区别是什么" class="headerlink" title="GET和POST的区别是什么"></a>GET和POST的区别是什么</h3></li></ul><p>（1）post更安全（不会作为url的一部分，不会被缓存、保存在服务器日志、以及浏览器浏览记录中）</p><p>（2）post发送的数据更大（get有url长度限制）</p><p>（3）post能发送更多的数据类型（get只能发送ASCII字符）</p><p>（4）post比get慢。GET产生一个TCP数据包，浏览器会把http header和data一并发送出去，服务器响应200(返回数据); POST产生两个TCP数据包，浏览器先发送header，服务器响应100 continue，浏览器再发送data，服务器响应200 ok(返回数据)。</p><p>（5）post用于修改和写入数据，get一般用于搜索排序和筛选之类的操作（淘宝，支付宝的搜索查询都是get提交），目的是资源的获取，读取数据</p><h3 id="cookie和session的区别"><a href="#cookie和session的区别" class="headerlink" title="cookie和session的区别"></a>cookie和session的区别</h3><p>cookie是<strong>客户端</strong>保持状态的方法；<br>session是<strong>服务器</strong>保持状态的方法；</p><p>(1)保存的位置不同：<br>    cookie保存在浏览器端，session保存在服务端。</p><p>(2)使用方式不同<br>    cookie：如果在浏览器端对cookie进行设置对应的时间，则cookie保存在本地硬盘中，此时如果没有过期，则就可以使用，如果过期则就删除。如果没有对cookie设置时间，则默认关闭浏览器，则cookie就会删除。<br>    session：我们在请求中，如果发送的请求中存在sessionId，则就会找到对应的session对象，如果不存在sessionId,则在服务器端就会创建一个session对象，并且将sessionId返回给浏览器，可以将其放到cookie中，进行传输，如果浏览器不支持cookie，则应该将其通过encodeURL(sessionID)进行调用，然后放到url中。</p><p>(3)存储内容不同<br>ookie只能存储字符串（小文件），而session存储结构类似于hashtable的结构，可以存放任何类型。</p><p>(4)存储大小：cookie最多可以存放4k大小的内容，session没有限制。</p><p>(5)session的安全性要高于cooKie</p><h3 id="token是什么"><a href="#token是什么" class="headerlink" title="token是什么"></a>token是什么</h3><p>token 的认证方式类似于临时的证书签名, 并且是一种服务端无状态的认证方式, 非常适合于 REST API 的场景</p><p>token在客户端一般存放于localStorage，cookie，或sessionStorage中。在服务器一般存于数据库中</p><p><strong>token的组成</strong></p><ul><li>uid: 用户唯一身份标识</li><li>time: 当前时间的时间戳</li><li>sign: 签名, 使用 hash/encrypt 压缩成定长的十六进制字符串，以防止第三方恶意拼接</li><li>固定参数(可选): 将一些常用的固定参数加入到 token 中是为了避免重复查库</li></ul><p><strong>token认证流程</strong></p><p>token 的认证流程与cookie很相似</p><ul><li>用户登录，成功后服务器返回Token给客户端。</li><li>客户端收到数据后保存在客户端</li><li>客户端再次访问服务器，将token放入headers中</li><li>服务器端采用filter过滤器校验。校验成功则返回请求数据，校验失败则返回错误码</li></ul><h3 id="分布式下的session共享问题"><a href="#分布式下的session共享问题" class="headerlink" title="分布式下的session共享问题"></a>分布式下的session共享问题</h3><p>session是有状态的，一般存于服务器内存或硬盘中，session就会面对负载均衡问题，多服务器不共享session</p><ol><li>可以将session存在一个服务器中来解决，但是就不能完全达到负载均衡的效果。</li><li>Redis替代了每个服务器存储session，实现共享。</li><li>使用token，token是无状态的，token字符串里就保存了所有的用户信息</li></ol><ul><li>客户端登陆传递信息给服务端，服务端收到后把用户信息加密（token）传给客户端，客户端将token存放于localStroage等容器中。客户端每次访问都传递token，服务端解密token，就知道这个用户是谁了。(JWT实现)<h3 id="浏览器中输入-URL-地址到显示主页的过程（HTTP通信过程）"><a href="#浏览器中输入-URL-地址到显示主页的过程（HTTP通信过程）" class="headerlink" title="浏览器中输入 URL 地址到显示主页的过程（HTTP通信过程）"></a>浏览器中输入 URL 地址到显示主页的过程（HTTP通信过程）</h3></li></ul><ol><li>用户输入网址</li><li>DNS服务器进行域名解析</li><li>进行TCP三次握手</li><li>建立TCP连接</li><li>发送HTTP请求</li><li>服务器接受请求并返回HTTP报文</li><li>释放连接TCP连接：分长短连接情况</li><li>客户端浏览器解析HTML内容，渲染页面</li></ol><p><strong>这个过程中用到哪些层的哪些协议</strong></p><p>应用层：DNS，UDP，HTTP<br>传输层：TCP<br>网络层：IP<br>网络接口层：OSPF<br>数据链路层：ARP</p><p>浏览器会解析URL地址，用DNS（应用层）将其转换为IP地址，DNS服务器是基于UDP（传输层）。</p><p>得到IP地址后，浏览器就要与服务器建立一个HTTP（应用层）连接。HTTP生成一个GET请求报文，利用TCP（传输层）传输。TCP数据包然后会发送给IP层（网络层），IP层通过路由选择协议，如OSPF（网络接口层）和交换机等找到目的主机IP，ARP协议将IP转化成主机的MAC地址（数据链路层）。</p><h3 id="URI-和-URL-的区别是什么"><a href="#URI-和-URL-的区别是什么" class="headerlink" title="URI 和 URL 的区别是什么?"></a>URI 和 URL 的区别是什么?</h3><ul><li>URI(Uniform Resource Identifier) 是统一资源标志符，可以唯一标识一个资源。</li><li>URL(Uniform Resource Locator) 是统一资源定位符，可以提供该资源的路径。它是一种具体的 URI，即 URL 可以用来标识一个资源，而且还指明了如何 locate 这个资源。</li></ul><p>URL 是一种具体的 URI，它不仅唯一标识资源，而且还提供了定位该资源的信息</p><h2 id="传输层"><a href="#传输层" class="headerlink" title="传输层"></a>传输层</h2><h3 id="TCP协议的特点"><a href="#TCP协议的特点" class="headerlink" title="TCP协议的特点"></a>TCP协议的特点</h3><p>（1）<strong>面向连接</strong>。双方传输数据之前，必须先建立一条通道。例如三次握手，四次挥手</p><p>（2）<strong>点对点</strong>。每一条TCP连接只能有两个端点（即两个套接字）</p><p>（3）<strong>提供可靠的传输服务</strong>。传送的数据无差错、不丢失、不重复、按序到达；</p><p>（4）<strong>提供全双工通信</strong>。允许通信双方的应用进程在任何时候都可以发送数据，因为两端都设有发送缓存和接受缓存；</p><p>（5）<strong>面向字节流</strong>。程序与TCP交互是一个个数据块，TCP把这些数据看成一连串无结构的字节流。</p><h3 id="UDP协议的特点"><a href="#UDP协议的特点" class="headerlink" title="UDP协议的特点"></a>UDP协议的特点</h3><p>（１）UDP是<strong>无连接</strong>的传输层协议；</p><p>（２）UDP使用尽最大努力交付，<strong>不保证可靠</strong>交付；</p><p>（３）UDP是<strong>面向报文</strong>的，对应用层交下来的报文，不合并，不拆分，保留原报文的边界；</p><p>（４）UDP<strong>没有拥塞控制</strong>，因此即使网络出现拥塞也不会降低发送速率；</p><p>（５）UDP支持一对一　一对多　多对多的交互通信；</p><p>（６）UDP的<strong>首部开销小</strong>，只有８字节．</p><h3 id="TCP-与-UDP-的区别"><a href="#TCP-与-UDP-的区别" class="headerlink" title="TCP 与 UDP 的区别"></a>TCP 与 UDP 的区别</h3><ol><li> <strong>是否面向连接</strong> ：UDP 在传送数据之前不需要先建立连接。而 TCP 提供面向连接的服务，在传送数据之前必须先建立连接，数据传送结束后要释放连接。</li><li> <strong>是否是可靠传输</strong>：远地主机在收到 UDP 报文后，不需要给出任何确认，并且不保证数据不丢失，不保证是否顺序到达。TCP 提供可靠的传输服务，TCP 在传递数据之前，会有三次握手来建立连接，而且在数据传递时，有确认、窗口、重传、拥塞控制机制。通过 TCP 连接传输的数据，无差错、不丢失、不重复、并且按序到达。</li><li> <strong>传输效率</strong> ：由于使用 TCP 进行传输的时候多了连接、确认、重传等机制，所以 TCP 的传输效率要比 UDP 低很多。</li><li> <strong>传输形式</strong> ： TCP 是面向字节流的，UDP 是面向报文的。</li><li> <strong>首部开销</strong> ：TCP 首部开销（20 ～ 60（options） 字节）比 UDP 首部开销（8 字节）要大。<br>76  <strong>是否提供广播或多播服务</strong> ：TCP 只支持点对点通信，UDP 支持一对一、一对多、多对一、多对多；<h3 id="TCP-和-UDP-应用场景"><a href="#TCP-和-UDP-应用场景" class="headerlink" title="TCP 和 UDP 应用场景"></a>TCP 和 UDP 应用场景</h3></li></ol><ul><li><p>  <strong>UDP用于效率要求相对高，对准确性要求相对低的场景。</strong>，比如： 语音、 视频 、直播等等。</p></li><li><p>  <strong>TCP 用于对传输准确性要求特别高的场景</strong>，比如文件传输、发送和接收邮件、远程登录等等。</p></li></ul><h3 id="使用-TCP-的协议有哪些-使用-UDP-的协议有哪些"><a href="#使用-TCP-的协议有哪些-使用-UDP-的协议有哪些" class="headerlink" title="使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?"></a>使用 TCP 的协议有哪些?使用 UDP 的协议有哪些?</h3><p><strong>运行于 TCP 协议之上的协议</strong> ：</p><ol><li> <strong>HTTP 协议</strong> ：超文本传输协议。</li><li> <strong>HTTPS 协议</strong> ：更安全的超文本传输协议，身披 SSL 外衣的 HTTP 协议</li><li> <strong>FTP 协议</strong>：文件传输协议，提供文件传输服务。</li><li> <strong>SMTP 协议</strong>：简单邮件传输协议，用来发送电子邮件。</li><li> <strong>POP3协议</strong>： 负责邮件接收的协议。</li><li> <strong>Telnet 协议</strong>：远程登陆协议，通过一个终端登陆到其他服务器。</li><li> <strong>SSH 协议</strong> : 目前较可靠，专为远程登录会话和其他网络服务提供安全性的协议。</li></ol><p><strong>运行于 UDP 协议之上的协议</strong> ：</p><ol><li> <strong>DHCP 协议</strong>：动态主机配置协议，动态配置 IP 地址</li><li> <strong>DNS</strong> ： 域名系统。实际上 DNS 同时支持 UDP 和 TCP 协议。</li><li> <strong>SNMP</strong>：简单网络管理协议，使用161号端口；</li></ol><h3 id="建立连接-TCP三次握手"><a href="#建立连接-TCP三次握手" class="headerlink" title="建立连接 TCP三次握手"></a>建立连接 TCP三次握手</h3><ul><li>  <strong>一次握手</strong> : 客户端发送带有 SYN（seq=x（isn）） 标志的数据包 -&gt; 服务端，然后客户端进入 <strong>SYN_SEND</strong> 状态，等待服务器的确认；</li><li>  <strong>二次握手</strong> : 服务端发送带有 SYN+ACK(seq=y（isn）,ack=x+1) 标志的数据包 –&gt; 客户端,然后服务端进入 <strong>SYN_RECV</strong> 状态</li><li>  <strong>三次握手</strong> : 客户端发送带有 ACK(ack=y+1) 标志的数据包 –&gt; 服务端，然后客户端和服务器端都进入<strong>ESTABLISHED</strong> 状态，完成TCP三次握手。</li></ul><p><strong>标志位</strong><br>ACK：确认序号有效。<br>SYN： 同步序列编号。发起一个新连接。<br>FIN：释放一个连接。</p><p>seq：数据包中第一个字节的序列号(isn：初始化序列号)</p><h3 id="为什么要三次握手"><a href="#为什么要三次握手" class="headerlink" title="为什么要三次握手"></a>为什么要三次握手</h3><p>三次握手的目的是建立可靠的通信信道，双方确认自己与对方的发送与接收是正常的。</p><ol><li> <strong>第一次握手</strong> ：Client 什么都不能确认；Server 确认了对方发送正常，自己接收正常</li><li> <strong>第二次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：对方发送正常，自己接收正常</li><li> <strong>第三次握手</strong> ：Client 确认了：自己发送、接收正常，对方发送、接收正常；Server 确认了：自己发送、接收正常，对方发送、接收正常</li></ol><p>确认双方的接受能力、发送能力是否正常。<br>指定自己的初始化序列号，为后面的可靠传送做准备。</p><h3 id="为什么不是两次或四次"><a href="#为什么不是两次或四次" class="headerlink" title="为什么不是两次或四次"></a>为什么不是两次或四次</h3><p><strong>四次握手的过程:</strong></p><ul><li>1.A发送同步信号SYN+ A’s Initial sequence number</li><li>2.B确认收到A的同步信号，并记录A’s ISN到本地，命名B’s ACK sequence number</li><li>3.B发送同步信号SYN + B’s lnitial sequence number</li><li>4.A确认收到B的同步信号，并记录B’s lSN到本地，命名A’s ACK sequence number</li></ul><p>很显然2、3步骤可以合并，只需要三次握手，可以提高连接的速度与效率。</p><p><strong>二次握手的过程:</strong></p><ul><li>1.A发送同步信号SYN + A’s Initial sequence number</li><li>2.B发送同步信号SYN + B’s Initial sequence number + B’s ACK sequence number</li></ul><p>A与B就A的初始序列号达成了一致。但是B无法知道A是否已经接收到自己的同步信号，如果这个同步信号丢失了，A和B就B的<strong>初始序列号将无法达成一致</strong>。</p><p>B此时也不知道自己发送、对方接收是否正常</p><h3 id="数据丢失问题"><a href="#数据丢失问题" class="headerlink" title="数据丢失问题"></a>数据丢失问题</h3><p><strong>第一个包，即A发给B的SYN中途被丢，没有到达B：</strong><br>A会周期性超时重传，直到收到B的确认</p><p><strong>第二个包，即B发给A的SYN +ACK中途被丢，没有到达A：</strong><br>B会周期性超时重传，直到收到A的确认</p><p><strong>第三个包，即A发给B的ACK中途被丢，没有到达B</strong>：<br>A发完ACK，单方面认为TCP为Established状态，而B显然认为TCP为Active状态:</p><ul><li>1.假定此时双方都没有数据发送，B会周期性超时重传，直到收到A的确认，收到之后B的TCP连接也为Established状态，双向可以发包。</li><li>2.假定此时A有数据发送，B收到A的Data + ACK，自然会切换为established 状态，并接受A的Data。</li><li>3.假定B有数据发送，数据发送不了，会一直周期性超时重传SYN + ACK，直到收到A的确认才坷以发送数据。<h3 id="断开连接-TCP四次挥手"><a href="#断开连接-TCP四次挥手" class="headerlink" title="断开连接 TCP四次挥手"></a>断开连接 TCP四次挥手</h3></li></ul><ol><li> <strong>第一次挥手</strong> ：客户端发送一个 FIN（SEQ=X） 标志的数据包-&gt;服务端，用来关闭客户端到服务器的数据传送。然后，客户端进入 <strong>FIN-WAIT-1</strong> 状态。</li><li> <strong>第二次挥手</strong> ：服务器收到这个 FIN（SEQ=X） 标志的数据包，它发送一个 ACK （SEQ=X+1）标志的数据包-&gt;客户端 。然后，此时服务端进入<strong>CLOSE-WAIT</strong>状态，客户端进入<strong>FIN-WAIT-2</strong>状态。</li><li> <strong>第三次挥手</strong> ：服务端关闭与客户端的连接并发送一个 FIN (SEQ=y)标志的数据包-&gt;客户端请求关闭连接，然后，服务端进入<strong>LAST-ACK</strong>状态。</li><li> <strong>第四次挥手</strong> ：客户端发送 ACK (SEQ=y+1)标志的数据包-&gt;服务端并且进入<strong>TIME-WAIT</strong>状态，服务端在收到 ACK (SEQ=y+1)标志的数据包后进入 CLOSE 状态。此时，如果客户端等待 <strong>2MSL</strong> 后依然没有收到回复，就证明服务端已正常关闭，随后，客户端也可以关闭连接了。<h3 id="为什么要四次挥手"><a href="#为什么要四次挥手" class="headerlink" title="为什么要四次挥手"></a>为什么要四次挥手</h3></li></ol><p>任何一方都可以在数据传送结束后发出连接释放的通知，待对方确认后进入半关闭状态。当另一方也没有数据再发送的时候，则发出连接释放通知，对方确认后就完全关闭了 TCP 连接。</p><ol><li> <strong>第一次挥手</strong> ： A 告诉 B 没有数据要发了，需要断开连接</li><li> <strong>第二次挥手</strong> ：B 收到 A 的信息，向A发送确认数据包，这时候B可能还没有发完数据，不能断开连接</li><li> <strong>第三次挥手</strong> ：B 发送数据结束，向A 发送断开连接信息</li><li> <strong>第四次挥手</strong> ：A 收到 B 的断开信息，发送确认断开信息，B收到后断开，最后A断开连接</li></ol><h3 id="为什么不能把ACK-和-FIN-合并起来，变成三次挥手"><a href="#为什么不能把ACK-和-FIN-合并起来，变成三次挥手" class="headerlink" title="为什么不能把ACK 和 FIN 合并起来，变成三次挥手"></a>为什么不能把ACK 和 FIN 合并起来，变成三次挥手</h3><p>因为服务器收到客户端断开连接的请求时，<strong>可能还有一些数据没有发</strong>完，这时先回复 ACK，表示接收到了断开连接的请求。等到数据发完之后再发 FIN，断开服务器到客户端的数据传送。</p><h3 id="为什么第四次挥手客户端需要等待-2MSL（报文段最长寿命）时间后才进入-CLOSED-状态？"><a href="#为什么第四次挥手客户端需要等待-2MSL（报文段最长寿命）时间后才进入-CLOSED-状态？" class="headerlink" title="为什么第四次挥手客户端需要等待 2MSL（报文段最长寿命）时间后才进入 CLOSED 状态？"></a>为什么第四次挥手客户端需要等待 2MSL（报文段最长寿命）时间后才进入 CLOSED 状态？</h3><p>第四次挥手时，客户端发送给服务器的 ACK 有可能丢失，如果服务端因为某些原因而没有收到 ACK 的话，服务端就会重发 FIN，如果客户端在 2*MSL 的时间内收到了 FIN，就会重新发送 ACK 并再次等待 2MSL，防止 Server 没有收到 ACK 而不断重发 FIN。</p><blockquote><p><strong>MSL(Maximum Segment Lifetime)</strong> : 一个片段在网络中最大的存活时间，2MSL 就是一个发送和一个回复所需的最大时间。如果直到 2MSL，Client 都没有再次收到 FIN，那么 Client 推断 ACK 已经被成功接收，则结束 TCP 连接。</p></blockquote><h3 id="TCP-如何保证传输的可靠性"><a href="#TCP-如何保证传输的可靠性" class="headerlink" title="TCP 如何保证传输的可靠性"></a>TCP 如何保证传输的可靠性</h3><ol><li> <strong>首部校验和</strong> : TCP 将保持它首部和数据的检验和。目的是检测数据在传输过程中的任何变化。</li><li> <strong>序列号，确认应答，超时重传</strong>：数据到达接收方，接收方需要发出一个确认应答，表示已经收到该数据段，并且确认序号会说明了它下一次需要接收的数据序列号。如果发送方迟迟未收到确认应答，那么可能是发送的数据丢失，也可能是确认应答丢失，这时发送方在等待一定时间后会进行重传。这个时间一般是2*RTT(报文段往返时间）+一个偏差值。</li><li> <strong>流量控制</strong> : TCP 连接的每一方都有固定大小的缓冲空间，TCP 的接收端只允许发送端发送接收端缓冲区能接纳的数据。当接收方来不及处理发送方的数据，能提示发送方降低发送的速率，防止包丢失。（滑动窗口）</li><li> <strong>拥塞控制</strong> : 当网络拥塞时，减少数据的发送。</li></ol><h3 id="TCP-如何实现流量控制"><a href="#TCP-如何实现流量控制" class="headerlink" title="TCP 如何实现流量控制"></a>TCP 如何实现流量控制</h3><p>TCP 利用<strong>滑动窗口</strong>实现流量控制。流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。</p><p>接收窗口的大小是根据接收端处理数据的速度<strong>动态调整</strong>的。&nbsp;如果接收端读取数据快，接收窗口可能会扩大。 否则，它可能会缩小。</p><h3 id="TCP-如何实现拥塞控制"><a href="#TCP-如何实现拥塞控制" class="headerlink" title="TCP 如何实现拥塞控制"></a>TCP 如何实现拥塞控制</h3><p>拥塞控制和流量控制不同，前者是一个全局性的过程，而后者指点对点通信量的控制。在某段时间，若对网络中某一资源的需求超过了该资源所能提供的可用部分，网络的性能就要变坏。这种情况就叫拥塞。</p><p>如果把拥塞窗口cwnd定的很大，那么发送端不停的发送数据，有可能导致网络拥塞。一般会有<strong>慢启动</strong>和<strong>拥塞避免</strong>和<strong>快速重传</strong>和<strong>快速恢复</strong>策略。</p><p><strong>慢启动</strong>：定义拥塞窗口，一开始设为1，之后每经过一个往返时间 RTT，窗口大小乘2</p><p><strong>拥塞避免</strong>：设置慢启动阈值sshthres。当前拥塞窗口大小达到这个阈值，每经过一个往返时间 RTT，拥塞窗口+1，以避免拥塞。</p><p><strong>快速重传</strong>：</p><p>在 TCP 传输过程中，<strong>如果发生了丢包，接收端就会发送之前重复 ACK</strong>，比如 第 5 个包丢了，6、7 达到，然后接收端会为 5，6，7 都发送丢失包的 ACK，这个时候发送端受到了 3 个重复的 ACK，意识到丢包了，就会马上进行重传，而不用等到 RTO （超时重传的时间）</p><p><strong>快速恢复</strong>：</p><p>当<strong>发送方连续收到了三次重复ACK</strong>时，就认为当前网络处于拥塞状态，就会进入快速恢复：</p><ul><li>将<strong>拥塞阈值</strong>降低为<strong>拥塞窗口</strong>的<strong>一半</strong>（与协议有关）；</li><li>将<strong>拥塞窗口的大小</strong>变为<strong>拥塞阈值</strong>；</li><li>接着拥塞窗口再线性增加，以适应网络环境；</li></ul><p><img src="/images/image_%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/13.png"></p><h3 id="ARQ-协议是什么"><a href="#ARQ-协议是什么" class="headerlink" title="ARQ 协议是什么"></a>ARQ 协议是什么</h3><p><strong>自动重传请求</strong>（Automatic Repeat-reQuest，ARQ）是 OSI 模型中数据链路层和传输层的错误纠正协议之一。</p><p>它通过使用确认和超时这两个机制，在不可靠服务的基础上实现可靠的信息传输。如果发送方在发送后一段时间之内没有收到确认信息，它通常会重新发送，直到收到确认或者重试超过一定的次数。</p><p>ARQ 包括停止等待 ARQ 协议和连续 ARQ 协议。</p><h4 id="停止等待-ARQ-协议（自动重传请求-ARQ）"><a href="#停止等待-ARQ-协议（自动重传请求-ARQ）" class="headerlink" title="停止等待 ARQ 协议（自动重传请求 ARQ）"></a>停止等待 ARQ 协议（自动重传请求 ARQ）</h4><p>每发完一个分组就停止发送，等待对方确认（回复 ACK）。如果过了一段时间（超时时间后），还是没有收到 ACK 确认，说明没有发送成功，需要重新发送，直到收到确认后再发下一个分组；</p><p>在停止等待协议中，若接收方收到重复分组，就丢弃该分组，但同时还要发送确认。</p><p><strong>1) 无差错情况:</strong></p><p>发送方发送分组,接收方在规定时间内收到,并且回复确认.发送方再次发送。</p><p><strong>2) 出现差错情况（超时重传）:</strong></p><p>只要超过一段时间仍然没有收到确认，就重传前面发送过的分组（认为刚才发送过的分组丢失了）。若收到重复分组，就丢弃该分组，但同时还要发送确认。</p><p><strong>3) 确认丢失和确认迟到</strong></p><ul><li>  <strong>确认丢失</strong> ：确认消息在传输过程丢失。当 A 发送 M1 消息，B 收到后，B 向 A 发送了一个 M1 确认消息，但却在传输过程中丢失。而 A 并不知道，在超时计时过后，A 重传 M1 消息，B 再次收到该消息后采取以下两点措施：1. 丢弃这个重复的 M1 消息，不向上层交付。 2. 向 A 发送确认消息。</li><li>  <strong>确认迟到</strong> ：确认消息在传输过程中迟到。A 发送 M1 消息，B 收到并发送确认。在超时时间内没有收到确认消息，A 重传 M1 消息，B 仍然收到并继续发送确认消息（B 收到了 2 份 M1）。此时 A 收到了 B 第二次发送的确认消息。接着发送其他数据。过了一会，A 收到了 B 第一次发送的对 M1 的确认消息（A 也收到了 2 份确认消息）。处理如下：1. A 收到重复的确认后，直接丢弃。2. B 收到重复的 M1 后，也直接丢弃重复的 M1。</li></ul><h4 id="连续-ARQ-协议"><a href="#连续-ARQ-协议" class="headerlink" title="连续 ARQ 协议"></a>连续 ARQ 协议</h4><p>连续 ARQ 协议可提高信道利用率。发送方维持一个发送窗口，凡位于发送窗口内的分组可以连续发送出去，而不需要等待对方确认。接收方一般采用累计确认，对按序到达的最后一个分组发送确认，表明到这个分组为止的所有分组都已经正确收到了。</p><p><strong>优点：</strong> 信道利用率高，容易实现，即使确认丢失，也不必重传。</p><p><strong>缺点：</strong> 不能向发送方反映出接收方已经正确收到的所有分组的信息。 比如：发送方发送了 5 条 消息，中间第三条丢失（3 号），这时接收方只能对前两个发送确认。发送方无法知道后三个分组的下落，而只好把后三个全部重传一次。</p><h2 id="网络层"><a href="#网络层" class="headerlink" title="网络层"></a>网络层</h2><h3 id="ping命令是基于哪一层协议？原理是什么"><a href="#ping命令是基于哪一层协议？原理是什么" class="headerlink" title="ping命令是基于哪一层协议？原理是什么"></a>ping命令是基于哪一层协议？原理是什么</h3><p>PING 命令是一种常用的网络诊断工具，经常用来测试网络中主机之间的连通性和网络延迟。</p><p>ping是基于<strong>网络层</strong>的<strong>ICMP协议</strong>工作的。ICMP全称是<strong>互联网报文控制协议</strong>。</p><p>ICMP的功能是：<strong>确定IP包是否成功送达目标地址、以及失败原因，网络参数调优等</strong>。ICMP是IP协议的得力助手。</p><p>ICMP类型分为两大类：</p><ol><li><strong>差错报告</strong></li><li><strong>询问报告</strong></li></ol><h3 id="IP和ICMP协议有什么区别"><a href="#IP和ICMP协议有什么区别" class="headerlink" title="IP和ICMP协议有什么区别"></a>IP和ICMP协议有什么区别</h3><p><strong>IP（Internet Protocol，网际协议）</strong> 是网络层的协议，主要作用是定义数据包的格式、对数据包进行路由和寻址，以便它们可以跨网络传播并到达正确的目的地。</p><p>IP协议和ICMP协议都工作于网络层，通常ICMP协议嵌入在IP协议中。IP协议本身不保证可靠性，ICMP是IP协议的一个补充，包括<strong>差错报告</strong>和<strong>询问报告两类。</strong>IP的检验和只计算报文头部，ICMP是计算报文头部和数据主体。</p><h3 id="IP地址和MAC地址有什么区别"><a href="#IP地址和MAC地址有什么区别" class="headerlink" title="IP地址和MAC地址有什么区别"></a>IP地址和MAC地址有什么区别</h3><p>IP 地址主要用来网络寻址用的，就是大致定位你在哪里，而 MAC 地址，则是身份的唯一象征，通过 MAC 来唯一确认这人是不是就是你，MAC 地址不具备寻址的功能。</p><h3 id="什么是IPv4和IPv6"><a href="#什么是IPv4和IPv6" class="headerlink" title="什么是IPv4和IPv6"></a>什么是IPv4和IPv6</h3><p>IPv4和IPv6是不同类型的IP地址。它们的主要用途相同，标记不同的用户，并且让用户能通过IP进行通信。主要区别在于IPv6是最新一代的IP地址。</p><h3 id="IPv4和IPv6的区别"><a href="#IPv4和IPv6的区别" class="headerlink" title="IPv4和IPv6的区别"></a>IPv4和IPv6的区别</h3><ol><li>地址长度：IPv4地址长度为32位，而IPv6地址长度为128位。</li><li>表示方式：IPv4用点分十进制，IPv6用以冒号分隔的十六进制数字</li><li>头部大小：IPv4为20字节，IPv6为40字节</li><li>地址数量：IPv6地址数量比IPv4大得多</li><li>数据包大小：IPv4数据包最大长度为64KB，而IPv6数据包最大长度为4GB。</li><li>安全性：IPv6支持IPSec (Internet Protocol Security)协议，可提供更强的安全性。</li></ol><h3 id="NAT-的是什么"><a href="#NAT-的是什么" class="headerlink" title="NAT 的是什么"></a>NAT 的是什么</h3><p><strong>NAT（Network Address Translation，网络地址转换）</strong> 主要用于在不同网络之间转换 IP 地址。它允许将私有 IP 地址（如在局域网中使用的 IP 地址）映射为公有 IP 地址（在互联网中使用的 IP 地址）或者反向映射，从而实现局域网内的多个设备通过单一公有 IP 地址访问互联网。</p><h2 id="数据链路层"><a href="#数据链路层" class="headerlink" title="数据链路层"></a>数据链路层</h2><h3 id="数据链路层有哪些协议"><a href="#数据链路层有哪些协议" class="headerlink" title="数据链路层有哪些协议"></a>数据链路层有哪些协议</h3><p>ARP ：地址解析协议。根据IP地址获取物理地址<br>RARP：反向地址解析协议。根据物理地址获取IP地址</p>]]></content>
      
      
      
        <tags>
            
            <tag> 计算机网络 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>操作系统(补档)</title>
      <link href="/2022/10/10/cao-zuo-xi-tong-bu-dang/"/>
      <url>/2022/10/10/cao-zuo-xi-tong-bu-dang/</url>
      
        <content type="html"><![CDATA[<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><h3 id="什么是操作系统"><a href="#什么是操作系统" class="headerlink" title="什么是操作系统"></a>什么是操作系统</h3><p>操作系统（Operating System，简称 OS）是管理计算机硬件与软件资源的程序，是计算机的基石。</p><p>操作系统本质上是一个运行在计算机上的软件程序 ，用于管理计算机硬件和软件资源。</p><p>从资源管理的角度来看，操作系统有 6 大功能：</p><ol><li><strong>进程和线程的管理</strong>：进程的创建、撤销、阻塞、唤醒，进程间的通信等。</li><li><strong>存储管理</strong>：内存的分配和管理、外存（磁盘等）的分配和管理等。</li><li><strong>文件管理</strong>：文件的读、写、创建及删除等。</li><li><strong>设备管理</strong>：完成设备（输入输出设备和外部存储设备等）的请求或释放，以及设备启动等功能。</li><li><strong>网络管理</strong>：操作系统负责管理计算机网络的使用。网络是计算机系统中连接不同计算机的方式，操作系统需要管理计算机网络的配置、连接、通信和安全等，以提供高效可靠的网络服务。</li><li><strong>安全管理</strong>：用户的身份认证、访问控制、文件加密等，以防止非法用户对系统资源的访问和操作<h3 id="用户态和内核态的区别"><a href="#用户态和内核态的区别" class="headerlink" title="用户态和内核态的区别"></a>用户态和内核态的区别</h3></li></ol><p>根据进程访问资源的特点，我们可以把进程在系统上的运行分为两个级别：</p><ul><li>用户态(user mode) : 用户态运行的进程可以直接读取用户程序的数据。处于用户态的 CPU 只能受限的访问内存，并且不允许访问外围设备</li><li>系统态(kernel mode) : 系统态运行的进程或程序几乎可以访问计算机的任何资源，不受限制。</li></ul><p>具有用户态和内核态主要是为了保证计算机系统的安全性、稳定性和性能</p><h3 id="什么是系统调用"><a href="#什么是系统调用" class="headerlink" title="什么是系统调用"></a>什么是系统调用</h3><p>系统调用是应用程序与操作系统之间进行交互的一种方式，通过系统调用，应用程序可以访问操作系统底层资源例如文件、设备、网络等。</p><p>运行在<strong>用户态</strong>的程序，调用操作系统提供的<strong>系统态</strong>级别的功能或资源，需要用到系统调用</p><p>系统调用按功能大致可分为如下几类：</p><ul><li>设备管理。完成设备的请求或释放，以及设备启动等功能。</li><li>文件管理。完成文件的读、写、创建及删除等功能。</li><li>进程控制。完成进程的创建、撤销、阻塞及唤醒等功能。</li><li>进程通信。完成进程之间的消息传递或信号传递等功能。</li><li>内存管理。完成内存的分配、回收以及获取作业占用内存区大小及地址等功能。</li></ul><h3 id="用户态和内核态是如何切换的"><a href="#用户态和内核态是如何切换的" class="headerlink" title="用户态和内核态是如何切换的"></a>用户态和内核态是如何切换的</h3><p>用户态切换到内核态的 3 种方式：</p><ol><li><strong>系统调用（Trap）</strong>：用户态进程 <strong>主动</strong> 要求切换到内核态的一种方式，主要是为了使用内核态才能做的事情比如读取磁盘资源。</li><li><strong>中断（Interrupt）</strong>：当外围设备完成用户请求的操作后，会向 CPU 发出相应的中断信号，如果先前执行的指令是用户态下的程序，就会由用户态到内核态的切换。比如硬盘读写操作完成</li><li><strong>异常（Exception）</strong>：当 CPU 在执行运行在用户态下的程序时，发生了异常，会转到了内核态处理异常，比如缺页异常。</li></ol><h3 id="系统调用的过程是什么"><a href="#系统调用的过程是什么" class="headerlink" title="系统调用的过程是什么"></a>系统调用的过程是什么</h3><ol><li>用户态的程序发起系统调用，因为系统调用中涉及一些特权指令，用户态程序权限不足，因此会中断执行，也就是 Trap（Trap 是一种中断）。</li><li>发生中断后，当前 CPU 执行的程序会中断，跳转到中断处理程序。内核程序开始执行，也就是开始处理系统调用。</li><li>内核处理完成后，主动触发 Trap，这样会再次发生中断，切换回用户态工作。</li></ol><h3 id="并发与并行的区别"><a href="#并发与并行的区别" class="headerlink" title="并发与并行的区别"></a>并发与并行的区别</h3><ul><li> <strong>并发</strong>：指在同一时刻只能有一条指令执行，但多个进程指令被快速的轮换执行。（时间片轮转）</li><li> <strong>并行</strong>：指在同一时刻，有多条指令在多个处理器上同时执行。</li></ul><p>并行在多处理器系统中存在，而并发可以在单处理器和多处理器系统中都存在<br>最关键点是：是否是 <strong>同时</strong> 执行。</p><h3 id="同步和异步的区别"><a href="#同步和异步的区别" class="headerlink" title="同步和异步的区别"></a>同步和异步的区别</h3><ul><li><p> <strong>同步</strong> ： 发出一个调用之后，在没有得到结果之前， 该调用就不可以返回，一直等待。</p></li><li><p> <strong>异步</strong> ：调用在发出之后，不用等待返回结果，该调用直接返回。</p><h3 id="阻塞和非阻塞的区别"><a href="#阻塞和非阻塞的区别" class="headerlink" title="阻塞和非阻塞的区别"></a>阻塞和非阻塞的区别</h3></li><li><p><strong>阻塞</strong>：是指调用结果返回前，当前线程会被挂起，即阻塞。</p></li><li><p><strong>非阻塞</strong>：是指即使调用结果没返回，也不会阻塞当前线程。</p></li></ul><h2 id="进程和线程"><a href="#进程和线程" class="headerlink" title="进程和线程"></a>进程和线程</h2><h3 id="线程、进程、协程是什么"><a href="#线程、进程、协程是什么" class="headerlink" title="线程、进程、协程是什么"></a>线程、进程、协程是什么</h3><p>进程：进程是系统进行资源分配的基本单位，进程就是运行起来的可执行程序。</p><p>线程：线程是程序执行的最基本的单位，是轻量级的进程，多个线程可以在同一个进程中同时执行，并且共享进程的资源比如内存空间、文件句柄、网络连接等。</p><p>协程：是一种特殊类型的子程序或函数，允许在同一个线程中进行多个流程（或称为协作任务）之间的切换和调度，实现高效的非阻塞并发操作。用户自己控制切换的时机，不再需要陷入系统的内核态</p><h3 id="进程和线程的区别"><a href="#进程和线程的区别" class="headerlink" title="进程和线程的区别"></a>进程和线程的区别</h3><ul><li><strong>资源</strong>：进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问进程的资源。</li><li><strong>包含关系</strong>：线程是进程划分成的更小的运行单位,一个进程在其执行的过程中可以产生多个线程。</li><li><strong>独立性</strong>：各进程基本上是独立的，而同一进程中的线程极有可能会相互影响。</li><li><strong>开销</strong>：线程执行开销小，但不利于资源的管理和保护；而进程正相反</li><li><strong>通信</strong>：线程间可以通过直接读写同一进程的数据进行通信，但是进程通信需要借助一些复杂的方法。<h3 id="线程间的同步的方式有哪些"><a href="#线程间的同步的方式有哪些" class="headerlink" title="线程间的同步的方式有哪些"></a>线程间的同步的方式有哪些</h3></li></ul><p>线程同步是两个或多个共享关键资源的线程的并发执行。</p><ol><li>**互斥锁(Mutex)**：只有拥有互斥对象的线程才有访问公共资源的权限。(synchronized、Lock)</li><li><strong>读写锁（Read-Write Lock）</strong>：允许多个线程同时读取共享资源，但只有一个线程可以对共享资源进行写操作。</li><li>**信号量(Semaphore)**：它允许同一时刻多个线程访问同一资源，但是需要控制同一时刻访问此资源的最大线程数量。</li><li><strong>屏障（Barrier）</strong>：屏障是一种同步原语，用于等待多个线程到达某个点再一起继续执行。(CyclicBarrier)</li><li><strong>事件(Event)</strong> : Wait/Notify：通过通知操作的方式来保持多线程同步<h3 id="PCB-是什么"><a href="#PCB-是什么" class="headerlink" title="PCB 是什么"></a>PCB 是什么</h3></li></ol><p><strong>PCB（Process Control Block）</strong> 即进程控制块，是操作系统中用来管理和跟踪进程的数据结构，操作系统会根据这些信息来管理和调度进程。</p><p>PCB 主要包含下面几部分的内容：</p><ul><li>进程的<strong>描述信息</strong>，包括进程的名称、标识符等等；</li><li>进程的<strong>调度信息</strong>，包括进程阻塞原因、进程状态（就绪、运行、阻塞等）、进程优先级等；</li><li>进程对<strong>资源的需求情况</strong>，包括 CPU 时间、内存空间、I/O 设备等等。</li><li><strong>处理机</strong>的状态信息，包括通用寄存器、指令计数器、程序状态字 PSW、用户栈指针</li></ul><p>PCB使得多道程序环境下，使得程序可以并发执行</p><h3 id="进程有哪几种状态"><a href="#进程有哪几种状态" class="headerlink" title="进程有哪几种状态"></a>进程有哪几种状态</h3><p>有<strong>创建状态、就绪状态、运行状态、阻塞状态、结束状态</strong>。</p><ul><li>其中只有就绪状态和运行状态能互相转化，当进程为就绪态时，等待 CPU 分配时间片，得到时间片后就进入 运行状态</li><li>运行状态在使用完 CPU 时间片后，又重回就绪态。</li><li>阻塞状态是进程在运行状态时，需要等待某个资源比如打印机资源，而进入一个挂起的状态，等资源拿到后会回到就绪状态，等待 CPU 时间片。<h3 id="进程间的通信方式有哪些"><a href="#进程间的通信方式有哪些" class="headerlink" title="进程间的通信方式有哪些"></a>进程间的通信方式有哪些</h3></li></ul><p>进程间通信（IPC，InterProcess Communication）是指在不同进程之间传播或交换信息。</p><p><strong>无名管道</strong></p><ol><li>用于具有亲缘关系的父子进程间或者兄弟进程之间的通信。</li></ol><p><strong>命名管道</strong></p><ol><li>与无名管道不同，命名管道可以在无关的进程之间交换数据</li><li>有名管道严格遵循先进先出FIFO</li><li>有名管道以磁盘文件的方式存在</li></ol><p><strong>消息队列</strong></p><ol><li>消息队列，是消息的链接表，存放在内核中。一个消息队列由一个标识符 ID 来标识；</li><li>消息队列独立于发送与接收进程。进程终止时，消息队列及其内容并不会被删除；</li><li>消息队列可以实现消息的随机查询，消息不一定要以先进先出的次序读取，也可以按消息的类型读取。</li></ol><p><strong>信号量</strong></p><ol><li>信号量（semaphore）是一个计数器。用于实现进程间的互斥与同步，而不是用于存储进程间通信数据；</li><li>用于进程间同步，对共享数据的访问</li><li>基于操作系统的 PV 操作，程序对信号量的操作都是原子操作</li><li>每次对信号量的 PV 操作不仅限于对信号量值加 1 或减 1，而且可以加减任意正整数；</li></ol><p><strong>共享内存</strong></p><ol><li>需要依靠某种同步操作</li><li>多个进程可以访问同一块内存空间，不同进程可以及时看到对方进程中对共享内存中数据的更新</li><li>共享内存是最快的一种 IPC，因为进程是直接对内存进行存取。</li></ol><p><strong>套接字(Sockets)</strong> </p><ol><li>主要用于在客户端和服务器之间通过网络进行通信。支持不同主机上的两个进程 IPC</li></ol><h3 id="进程的调度算法有哪些"><a href="#进程的调度算法有哪些" class="headerlink" title="进程的调度算法有哪些"></a>进程的调度算法有哪些</h3><ul><li><p><strong>先到先服务调度算法(FCFS，First Come, First Served)</strong> </p></li><li><p>**短作业优先的调度算法(SJF，Shortest Job First)</p></li><li><p><strong>时间片轮转调度算法（RR，Round-Robin）</strong> : 每个进程被分配一个时间段，称作它的时间片，即该进程允许运行的时间。</p></li><li><p><strong>多级反馈队列调度算法（MFQ，Multi-level Feedback Queue）</strong>：</p></li><li><p>多级：表示有多个队列，每个队列优先级从高到低，同时优先级越高时间片越短。  </p></li><li><p>反馈：表示如果有新的进程加入优先级高的队列时，立即停止当前正在运行的进程，转而去运行优先级高的队列</p></li><li><p>进程在不同优先级的队列间迁移，首先调度优先级高的队列中的进程，只有优先级高的队列为空时才去调度优先级低的队列中的进程；对于同一个队列中的进程，按照时间片轮转的方式进行调度，如果一定时间片后依然未能完成，则进入优先级低的队列等待。</p></li><li><p><strong>优先级调度算法（Priority）</strong>：为每个流程分配优先级，首先执行具有最高优先级的进程，依此类推。具有相同优先级的进程以 FCFS 方式执行。</p></li></ul><h3 id="守护进程、僵尸进程和孤儿进程是什么"><a href="#守护进程、僵尸进程和孤儿进程是什么" class="headerlink" title="守护进程、僵尸进程和孤儿进程是什么"></a>守护进程、僵尸进程和孤儿进程是什么</h3><p><strong>守护进程</strong></p><p>指在后台运行的，没有控制终端与之相连的进程。它独立于控制终端，周期性地执行某种任务。Linux的大多数服务器就是用守护进程的方式实现的，如web服务器进程http等</p><p><strong>孤儿进程</strong></p><p>一个父进程退出，而它的子进程还在运行，这些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</p><p><strong>僵尸进程</strong></p><p>如果子进程先退出，父进程还没退出，那么子进程必须等到父进程捕获到了子进程的退出状态才真正结束，否则这个时候子进程就成为僵尸进程</p><p>设置<strong>僵尸进程的目</strong>的是维护子进程的信息，当终止子进程的父进程调用wait或waitpid时就可以得到这些信息</p><h2 id="死锁"><a href="#死锁" class="headerlink" title="死锁"></a>死锁</h2><h3 id="什么是死锁"><a href="#什么是死锁" class="headerlink" title="什么是死锁"></a>什么是死锁</h3><p>多个进程/线程同时被阻塞，它们中的一个或者全部都在等待某个资源被释放。由于进程/线程被无限期地阻塞，因此程序不可能正常终止。</p><h3 id="死锁的四个必要条件"><a href="#死锁的四个必要条件" class="headerlink" title="死锁的四个必要条件"></a>死锁的四个必要条件</h3><ul><li>  <strong>互斥</strong>：资源必须处于非共享模式，即一次只有一个进程可以使用。</li><li>  <strong>请求和保持</strong>：进程每次申请它所需要的一部分资源，在申请新的资源的同时，继续占用已分配到的资源。</li><li>  <strong>不可剥夺</strong>：资源不可剥夺。只能在持有资源的进程完成任务后，该资源才会被释放。</li><li>  <strong>循环等待</strong>：有一组等待进程 <code>{P0, P1,..., Pn}</code>， <code>P0</code> 等待的资源被 <code>P1</code> 占有，<code>P1</code> 等待的资源被 <code>P2</code> 占有，……，<code>Pn-1</code> 等待的资源被 <code>Pn</code> 占有，<code>Pn</code> 等待的资源被 <code>P0</code> 占有。</li></ul><h3 id="解决死锁的方法有哪些"><a href="#解决死锁的方法有哪些" class="headerlink" title="解决死锁的方法有哪些"></a>解决死锁的方法有哪些</h3><p><strong>预防</strong>：采用某种策略，<strong>限制并发进程对资源的请求</strong>，从而使得死锁的必要条件在系统执行的任何时间上都不满足。</p><ol><li>破坏互斥条件：一次性分配所有资源</li><li>破坏请保持条件：只要有一个资源得不到分配，也不给这个进程分配其他的资源：</li><li>破坏不可剥夺条件：当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源；</li><li>破坏循环等待条件：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反。</li></ol><p><strong>避免</strong>：允许系统中<strong>同时存在四个必要条件</strong> ，只要掌握并发进程中与每个进程有关的资源动态申请情况，根据资源的使用情况<strong>提前做出预测</strong> ，仍然可以避免死锁</p><p><strong>银行家算法</strong>：当一个进程申请使用资源的时候，通过 <strong>试探</strong> 分配给该进程资源，然后通过 <strong>安全性算法</strong> 判断分配后系统是否处于安全状态，若不安全则试探分配作废，让该进程继续等待，若能够进入到安全的状态，则就 <strong>真的分配资源给该进程</strong>。</p><p><strong>检测</strong>：系统 <strong>定时地运行一个 “死锁检测”</strong> 的程序，判断系统内是否出现死锁，如果检测到系统发生了死锁，再采取措施去解除它。<br><strong>进程-资源分配图</strong>：描述进程和资源申请及分配关系的一种有向图，可用于<strong>检测系统是否处于死锁状态</strong>。</p><p><strong>解除</strong>：与检测相配套的一种措施，用于<strong>将进程从死锁状态下解脱出来</strong>。</p><ol><li>资源剥夺：挂起某些死锁进程，并抢占它的资源</li><li>撤销进程：强制撤销部分、甚至全部死锁进程并剥夺这些进程的资源</li><li>进程回退：让一个或多个进程回退到足以避免死锁的地步。<h2 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h2></li></ol><h3 id="内存管理是干什么的"><a href="#内存管理是干什么的" class="headerlink" title="内存管理是干什么的"></a>内存管理是干什么的</h3><ul><li><p><strong>内存的分配与回收</strong>：对进程所需的内存进行分配和释放</p></li><li><p><strong>地址转换</strong>：将程序中的虚拟地址转换成内存中的物理地址。</p></li><li><p><strong>内存扩充</strong>：当系统没有足够的内存时，利用虚拟内存技术或自动覆盖技术，从逻辑上扩充内存。</p></li><li><p><strong>内存映射</strong>：将一个文件直接映射到进程的进程空间中，这样可以通过内存指针用读写内存的办法直接存取文件内容，速度更快。</p></li><li><p><strong>内存安全</strong>：保证进程之间使用内存互不干扰，避免一些恶意程序通过修改内存来破坏系统的安全性。</p><h3 id="什么是内存碎片"><a href="#什么是内存碎片" class="headerlink" title="什么是内存碎片"></a>什么是内存碎片</h3></li><li><p><strong>内部内存碎片</strong>：已经分配给进程使用但未被使用的内存。</p></li><li><p><strong>外部内存碎片</strong>：并未分配给进程但又太小导致无法使用的内存。这些内存碎片不能满足任意进程所需要的内存分配请求</p></li></ul><h3 id="什么是虚拟地址（逻辑地址）和物理地址"><a href="#什么是虚拟地址（逻辑地址）和物理地址" class="headerlink" title="什么是虚拟地址（逻辑地址）和物理地址"></a>什么是虚拟地址（逻辑地址）和物理地址</h3><p><strong>物理地址</strong>：它是地址转换的最终地址，进程在运行时执行指令和访问数据最后都要通过物理地址从主存中存取，是内存单元真正的地址。</p><p><strong>逻辑地址</strong>：是指计算机用户看到的地址。编程时的指针值，数组在逻辑地址上是连续的，在物理地址上并不连续，操作系统通过地址映射，将逻辑地址映射成连续的。（CPU 芯片中的一个重要组件&nbsp;<strong>MMU</strong>，地址转换）</p><p>MMU 将虚拟地址翻译为物理地址的主要机制有两种:&nbsp;<strong>分段机制</strong>&nbsp;和&nbsp;<strong>分页机制</strong>&nbsp;。</p><h3 id="常见的内存管理方式有哪些"><a href="#常见的内存管理方式有哪些" class="headerlink" title="常见的内存管理方式有哪些"></a>常见的内存管理方式有哪些</h3><ul><li><strong>连续内存管理</strong>：为一个程序分配一个连续的内存空间，内存利用率一般不高。</li><li><strong>非连续内存管理</strong>：允许一个程序使用的内存分布在不相邻的内存中，相对更加灵活一些。</li></ul><p><strong>连续内存管理</strong></p><ul><li><p><strong>块式管理</strong>：块式管理会将内存分为几个固定大小的块，每个块中只包含一个进程。</p></li><li><p> <strong>伙伴系统算法</strong>：将内存按 2 的幂次划分（每一块内存大小都是 2 的幂次比如 2^6=64 KB），并将相邻的内存块组合成一对伙伴（<strong>必须是相邻的才是伙伴</strong>）。</p></li><li><p>当进行内存分配时，伙伴系统会尝试找到大小最合适的内存块。如果找到的内存块过大，就将其一分为二，分成两个大小相等的伙伴块。如果还是大的话，就继续切分，直到到达合适的大小为止。</p></li></ul><p><strong>非连续内存管理</strong></p><ul><li><strong>段式管理</strong>：以段(—段连续的物理内存)的形式管理/分配物理内存。应用程序的虚拟地址空间被分为大小不等的段，段是有实际意义的，每个段定义了一组逻辑信息</li><li><strong>页式管理</strong>：把物理内存分为连续等长的物理页，应用程序的虚拟地址空间划也被分为连续等长的虚拟页</li><li><strong>段页式管理机制</strong>：结合了段式管理和页式管理的一种内存管理机制，把物理内存先分成若干段，每个段又继续分成若干大小相等的页。<h3 id="介绍一下分页机制"><a href="#介绍一下分页机制" class="headerlink" title="介绍一下分页机制"></a>介绍一下分页机制</h3></li></ul><p><strong>分页机制</strong> 把主存（物理内存）分为连续等长的物理页（一般是4或8字节），应用程序的虚拟地址空间划也被分为连续等长的虚拟页。现代操作系统广泛采用分页机制。</p><p>在分页机制下，应用程序虚拟地址空间中的任意虚拟页可以被映射到物理内存中的任意物理页上，因此可以实现物理内存资源的离散分配。</p><p>分页机制按照固定页大小分配物理内存，使得物理内存资源易于管理，可有效避免分段机制中外部内存碎片的问题。</p><h3 id="页表有什么用？地址翻译过程是怎样的？"><a href="#页表有什么用？地址翻译过程是怎样的？" class="headerlink" title="页表有什么用？地址翻译过程是怎样的？"></a>页表有什么用？地址翻译过程是怎样的？</h3><p>分页管理通过&nbsp;<strong>页表（Page Table）</strong>&nbsp;映射虚拟地址和物理地址。</p><p>分页机制下的虚拟地址由两部分组成：</p><ul><li><strong>页号</strong>：通过虚拟页号可以从页表中取出对应的物理页号；</li><li><strong>页内偏移量</strong>：物理页起始地址+页内偏移量=物理内存地址。</li></ul><p>页表中还存有诸如访问标志（标识该页面有没有被访问过）、脏数据标识位等信息。</p><p>具体的地址翻译过程：</p><ol><li>MMU 首先解析得到虚拟地址中的虚拟页号；</li><li>通过虚拟页号去该应用程序的页表中取出对应的物理页号（找到对应的页表项）；</li><li>用该物理页号对应的物理页起始地址（物理地址）加上虚拟地址中的页内偏移量得到最终的物理地址。<h3 id="多级页表是什么，作用是什么"><a href="#多级页表是什么，作用是什么" class="headerlink" title="多级页表是什么，作用是什么"></a>多级页表是什么，作用是什么</h3></li></ol><p>多级页表就是，存放下一个页表地址的页表<br>目的是避免把全部页表一直放在内存中占用过多空间。</p><p>多级页表属于时间换空间的典型场景。利用增加页表查询的次数减少页表占用的空间。</p><h3 id="快表是什么，使用快表之后的地址转换流程"><a href="#快表是什么，使用快表之后的地址转换流程" class="headerlink" title="快表是什么，使用快表之后的地址转换流程"></a>快表是什么，使用快表之后的地址转换流程</h3><p>为了提高虚拟地址到物理地址的转换速度，操作系统在 <strong>页表方案</strong> 基础之上引入了 <strong>快表</strong>（TLB） 来加速虚拟地址到物理地址的转换。可以把快表理解为一种特殊的高速缓冲存储器（Cache），其中的内容是页表的一部分。作为页表的 Cache，它的作用与页表相似，但是提高了访问速率。</p><p>由于采用页表做地址转换，读写内存数据时 CPU 要访问两次主存。有了快表，有时只要访问一次高速缓冲存储器，一次主存，这样可加速查找并提高指令执行速度。</p><p>使用快表之后的地址转换流程是这样的：</p><ol><li> 根据虚拟地址中的页号查快表；</li><li> 如果该页在快表中，直接从快表中读取相应的物理地址；</li><li> 如果该页不在快表中，就访问内存中的页表，再从页表中得到物理地址，同时将页表中的该映射表项添加到快表中；</li><li> 当快表填满后，又要登记新页时，就按照一定的淘汰策略淘汰掉快表中的一个页。</li></ol><h3 id="分页与分段的区别是什么"><a href="#分页与分段的区别是什么" class="headerlink" title="分页与分段的区别是什么"></a>分页与分段的区别是什么</h3><ol><li>段是信息的逻辑单位，是为了满足程序对内存空间的逻辑需求而设计的，通常根据程序中数据和代码的逻辑结构来划分。页是信息的物理单位，是为了管理内存的方便而划分的</li><li>段的大小不固定，有它所完成的功能决定；页大大小固定，由系统决定；</li><li>段是信息的逻辑单位，便于存储保护和信息的共享，页的保护和共享受到限制。</li><li>页有内部碎片，无外部碎片；段有外部碎片，无内部碎片</li></ol><h2 id="虚拟内存"><a href="#虚拟内存" class="headerlink" title="虚拟内存"></a>虚拟内存</h2><h3 id="虚拟内存是什么"><a href="#虚拟内存是什么" class="headerlink" title="虚拟内存是什么"></a>虚拟内存是什么</h3><p><strong>虚拟内存(Virtual Memory)</strong> ：本质上来说它只是逻辑存在的，是一个假想出来的内存空间，主要作用是作为进程访问主存（物理内存）的桥梁并简化内存管理。</p><p>通过 <strong>虚拟内存</strong> 可以让程序拥有超过系统物理内存大小的可用内存空间。虚拟内存为每个进程提供了一个私有的地址空间，每个进程拥有一片连续完整的内存空间</p><p>虚拟内存的重要意义是它定义了一个连续的虚拟地址空间，并且 <strong>把内存扩展到硬盘空间</strong>。</p><h3 id="虚拟内存的作用是什么"><a href="#虚拟内存的作用是什么" class="headerlink" title="虚拟内存的作用是什么"></a>虚拟内存的作用是什么</h3><ul><li><strong>隔离进程</strong>：物理内存通过虚拟地址空间访问，虚拟地址空间与进程一一对应。进程之间彼此隔离，一个进程中的代码无法更改正在由另一进程或操作系统使用的物理内存。</li><li><strong>提高内存使用安全性</strong>：控制进程对物理内存的访问，隔离不同进程的访问权限，提高系统的安全性。</li><li><strong>提升物理内存利用率</strong>：有了虚拟地址空间后，操作系统只需要将进程当前正在使用的部分数据或指令加载入物理内存。</li><li><strong>提供更大的可使用内存空间</strong>：可以让程序拥有超过系统物理内存大小的可用内存空间。当物理内存不够用时，可以利用磁盘充当物理内存。</li><li><strong>简化内存管理</strong>：进程都有一个一致且私有的虚拟地址空间，程序员不用和真正的物理内存打交道，而是借助虚拟地址空间访问物理内存，从而简化了内存管理。<h3 id="虚拟内存的技术实现方式"><a href="#虚拟内存的技术实现方式" class="headerlink" title="虚拟内存的技术实现方式"></a>虚拟内存的技术实现方式</h3></li></ul><p>虚拟内存的实现需要建立在<strong>离散分配</strong>的内存管理方式的基础上。</p><ol><li> <strong>请求分页存储管理</strong> ：建立在分页管理之上，在作业开始运行之前，仅装入当前要执行的部分段即可运行。发现要访问的页面不在内存，<strong>缺页中断</strong>，调入内存</li><li> <strong>请求分段存储管理</strong> ：建立在分段存储管理之上，如同请求分页储存管理方式一样。</li><li> <strong>请求段页式存储管理</strong></li></ol><p><strong>请求分页与分页存储管理有何不同</strong></p><p>请求分页存储管理建立在分页管理之上。<br>他们的根本区别是：是否将程序所需的全部地址空间都装入主存</p><h3 id="页面置换算法有哪些"><a href="#页面置换算法有哪些" class="headerlink" title="页面置换算法有哪些"></a>页面置换算法有哪些</h3><p>地址映射过程中，若在页面中发现所要访问的页面不在内存中，则发生缺页中断 。</p><blockquote><p><strong>缺页中断</strong> 就是要访问的<strong>页</strong>不在主存，需要操作系统将其调入主存后再进行访问。 在这个时候，被内存映射的文件实际上成了一个分页交换文件。</p></blockquote><ul><li>  <strong>OPT（最佳页面置换算法）</strong> ：选未来最远将使用的页淘汰，是一种最优的方案</li><li>  <strong>FIFO（先进先出页面置换算法）</strong> : 淘汰最先进入内存的页面</li><li>  <strong>LRU（最近最久未使用页面置换算法）</strong> ：选择最近最久未使用的页面予以淘汰</li><li>  <strong>LFU （最少使用页面置换算法）</strong> : 选择在之前使用最少的页面作为淘汰页。<h2 id="文件系统"><a href="#文件系统" class="headerlink" title="文件系统"></a>文件系统</h2><h3 id="文件系统主要做了什么"><a href="#文件系统主要做了什么" class="headerlink" title="文件系统主要做了什么"></a>文件系统主要做了什么</h3></li></ul><ol><li><strong>存储管理</strong>：将文件数据存储到物理存储介质中，并且管理空间分配。</li><li><strong>文件管理</strong>：文件的创建、删除、移动、重命名、压缩、加密、共享等等。</li><li><strong>目录管理</strong>：目录的创建、删除、移动、重命名等等。</li><li><strong>文件访问控制</strong>：管理不同用户或进程对文件的访问权限，保证文件的安全性和保密性。<h3 id="常见的磁盘调度算法有哪些"><a href="#常见的磁盘调度算法有哪些" class="headerlink" title="常见的磁盘调度算法有哪些"></a>常见的磁盘调度算法有哪些</h3></li></ol><ul><li><strong>先来先服务算法（FCFS）</strong>：按照请求到达磁盘调度器的顺序进行处理，先到达的请求的先被服务。</li><li><strong>最短寻道时间优先算法（SSTF）</strong>：优先选择距离当前磁头位置最近的请求进行服务。</li><li><strong>扫描算法（SCAN）</strong>：也被称为电梯（Elevator）算法。磁头沿着一个方向扫描磁盘，如果经过的磁道有请求就处理，直到到达磁盘的边界，然后改变移动方向，依此往复。</li><li><strong>循环扫描算法（C-SCAN）</strong>：SCAN 算法的变体，只在磁盘的一侧进行扫描，并且只按照一个方向扫描，直到到达磁盘边界，然后回到磁盘起点，重新开始循环。</li></ul><h2 id="Linux-常用命令有哪些"><a href="#Linux-常用命令有哪些" class="headerlink" title="Linux 常用命令有哪些"></a>Linux 常用命令有哪些</h2><p>目录/文件：</p><ul><li><p><code>cd usr</code>：切换到该目录下 usr 目录</p></li><li><p><code>ls</code>：显示目录中的文件和子目录的列表</p></li><li><p><code>mkdir [选项] 目录名</code>：创建新目录（增）。</p></li><li><p><code>pwd</code>：显示当前工作目录的路径。</p></li><li><p><code>rmdir [选项] 目录名</code>：删除空目录（删）</p></li><li><p><code>rm [选项] 文件或目录名</code>：删除文件/目录（删）。</p></li><li><p><code>cp [选项] 源文件/目录 目标文件/目录</code>：复制文件或目录（移）。</p></li><li><p><code>mv [选项] 源文件/目录 目标文件/目录</code>：移动文件或目录（移），也可以用于重命名文件或目录。</p></li><li><p><code>touch [选项] 文件名..</code>：创建新文件或更新已存在文件（增）</p></li><li><p><code>cat 文件名</code>：文件的查看（查） 。</p></li><li><p><code>vim 文件名</code>：修改文件的内容（改）。</p></li><li><p><code>tar -zcvf 打包压缩后的文件名 要打包压缩的文件</code>：打包并压缩文件</p><ul><li>z：调用 gzip 压缩命令进行压缩</li><li>c：打包文件</li><li>v：显示运行过程</li><li>f：指定文件名</li></ul></li><li><p><code>tar [-xvf] 压缩文件</code>：解压文件</p><ul><li>&nbsp;<code>x</code> ：解压</li></ul></li></ul><p>网络：</p><ul><li><code>ping [选项] 目标主机</code>：测试与目标主机的网络连接。</li><li><code>ifconfig</code>&nbsp;或&nbsp;<code>ip</code>：用于查看系统的网络接口信息，包括网络接口的 IP 地址、MAC 地址、状态等。</li></ul><p>进程：：</p><ul><li><p><code>ps</code>：用于显示当前运行的进程状态。</p><ul><li><code>ps aux</code>：显示所有用户的所有进程。</li><li><code>ps -ef</code>：以全格式显示进程信息。</li><li><code>ps -e | grep &lt;关键字&gt;</code>：根据关键字过滤显示进程。</li></ul></li><li><p><code>top</code>：动态实时显示进程的系统资源占用情况和进程信息。</p></li><li><p><code>htop</code>：类似于<code>top</code>命令，但提供了更加交互式和直观的界面，支持鼠标操作。</p></li><li><p><code>kill</code>：向进程发送信号，通常用于终止或操作进程。常用选项有：</p><ul><li><code>kill &lt;PID&gt;</code>：终止指定进程ID的进程。</li><li><code>kill - 9 &lt;PID&gt;</code>：强行终止</li><li><code>killall &lt;进程名&gt;</code>：终止指定名称的所有进程。</li></ul></li><li><p><code>pgrep</code>：根据进程名或其它条件来查找进程的PID。常用选项有：</p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>仿牛客网论坛网站开发流程一</title>
      <link href="/2022/09/22/fang-niu-ke-wang-lun-tan-wang-zhan-kai-fa-liu-cheng-yi/"/>
      <url>/2022/09/22/fang-niu-ke-wang-lun-tan-wang-zhan-kai-fa-liu-cheng-yi/</url>
      
        <content type="html"><![CDATA[<h3 id="技术栈"><a href="#技术栈" class="headerlink" title="技术栈"></a>技术栈</h3><ul><li>Spring Boot、MySQL</li><li>Spring、Spring MVC、MyBatis</li><li>Redis、Kafka、Elasticsearch、Zookeeper</li><li>Spring Security、Spring Actuator</li><li>Caffeine</li><li>Thymeleaf</li></ul><h3 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h3><p>在intellij IDEA中利用<a href="https://start.spring.io/">Spring Initializer</a>创建SpringBoot项目，使用Maven管理项目</p><p><strong>maven常用命令：</strong></p><pre class="line-numbers language-bash" data-language="bash"><code class="language-bash">mvn compile <span class="token builtin class-name">:</span> 编译maven项目，会出现target目录 mvn clean <span class="token builtin class-name">:</span> 删除编译后的内容，target目录会被删除 mvn <span class="token builtin class-name">test</span> ：执行test中的方法，会首先编译test类<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>Spring boot的核心作用：起步依赖，自动配置，端点监控</p><h3 id="配置测试数据库连接"><a href="#配置测试数据库连接" class="headerlink" title="配置测试数据库连接"></a>配置测试数据库连接</h3><p>引入依赖</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- mysql数据库连接驱动--&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>mysql<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mysql-connector-java<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- 引入Spring封装的jdbc，内部默认依赖了 HikariDataSource  数据源--&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-jdbc<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span>    <span class="token comment">&lt;!-- mybatis --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.mybatis.spring.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>mybatis-spring-boot-starter<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.2.0<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置文件application.yml</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">server</span><span class="token punctuation">:</span>    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">80</span>    <span class="token comment"># 应用的上下文路径，也可以称为项目路径，是构成url地址的一部分  </span>  <span class="token comment"># 此时的访问方式为localhost:8088/community/xxxxxx  </span>  <span class="token key atrule">servlet</span><span class="token punctuation">:</span>      <span class="token key atrule">context-path</span><span class="token punctuation">:</span> /community<span class="token comment"># Mybatis  </span><span class="token key atrule">mybatis</span><span class="token punctuation">:</span>    <span class="token key atrule">configuration</span><span class="token punctuation">:</span>      <span class="token comment"># 自动转驼峰  </span>    <span class="token key atrule">map-underscore-to-camel-case</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token comment"># 允许JDBC支持自动生成主键，需要驱动兼容  </span>    <span class="token key atrule">use-generated-keys</span><span class="token punctuation">:</span> <span class="token boolean important">true</span>      <span class="token comment"># 控制台标准日志  </span>    <span class="token key atrule">log-impl</span><span class="token punctuation">:</span> org.apache.ibatis.logging.stdout.StdOutImpl<span class="token key atrule">spring</span><span class="token punctuation">:</span>    <span class="token comment"># Thymeleaf 模板缓存  </span>  <span class="token key atrule">thymeleaf</span><span class="token punctuation">:</span>      <span class="token key atrule">cache</span><span class="token punctuation">:</span> <span class="token boolean important">false</span>      <span class="token comment"># DataSource  </span>  <span class="token key atrule">datasource</span><span class="token punctuation">:</span>      <span class="token key atrule">driver-class-name</span><span class="token punctuation">:</span> com.mysql.cj.jdbc.Driver      <span class="token key atrule">url</span><span class="token punctuation">:</span> jdbc<span class="token punctuation">:</span>mysql<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span>3306/community<span class="token punctuation">?</span>characterEncoding=utf<span class="token punctuation">-</span>8<span class="token important">&amp;useSSL=false&amp;serverTimezone=Hongkong</span>      <span class="token key atrule">username</span><span class="token punctuation">:</span> root      <span class="token key atrule">password</span><span class="token punctuation">:</span> root      <span class="token key atrule">type</span><span class="token punctuation">:</span> com.zaxxer.hikari.HikariDataSource      <span class="token key atrule">hikari</span><span class="token punctuation">:</span>        <span class="token key atrule">maximum-pool-size</span><span class="token punctuation">:</span> <span class="token number">15</span>        <span class="token key atrule">minimum-idle</span><span class="token punctuation">:</span> <span class="token number">5</span>        <span class="token key atrule">idle-timeout</span><span class="token punctuation">:</span> <span class="token number">30000</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建entity包并创建User类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span>  <span class="token annotation punctuation">@NoArgsConstructor</span>  <span class="token annotation punctuation">@AllArgsConstructor</span>  <span class="token annotation punctuation">@ToString</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">User</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">String</span> username<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">String</span> password<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">String</span> salt<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">String</span> email<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> type<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> status<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">String</span> activationCode<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">String</span> headerUrl<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Date</span> createTime<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建mapper包并创建UserMapper接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Mapper</span>  <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">UserMapper</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select * from user where id = #{id}"</span><span class="token punctuation">)</span>      <span class="token class-name">User</span> <span class="token function">selectById</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select * from user where username = #{username}"</span><span class="token punctuation">)</span>      <span class="token class-name">User</span> <span class="token function">selectByName</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>测试</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@SpringBootTest</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">UserMapperTest</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Autowired</span>      <span class="token class-name">UserMapper</span> userMapper<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Test</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selectByIdTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token class-name">User</span> user <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span><span class="token number">166</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token annotation punctuation">@Test</span>      <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">selectByUsernameTest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token class-name">User</span> user <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectByName</span><span class="token punctuation">(</span><span class="token string">"SYSTEM"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token class-name">System</span><span class="token punctuation">.</span>out<span class="token punctuation">.</span><span class="token function">println</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="社区首页"><a href="#社区首页" class="headerlink" title="社区首页"></a>社区首页</h3><p><strong>开发流程</strong></p><ul><li>1次请求的执行过程</li><li>分步实现<ul><li>开发社区首页，显示前10个帖子</li><li>开发分页组件，分页显示所有的帖子</li></ul></li></ul><p>社区首页</p><ol><li>开发社区首页，显示前10个帖子<ol><li>创建实体类</li><li>写对应mapper</li><li>创建service,因为在首页得到的DiscussPost并不携带userid,所以需要创建DiscusspostService和UserService来实现首页展示10个帖子的功能</li><li>写controller,将查询到的数据注入到model中</li><li>修改index.html</li></ol></li><li>开发分页组件，分页显示所有的帖子<ol><li>创建page类,在Page中设置当前页码,显示上限，数据总数，查询路径</li><li>在开发社区首页的controller方法中，第一次访问自动注入page，page会自动注入到model中，然后我们让前端在跳转页面的时候在参数上添加页数，我们的SpringMVC会自动注入Page页面</li><li>index.html首页中修改分页组件</li></ol></li></ol><h4 id="社区首页-1"><a href="#社区首页-1" class="headerlink" title="社区首页"></a>社区首页</h4><p>创建实体类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span>  <span class="token annotation punctuation">@NoArgsConstructor</span>  <span class="token annotation punctuation">@AllArgsConstructor</span>  <span class="token annotation punctuation">@ToString</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">DiscussPost</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Id</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> userId<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">String</span> title<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">String</span> content<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> type<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> status<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Date</span> createTime<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> commentCount<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">double</span> score<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建DiscussPostMapper接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Mapper</span>  <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">DiscussPostMapper</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select * from discuss_post where if (#{userId} != 0, status != 2 and user_id = #{userId}, status != 2) "</span> <span class="token operator">+</span>              <span class="token string">"order by type desc,create_time desc "</span> <span class="token operator">+</span>              <span class="token string">"limit #{offset},#{limit}"</span><span class="token punctuation">)</span>      <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DiscussPost</span><span class="token punctuation">&gt;</span></span> <span class="token function">selectDiscussPosts</span><span class="token punctuation">(</span><span class="token keyword">int</span> userId<span class="token punctuation">,</span> <span class="token keyword">int</span> offset<span class="token punctuation">,</span> <span class="token keyword">int</span> limit<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select count(id) from discuss_post where if (#{userId} != 0, status != 2 and user_id = #{userId}, status != 2)"</span><span class="token punctuation">)</span>      <span class="token keyword">int</span> <span class="token function">selectDiscussPostRows</span><span class="token punctuation">(</span><span class="token keyword">int</span> userId<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建service包<br>创建DiscussPostService类和UserService类</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Service  public class DiscussPostService {        @Autowired      private DiscussPostMapper discussPostMapper;public List&lt;DiscussPost&gt; findDiscussPosts(int userId, int offset, int limit){      return discussPostMapper.selectDiscussPosts(userId,offset,limit);  }  public int findDiscussPostRows(int userId){      return discussPostMapper.selectDiscussPostRows(userId);  }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">@Service  public class UserService {        @Autowired      private UserMapper userMapper;        public User findUserById(int userId) {      return userMapper.selectById(userId);      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>将静态资源（css image js等文件）放到static文件下，将模板文件（site index.html）放到templates文件下。Spring MVC将在resource/templates文件夹下查找html页面，返回给客户端</p><p><img src="/images/image_%E8%AE%BA%E5%9D%9B1/1.png"></p><p>接下来开发视图层，创建controller包，创建HomeController类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Controller</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">HomeController</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Autowired</span>      <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>        <span class="token annotation punctuation">@Autowired</span>      <span class="token keyword">private</span> <span class="token class-name">DiscussPostService</span> discussPostService<span class="token punctuation">;</span>    <span class="token comment">/**       * 分页显示首页帖子       */</span>      <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"/index"</span><span class="token punctuation">,</span><span class="token string">"/"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span>      <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getIndexPage</span><span class="token punctuation">(</span><span class="token class-name">Model</span> model<span class="token punctuation">)</span><span class="token punctuation">{</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DiscussPost</span><span class="token punctuation">&gt;</span></span> discussPostList <span class="token operator">=</span> discussPostService<span class="token punctuation">.</span><span class="token function">findDiscussPosts</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> discussPosts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>discussPostList <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">DiscussPost</span> post <span class="token operator">:</span> discussPostList<span class="token punctuation">)</span> <span class="token punctuation">{</span>                  <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"post"</span><span class="token punctuation">,</span> post<span class="token punctuation">)</span><span class="token punctuation">;</span>                  <span class="token class-name">User</span> user <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">findUserById</span><span class="token punctuation">(</span>post<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>                  map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>                    discussPosts<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token punctuation">}</span>          <span class="token punctuation">}</span>          model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"discussPosts"</span><span class="token punctuation">,</span> discussPosts<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token string">"/index"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更改Index.html文件，使用Thymeleaf对其中相对路径进行更改</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>th</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.thymeleaf.org<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>viewport<span class="token punctuation">"</span></span> <span class="token attr-name">content</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>width=device-width, initial-scale=1, shrink-to-fit=no<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>https://stackpath.bootstrapcdn.com/bootstrap/4.3.1/css/bootstrap.min.css<span class="token punctuation">"</span></span> <span class="token attr-name">crossorigin</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>anonymous<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>link</span> <span class="token attr-name">rel</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>stylesheet<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@{/css/global.css}<span class="token punctuation">"</span></span> <span class="token punctuation">/&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>首页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>......<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>list-unstyled<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>media pb-3 pt-3 mb-3 border-bottom<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>each</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>map:${discussPosts}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>site/profile.html<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name"><span class="token namespace">th:</span>src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${map.user.headerUrl}<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mr-4 rounded-circle<span class="token punctuation">"</span></span> <span class="token attr-name">alt</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>用户头像<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">width</span><span class="token punctuation">:</span>50px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span>50px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>media-body<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h6</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mt-0 mb-3<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>#<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>utext</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${map.post.title}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>备战春招，面试刷题跟他复习，一个月全搞定！<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>badge badge-secondary bg-primary<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${map.post.type==1}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>置顶<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>badge badge-secondary bg-danger<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${map.post.status==1}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>精华<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h6</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text-muted font-size-12<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>u</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mr-3<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>utext</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${map.user.username}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>寒江雪<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>u</span><span class="token punctuation">&gt;</span></span> 发布于 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${#dates.format(map.post.createTime,'yyyy-MM-dd HH:mm:ss')}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>2019-04-15 15:32:18<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>b</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>d-inline float-right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>d-inline ml-2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>赞 11<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>d-inline ml-2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>|<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>d-inline ml-2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>回帖 7<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span>......<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name"><span class="token namespace">th:</span>src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@{/js/global.js}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span> <span class="token attr-name"><span class="token namespace">th:</span>src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@{js/index.js}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token script"></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="分页组件"><a href="#分页组件" class="headerlink" title="分页组件"></a>分页组件</h4><p>开发分页组件，分页显示所有帖子</p><p>在entity包下创建Page类，用于记录分页数据</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**   * 封装分页相关的信息.   */</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">Page</span> <span class="token punctuation">{</span>        <span class="token comment">// 当前页码  </span>    <span class="token keyword">private</span> <span class="token keyword">int</span> current <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>      <span class="token comment">// 显示上限  </span>    <span class="token keyword">private</span> <span class="token keyword">int</span> limit <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>      <span class="token comment">// 数据总数(用于计算总页数)  </span>    <span class="token keyword">private</span> <span class="token keyword">int</span> rows<span class="token punctuation">;</span>      <span class="token comment">// 查询路径(用于复用分页链接)  </span>    <span class="token keyword">private</span> <span class="token class-name">String</span> path<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getCurrent</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> current<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setCurrent</span><span class="token punctuation">(</span><span class="token keyword">int</span> current<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>current <span class="token operator">&gt;=</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>current <span class="token operator">=</span> current<span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getLimit</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> limit<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setLimit</span><span class="token punctuation">(</span><span class="token keyword">int</span> limit<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>limit <span class="token operator">&gt;=</span> <span class="token number">1</span> <span class="token operator">&amp;&amp;</span> limit <span class="token operator">&lt;=</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>limit <span class="token operator">=</span> limit<span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getRows</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> rows<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setRows</span><span class="token punctuation">(</span><span class="token keyword">int</span> rows<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">if</span> <span class="token punctuation">(</span>rows <span class="token operator">&gt;=</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">this</span><span class="token punctuation">.</span>rows <span class="token operator">=</span> rows<span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getPath</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> path<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">setPath</span><span class="token punctuation">(</span><span class="token class-name">String</span> path<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">this</span><span class="token punctuation">.</span>path <span class="token operator">=</span> path<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token comment">/**       * 获取当前页的起始行       *       * @return       */</span>      <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">// current * limit - limit  </span>        <span class="token keyword">return</span> <span class="token punctuation">(</span>current <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">*</span> limit<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token comment">/**       * 获取总页数       *       * @return       */</span>      <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token comment">// rows / limit [+1]  </span>        <span class="token keyword">if</span> <span class="token punctuation">(</span>rows <span class="token operator">%</span> limit <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token keyword">return</span> rows <span class="token operator">/</span> limit<span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>              <span class="token keyword">return</span> rows <span class="token operator">/</span> limit <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>        <span class="token comment">/**       * 获取起始页码       *       * @return       */</span>      <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getFrom</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">int</span> from <span class="token operator">=</span> current <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> from <span class="token operator">&lt;</span> <span class="token number">1</span> <span class="token operator">?</span> <span class="token number">1</span> <span class="token operator">:</span> from<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token comment">/**       * 获取结束页码       *       * @return       */</span>      <span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">getTo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">int</span> <span class="token keyword">to</span> <span class="token operator">=</span> current <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">;</span>          <span class="token keyword">int</span> total <span class="token operator">=</span> <span class="token function">getTotal</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token keyword">to</span> <span class="token operator">&gt;</span> total <span class="token operator">?</span> total <span class="token operator">:</span> <span class="token keyword">to</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改HomeController的getIndexPage方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token string">"/index"</span><span class="token punctuation">,</span><span class="token string">"/"</span><span class="token punctuation">}</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getIndexPage</span><span class="token punctuation">(</span><span class="token class-name">Model</span> model<span class="token punctuation">,</span> <span class="token class-name">Page</span> page<span class="token punctuation">)</span><span class="token punctuation">{</span>      page<span class="token punctuation">.</span><span class="token function">setRows</span><span class="token punctuation">(</span>discussPostService<span class="token punctuation">.</span><span class="token function">findDiscussPostRows</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      page<span class="token punctuation">.</span><span class="token function">setPath</span><span class="token punctuation">(</span><span class="token string">"/index"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">DiscussPost</span><span class="token punctuation">&gt;</span></span> discussPostList <span class="token operator">=</span> discussPostService<span class="token punctuation">.</span><span class="token function">findDiscussPosts</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> page<span class="token punctuation">.</span><span class="token function">getOffset</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> page<span class="token punctuation">.</span><span class="token function">getLimit</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token class-name">List</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">Map</span><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span><span class="token punctuation">&gt;</span></span> discussPosts <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ArrayList</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>discussPostList <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token class-name">DiscussPost</span> post <span class="token operator">:</span> discussPostList<span class="token punctuation">)</span> <span class="token punctuation">{</span>              <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"post"</span><span class="token punctuation">,</span> post<span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token class-name">User</span> user <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">findUserById</span><span class="token punctuation">(</span>post<span class="token punctuation">.</span><span class="token function">getUserId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"user"</span><span class="token punctuation">,</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>                discussPosts<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>      model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"discussPosts"</span><span class="token punctuation">,</span> discussPosts<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token string">"/index"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更改Index.html中分页组件</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token comment">&lt;!-- 分页 --&gt;</span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>nav</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mt-5<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>if</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${page.rows&gt;0}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>ul</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>pagination justify-content-center<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>page-item<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>page-link<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@{${page.path}(current=1)}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>首页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name"><span class="token namespace">th:</span>class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>|page-item ${page.current==1?'disabled':''}|<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>page-link<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@{${page.path}(current=${page.current - 1})}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>上一页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name"><span class="token namespace">th:</span>class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>|page-item ${i==page.current?'active':''}|<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>each</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>i:${#numbers.sequence(page.from,page.to)}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>page-link<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@{${page.path}(current=${i})}<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${i}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>1<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name"><span class="token namespace">th:</span>class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>|page-item ${page.current==page.total?'disabled':''}|<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>page-link<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@{${page.path}(current=${page.current+1})}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>下一页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>li</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>page-item<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>page-link<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@{${page.path}(current=${page.total})}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>末页<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>li</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>ul</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>nav</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="发送邮箱"><a href="#发送邮箱" class="headerlink" title="发送邮箱"></a>发送邮箱</h3><p><strong>开发流程</strong></p><ul><li>邮箱设置<ul><li>启用客户端SMTP服务</li></ul></li><li>Spring Email<ul><li>导入 jar 包</li><li>邮箱参数配置</li><li>使用 JavaMailSender 发送邮件</li></ul></li><li>模板引擎<ul><li>使用 Thymeleaf 发送 HTML 邮件</li></ul></li></ul><p>Spring Mail配置文件并加入到pom文件中</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>org.springframework.boot<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>spring-boot-starter-mail<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><p>在application.yml文件中配置Mail的参数</p><p>需要在个人邮箱的网站设置启用授权码，验证手机</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">spring</span><span class="token punctuation">:</span><span class="token comment"># Mail  </span><span class="token key atrule">mail</span><span class="token punctuation">:</span>    <span class="token key atrule">host</span><span class="token punctuation">:</span> smtp.qq.com    <span class="token key atrule">port</span><span class="token punctuation">:</span> <span class="token number">465</span>    <span class="token key atrule">username</span><span class="token punctuation">:</span> 10xxxxxx51@qq.com    <span class="token key atrule">password</span><span class="token punctuation">:</span> zjnxxxxxxxxxbchb    <span class="token key atrule">protocol</span><span class="token punctuation">:</span> smtps    <span class="token key atrule">default-encoding</span><span class="token punctuation">:</span> UTF<span class="token punctuation">-</span><span class="token number">8</span>  <span class="token key atrule">banner</span><span class="token punctuation">:</span>    <span class="token key atrule">charset</span><span class="token punctuation">:</span> UTF<span class="token punctuation">-</span><span class="token number">8</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建util工具文件包，并在util包中创建MailClient类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Component</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">MailClient</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">static</span> <span class="token keyword">final</span> <span class="token class-name">Logger</span> logger <span class="token operator">=</span> <span class="token class-name">LoggerFactory</span><span class="token punctuation">.</span><span class="token function">getLogger</span><span class="token punctuation">(</span><span class="token class-name">MailClient</span><span class="token punctuation">.</span><span class="token keyword">class</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Resource</span>      <span class="token keyword">private</span> <span class="token class-name">JavaMailSender</span> mailSender<span class="token punctuation">;</span>        <span class="token comment">//从配置文件中获取值  </span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${spring.mail.username}"</span><span class="token punctuation">)</span>      <span class="token keyword">private</span> <span class="token class-name">String</span> from<span class="token punctuation">;</span>        <span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">sendMail</span><span class="token punctuation">(</span><span class="token class-name">String</span> <span class="token keyword">to</span><span class="token punctuation">,</span> <span class="token class-name">String</span> subject<span class="token punctuation">,</span> <span class="token class-name">String</span> content<span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">try</span> <span class="token punctuation">{</span>              <span class="token class-name">MimeMessage</span> message <span class="token operator">=</span> mailSender<span class="token punctuation">.</span><span class="token function">createMimeMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              <span class="token class-name">MimeMessageHelper</span> helper <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MimeMessageHelper</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">;</span>              helper<span class="token punctuation">.</span><span class="token function">setFrom</span><span class="token punctuation">(</span>from<span class="token punctuation">)</span><span class="token punctuation">;</span>              helper<span class="token punctuation">.</span><span class="token function">setTo</span><span class="token punctuation">(</span><span class="token keyword">to</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              helper<span class="token punctuation">.</span><span class="token function">setSubject</span><span class="token punctuation">(</span>subject<span class="token punctuation">)</span><span class="token punctuation">;</span>              helper<span class="token punctuation">.</span><span class="token function">setText</span><span class="token punctuation">(</span>content<span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span>              mailSender<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span>helper<span class="token punctuation">.</span><span class="token function">getMimeMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">MessagingException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>              logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"发送邮件失败:"</span> <span class="token operator">+</span> e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token punctuation">}</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注册"><a href="#注册" class="headerlink" title="注册"></a>注册</h3><p><strong>开发流程</strong></p><ul><li>访问注册页面<ul><li>点击顶部区域内的链接，打开注册页面。</li></ul></li><li>提交注册数据<ul><li>通过表单提交数据。</li><li>服务端验证账号是否已存在、邮箱是否已注册。</li><li>服务端发送激活邮件。</li></ul></li><li>激活注册账号<ul><li>点击邮件中的链接，访问服务端的激活服务</li></ul></li></ul><p><strong>首先导入一个常用的包 commons lang</strong></p><p>主要是字符串判空等功能</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token generics"><span class="token punctuation">&lt;</span>dependency<span class="token punctuation">&gt;</span></span>      <span class="token generics"><span class="token punctuation">&lt;</span>groupId<span class="token punctuation">&gt;</span></span>commons<span class="token operator">-</span>lang<span class="token operator">&lt;</span><span class="token operator">/</span>groupId<span class="token operator">&gt;</span>      <span class="token generics"><span class="token punctuation">&lt;</span>artifactId<span class="token punctuation">&gt;</span></span>commons<span class="token operator">-</span>lang<span class="token operator">&lt;</span><span class="token operator">/</span>artifactId<span class="token operator">&gt;</span>      <span class="token generics"><span class="token punctuation">&lt;</span>version<span class="token punctuation">&gt;</span></span><span class="token number">2.4</span><span class="token operator">&lt;</span><span class="token operator">/</span>version<span class="token operator">&gt;</span>  <span class="token operator">&lt;</span><span class="token operator">/</span>dependency<span class="token operator">&gt;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>添加配置信息</strong></p><p>因为开发、上线域名不一样所以用户打开邮箱激活的链接也不一样，所以写在yml配置文件中方便更改</p><pre class="line-numbers language-yaml" data-language="yaml"><code class="language-yaml"><span class="token key atrule">Community</span><span class="token punctuation">:</span>    <span class="token key atrule">path</span><span class="token punctuation">:</span>      <span class="token key atrule">domain</span><span class="token punctuation">:</span> http<span class="token punctuation">:</span>//127.0.0.1<span class="token punctuation">:</span><span class="token number">80</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>在util中添加CommunityUtil工具类，对用户的密码加密</p><pre class="line-numbers language-JAVA" data-language="JAVA"><code class="language-JAVA">public class CommunityUtil {        // 生成随机字符串      public static String generateUUID() {          return UUID.randomUUID().toString().replaceAll("-", "");      }        // MD5加密      // hello -&gt; abc123def456      // hello + 3e4a8 -&gt; abc123def456abc    public static String md5(String key) {          if (StringUtils.isBlank(key)) {              return null;          }          return DigestUtils.md5DigestAsHex(key.getBytes());      }}<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在UserMapper接口中添加下面几个方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token string">"select * from user where email = #{email}"</span><span class="token punctuation">)</span>  <span class="token class-name">User</span> <span class="token function">selectByEmail</span><span class="token punctuation">(</span><span class="token class-name">String</span> email<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Insert</span><span class="token punctuation">(</span><span class="token string">"insert into user(username, password, salt, email, type, status, activation_code, header_url, create_time) "</span> <span class="token operator">+</span>          <span class="token string">"values(#{username}, #{password}, #{salt}, #{email}, #{type}, #{status}, #{activationCode}, #{headerUrl}, #{createTime})"</span><span class="token punctuation">)</span>  <span class="token keyword">int</span> <span class="token function">insertUser</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span><span class="token punctuation">;</span>    <span class="token annotation punctuation">@Update</span><span class="token punctuation">(</span><span class="token string">"update user set status = #{status} where id = #{id}"</span><span class="token punctuation">)</span>  <span class="token keyword">int</span> <span class="token function">updateStatus</span><span class="token punctuation">(</span><span class="token keyword">int</span> id<span class="token punctuation">,</span> <span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>在Service中更新UserService类，用于注册用户业务，并更新激活页面activation.html</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span>  <span class="token keyword">private</span> <span class="token class-name">UserMapper</span> userMapper<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Autowired</span>  <span class="token keyword">private</span> <span class="token class-name">MailClient</span> mailClient<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Resource</span>  <span class="token keyword">private</span> <span class="token class-name">TemplateEngine</span> templateEngine<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${Community.path.domain}"</span><span class="token punctuation">)</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> domain<span class="token punctuation">;</span>    <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${server.servlet.context-path}"</span><span class="token punctuation">)</span>  <span class="token keyword">private</span> <span class="token class-name">String</span> contextPath<span class="token punctuation">;</span>      <span class="token keyword">public</span> <span class="token class-name">User</span> <span class="token function">findUserById</span><span class="token punctuation">(</span><span class="token keyword">int</span> userId<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> userMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 空值处理  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">IllegalArgumentException</span><span class="token punctuation">(</span><span class="token string">"参数不能为空!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"usernameMsg"</span><span class="token punctuation">,</span> <span class="token string">"账号不能为空!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> map<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"passwordMsg"</span><span class="token punctuation">,</span> <span class="token string">"密码不能为空!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> map<span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"emailMsg"</span><span class="token punctuation">,</span> <span class="token string">"邮箱不能为空!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> map<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token comment">// 验证账号  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>userMapper<span class="token punctuation">.</span><span class="token function">selectByName</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"usernameMsg"</span><span class="token punctuation">,</span> <span class="token string">"该账号已存在!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> map<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token comment">// 验证邮箱  </span>    <span class="token keyword">if</span> <span class="token punctuation">(</span>userMapper<span class="token punctuation">.</span><span class="token function">selectByEmail</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">!=</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"emailMsg"</span><span class="token punctuation">,</span> <span class="token string">"该邮箱已被注册!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> map<span class="token punctuation">;</span>      <span class="token punctuation">}</span>        <span class="token comment">// 注册用户  </span>    user<span class="token punctuation">.</span><span class="token function">setSalt</span><span class="token punctuation">(</span><span class="token class-name">CommunityUtil</span><span class="token punctuation">.</span><span class="token function">generateUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">substring</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      user<span class="token punctuation">.</span><span class="token function">setPassword</span><span class="token punctuation">(</span><span class="token class-name">CommunityUtil</span><span class="token punctuation">.</span><span class="token function">md5</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> user<span class="token punctuation">.</span><span class="token function">getSalt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      user<span class="token punctuation">.</span><span class="token function">setType</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      user<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      user<span class="token punctuation">.</span><span class="token function">setActivationCode</span><span class="token punctuation">(</span><span class="token class-name">CommunityUtil</span><span class="token punctuation">.</span><span class="token function">generateUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      user<span class="token punctuation">.</span><span class="token function">setHeaderUrl</span><span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">.</span><span class="token function">format</span><span class="token punctuation">(</span><span class="token string">"http://images.nowcoder.com/head/%dt.png"</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">Random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">nextInt</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      user<span class="token punctuation">.</span><span class="token function">setCreateTime</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      userMapper<span class="token punctuation">.</span><span class="token function">insertUser</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">//重新查询，因为表单没有id字段，默认0,user对象的id不是插入数据库的id  </span>    <span class="token class-name">User</span> user1 <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectByName</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getUsername</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token comment">// 激活邮件  </span>    <span class="token class-name">Context</span> context <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Context</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      context<span class="token punctuation">.</span><span class="token function">setVariable</span><span class="token punctuation">(</span><span class="token string">"email"</span><span class="token punctuation">,</span> user<span class="token punctuation">.</span><span class="token function">getEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token comment">// http://127.0.0.1:80/community/activation/170/code  </span>    <span class="token class-name">String</span> url <span class="token operator">=</span> domain <span class="token operator">+</span> contextPath <span class="token operator">+</span> <span class="token string">"/activation/"</span> <span class="token operator">+</span> user1<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">"/"</span> <span class="token operator">+</span> user1<span class="token punctuation">.</span><span class="token function">getActivationCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      context<span class="token punctuation">.</span><span class="token function">setVariable</span><span class="token punctuation">(</span><span class="token string">"url"</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token class-name">String</span> content <span class="token operator">=</span> templateEngine<span class="token punctuation">.</span><span class="token function">process</span><span class="token punctuation">(</span><span class="token string">"/mail/activation"</span><span class="token punctuation">,</span> context<span class="token punctuation">)</span><span class="token punctuation">;</span>      mailClient<span class="token punctuation">.</span><span class="token function">sendMail</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getEmail</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token string">"激活账号"</span><span class="token punctuation">,</span> content<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token keyword">return</span> map<span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token doctype"><span class="token punctuation">&lt;!</span><span class="token doctype-tag">doctype</span> <span class="token name">html</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>html</span> <span class="token attr-name">lang</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>en<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">xmlns:</span>th</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>http://www.thymeleaf.org<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>head</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>meta</span> <span class="token attr-name">charset</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>utf-8<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>title</span><span class="token punctuation">&gt;</span></span>激活账号<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>title</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>head</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>b</span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${email}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>xxx@xxx.com<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>b</span><span class="token punctuation">&gt;</span></span>, 您好!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>您正在注册, 这是一封激活邮件, 请点击<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${url}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>此链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>, 激活您的账号!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>body</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>html</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>创建LoginController类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Controller</span><span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginController</span> <span class="token keyword">implements</span> <span class="token class-name">CommunityConstant</span> <span class="token punctuation">{</span>     <span class="token annotation punctuation">@Autowired</span>    <span class="token keyword">private</span> <span class="token class-name">UserService</span> userService<span class="token punctuation">;</span>     <span class="token annotation punctuation">@Value</span><span class="token punctuation">(</span><span class="token string">"${server.servlet.context-path}"</span><span class="token punctuation">)</span>    <span class="token keyword">private</span> <span class="token class-name">String</span> contextPath<span class="token punctuation">;</span> <span class="token comment">/**   * 跳转到注册   */</span>  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path <span class="token operator">=</span> <span class="token string">"/register"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getRegisterPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token string">"/site/register"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>    <span class="token comment">/**   * 跳转到登录   */</span>  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path <span class="token operator">=</span> <span class="token string">"/login"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">getLoginPage</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">return</span> <span class="token string">"/site/login"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>      <span class="token comment">/**   * 注册   */</span>  <span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path <span class="token operator">=</span> <span class="token string">"/register"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">POST</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">register</span><span class="token punctuation">(</span><span class="token class-name">Model</span> model<span class="token punctuation">,</span> <span class="token class-name">User</span> user<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">register</span><span class="token punctuation">(</span>user<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>map <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">||</span> map<span class="token punctuation">.</span><span class="token function">isEmpty</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"注册成功,我们已经向您的邮箱发送了一封激活邮件,请尽快激活!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"target"</span><span class="token punctuation">,</span> <span class="token string">"/index"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token string">"/site/operate-result"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"usernameMsg"</span><span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"usernameMsg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"passwordMsg"</span><span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"passwordMsg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"emailMsg"</span><span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"emailMsg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token string">"/site/register"</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更改register.html页面</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container pl-5 pr-5 pt-3 pb-3 mt-3 mb-3<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text-center text-info border-bottom pb-3<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>注<span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span>册<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mt-5<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@{/register}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-group row<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-2 col-form-label text-right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>账号:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-10<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span>                       <span class="token attr-name"><span class="token namespace">th:</span>class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>|form-control ${usernameMsg!=null?'is-invalid':''}|<span class="token punctuation">"</span></span>                       <span class="token attr-name"><span class="token namespace">th:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${user!=null?user.username:''}<span class="token punctuation">"</span></span>                       <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入您的账号!<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>invalid-feedback<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${usernameMsg}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                    该账号已存在!                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-group row mt-4<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-2 col-form-label text-right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>密码:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-10<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span>                       <span class="token attr-name"><span class="token namespace">th:</span>class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>|form-control ${passwordMsg!=null?'is-invalid':''}|<span class="token punctuation">"</span></span>                       <span class="token attr-name"><span class="token namespace">th:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${user!=null?user.password:''}<span class="token punctuation">"</span></span>                       <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入您的密码!<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>invalid-feedback<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${passwordMsg}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                    密码长度不能小于8位!                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-group row mt-4<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>confirm-password<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-2 col-form-label text-right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>确认密码:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-10<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-control<span class="token punctuation">"</span></span>                       <span class="token attr-name"><span class="token namespace">th:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${user!=null?user.password:''}<span class="token punctuation">"</span></span>                       <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>confirm-password<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请再次输入密码!<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>invalid-feedback<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                    两次输入的密码不一致!                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-group row<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-2 col-form-label text-right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>邮箱:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-10<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span>                       <span class="token attr-name"><span class="token namespace">th:</span>class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>|form-control ${emailMsg!=null?'is-invalid':''}|<span class="token punctuation">"</span></span>                       <span class="token attr-name"><span class="token namespace">th:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${user!=null?user.email:''}<span class="token punctuation">"</span></span>                       <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>email<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入您的邮箱!<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>invalid-feedback<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${emailMsg}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                    该邮箱已注册!                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>             <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-group row mt-4<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-10 text-center<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn btn-info text-white form-control<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>立即注册<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>更改operate-result页面</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container mt-5<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>jumbotron<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>lead<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${msg}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>您的账号已经激活成功,可以正常使用了!<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>hr</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>my-4<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>p</span><span class="token punctuation">&gt;</span></span>            系统会在 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>span</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>seconds<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text-danger<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>8<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>span</span><span class="token punctuation">&gt;</span></span> 秒后自动跳转,              您也可以点此 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>target<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@{${target}}<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text-primary<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>链接<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>, 手动跳转!           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>p</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>       <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>......<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">     <span class="token function">$</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>        <span class="token function">setInterval</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>           <span class="token keyword">var</span> seconds <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#seconds"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#seconds"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token operator">--</span>seconds<span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token keyword">if</span><span class="token punctuation">(</span>seconds <span class="token operator">==</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>              location<span class="token punctuation">.</span>href <span class="token operator">=</span> <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#target"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"href"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>           <span class="token punctuation">}</span>        <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="激活注册账号"><a href="#激活注册账号" class="headerlink" title="激活注册账号"></a>激活注册账号</h3><p>util包中创建CommunityConstant接口，定义几个激活状态常量</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">CommunityConstant</span> <span class="token punctuation">{</span>        <span class="token comment">/**       * 激活成功       */</span>      <span class="token keyword">int</span> <span class="token constant">ACTIVATION_SUCCESS</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>        <span class="token comment">/**       * 重复激活       */</span>      <span class="token keyword">int</span> <span class="token constant">ACTIVATION_REPEAT</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>        <span class="token comment">/**       * 激活失败       */</span>      <span class="token keyword">int</span> <span class="token constant">ACTIVATION_FAILURE</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>UserService实现此接口，增加新方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">int</span> <span class="token function">activation</span><span class="token punctuation">(</span><span class="token keyword">int</span> userId<span class="token punctuation">,</span> <span class="token class-name">String</span> code<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token class-name">User</span> user <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectById</span><span class="token punctuation">(</span>userId<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>user <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token constant">ACTIVATION_FAILURE</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token constant">ACTIVATION_REPEAT</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getActivationCode</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          userMapper<span class="token punctuation">.</span><span class="token function">updateStatus</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> <span class="token constant">ACTIVATION_SUCCESS</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          <span class="token keyword">return</span> <span class="token constant">ACTIVATION_FAILURE</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LoginController类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token comment">/**   * 邮箱激活   */</span>  <span class="token comment">// http://127.0.0.1:80/community/activation/170/code  </span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path <span class="token operator">=</span> <span class="token string">"/activation/{userId}/{code}"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">activation</span><span class="token punctuation">(</span><span class="token class-name">Model</span> model<span class="token punctuation">,</span> <span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">)</span> <span class="token keyword">int</span> userId<span class="token punctuation">,</span> <span class="token annotation punctuation">@PathVariable</span><span class="token punctuation">(</span><span class="token string">"code"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> code<span class="token punctuation">)</span> <span class="token punctuation">{</span>      <span class="token keyword">int</span> result <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">activation</span><span class="token punctuation">(</span>userId<span class="token punctuation">,</span> code<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token constant">ACTIVATION_SUCCESS</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"激活成功,您的账号已经可以正常使用了!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"target"</span><span class="token punctuation">,</span> <span class="token string">"/login"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>result <span class="token operator">==</span> <span class="token constant">ACTIVATION_REPEAT</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"无效操作,该账号已经激活过了!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"target"</span><span class="token punctuation">,</span> <span class="token string">"/index"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>          model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"msg"</span><span class="token punctuation">,</span> <span class="token string">"激活失败,您提供的激活码不正确!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"target"</span><span class="token punctuation">,</span> <span class="token string">"/index"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token punctuation">}</span>      <span class="token keyword">return</span> <span class="token string">"/site/operate-result"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="会话管理"><a href="#会话管理" class="headerlink" title="会话管理"></a>会话管理</h3><p>HTTP的基本性质</p><ul><li>HTTP是简单的</li><li>HTTP是可扩展的</li><li>HTTP是无状态的，有会话的</li></ul><p>Cookie</p><ul><li>是服务器发送到浏览器，并保存在浏览器端的一小块数据。</li><li>浏览器下次访问该服务器时，会自动携带块该数据，将其发送给服务器。</li></ul><p>Session</p><ul><li>是JavaEE的标准，用于在服务端记录客户端信息。</li><li>数据存放在服务端更加安全，但是也会增加服务端的内存压力。</li><li>服务器分布式部署的时候存放session并没有十分完美的解决方案，所以一般我们都把数据存放进数据库中（redis）解决此问题。</li></ul><h3 id="生成验证码"><a href="#生成验证码" class="headerlink" title="生成验证码"></a>生成验证码</h3><p>Kaptcha</p><ul><li>导入依赖</li><li>编写 Kaptcha 配置类</li><li>生成随机字符、生成图片</li></ul><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>dependency</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>groupId</span><span class="token punctuation">&gt;</span></span>com.github.penggle<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>groupId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>artifactId</span><span class="token punctuation">&gt;</span></span>kaptcha<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>artifactId</span><span class="token punctuation">&gt;</span></span>      <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>version</span><span class="token punctuation">&gt;</span></span>2.3.2<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>version</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>dependency</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>配置</p><p>在config包下新建KaptchaConfig</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Configuration</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">KaptchaConfig</span> <span class="token punctuation">{</span>        <span class="token annotation punctuation">@Bean</span>      <span class="token keyword">public</span> <span class="token class-name">Producer</span> <span class="token function">kaptchaProducer</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>          <span class="token class-name">Properties</span> properties <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Properties</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"kaptcha.image.width"</span><span class="token punctuation">,</span> <span class="token string">"100"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"kaptcha.image.height"</span><span class="token punctuation">,</span> <span class="token string">"40"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"kaptcha.textproducer.font.size"</span><span class="token punctuation">,</span> <span class="token string">"32"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"kaptcha.textproducer.font.color"</span><span class="token punctuation">,</span> <span class="token string">"0,0,0"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"kaptcha.textproducer.char.string"</span><span class="token punctuation">,</span> <span class="token string">"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYAZ"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"kaptcha.textproducer.char.length"</span><span class="token punctuation">,</span> <span class="token string">"4"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          properties<span class="token punctuation">.</span><span class="token function">setProperty</span><span class="token punctuation">(</span><span class="token string">"kaptcha.noise.impl"</span><span class="token punctuation">,</span> <span class="token string">"com.google.code.kaptcha.impl.NoNoise"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>            <span class="token class-name">DefaultKaptcha</span> kaptcha <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">DefaultKaptcha</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token class-name">Config</span> config <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Config</span><span class="token punctuation">(</span>properties<span class="token punctuation">)</span><span class="token punctuation">;</span>          kaptcha<span class="token punctuation">.</span><span class="token function">setConfig</span><span class="token punctuation">(</span>config<span class="token punctuation">)</span><span class="token punctuation">;</span>          <span class="token keyword">return</span> kaptcha<span class="token punctuation">;</span>      <span class="token punctuation">}</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LoginController增加新方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token keyword">private</span> <span class="token class-name">Producer</span> kaptchaProducer<span class="token punctuation">;</span><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path<span class="token operator">=</span><span class="token string">"/kaptcha"</span><span class="token punctuation">,</span>method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">getKaptcha</span><span class="token punctuation">(</span><span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token comment">//生成验证码</span><span class="token class-name">String</span> text <span class="token operator">=</span> kaptchaProducer<span class="token punctuation">.</span><span class="token function">createText</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">BufferedImage</span> image <span class="token operator">=</span> kaptchaProducer<span class="token punctuation">.</span><span class="token function">createImage</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将验证码存入session</span>session<span class="token punctuation">.</span><span class="token function">setAttribute</span><span class="token punctuation">(</span><span class="token string">"kaptcha"</span><span class="token punctuation">,</span>text<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//将图片输出给浏览器</span>response<span class="token punctuation">.</span><span class="token function">setContentType</span><span class="token punctuation">(</span><span class="token string">"image/png"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">try</span> <span class="token punctuation">{</span><span class="token class-name">ServletOutputStream</span> outputStream <span class="token operator">=</span> response<span class="token punctuation">.</span><span class="token function">getOutputStream</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token class-name">ImageIO</span><span class="token punctuation">.</span><span class="token function">write</span><span class="token punctuation">(</span>image<span class="token punctuation">,</span><span class="token string">"png"</span><span class="token punctuation">,</span>outputStream<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span><span class="token class-name">IOException</span> e<span class="token punctuation">)</span> <span class="token punctuation">{</span>logger<span class="token punctuation">.</span><span class="token function">error</span><span class="token punctuation">(</span><span class="token string">"响应验证码获取失败:"</span><span class="token operator">+</span>e<span class="token punctuation">.</span><span class="token function">getMessage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>修改login.html</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-4<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name"><span class="token namespace">th:</span>src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@{/kaptcha}<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>kaptcha<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">width</span><span class="token punctuation">:</span>100px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span>40px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mr-2<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>javascript:refresh_kaptcha();<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>font-size-12 align-bottom<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>刷新验证码<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>  <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>......<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>script</span><span class="token punctuation">&gt;</span></span><span class="token script"><span class="token language-javascript">     <span class="token comment">// 刷新验证码  </span>   <span class="token keyword">function</span> <span class="token function">refresh_kaptcha</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token keyword">var</span> path <span class="token operator">=</span> <span class="token constant">CONTEXT_PATH</span> <span class="token operator">+</span> <span class="token string">"/kaptcha?p="</span> <span class="token operator">+</span> Math<span class="token punctuation">.</span><span class="token function">random</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token function">$</span><span class="token punctuation">(</span><span class="token string">"#kaptcha"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">attr</span><span class="token punctuation">(</span><span class="token string">"src"</span><span class="token punctuation">,</span> path<span class="token punctuation">)</span><span class="token punctuation">;</span>     <span class="token punctuation">}</span>  </span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>script</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>global.js中</p><pre class="line-numbers language-javascript" data-language="javascript"><code class="language-javascript"><span class="token keyword">var</span> <span class="token constant">CONTEXT_PATH</span> <span class="token operator">=</span> <span class="token string">"/community"</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="登陆、退出"><a href="#登陆、退出" class="headerlink" title="登陆、退出"></a>登陆、退出</h3><p><strong>登录</strong></p><ul><li>访问登录页面<ul><li>点击顶部区域内的链接，打开登录页面。</li></ul></li><li>登录<ul><li>验证账号、密码、验证码。</li><li>成功时，生成登录凭证，发放给客户端。</li><li>失败时，跳转回登录页。</li></ul></li><li>退出<ul><li>将登录凭证修改为失效状态。</li><li>跳转至网站首页。</li></ul></li></ul><p>登陆凭证目前存到MySQL数据库中</p><p>entity包中新建LoginTicket类</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Data</span>  <span class="token annotation punctuation">@NoArgsConstructor</span>  <span class="token annotation punctuation">@AllArgsConstructor</span>  <span class="token annotation punctuation">@ToString</span>  <span class="token keyword">public</span> <span class="token keyword">class</span> <span class="token class-name">LoginTicket</span> <span class="token punctuation">{</span>        <span class="token keyword">private</span> <span class="token keyword">int</span> id<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> userId<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">String</span> ticket<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token keyword">int</span> status<span class="token punctuation">;</span>      <span class="token keyword">private</span> <span class="token class-name">Date</span> expired<span class="token punctuation">;</span>    <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>mapper包中新建LoginTicketMapper接口</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Mapper</span>  <span class="token keyword">public</span> <span class="token keyword">interface</span> <span class="token class-name">LoginTicketMapper</span> <span class="token punctuation">{</span>      <span class="token annotation punctuation">@Insert</span><span class="token punctuation">(</span><span class="token punctuation">{</span>              <span class="token string">"insert into login_ticket(user_id,ticket,status,expired) "</span><span class="token punctuation">,</span>              <span class="token string">"values(#{userId},#{ticket},#{status},#{expired})"</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token annotation punctuation">@Options</span><span class="token punctuation">(</span>useGeneratedKeys <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">,</span> keyProperty <span class="token operator">=</span> <span class="token string">"id"</span><span class="token punctuation">)</span>      <span class="token keyword">int</span> <span class="token function">insertLoginTicket</span><span class="token punctuation">(</span><span class="token class-name">LoginTicket</span> loginTicket<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Select</span><span class="token punctuation">(</span><span class="token punctuation">{</span>              <span class="token string">"select id,user_id,ticket,status,expired "</span><span class="token punctuation">,</span>              <span class="token string">"from login_ticket where ticket=#{ticket}"</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token class-name">LoginTicket</span> <span class="token function">selectByTicket</span><span class="token punctuation">(</span><span class="token class-name">String</span> ticket<span class="token punctuation">)</span><span class="token punctuation">;</span>        <span class="token annotation punctuation">@Update</span><span class="token punctuation">(</span><span class="token punctuation">{</span>              <span class="token string">"&lt;script&gt;"</span><span class="token punctuation">,</span>              <span class="token string">"update login_ticket set status=#{status} where ticket=#{ticket} "</span><span class="token punctuation">,</span>              <span class="token string">"&lt;if test=\"ticket!=null\"&gt; "</span><span class="token punctuation">,</span>              <span class="token string">"and 1=1 "</span><span class="token punctuation">,</span>              <span class="token string">"&lt;/if&gt;"</span><span class="token punctuation">,</span>              <span class="token string">"&lt;/script&gt;"</span>      <span class="token punctuation">}</span><span class="token punctuation">)</span>      <span class="token keyword">int</span> <span class="token function">updateStatus</span><span class="token punctuation">(</span><span class="token class-name">String</span> ticket<span class="token punctuation">,</span> <span class="token keyword">int</span> status<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>UserService中添加新方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@Autowired</span><span class="token class-name">LoginTicketMapper</span> loginTicketMapper<span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">,</span><span class="token keyword">int</span> expiredSeconds<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span><span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">HashMap</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token punctuation">&gt;</span></span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//空值的处理</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"usernameMsg"</span><span class="token punctuation">,</span><span class="token string">"用户名不能为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> map<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token keyword">else</span> <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>password<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"passwordMsg"</span><span class="token punctuation">,</span><span class="token string">"密码不能为空"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> map<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//验证账号</span><span class="token class-name">User</span> user <span class="token operator">=</span> userMapper<span class="token punctuation">.</span><span class="token function">selectByName</span><span class="token punctuation">(</span>username<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span>user<span class="token operator">==</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">{</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"usernameMsg"</span><span class="token punctuation">,</span><span class="token string">"用户不存在"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> map<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//验证状态</span><span class="token keyword">if</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">==</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"usernameMsg"</span><span class="token punctuation">,</span><span class="token string">"该账号未激活"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> map<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//验证密码</span>password <span class="token operator">=</span> <span class="token class-name">CommunityUtil</span><span class="token punctuation">.</span><span class="token function">md5</span><span class="token punctuation">(</span>password<span class="token operator">+</span>user<span class="token punctuation">.</span><span class="token function">getSalt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>password<span class="token punctuation">.</span><span class="token function">equals</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getPassword</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"passwordMsg"</span><span class="token punctuation">,</span><span class="token string">"密码不正确"</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> map<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token comment">//生成登陆凭证</span><span class="token class-name">LoginTicket</span> loginTicket <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">LoginTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>loginTicket<span class="token punctuation">.</span><span class="token function">setUserId</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getId</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>loginTicket<span class="token punctuation">.</span><span class="token function">setTicket</span><span class="token punctuation">(</span><span class="token class-name">CommunityUtil</span><span class="token punctuation">.</span><span class="token function">generateUUID</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>loginTicket<span class="token punctuation">.</span><span class="token function">setStatus</span><span class="token punctuation">(</span>user<span class="token punctuation">.</span><span class="token function">getStatus</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>loginTicket<span class="token punctuation">.</span><span class="token function">setExpired</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span><span class="token class-name">System</span><span class="token punctuation">.</span><span class="token function">currentTimeMillis</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">+</span>expiredSeconds<span class="token operator">*</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>loginTicketMapper<span class="token punctuation">.</span><span class="token function">insertLoginTicket</span><span class="token punctuation">(</span>loginTicket<span class="token punctuation">)</span><span class="token punctuation">;</span>map<span class="token punctuation">.</span><span class="token function">put</span><span class="token punctuation">(</span><span class="token string">"loginTicket"</span><span class="token punctuation">,</span>loginTicket<span class="token punctuation">.</span><span class="token function">getTicket</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">return</span> map<span class="token punctuation">;</span><span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>LoginController中添加新方法</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path <span class="token operator">=</span> <span class="token string">"/login"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">POST</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">login</span><span class="token punctuation">(</span><span class="token class-name">String</span> username<span class="token punctuation">,</span> <span class="token class-name">String</span> password<span class="token punctuation">,</span> <span class="token class-name">String</span> code<span class="token punctuation">,</span> <span class="token keyword">boolean</span> rememberMe<span class="token punctuation">,</span>  <span class="token class-name">Model</span> model<span class="token punctuation">,</span> <span class="token class-name">HttpSession</span> session<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token comment">// 检查验证码  </span>     <span class="token class-name">String</span> kaptcha <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> session<span class="token punctuation">.</span><span class="token function">getAttribute</span><span class="token punctuation">(</span><span class="token string">"kaptcha"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">//redis检查验证码  </span><span class="token class-name">String</span> kaptcha <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isNotBlank</span><span class="token punctuation">(</span>kaptchaOwner<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token class-name">String</span> redisKey <span class="token operator">=</span> <span class="token class-name">RedisKeyUtil</span><span class="token punctuation">.</span><span class="token function">getKaptchaKey</span><span class="token punctuation">(</span>kaptchaOwner<span class="token punctuation">)</span><span class="token punctuation">;</span>  kaptcha <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token class-name">String</span><span class="token punctuation">)</span> redisTemplate<span class="token punctuation">.</span><span class="token function">opsForValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>redisKey<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>kaptcha<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token class-name">StringUtils</span><span class="token punctuation">.</span><span class="token function">isBlank</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token operator">!</span>kaptcha<span class="token punctuation">.</span><span class="token function">equalsIgnoreCase</span><span class="token punctuation">(</span>code<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"codeMsg"</span><span class="token punctuation">,</span> <span class="token string">"验证码不正确!"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token string">"/site/login"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token comment">// 检查账号,密码  </span><span class="token keyword">int</span> expiredSeconds <span class="token operator">=</span> rememberMe <span class="token operator">?</span> <span class="token constant">REMEMBER_EXPIRED_SECONDS</span> <span class="token operator">:</span> <span class="token constant">DEFAULT_EXPIRED_SECONDS</span><span class="token punctuation">;</span>  <span class="token class-name">Map</span><span class="token generics"><span class="token punctuation">&lt;</span><span class="token class-name">String</span><span class="token punctuation">,</span> <span class="token class-name">Object</span><span class="token punctuation">&gt;</span></span> map <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">login</span><span class="token punctuation">(</span>username<span class="token punctuation">,</span> password<span class="token punctuation">,</span> expiredSeconds<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">if</span> <span class="token punctuation">(</span>map<span class="token punctuation">.</span><span class="token function">containsKey</span><span class="token punctuation">(</span><span class="token string">"ticket"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>  <span class="token class-name">Cookie</span> cookie <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cookie</span><span class="token punctuation">(</span><span class="token string">"ticket"</span><span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"ticket"</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  cookie<span class="token punctuation">.</span><span class="token function">setPath</span><span class="token punctuation">(</span>contextPath<span class="token punctuation">)</span><span class="token punctuation">;</span>  cookie<span class="token punctuation">.</span><span class="token function">setMaxAge</span><span class="token punctuation">(</span>expiredSeconds<span class="token punctuation">)</span><span class="token punctuation">;</span>  response<span class="token punctuation">.</span><span class="token function">addCookie</span><span class="token punctuation">(</span>cookie<span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token class-name">User</span> user <span class="token operator">=</span> userService<span class="token punctuation">.</span><span class="token function">findUserById</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token class-name">Integer</span><span class="token punctuation">)</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"userId"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token string">"redirect:/index"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>  model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"usernameMsg"</span><span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"usernameMsg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  model<span class="token punctuation">.</span><span class="token function">addAttribute</span><span class="token punctuation">(</span><span class="token string">"passwordMsg"</span><span class="token punctuation">,</span> map<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"passwordMsg"</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token keyword">return</span> <span class="token string">"/site/login"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p>login.html页面</p><pre class="line-numbers language-markup" data-language="markup"><code class="language-markup"><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>main<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>     <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>container pl-5 pr-5 pt-3 pb-3 mt-3 mb-3<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>h3</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text-center text-info border-bottom pb-3<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>登<span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span><span class="token entity named-entity" title="&nbsp;">&amp;nbsp;</span>录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>h3</span><span class="token punctuation">&gt;</span></span>        <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>form</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mt-5<span class="token punctuation">"</span></span> <span class="token attr-name">method</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>post<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>action</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@{/login}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>           <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-group row<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-2 col-form-label text-right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>账号:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-10<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>|form-control ${usernameMsg!=null?'is-invalid':''}|<span class="token punctuation">"</span></span>                       <span class="token attr-name"><span class="token namespace">th:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${param.username}<span class="token punctuation">"</span></span>                       <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>username<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入您的账号!<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>invalid-feedback<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${usernameMsg}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                    该账号不存在!                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-group row mt-4<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-2 col-form-label text-right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>密码:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-10<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>|form-control ${passwordMsg!=null?'is-invalid':''}|<span class="token punctuation">"</span></span>                       <span class="token attr-name"><span class="token namespace">th:</span>value</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${param.password}<span class="token punctuation">"</span></span>                       <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>password<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入您的密码!<span class="token punctuation">"</span></span> <span class="token attr-name">required</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>invalid-feedback<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${passwordMsg}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                    密码不能为空                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-group row mt-4<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>verifycode<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-2 col-form-label text-right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>验证码:<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-6<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>|form-control ${codeMsg!=null?'is-invalid':''}|<span class="token punctuation">"</span></span>                       <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>verifycode<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>code<span class="token punctuation">"</span></span> <span class="token attr-name">placeholder</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>请输入验证码!<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>invalid-feedback<span class="token punctuation">"</span></span> <span class="token attr-name"><span class="token namespace">th:</span>text</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${codeMsg}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                    验证码不正确!                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>            <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-4<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>img</span> <span class="token attr-name"><span class="token namespace">th:</span>src</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>@{/kaptcha}<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>kaptcha<span class="token punctuation">"</span></span> <span class="token special-attr"><span class="token attr-name">style</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span><span class="token value css language-css"><span class="token property">width</span><span class="token punctuation">:</span>100px<span class="token punctuation">;</span><span class="token property">height</span><span class="token punctuation">:</span>40px<span class="token punctuation">;</span></span><span class="token punctuation">"</span></span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>mr-2<span class="token punctuation">"</span></span><span class="token punctuation">/&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>javascript:refresh_kaptcha();<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>font-size-12 align-bottom<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>刷新验证码<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-group row mt-4<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-10<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>input</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>checkbox<span class="token punctuation">"</span></span> <span class="token attr-name">id</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>remember-me<span class="token punctuation">"</span></span> <span class="token attr-name">name</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>rememberme<span class="token punctuation">"</span></span>                       <span class="token attr-name"><span class="token namespace">th:</span>checked</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>${param.rememberme}<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>label</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-check-label<span class="token punctuation">"</span></span> <span class="token attr-name">for</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>remember-me<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>记住我<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>label</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>a</span> <span class="token attr-name">href</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>forget.html<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>text-danger float-right<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>忘记密码?<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>a</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>         <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>form-group row mt-4<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-2<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>div</span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>col-sm-10 text-center<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;</span>button</span> <span class="token attr-name">type</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>submit<span class="token punctuation">"</span></span> <span class="token attr-name">class</span><span class="token attr-value"><span class="token punctuation attr-equals">=</span><span class="token punctuation">"</span>btn btn-info text-white form-control<span class="token punctuation">"</span></span><span class="token punctuation">&gt;</span></span>立即登录<span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>button</span><span class="token punctuation">&gt;</span></span>              <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>                 <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span>          <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>form</span><span class="token punctuation">&gt;</span></span>   <span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span class="token tag"><span class="token tag"><span class="token punctuation">&lt;/</span>div</span><span class="token punctuation">&gt;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><strong>退出</strong></p><p>UserService</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token keyword">public</span> <span class="token keyword">void</span> <span class="token function">logout</span><span class="token punctuation">(</span><span class="token class-name">String</span> ticket<span class="token punctuation">)</span> <span class="token punctuation">{</span>  loginTicketMapper<span class="token punctuation">.</span><span class="token function">updateStatus</span><span class="token punctuation">(</span>ticket<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p>LoginController</p><pre class="line-numbers language-java" data-language="java"><code class="language-java"><span class="token annotation punctuation">@RequestMapping</span><span class="token punctuation">(</span>path <span class="token operator">=</span> <span class="token string">"/logout"</span><span class="token punctuation">,</span> method <span class="token operator">=</span> <span class="token class-name">RequestMethod</span><span class="token punctuation">.</span><span class="token constant">GET</span><span class="token punctuation">)</span>  <span class="token keyword">public</span> <span class="token class-name">String</span> <span class="token function">logout</span><span class="token punctuation">(</span><span class="token annotation punctuation">@CookieValue</span><span class="token punctuation">(</span><span class="token string">"ticket"</span><span class="token punctuation">)</span> <span class="token class-name">String</span> ticket<span class="token punctuation">,</span> <span class="token class-name">HttpServletResponse</span> response<span class="token punctuation">)</span> <span class="token punctuation">{</span>        <span class="token comment">//删除ticket cookie  </span>    <span class="token class-name">Cookie</span> cookie <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Cookie</span><span class="token punctuation">(</span><span class="token string">"ticket"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      cookie<span class="token punctuation">.</span><span class="token function">setMaxAge</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>      response<span class="token punctuation">.</span><span class="token function">addCookie</span><span class="token punctuation">(</span>cookie<span class="token punctuation">)</span><span class="token punctuation">;</span>        userService<span class="token punctuation">.</span><span class="token function">logout</span><span class="token punctuation">(</span>ticket<span class="token punctuation">)</span><span class="token punctuation">;</span>      <span class="token keyword">return</span> <span class="token string">"redirect:/login"</span><span class="token punctuation">;</span>  <span class="token punctuation">}</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> Spring Boot </tag>
            
            <tag> Spring MVC </tag>
            
            <tag> MyBatis </tag>
            
            <tag> Redis </tag>
            
            <tag> Kafka </tag>
            
            <tag> Elasticsearch </tag>
            
            <tag> Spring Security </tag>
            
            <tag> Spring Actuator </tag>
            
            <tag> 论坛网站 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
